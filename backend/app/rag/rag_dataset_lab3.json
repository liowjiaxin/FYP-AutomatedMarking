[
  {
    "student_id": "20604119",
    "code": "\n/* --- Q1.c --- */\n//q1\r\n#include <stdio.h>\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Validate dimensions\r\n    if (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE) {\r\n        printf(\"Invalid dimensions for Matrix A. Maximum size is %dx%d.\\n\", MAX_SIZE, MAX_SIZE);\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Validate dimensions\r\n    if (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE) {\r\n        printf(\"Invalid dimensions for Matrix B. Maximum size is %dx%d.\\n\", MAX_SIZE, MAX_SIZE);\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Adds two matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                // Subtract two matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                // Computes the transpose of matrix A\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                // Computes the transpose of Matrix B\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                // Exits program\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                // Handles invalid choices\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// inputs matrix elements\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Adds 2 matrices\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Subtracts one matrix from another\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to compute the transpose of a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Prints matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]); // Print each element\r\n        }\r\n        printf(\"\\n\"); // New line after each row\r\n    }\r\n}\r\n\n/* --- q2.c --- */\n//q2\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100 // Maximum number of grocery items that can be stored\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int in_stock;\r\n    int out_of_stock;\r\n} GroceryItem;\r\n\r\nGroceryItem inventory[MAX_ITEMS];\r\nint item_count = 0;\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addGroceryItem() {\r\n    if (item_count >= MAX_ITEMS) {\r\n        printf(\"Error: Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Prompt user for item details\r\n    printf(\"Enter item name: \");\r\n    scanf(\"%99s\", inventory[item_count].name);\r\n    printf(\"Enter category: \");\r\n    scanf(\"%49s\", inventory[item_count].category);\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &inventory[item_count].quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &inventory[item_count].price);\r\n\r\n    // Set the stock status\r\n    inventory[item_count].in_stock = 1;\r\n    inventory[item_count].out_of_stock = 0;\r\n    item_count++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items in the inventory\r\nvoid listAllGroceryItems() {\r\n    if (item_count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Display the list of items\r\n    printf(\"Grocery Item List:\\n\");\r\n    for (int i = 0; i < item_count; i++) {\r\n        printf(\"%s (%s) - Quantity: %d, Price: $%.2f, Status: %s\\n\",\r\n               inventory[i].name, inventory[i].category, inventory[i].quantity,\r\n               inventory[i].price, inventory[i].in_stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    scanf(\"%99s\", name);\r\n\r\n    int found = 0; // Flag to track if the item is found\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Error: Grocery item not found.\\n\");\r\n    }\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    scanf(\"%99s\", name);\r\n\r\n    int found = 0; //flag tracks if the item is found\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            for (int j = i; j < item_count - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            item_count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) { // If item is not found\r\n        printf(\"Error: Grocery item not found.\\n\");\r\n    }\r\n}\r\n\r\n// Main function to display the menu and handle user choices\r\nint main() {\r\n    int choice;\r\n\r\n    while (1) { // Infinite loop for the menu\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Handles menu choices using a switch statement\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listAllGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting Grocery Inventory Management System...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n}\r\n\n/* --- Q3.c --- */\n//q3\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Defines the structure for a student record\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student record\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    strncpy(newStudent->name, name, 99);\r\n    newStudent->name[99] = '\\0';\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record into the linked list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records in the list\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    if (current == NULL) {\r\n        printf(\"No student records in the list.\\n\");\r\n    } else {\r\n        printf(\"Student Records:\\n\");\r\n        while (current != NULL) {\r\n            printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n            current = current->next;\r\n        }\r\n    }\r\n}\r\n\r\n// Searches for student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function sorts linked list using bubble sort based on grades\r\nvoid bubbleSort() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swaps the nodes data if out of order\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                int tempID = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempID;\r\n\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n}\r\n\r\n// wr functionfpr sorting students\r\nvoid sortStudents() {\r\n    bubbleSort();\r\n}\r\n\r\n// Deletes the entire linked list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        Student* next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n//self explanatory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (Bubble Sort)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Input details for a new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                // Displaya student records\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                // Sorts by grades (le bubble sort)\r\n                sortStudents();\r\n                printf(\"Student records sorted by grade using Bubble Sort.\\n\");\r\n                break;\r\n            case 4:\r\n                // Searches by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                // Delete list\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                // Deletes memory and exists the program\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                // error message when invalid number\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation correctly sorts student records by grade. While bubble sort is simple and effective for small datasets, it has a time complexity of O(n?), which can lead to inefficiency with larger datasets. For better performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20593018",
    "code": "\n/* --- 20593018_Tan Chee Tai/20593018_Tan Chee Tai/q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 // Maximum size for matrices\r\n\r\n// Function to input matrix elements\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nint addMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n    return 1; // Returns 1 to indicate success\r\n}\r\n\r\n// Function to subtract two matrices\r\nint subtractMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n    return 1; // Returns 1 to indicate success\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\r\n    int choice;\r\n\r\n    // Get matrix dimensions and elements\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB); \r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    while (1) {\r\n        printf(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        if (choice == 1) {\r\n            // Add matrices\r\n            if (rowsA == rowsB && colsA == colsB) {\r\n                addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            } else {\r\n                printf(\"Error, try again with other value.\\n\");\r\n            }\r\n        } else if (choice == 2) {\r\n            // Subtract matrices\r\n            if (rowsA == rowsB && colsA == colsB) {\r\n                subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Subtraction of Matrix A - Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            } else {\r\n                printf(\"Error, try again with other value.\\n\");\r\n            }\r\n        } else if (choice == 3) {\r\n            // Transpose Matrix A\r\n            transposeMatrix(matrixA, result, rowsA, colsA);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(result, colsA, rowsA);\r\n        } else if (choice == 4) {\r\n            // Transpose Matrix B\r\n            transposeMatrix(matrixB, result, rowsB, colsB);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(result, colsB, rowsB);\r\n        } else if (choice == 5) {\r\n            // Exit the program\r\n            printf(\"Exiting........................byebyebyebyebyebyebyebye!!!!!!!\\n\");\r\n            break;\r\n        } else {\r\n            // Invalid choice\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- 20593018_Tan Chee Tai/20593018_Tan Chee Tai/q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100 // Maximum number of grocery items\r\n\r\n// Struct for grocery items\r\ntypedef struct {\r\n    char name[50];\r\n    char category[20];\r\n    int quantity;\r\n    float price;\r\n    int inStock; \r\n} GroceryItem;\r\n\r\n// Global variables\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n// Function to add a grocery item\r\nvoid addItem() {\r\n\r\n    GroceryItem newItem;\r\n    printf(\"Enter Item name: \");\r\n    getchar(); // To clear the newline left by scanf\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; // Remove newline\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    newItem.inStock = (newItem.quantity > 0) ? 1 : 0; // Set stock status\r\n\r\n    inventory[itemCount] = newItem; // Add item to inventory\r\n    itemCount++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n// Function to list all grocery items\r\nvoid listItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty!\\n\");\r\n        return;\r\n    }\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty! Add items first.\\n\");\r\n        return;\r\n    }\r\n    char itemName[50];\r\n    int newQuantity;\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar();\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    int found = 0;\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity for %s: \", inventory[i].name);\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            inventory[i].quantity = newQuantity;\r\n            inventory[i].inStock = (newQuantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n    if (!found) {\r\n        printf(\"Error: Item not found in inventory.\\n\");\r\n    }\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeItem() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty! Add items first.\\n\");\r\n        return;\r\n    }\r\n    char itemName[50];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    getchar();\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    int found = 0;\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            // Shift items to \"delete\" the selected one\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n\r\n            printf(\"Item removed successfully!\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Error: Item not found in inventory.\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    // Menu loop\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        if (choice == 1) {\r\n            addItem();\r\n        } else if (choice == 2) {\r\n            listItems();\r\n        } else if (choice == 3) {\r\n            updateQuantity();\r\n        } else if (choice == 4) {\r\n            removeItem();\r\n        } else if (choice == 5) {\r\n            printf(\"Goodbye, my 100 plus is super expensive.\\n\");\r\n        } else {\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n\n/* --- 20593018_Tan Chee Tai/20593018_Tan Chee Tai/q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No records to display!\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student record by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the students by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return; \r\n    }\r\n\r\n    Student* i;\r\n    Student* j;\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap the student data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempID;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name,\"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3- The sortStudents function uses a nested loop to swap student records based on their grades. This method effectively sorts the list, but it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using a more efficient sorting algorithm like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20620220",
    "code": "\n/* --- Q1 .c --- */\n#include <stdio.h>\n#define N 10 // maximum allowed size of matrix\n\n// Function adds A[][] and B[][] and stores the result in C[][]\nvoid addMatrices (int A[][N], int B[][N], int C[][N]) {\n    int i, j;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\n// Function subtract A[][] and B[][] and stores the result in C[][]\nvoid subtractMatrices (int A[][N], int B[][N], int C[][N]) {\n    int i, j;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\n// Function to transpose Matrix A\nvoid transposeMatrixA (int A[][N], int T[][N]) {\n    int i, j;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            T[j][i] = A[i][j];\n        }\n    }\n}\n\n// Function to transpose Matrix B\nvoid transposeMatrixB (int B[][N], int T[][N]) {\n    int i, j;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            T[j][i] = B[i][j];\n        }\n    }\n}\n\nint main() {\n    int A[N][N], B[N][N], C[N][N], T[N][N];\n    int choice; \n    int i, j;\n    \n    // Input matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\\n\", &i, &j);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            printf(\"Enter elements for Matrix A [%d][%d]:\", i + 1, j + 1);\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n    \n    // Input matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\\n\", &i, &j);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            printf(\"Enter elements for Matrix B [%d][%d]:\", i + 1, j + 1);\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n    \n    printf(\"Matrix Operations Menu:\\n\");\n    printf(\"1. Add Matrices\\n\");\n    printf(\"2. Subtract Matrices\\n\");\n    printf(\"3. Transpose Matrix A\\n\");\n    printf(\"4. Transpose Matrix B\\n\");\n    printf(\"5. Exit\\n\");\n    printf(\"Enter your choice:\");\n    scanf(\"%d\", &choice);\n    \n    switch (choice) {\n        case 1: \n            addMatrices(A, B, C);\n            printf(\"Result of Matrix A + Matrix B:\\n\");\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    printf(\"%d \", C[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            break;\n        \n        case 2: \n            subtractMatrices(A, B, C);\n            printf(\"Result of Matrix A - Matrix B:\\n\");\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    printf(\"%d \", C[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            break;\n            \n        case 3: \n            transposeMatrixA(A, T);\n            printf(\"Transpose of Matrix A:\\n\");\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    printf(\"%d \", T[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            break;\n        \n        case 4: \n            transposeMatrixB(B, T);\n            printf(\"Transpose of Matrix B:\\n\");\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    printf(\"%d \", T[i][j]);\n                }\n                printf(\"\\n\");\n            }\n            break;\n        \n        case 5:\n            printf(\"Exiting...\\n\");\n            break;\n        \n        default:\n            printf(\"Invalid choice. Please try again\");\n    }\n\n    return 0;\n}\n/* --- Q2 .c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n} GroceryItem;\n\ntypedef struct {\n    bool inStock;\n    bool outStock;\n} AvailabilityStatus;\n\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    AvailabilityStatus availability[MAX_ITEMS];\n    int count; // total number of grocery items\n} GroceryInventory;\n\n// Function to add grocery item\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) {\n        printf(\"Inventory is full\\n\");\n        return;\n    }\n    \n    GroceryItem addedItem;\n    printf(\"enter the name of the item: \");\n    scanf(\" %[^\\n]\", addedItem.name);\n    printf(\"enter the category of the item: \");\n    scanf(\" %[^\\n]\", addedItem.category);\n    printf(\"enter the quantity of the item: \");\n    scanf(\"%d\", &addedItem.quantity);\n    printf(\"enter the price of the item: \");\n    scanf(\"%f\", &addedItem.price);\n    \n    inventory->items[inventory->count] = addedItem; // add item to the inventory\n    \n    // Update avvailability status\n    inventory->availability[inventory->count].inStock = (addedItem.quantity > 0);\n    inventory->availability[inventory->count].outStock = (addedItem.quantity == 0);\n    \n    inventory->count++; // increment the item in inventory\n    \n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items\nvoid listGroceryItems (const GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n    \n    for(int i = 0; i < inventory->count; i++) {\n        const GroceryItem *item = &inventory->items[i];\n        const AvailabilityStatus *status = &inventory->availability[i];\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of stock\");\n        \n    }\n}\n\n// Function to update the grocery item \nvoid updateItem (GroceryInventory *inventory) {\n    char itemName[100];\n    int match = 0;\n    \n    if (inventory->count == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n    \n    printf(\"Enter the name of the grocery item to update quantity: \");\n    scanf(\" %[^\\n]\", itemName); \n    \n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            printf(\"Item found: %s\\n\", inventory->items[i].name);\n            printf(\"Current quantity: %d\\n\", inventory->items[i].quantity);\n            printf(\"Enter new quantity: \");\n            scanf(\"%d\", &inventory->items[i].quantity);\n            \n            // Update availability status\n            inventory->availability[i].inStock = (inventory->items[i].quantity > 0);\n            printf(\"Item updated successfully.\\n\");\n            match = 1;\n            break;\n        }\n    }\n    \n    if (!match) {\n        printf(\"Item not found\");\n    }\n}\n\n// Function to remove item\nvoid removeItem (GroceryInventory *inventory) {\n    char itemName[100];\n    int match = 0;\n    \n    if (inventory->count == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n    \n    printf(\"Enter the name of the grocery item to remove: \");\n    scanf(\" %[^\\n]\", itemName); \n    \n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            printf(\"Item found: %s\\n\", inventory->items[i].name);\n            \n            for (int j = i; j < inventory->count - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n            }\n            inventory->count--;\n            printf(\"Item removed successfully!\\n\");\n            match = 1;\n            break;\n        }\n    }\n    \n    if (!match) {\n        printf(\"Item not found\");\n    }\n}\n\nint main()\n{\n    GroceryInventory inventory = {0};\n    int count = 0;\n    int choice;\n    \n    printf(\"Grocery Inventory Management System\\n\");\n    printf(\"1. Add Grocery Item\\n\");\n    printf(\"2. List All Grocery Items\\n\");\n    printf(\"3. Update Quantity\\n\");\n    printf(\"4. Remove Grocery Item\\n\");\n    printf(\"5. Exit\\n\");\n    printf(\"Enter your choice:\");\n    scanf(\"%d\", &choice);\n        \n    switch (choice) {\n        case 1:\n            addGroceryItem(&inventory);\n            break;\n        case 2:\n            listGroceryItems(&inventory);\n            break;\n        case 3:\n            updateItem(&inventory);\n            break;\n        case 4:\n            removeItem(&inventory);\n            break;\n        case 5:\n            printf(\"Exiting...\\n\");\n            break;\n        default:\n            printf(\"Invalid choice.\\n\");\n    }\n\n    return 0;\n}\n\n/* --- Q3 .c --- */\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n \n// Structure for Student \ntypedef struct Student { \n    char name[100]; \n    int id; \n    float grade; \n    struct Student* next; \n} Student; \n \nStudent* head = NULL; \n \n// Function to create a new student node \nStudent* createStudent(const char* name, int id, float grade) { \n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    \n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n \n} \n \n// Function to insert a new student record \nvoid insertStudent(const char* name, int id, float grade) { \n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted.\\n\");\n} \n \n// Function to display all student records \nvoid displayStudents() { \n    Student* current = head;\n    while(1) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n    \n} \n \n// Function to search for a student by ID \nStudent* searchStudentByID(int id) { \n   Student* current = head; \n   while(current != NULL) {\n       if (current -> id == id) {\n           return current;\n       }\n       current = current->next;\n   }\n   return NULL;\n} \n \n// Function to delete the entire list \nvoid deleteList() { \n    Student* current = head; \n    Student* next; \n \n    while (current != NULL) { \n        next = current->next; \n        free(current); \n        current = next; \n    } \n    head = NULL; \n} \n \nvoid freeMemory() { \n    deleteList(); \n} \n \n// Sort function to sort the student records by grade based on an algorithm of your choice \nvoid sortStudents() { \n    int swapped;\n    Student *ptr1, *ptr2 = NULL;\n    \n    do {\n        swapped = 0;\n        ptr1 = head;\n        \n        while(ptr1->next != ptr2) {\n            if (ptr1->grade < ptr1->next->grade) {\n                char tempName[100];\n                int tempId;\n                float tempGrade;\n                \n                strcpy(tempName, ptr1->name);\n                strcpy(ptr1->name, ptr1->next->name);\n                strcpy(ptr1->next->name, tempName);\n                \n                tempId = ptr1->id;\n                ptr1->id = ptr1->next->id;\n                ptr1->next->id = tempId;\n                \n                tempGrade = ptr1->grade;\n                ptr1->grade = ptr1->next->grade;\n                ptr1->next->grade = tempGrade;\n                \n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        ptr2 = ptr1;\n    } while(swapped);\n    \n    printf(\"Student records sorted by grade.\\n\");\n} \n \n// Main function to drive the program \nint main() { \n \n    int choice, id; \n    char name[100]; \n    float grade; \n \n    do { \n        printf(\"\\n1. Insert Student Record\\n\"); \n        printf(\"2. Display Student Records\\n\"); \n        printf(\"3. Sort Records (choose sorting method)\\n\"); \n        printf(\"4. Search Record by ID\\n\"); \n        printf(\"5. Delete List\\n\"); \n        printf(\"6. Exit\\n\"); \n        printf(\"Enter your choice: \"); \n        scanf(\"%d\", &choice); \n        getchar(); // To consume the newline character \n \n        switch (choice) { \n            case 1: \n                printf(\"Enter Name: \"); \n                fgets(name, sizeof(name), stdin); \n                strtok(name, \"\\n\"); \n                printf(\"Enter ID: \"); \n                scanf(\"%d\", &id); \n                printf(\"Enter Grade: \"); \n                scanf(\"%f\", &grade); \n                insertStudent(name, id, grade); \n                break; \n            case 2: \n                displayStudents(); \n                break; \n            case 3: \n                sortStudents();                 \n                break; \n            case 4: \n                printf(\"Enter ID to search: \"); \n                scanf(\"%d\", &id); \n                Student* found = searchStudentByID(id); \n \n                if (found) { \n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \n                } else { \n                    printf(\"Student not found.\\n\"); \n                } \n                break; \n            case 5: \n                deleteList(); \n                printf(\"List deleted.\\n\"); \n                break; \n            case 6: \n                freeMemory(); \n                printf(\"Exiting...\\n\"); \n                break; \n            default: \n                printf(\"Invalid choice! Please try again.\\n\"); \n        } \n    } while (choice != 6); \n \n    return 0; \n} ",
    "feedback": "q1-The scanf statements for dimensions include an extra newline character (\\n), which can cause issues when reading input.     The loops for reading matrix elements do not properly limit the input to the specified dimensions provided by the user.    Transposing assumes the matrix is always N x N, which may not hold true if the user enters different dimensions.\nq2-    In the main function, the menu loop is missing. After displaying the options and taking input, it should repeat until the user chooses to exit.   The initialization of GroceryInventory inventory = {0}; is correct, but count is unused and unnecessary.\nq3-The displayStudents function has an infinite loop because it does not check if current is NULL before dereferencing it. This can lead to a crash or undefined behavior."
  },
  {
    "student_id": "20701680",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\n#define MAX_SIZE 10\r\n//function to transpose a matrix\r\nvoid transpose(int arr[][MAX_SIZE], int r, int c) {\r\n    int trans[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < r; ++i)\r\n        for (int j = 0; j < c; ++j) {\r\n            trans[j][i] = arr[i][j];\r\n        }\r\n    \r\n    for (int i = 0; i < c; ++i)\r\n        for (int j = 0; j < r; ++j) {\r\n            printf(\"%d \", trans[i][j]);\r\n            if (j == r - 1) {\r\n                printf(\"\\n\");\r\n            }\r\n        }\r\n}\r\n//function to add 2 matrices\r\nvoid add(int a[][MAX_SIZE], int b[][MAX_SIZE], int r, int c) {\r\n    int sum[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < r; ++i)\r\n        for (int j = 0; j < c; ++j) {\r\n            sum[i][j] = a[i][j] + b[i][j];\r\n        }\r\n   \r\n    for (int i = 0; i < r; ++i)\r\n        for (int j = 0; j < c; ++j) {\r\n            printf(\"%d \", sum[i][j]);\r\n            if (j == c - 1) {\r\n                printf(\"\\n\");\r\n            }\r\n        }\r\n}\r\n//function to subtract matrices\r\nvoid sub(int a[][MAX_SIZE], int b[][MAX_SIZE], int r, int c) {\r\n    int sum[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < r; ++i)\r\n        for (int j = 0; j < c; ++j) {\r\n            sum[i][j] = a[i][j] - b[i][j];\r\n        }\r\n   \r\n    for (int i = 0; i < r; ++i)\r\n        for (int j = 0; j < c; ++j) {\r\n            printf(\"%d \", sum[i][j]);\r\n            if (j == c - 1) {\r\n                printf(\"\\n\");\r\n            }\r\n        }\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    int rows, columns, rows1, columns1;\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n    //enter dimension for matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rows, &columns);\r\n    while (rows > MAX_SIZE || columns > MAX_SIZE) {\r\n        printf(\"Please enter less than or equal to 10  rows and columns\\n\");    // loop until less that 10 rows and columns are input\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rows, &columns);\r\n    }\r\n   // element for matrix a\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rows; ++i)\r\n          for (int j = 0; j < columns; ++j) {\r\n      printf(\"Element[%d][%d]: \", i + 1, j + 1);\r\n      scanf(\"%d\", &A[i][j]);\r\n        }\r\n  // dimensions for matrix b\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rows1, &columns1);\r\n    while (rows1 > MAX_SIZE || columns1 > MAX_SIZE) {                        // loop until less than 10 rows and columns are input\r\n        printf(\"Please enter less than or equal to %d rows and columns\\n\", MAX_SIZE);\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rows1, &columns1);\r\n    }\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < rows1; ++i)\r\n        for (int j = 0; j < columns1; ++j) {\r\n            printf(\"Element[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n   // menu\r\n    while (1) {    //loops until exit\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"\\nEnter your choice : \");\r\n        scanf(\"%d\", &choice);;\r\n        getchar();// Consume the newline character\r\n  \r\n        \r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                if (rows == rows1 && columns == columns1) {\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    add(A, B, rows, columns);\r\n                } else {\r\n                    printf(\"Error: Matrices are not of the same size.\\n\");// for addition matrices have to be the same\r\n                }\r\n              break ;\r\n           case 2 :\r\n              if (rows == rows1 && columns == columns1) {\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    sub(A, B, rows, columns);\r\n                } else {\r\n                    printf(\"Error: Matrices are not of the same size.\\n\"); // for subtraction matrices have to be the same\r\n                }\r\n         \r\n              break;\r\n          case 3:\r\n              printf(\"\\n Transpose  of Matrix A\\n\");       //transpose function\r\n             transpose(A,rows , columns);\r\n             break;\r\n          case 4:\r\n             printf(\"\\nTranspose of Matrix B\\n\");\r\n             transpose(B,rows1, columns1);\r\n              break;\r\n         case 5 : \r\n             printf(\"Exiting......\");\r\n             return 0 ;   //exit program if 5 is entered\r\n              break ;\r\n         default :\r\n              puts(\"Please enter a choice between 1 and 5\");\r\n              break ;\r\n\r\n\r\n\r\n\r\n\r\n        }\r\n }\r\n \r\n\r\n    return 0 ;\r\n}\n/* --- Q2.c --- */\n#include<stdio.h>\r\n#include<stdbool.h>\r\n#include<string.h>\r\n#include <stdlib.h>\r\n\r\n//define a struct\r\ntypedef struct {\r\n  char name[100];\r\n  char category[50];\r\n  int Quantity ;\r\n  double Price ;\r\n}Groceries ;\r\n\r\n\r\ntypedef struct {\r\n    bool inStock ;\r\n    bool outofStock ;\r\n\r\n}AvailabilityStatus;\r\n\r\ntypedef struct{\r\n Groceries items[100];\r\n AvailabilityStatus Availability[100];\r\n int count ; \r\n}GroceryInventory ;\r\n\r\nvoid add(GroceryInventory* inventory){\r\n    //allow user to add the items\r\n    printf(\"Please enter name : \");\r\n    fgets(inventory->items[inventory->count].name,100,stdin);\r\n    inventory->items[inventory->count].name[strcspn(inventory->items[inventory->count].name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"\\nPlease enter category: \");\r\n    fgets(inventory->items[inventory->count].category,50,stdin);\r\n    inventory->items[inventory->count].category[strcspn(inventory->items[inventory->count].category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"\\nPlease enter quantity:\");\r\n    scanf(\"%d\",&inventory->items[inventory->count].Quantity);\r\n\r\n     printf(\"\\nPlease enter price:\");\r\n     scanf(\"%lf\",&inventory->items[inventory->count].Price);\r\n    //since item is added make instock true\r\n     inventory->Availability[inventory->count].inStock = true;\r\n     inventory->Availability[inventory->count].outofStock = false;\r\n\r\n}\r\n\r\n//function to list all the items\r\nvoid list (GroceryInventory* inventory){\r\n  for (int i = 0 ; i < inventory->count ; i++){\r\n    printf(\"Name: %s\\n\",inventory->items[i].name);\r\n    printf(\"Category: %s\\n\",inventory->items[i].category);\r\n    printf(\"Quantity: %d\\n\",inventory->items[i].Quantity);\r\n    printf(\"Price: %.2lf\\n\",inventory->items[i].Price);\r\n    if(inventory->Availability[i].inStock){\r\n        printf(\"Status: InStock\\n\");\r\n    }\r\n    else{\r\n        printf(\"Status: OutofStock\\n\");\r\n    }\r\n     printf(\"----------------------------------\\n\");\r\n  }\r\n}\r\n//function to update quantity \r\nvoid update(GroceryInventory* inventory){\r\n    char change[100] ;\r\n\r\n    printf(\"\\nPlease enter name of item to be changed quantity: \");\r\n    fgets(change,100,stdin);\r\n    change[strcspn(change,\"\\n\")] ='\\0' ;\r\n    for (int i = 0 ; i < inventory->count ; i++){\r\n    if (strcmp(change,inventory->items[i].name)==0){\r\n        printf(\"\\nEnter new quantity :\"); \r\n        scanf(\"%d\",&inventory->items[i].Quantity);\r\n        printf(\"Item updated successfully\\n\");\r\n     }\r\n     else{\r\n         printf(\"Item does not exist\\n\");\r\n     }\r\n     if (inventory->items[i].Quantity == 0 ){\r\n       inventory->Availability[i].inStock = false ;\r\n     inventory->Availability[i].outofStock = true ;\r\n    }\r\n    }  \r\n}\r\n\r\n//function to remove grocery item \r\nvoid removeitem(GroceryInventory* inventory){\r\n  char change[100] ;\r\n printf(\"\\nPlease enter name of item to be removed \");\r\n  fgets(change,100,stdin);\r\n  change[strcspn(change,\"\\n\")] ='\\0' ;\r\n  for (int i = 0 ; i < inventory->count ; i++){\r\n    if (strcmp(change,inventory->items[i].name)==0){\r\n      for (int j = i; j < inventory->count-1 ; j++){\r\n        inventory->items[j]=inventory->items[j+1];\r\n       inventory->Availability[j] = inventory->Availability[j+ 1];\r\n\r\n     }\r\n    }\r\n  }\r\n}\r\nint main(){\r\n GroceryInventory* inventory = (GroceryInventory*)malloc(sizeof(GroceryInventory));\r\n  inventory->count = 0;\r\n\r\n  char choice ;\r\n // loop until exit\r\n   while (1){\r\n     \r\n        //menu\r\n   printf(\"Grocery Inventory Management System\\n\");\r\n   printf(\"1:Add Grocery Item\\n\");\r\n   printf(\"2:List All Grocery Items\\n\");\r\n   printf(\"3:Update Quantity\\n\");\r\n   printf(\"4:Remove Grocery Item\\n\");\r\n   printf(\"5:Exit\\n\");\r\n   \r\n   printf(\"\\nEnter your choice : \");\r\n   scanf(\" %c\",&choice);\r\n  getchar();// Consume the newline character\r\n\r\n\r\n   switch(choice){\r\n      case '1' :\r\n        if (inventory->count >= 100) {\r\n         printf(\"\\nInventory is full. Cannot add more items.\\n\");\r\n          break;\r\n        }\r\n          add(inventory);\r\n          inventory->count++ ;\r\n          printf(\"Item added successfully\\n\");\r\n          break ;\r\n      case '2' :\r\n         if (inventory->count == 0) {\r\n         printf(\"\\nThere are no items in the inventory\\n\");\r\n          break;\r\n        }\r\n         list(inventory);\r\n         break;\r\n      case '3' :\r\n          if (inventory->count == 0) {\r\n         printf(\"There are no items in the inventory\\n\");\r\n          break;\r\n        }\r\n\r\n         update(inventory);\r\n         \r\n          break;\r\n      case '4' :\r\n          if (inventory->count == 0) {\r\n         printf(\"There are no items in the inventory\\n\");\r\n          break;\r\n        }\r\n         removeitem(inventory);\r\n         inventory->count-- ;\r\n         printf(\"Item removed successfully\\n\");\r\n         break;\r\n      case '5' :\r\n         printf(\"Exiting.......\");\r\n          return 0;\r\n          break;\r\n     default :\r\n         printf(\"Please enter a choice between 1 and 5 \\n\");\r\n         break;\r\n   }\r\n       \r\n   }\r\n       \r\n\r\n    return 0 ;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* queue = malloc(sizeof(Student)); // Allocate space\r\n    if (!queue) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(queue->name, name);\r\n    queue->id = id;\r\n    queue->grade = grade;\r\n    queue->next = NULL;\r\n    return queue;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* queue = createStudent(name, id, grade);\r\n    queue->next = head;\r\n    head = queue;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"List is empty, nothing to display.\\n\");\r\n        return;\r\n    }\r\n    Student* node = head;\r\n    printf(\"Student records:\\n\");\r\n    while (node) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", node->name, node->id, node->grade);\r\n        node = node->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int ID) {\r\n    if (head == NULL) {\r\n        printf(\"List is empty, nothing to search.\\n\");\r\n        return NULL;\r\n    }\r\n    Student* p = head;\r\n    while (p) {\r\n        if (p->id == ID) {\r\n            return p; // Return the matching student node\r\n        }\r\n        p = p->next;\r\n    }\r\n    printf(\"No student found with ID %d.\\n\", ID);\r\n    return NULL; // Return NULL if no match is found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to free memory (wrapper for deleteList)\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade (Bubble Sort)\r\nvoid sortStudents() {\r\n    if (head == NULL) {\r\n        printf(\"List is empty, nothing to sort.\\n\");\r\n        return;\r\n    }\r\n    Student *node1, *index;\r\n    float tempGrade;\r\n    int tempID;\r\n    char tempName[100];\r\n\r\n    for (node1 = head; node1 != NULL; node1 = node1->next) {\r\n        for (index = node1->next; index != NULL; index = index->next) {\r\n            if (node1->grade > index->grade) {\r\n                // Swap grades\r\n                tempGrade = node1->grade;\r\n                node1->grade = index->grade;\r\n                index->grade = tempGrade;\r\n\r\n                // Swap IDs\r\n                tempID = node1->id;\r\n                node1->id = index->id;\r\n                index->id = tempID;\r\n\r\n                // Swap names\r\n                strcpy(tempName, node1->name);\r\n                strcpy(node1->name, index->name);\r\n                strcpy(index->name, tempName);\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\"); // Remove newline character\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student* found = searchStudentByID(id);\r\n            if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n            }\r\n            break;\r\n\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-The variable sum is reused in both the add and sub functions. While this does not cause a syntax error, it may lead to confusion as it should be named appropriately (e.g., result for clarity).\nq2-In the update function, the message \"Item does not exist\" is printed for every item that doesn't match the input name, rather than just once after the loop if no matches are found.In the removeitem function, the count is decremented after the item is removed, but it doesn't handle the last item properly, which could lead to accessing invalid memory. The last item should be set to a \"null\" state.The inStock and outofStock fields in the AvailabilityStatus struct are not updated correctly when the quantity is changed. The logic should ensure that only one of these fields is true at any time.\nq3-Bubble Sort is implemented correctly, but it is inefficient for larger datasets, with a time complexity of O(n?). While suitable for educational purposes, it would be beneficial to consider a more efficient sorting algorithm, such as Quick Sort or Merge Sort, especially as the number of records increases."
  },
  {
    "student_id": "20603953",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_ROW 10\r\n#define MAX_COL 10\r\n\r\n// FUnction prototypes\r\nint add_matrix(int a[MAX_ROW][MAX_COL], int b[MAX_ROW][MAX_COL], int row, int col, int result[MAX_ROW][MAX_COL]);\r\nint subtract_matrix(int a[MAX_ROW][MAX_COL], int b[MAX_ROW][MAX_COL], int row, int col, int result[MAX_ROW][MAX_COL]);\r\nint transpose_matrix(int matrix[MAX_ROW][MAX_COL], int row, int col, int result[MAX_ROW][MAX_COL]);\r\n\r\nint main(){\r\n    // initialise variables\r\n    int rowA=0; \r\n    int colA=0;\r\n    int rowB=0;\r\n    int colB=0;\r\n    \r\n    int matrixA[MAX_ROW][MAX_COL];\r\n    int matrixB[MAX_ROW][MAX_COL];\r\n    int result_matrix[MAX_ROW][MAX_COL];\r\n\r\n    // while user inputs for row or col exceed 10(invalid), it'll keep looping until user enters a valid input\r\n    while(1){\r\n\r\n        printf(\"Enter dimensions for Matrix A (rows & columns): \");\r\n        scanf(\"%d %d\", &rowA, &colA);\r\n\r\n        if (rowA >= 10 || colA >= 10){\r\n            puts(\"Error. Matrix dimension size must be not more than 10.\\n\");\r\n        }\r\n        else{\r\n            break;\r\n        }   \r\n    }\r\n    puts(\"Enter elements for Matrix A:\");\r\n    // allocate elements into array\r\n    for (int i=0; i<rowA; i++){\r\n        for(int j=0; j<colA; j++){\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    // while user inputs for row & col exceed 10(invalid), it'll keep looping until user enters a valid input\r\n    while (1){\r\n        printf(\"Enter dimensions for Matrix B (rows & columns): \");\r\n        scanf(\"%d %d\", &rowB, &colB);\r\n        \r\n        if (rowB >= 10 || colB >= 10){\r\n            puts(\"Error. Matrix dimension size must be not more than 10.\\n\");\r\n        }\r\n        else{\r\n            break;\r\n        }\r\n    }\r\n    puts(\"Enter elements for Matrix B:\");\r\n    // allocate elements into array\r\n    for (int i=0; i<rowB; i++){\r\n        for(int j=0; j<colB; j++){\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n    while(1){\r\n        char choice;\r\n        // menu\r\n        puts(\"\\n\");\r\n        puts(\"Matrix Operations Menu:\");\r\n        puts(\"1. Add Matrices\");\r\n        puts(\"2. Subtract Matrices\");\r\n        puts(\"3. Transpose Matrix A\");\r\n        puts(\"4. Transpose Matrix B\");\r\n        puts(\"5. Exit\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\" %c\", &choice);\r\n        // uses %c instead of %d to prevent error if user enters characters/string, space before %c to prevent newline being read as 2nd choice\r\n\r\n        switch (choice){\r\n        case '1':\r\n        // only identical size/dimensions array can do addition\r\n            if (rowA != rowB || colA != colB){\r\n                printf(\"Error. Matrices must have identical dimensions.\\n\");\r\n                break;\r\n            }\r\n            else{\r\n                add_matrix(matrixA, matrixB, rowA, colA, result_matrix);   \r\n            }\r\n            break;\r\n        case '2':\r\n        // only identical size/dimensions array can do subtraction\r\n            if (rowA != rowB || colA != colB){\r\n                printf(\"Error. Matrices must have identical dimensions.\\n\");\r\n            }\r\n            else{\r\n                subtract_matrix(matrixA, matrixB, rowA, colA, result_matrix);   \r\n            }\r\n            break;\r\n        case '3':\r\n            puts(\"Transpose of Matrix A:\");\r\n            transpose_matrix(matrixA, rowA, colA, result_matrix);\r\n            break;\r\n        case '4':\r\n            puts(\"Transpose of Matrix B:\");\r\n            transpose_matrix(matrixB, rowB, colB, result_matrix);\r\n            break;\r\n        case '5':\r\n            printf(\"Exiting...\");\r\n            return 0;\r\n        default:\r\n            printf(\"Error. Pls enter available choice(1-5).\");\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n// Functions \r\nint add_matrix(int a[MAX_ROW][MAX_COL], int b[MAX_ROW][MAX_COL], int row, int col, int result[MAX_ROW][MAX_COL]){\r\n    // Matrix A + Matrix B\r\n    for(int i=0; i < row; i++){\r\n        for (int j=0; j < col; j++){\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n    // print results\r\n    puts(\"Result of Matrix A + Matrix B:\");\r\n    for(int i=0; i < row; i++){\r\n        for (int j=0; j < col; j++){\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n\r\nint subtract_matrix(int a[MAX_ROW][MAX_COL], int b[MAX_ROW][MAX_COL], int row, int col, int result[MAX_ROW][MAX_COL]){\r\n    // Matrix A - Matrix B\r\n    for(int i=0; i < row; i++){\r\n        for (int j=0; j < col; j++){\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n    // print results\r\n    puts(\"Result of Matrix A - Matrix B:\");\r\n    for(int i=0; i < row; i++){\r\n        for (int j=0; j < col; j++){\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\r\n\r\n// swap values of row & cols\r\nint transpose_matrix(int matrix[MAX_ROW][MAX_COL], int row, int col, int result[MAX_ROW][MAX_COL]){\r\n    for(int i=0; i < row; i++){\r\n        for (int j=0; j < col; j++){\r\n            result[j][i]=matrix[i][j];\r\n        }\r\n        /*\r\n        exp: \r\n            [0] [1] [2]\r\n        [0]  1   2   3\r\n        [1]  4   5   6\r\n\r\n        when i=0, j=2\r\n        result[2][0] = matrix[0][2] = 3\r\n\r\n        result =    [0] [1] [2]\r\n                 [0]    \r\n                 [1]\r\n                 [2] 3    \r\n        \r\n        when i=1, j=0\r\n        result[0][1] = matrix[1][0] = 4\r\n        \r\n        result =    [0] [1] [2]\r\n                 [0]     4\r\n                 [1]\r\n                 [2] 3   \r\n                 .\r\n                 :\r\n        final result =      [0] [1] [2]\r\n                        [0]  1   4\r\n                        [1]  2   5\r\n                        [2]  3   6\r\n        */\r\n    }\r\n    // print transposed matrix\r\n    for(int i=0; i < col; i++){\r\n        for (int j=0; j < row; j++){\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n#define MAX_SIZE 100\r\n#define CATEGORY_SIZE 50\r\n\r\n// structure of grocery\r\ntypedef struct grocery\r\n{\r\n    char name[MAX_SIZE];\r\n    char category[CATEGORY_SIZE];\r\n    int quantity;\r\n    float price;\r\n    bool avai_status;       // availability status of item\r\n}Item;\r\n\r\n// Function prototypes\r\nvoid add_item(struct grocery item_array[], int* n, bool status[], bool i_stock, bool o_stock);\r\nvoid list_item(struct grocery item_array[], int n, bool status[], bool i_stock, bool o_stock);\r\nvoid update_quantity(struct grocery item_array[], int n, bool status[], bool i_stock, bool o_stock);\r\nvoid remove_item(struct grocery item_array[], int* n, bool status[], bool i_stock, bool o_stock);\r\nvoid clear (void);\r\n\r\nint main(){\r\n    // Grocery Inventory:\r\n    Item grocery_items[MAX_SIZE];                   // array of grocery items\r\n\r\n    // Avaibility status: \r\n    bool in_stock = true;\r\n    bool out_of_stock = false;\r\n    bool item_status[MAX_SIZE]={out_of_stock};      // set values in array of avaibility status default to out-of-stock (0)\r\n\r\n    int count_total =0;                             // count of total num of items in inventory\r\n\r\n    while(1){\r\n        char choice;\r\n        // menu\r\n        puts(\"\\n\");\r\n        puts(\"Grocery Inventory Management System\");\r\n        puts(\"1. Add Grocery Item\");\r\n        puts(\"2. List All Grocery Items\");\r\n        puts(\"3. Update Quantity\");\r\n        puts(\"4. Remove Grocery Item\");\r\n        puts(\"5. Exit\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\" %c\", &choice);          \r\n        // uses %c instead of %d to prevent error if user enters characters/string, space before %c to prevent newline being read as 2nd choice\r\n\r\n        puts(\" \");\r\n        switch (choice){\r\n        case '1':\r\n            add_item(grocery_items, &count_total, item_status, in_stock, out_of_stock);\r\n            break;\r\n        case '2':\r\n            list_item(grocery_items, count_total, item_status, in_stock, out_of_stock);\r\n            break;\r\n        case '3':\r\n            update_quantity(grocery_items, count_total, item_status, in_stock, out_of_stock);\r\n            break;\r\n        case '4':\r\n            remove_item(grocery_items, &count_total, item_status, in_stock, out_of_stock);\r\n            break;\r\n        case '5':\r\n            printf(\"Exiting...\");\r\n            return 0;\r\n        default:\r\n            printf(\"Error. Pls enter available choice(1-5).\");\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid add_item(struct grocery item_array[], int* n, bool status[], bool i_stock, bool o_stock){\r\n\r\n    clear();        // clear input buffer\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item_array[*n].name, MAX_SIZE, stdin);\r\n    item_array[*n].name[strcspn(item_array[*n].name, \"\\n\")]='\\0';     // remove newline character\r\n\r\n    // change all characters to lowercase for comparing in other functions\r\n    for (int k=0; k< sizeof(item_array[*n].name); k++){\r\n        item_array[*n].name[k] = tolower(item_array[*n].name[k]);\r\n    }\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item_array[*n].category, CATEGORY_SIZE, stdin);\r\n    item_array[*n].category[strcspn(item_array[*n].category, \"\\n\")]='\\0';     // remove newline character    \r\n\r\n    // change all characters to lowercase for comparing in other functions\r\n    for (int k=0; k< sizeof(item_array[*n].category); k++){\r\n        item_array[*n].category[k] = tolower(item_array[*n].category[k]);\r\n    }\r\n\r\n    while (1){\r\n        printf(\"Enter Quantity: \");\r\n        scanf(\"%d\", &item_array[*n].quantity);\r\n        \r\n        if (item_array[*n].quantity <= 0){\r\n            clear();\r\n            printf(\"Initial quantity of item must not be less than 0.\\n\");\r\n            continue;\r\n        }\r\n        else{\r\n            break;       \r\n        }\r\n    }\r\n\r\n    while(1){\r\n        printf(\"Enter Price: \");\r\n        scanf(\"%f\", &item_array[*n].price);\r\n\r\n        if (item_array[*n].price <= 0){\r\n            clear();\r\n            printf(\"Price of item must not be less than 0.00.\\n\");\r\n            continue;\r\n        }\r\n        else{\r\n            break;       \r\n        }\r\n    }\r\n\r\n    if (item_array[*n].quantity > 0){\r\n        item_array[*n].avai_status = i_stock;\r\n\r\n        for (int i=0; i < MAX_SIZE; i++){\r\n            if (status[i] == o_stock && i >= *n){\r\n                status[i] = i_stock;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        item_array[*n].avai_status = o_stock;\r\n    }\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n\r\n    (*n) += 1;      // count of total num +1\r\n}\r\n\r\nvoid list_item(struct grocery item_array[], int n, bool status[], bool i_stock, bool o_stock){\r\n\r\n    if (n==0){\r\n        printf(\"No grocery items in the inventory.\");\r\n        return;     // return to main function\r\n    }\r\n    \r\n    for (int i=0; i < n; i++){        \r\n        printf(\"Item [%d]:\\n\", i+1);\r\n\r\n        item_array[i].name[0] = toupper(item_array[i].name[0]);     // display 1st character in uppercase\r\n        printf(\"Name: %s\\n\", item_array[i].name);\r\n\r\n        item_array[i].category[0] = toupper(item_array[i].category[0]);     // display 1st character in uppercase\r\n        printf(\"Category: %s\\n\", item_array[i].category);\r\n\r\n        printf(\"Quantity: %d\\n\", item_array[i].quantity);\r\n        printf(\"Price: %.2f\\n\", item_array[i].price);\r\n\r\n        if (item_array[i].avai_status == i_stock){\r\n            printf(\"Status: %s\", \"In Stock\\n\");\r\n        }\r\n        else{\r\n            printf(\"Status: %s\", \"Out of Stock\\n\");\r\n        }\r\n        printf(\"------------------------------\\n\");\r\n        // return back to lowercase for comparing in option 3 & 4\r\n        item_array[i].name[0] = tolower(item_array[i].name[0]);\r\n        item_array[i].category[0] = tolower(item_array[i].category[0]);\r\n    }\r\n}\r\n\r\nvoid update_quantity(struct grocery item_array[], int n, bool status[], bool i_stock, bool o_stock){\r\n    clear();\r\n\r\n    char temp[MAX_SIZE];\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(temp, MAX_SIZE, stdin);\r\n    temp[strcspn(temp, \"\\n\")]='\\0';         // remove '\\n'\r\n\r\n    // change all characters to lowercase -> easy for comparing\r\n    for (int k=0; k< sizeof(temp)/sizeof(temp[0]); k++){\r\n        temp[k] = tolower(temp[k]);\r\n    }\r\n\r\n    for (int i=0; i < n; i++){\r\n        if (strcmp(temp, item_array[i].name)==0){\r\n            while (1){\r\n                printf(\"Enter new quantity for %s: \", temp);\r\n                scanf(\"%d\", &item_array[i].quantity);\r\n            \r\n                if (item_array[i].quantity > 0){\r\n                    item_array[i].avai_status = i_stock;\r\n                    break;      // break while loop\r\n                }\r\n                else if (item_array[i].quantity == 0){\r\n                    item_array[i].avai_status = o_stock;\r\n                    break;       // break while loop\r\n                }\r\n                else{\r\n                    printf(\"Quantity of item must not be less than 0.\\n\");\r\n                }\r\n            }  \r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;      // return to main function\r\n        }\r\n    }\r\n    // after looping through the array, if the item name is not found, display the message below\r\n    temp[0] = toupper(temp[0]);\r\n    printf(\"Item '%s' not found in the inventory.\\n\", temp);\r\n}\r\n\r\nvoid remove_item(struct grocery item_array[], int* n, bool status[], bool i_stock, bool o_stock){\r\n    clear();\r\n\r\n    char temp[MAX_SIZE];\r\n    \r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(temp, MAX_SIZE, stdin);\r\n    temp[strcspn(temp, \"\\n\")]='\\0';         // remove '\\n'\r\n\r\n    // change all characters to lowercase -> easy for comparing\r\n    for (int k=0; k< sizeof(temp)/sizeof(temp[0]); k++){\r\n        temp[k] = tolower(temp[k]);\r\n    }\r\n\r\n    for (int i=0; i < *n; i++){\r\n        if (strcmp(temp, item_array[i].name)==0){\r\n            item_array[i]=item_array[i+1];          // move elements in next index to current index, current index elements replaced by next index's elements\r\n\r\n            temp[0] = toupper(temp[0]);\r\n            printf(\"Grocery item '%s' removed successfully!\", temp);\r\n            (*n) -= 1;      // count of total num -1\r\n            return;         // return to main function\r\n        }\r\n    }\r\n    // display message below if item name is not found after looping through the array\r\n    temp[0] = toupper(temp[0]);\r\n    printf(\"Item '%s' not found in the inventory.\\n\", temp);\r\n}\r\n\r\n// clear input buffer\r\nvoid clear (void){\r\n    while ( getchar() != '\\n' );\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;       // singly linked list\r\n\r\n// Function prototypes\r\n\r\n// 1. Inserts a new student record into the linked list.\r\nvoid insertStudent(const char* name, int id, float grade);\r\nStudent* createStudent(const char* name, int id, float grade);  // Creates a new student node and returns a pointer to it.\r\n\r\n// 2. Displays all current student records in the linked list.\r\nvoid displayStudents(Student* head1); \r\n\r\n// 3. Sort the student records by grade according to a sorting algorithm of your choice. \r\nvoid sortStudents(); \r\nStudent* split_list(Student* head1);        // split linked-list into two halves\r\nStudent* mergeSort(Student* head1);\r\nStudent* merge(Student* first, Student* second);\r\n\r\n// 4. Searches for a student record by student ID and returns a pointer to the corresponding student node.\r\nStudent* searchStudentByID(int id);  \r\n\r\n// 5. Deletes the entire linked list and frees the allocated memory.\r\nvoid deleteList();  \r\n\r\n// 6. Exit - A utility function to ensure that all memory is freed when the program exits.\r\nvoid freeMemory();  \r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (Merge Sort)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n    \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                while(1){\r\n                    printf(\"Enter ID: \");\r\n                    scanf(\"%d\", &id);\r\n                    // use searchStudentByID(id) to see if the ID is already in used\r\n                    if (searchStudentByID(id) != NULL){\r\n                        printf(\"ID is taken, pls enter a valid ID.\\n\");\r\n                    }\r\n                    else{\r\n                        break;\r\n                    }\r\n                }\r\n                // grade validation - set grade range\r\n                while(1){\r\n                    printf(\"Enter Grade: \");\r\n                    scanf(\"%f\", &grade);\r\n                    if (grade < 0 || grade > 100){\r\n                        printf(\"Grade should be within 0-100, pls enter a valid range.\\n\");\r\n                    }\r\n                    else{\r\n                        break;\r\n                    }\r\n                }\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents(head);\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id); \r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                    found->name, found->id, found->grade);\r\n                }\r\n                else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n} \r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // create a new node\r\n    Student* newNode = (struct Student*)malloc(sizeof(Student));\r\n    \r\n    // assign new student node data\r\n    strcpy(newNode->name, name);\r\n    newNode->id = id;\r\n    newNode->grade = grade;\r\n    newNode->next = NULL;\r\n    \r\n    return newNode;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newNode = createStudent(name, id, grade);\r\n    // insert student at first(top) of the record\r\n    newNode->next = head;\r\n    head = newNode;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents(Student* head1) {\r\n    if (head1 == NULL){\r\n        printf(\"Student record is empty.\\n\");\r\n        return;     // return to main() function if linked-list is empty\r\n    }\r\n    \r\n    Student* temp = head1;\r\n    while (temp != NULL){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n\r\n    while(current != NULL){\r\n        if(id == current->id){\r\n            return current;         // return compatible id to main()\r\n        }\r\n        current = current->next;    // else continue to compare next id\r\n    }\r\n    return NULL;       // return NULL if no student is found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next; \r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);          // free current allocated memory\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (head == NULL){\r\n        printf(\"Student record is empty.\\n\");\r\n        return;     // return to main() function if linked-list is empty\r\n    }\r\n    head = mergeSort(head);\r\n    printf(\"Records sorted by grade using Merge Sort\\n\");\r\n}\r\n// merge sort algorithm\r\n// chose this algorithm because i have done this algorithm on another project so i'm more familiar with it\r\n// it also suitable for large datasets\r\nStudent* split_list(Student* head1){      // split linked list\r\n    // struct pointers\r\n    Student* two = head1;\r\n    Student* one = head1;\r\n\r\n    // two - move 2 steps, one - move 1 step --> when two reaches the end, one is at the midpoint og list\r\n    while (two != NULL && two->next != NULL){\r\n        two = two->next->next;\r\n        if (two != NULL){\r\n            one = one->next;\r\n        }\r\n    }\r\n    // split list into 2 halves\r\n    Student* temp = one->next;\r\n    one->next = NULL;\r\n    return temp;\r\n}\r\n\r\nStudent* mergeSort(Student* head1){\r\n    // if head or next == NULL --> sorted --> merge\r\n    if (head1 == NULL || head1->next == NULL) {\r\n        return head1;     // return to sortStudents()\r\n    }\r\n\r\n    Student* second = split_list(head1);\r\n\r\n    // recursion call (keep splitting array until both left[] & right[] only contain 1 element --> prepare to merge)\r\n    head1 = mergeSort(head1);\r\n    second = mergeSort(second);\r\n\r\n    // merge the sorted halves arrays\r\n    return merge(head1, second);\r\n}\r\n\r\nStudent* merge(Student* first, Student* second){\r\n    // if list is empty --> return the other list (pointed by pointer)\r\n    if (first == NULL){\r\n        return second;\r\n    }\r\n    if (second == NULL){\r\n        return first;\r\n    }\r\n\r\n    // compare first->grade & second->grade\r\n    if (first->grade <= second->grade){\r\n        // recursively call merge() & link result to current node\r\n        first->next = merge(first->next, second);\r\n        return first;\r\n    }\r\n    else{\r\n        // recursively call merge() & link result to current node\r\n        second->next = merge(first, second->next);\r\n        return second;\r\n    }\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Merge Sort algorithm is implemented correctly. It has a time complexity of O(n log n), which makes it suitable for larger datasets compared to Bubble Sort. The splitting and merging functions are well-structured and effectively sort the linked list."
  },
  {
    "student_id": "20713649",
    "code": "",
    "feedback": "q1-To improve, ensure that the dimensions used for printing the transposed matrices in cases 3 and 4 reflect the correct number of rows and columns after transposition. Specifically, when printing the transposed matrix, swap the row and column dimensions in the print loop. Overall, the program is well-structured and functions as intended.\nq2-    Uninitialized Pointer Usage: In the updateQuantity and removeItem functions, the pointers QuantityItemInfo and RemoveItemInfo are declared but not initialized before use. This leads to undefined behavior when accessing the item data.    Inefficient Search: The program uses a linear search when updating and removing items, which is acceptable, but it may lead to inefficiencies for large inventories. Consider using a more efficient data structure if performance is a concern.\nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20590531",
    "code": "\n/* --- Question_1.c --- */\n#include <stdio.h>\n\n#define MAX 10  // Maximum size of the matrix\n\n// Function Prototypes\n// Function to print a matrix\nvoid printMatrix (int matrix[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf (\"%d \", matrix[i][j]);\n        }\n        printf (\"\\n\");\n    }\n}\n\n// Function to add two matrices\nvoid addMatrices (int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = a[i][j] + b[i][j];   // Add coresponding elements\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices (int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = a[i][j] - b[i][j];   // Substract corresponding elements\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix (int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];    // Swap rows with columns\n        }\n     }\n}\n\nint main () {\n    int rowsA, colsA, rowsB, colsB;\n    int matrixA[MAX][MAX], matrixB[MAX][MAX];\n    int result[MAX][MAX];\n    int choice;\n\n    // Prompt user to input dimensions for Matrix A and validate it\n    printf (\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf (\"%d %d\", &rowsA, &colsA);\n    while (rowsA <= 0 || colsA <= 0 || rowsA > MAX || colsB > MAX) {\n        printf (\"Invalid dimensions for Matrix A. Please enter values between 1 and %d for both rows and columns. \\n\", MAX);\n        printf (\"Enter dimensions for Matrix A (rows and columns): \");\n        scanf (\"%d %d\", &rowsA, &colsA);\n    }\n\n    // Input elements for Matrix A\n    printf (\"Enter elements for Matrix A: \\n\");\n    for (int i = 0; i < rowsA; i++) {\n        for (int j = 0; j < colsA; j++) {\n            printf (\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf (\"%d\", &matrixA[i][j]);\n        }\n    }\n\n    // Prompt user to Input dimensions for Matrix B and validate it \n    printf (\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf (\"%d %d\", &rowsB, &colsB);\n    while (rowsA <= 0 || colsA <= 0 || rowsB > MAX || colsB > MAX) {\n        printf (\"Invalid dimensions for Matrix B. Please enter values between 1 and %d for both rows and columns. \\n\", MAX);\n        printf (\"Enter dimensions for Matrix B (rows and columns): \");\n        scanf (\"%d %d\", &rowsB, &colsB);\n    }\n\n    printf (\"Enter elements for Matrix B: \\n\");\n    for (int i = 0; i < rowsB; i++) {\n        for (int j = 0; j < colsB; j++) {\n            printf (\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf (\"%d\", &matrixB[i][j]);\n        }\n    }\n\n    // Menu and Operaton loop\n    while (1) {\n        // Menu display\n        printf (\"\\nMatrix Operation Menu: \\n\");\n        printf (\"1. Add Matrics\\n\");\n        printf (\"2. Subtract Matrices\\n\");\n        printf (\"3. Transpose Matrix A\\n\");\n        printf (\"4. Transpose Matrix B\\n\");\n        printf (\"5. Exit\\n\");\n        printf (\"Enter your choice: \");\n        scanf (\"%d\", &choice);\n\n        // Switch case for operations\n        switch (choice) {\n            case 1:\n                // Add matrices if dimensions match\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices (matrixA, matrixB, result, rowsA, colsB);\n                    printf (\"Result of Matrix A + Matrix B: \\n\");\n                    printMatrix (result, rowsA, colsA);\n                } else {\n                    printf (\"Matrix dimensions must match for addition. \\n\");\n                }\n                break;\n            \n            case 2:\n                // Subtract matrices if dimensions match\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices (matrixA, matrixB, result, rowsA, colsA);\n                    printf (\"Result of Matrix A - Matrix B: \\n\");\n                    printMatrix (result, rowsA, colsA);\n                } else {\n                    printf (\"Matrix dimensions must match for subtractions. \\n\");\n                }\n                break;\n\n            case 3: \n                // Transpose Matrix A\n                transposeMatrix (matrixA, result, rowsA, colsA);\n                printf (\"Transpose of Matrix A: \\n\");\n                printMatrix (result, colsA, rowsA); // Rows become columns \n                break;\n\n            case 4: \n                // Transpose Matrix B\n                transposeMatrix (matrixB, result, rowsB, colsB);\n                printMatrix (result, colsB, rowsB);\n                break;\n\n            case 5:\n                // Exit Program\n                printf (\"Exiting...\\n\");\n                return 0;\n\n            default:\n                // Invalid Menu Choice (Choice > 5)\n                printf (\"Invalid choice. Please try again. \\n\");\n                break;\n        }\n    }\n\n    return 0;\n}\n/* --- Question_2.c --- */\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n\ntypedef struct {\n    char name[100];     // Name of the grocery item\n    char category[50];  // Category of the item\n    int quantity;       // Quantity of the item\n    float price;        // Price of the item\n    char status[20];    // Status: \"In Stock\" or \"Out of Stock\"\n} GroceryItem;\n\n// Function Prototypes\n\n// Function to add a new grocery item to the inventory\nvoid addGroceryItem (GroceryItem inventory[], int *count) {\n    // Check if the inventory is full\n    if (*count >= MAX_ITEMS) {\n        printf (\"Inventory is full. Cannot add more items. \\n\");\n        return;\n    }\n    GroceryItem item;\n\n    // Input item details\n    printf (\"Enter Item Name: \");\n    scanf (\" %[^\\n]%*c\", item.name);\n    printf (\"Enter Category: \");\n    scanf (\" %[^\\n]%*c\", item.category);\n    printf (\"Enter Quantity: \");\n    scanf (\"%d\", &item.quantity);\n    printf (\"Enter Price: \");\n    scanf (\"%f\", &item.price);\n\n    // Set the status based on the quantity\n    strcpy (item.status, item.quantity > 0 ? \"In Stock\" : \"Out of Stock\");\n\n    // Add item to the inventory\n    inventory[*count] = item;\n    (*count)++; // Increment the inventory count\n    printf (\"Grocery item added successfully! \\n\");\n}\n\n// Function to list all grocery items in the inventory\nvoid listGroceryItems (GroceryItem inventory[], int count) {\n    // Check if there are no items in the inventory\n    if (count == 0) {\n        printf (\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    // Loop and display each item\n    for (int i = 0; i < count; i++) {\n        printf (\"Name: %s\\n\", inventory[i].name);\n        printf (\"Category: %s\\n\", inventory[i].category);\n        printf (\"Quantity: %d\\n\", inventory[i].quantity);\n        printf (\"Price: %.2f\\n\", inventory[i].price);\n        printf (\"Status: %s\\n\\n\", inventory[i].status);\n    }\n}\n\n// Function to update the quantity of a specific grocery item\nvoid updateQuantity (GroceryItem inventory[], int count) {\n    char name[100];\n    int newQuantity;\n\n    // Prompt user to input the name fo the item to update\n    printf (\"Enter name of the grocery item to update quantity: \");\n    scanf (\" %[^\\n]%*c\", name);\n\n    // Search for the item in the inventory\n    for (int i = 0; i < count; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            // Prompt user to input the new quantity\n            printf (\"Enter new quantity for %s: \", name);\n            scanf (\"%d\", &newQuantity);\n\n            // Update the quantity and status\n            inventory[i].quantity = newQuantity;\n            strcpy (inventory[i].status, newQuantity > 0 ? \"In Stock\" : \"Out of Stock\");\n            printf (\"Quantity updated successfully! \\n\");\n            return;\n        }\n    }\n    // If item is not found\n    printf (\"Item not found in inventory. \\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem (GroceryItem inventory[], int *count) {\n    char name[100];\n    // Prompt user to input the name fo the item to remove\n    printf (\"Enter name of the grocery item to remove: \");\n    scanf (\" %[^\\n]%*c\", name);\n    \n    // Search for the item in the inventory\n    for (int i = 0; i < *count; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            // Shift all items after the found item to fill the gap\n            for (int j = i; j < *count - 1; j++) {\n                inventory[j] = inventory[j + 1];\n            }\n            (*count)--; // Decrement the inventory count\n            printf (\"Grocery item '%s' removed successfully! \\n\", name);\n            return;\n        }\n    }\n    // If the item is not found\n    printf (\"Item not found in inventory.\\n\");\n}\n\n// Main function to manage the grocery inventory system\nint main () {\n    GroceryItem inventory[MAX_ITEMS];   // Array to store grocery items\n    int count = 0;  // Number of items in the inventory\n    int choice; // User's menu choice\n\n    // Loop until user choose to exit\n    while (choice != 5) {\n        printf (\"\\nGrocery Inventory Management System\\n\");\n        printf (\"1. Add Grocery Item\\n\");\n        printf (\"2. List All Grocery Items\\n\");\n        printf (\"3. Update Quantity\\n\");\n        printf (\"4. Remove Grocery Item\\n\");\n        printf (\"5. Exit\\n\");\n        printf (\"Enter Your Choice: \");\n        scanf (\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                addGroceryItem (inventory, &count);\n                break;\n            \n            case 2: \n                listGroceryItems (inventory, count);\n                break;\n\n            case 3: \n                updateQuantity (inventory, count);\n                break;\n\n            case 4: \n                removeGroceryItem (inventory, &count);\n                break;\n\n            case 5: \n                printf (\"Exiting...\\n\");\n                break;\n            \n            default:\n                printf (\"Invalid Choice. Please try again. \\n\");\n        }\n    }\n    return 0;\n}\n/* --- Question_3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent (const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf (\"Memory allocation failed. \\n\");\n        return NULL;\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent (const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    if (!newStudent) return;\n\n    if (!head) {\n        head = newStudent;\n    } else {\n        Student* temp = head;\n        while (temp->next) {\n            temp = temp->next;\n        }\n        temp->next = newStudent;\n     }\n     printf (\"Student record inserted successfully.\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents () {\n    if (!head) {\n        printf (\"No student records found.\\n\");\n        return;\n    }\n\n    Student* temp = head;\n    while (temp) {\n        printf (\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp) {\n        if (temp->id == id) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList () {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n    printf (\"All student records deleted successfully. \\n\");\n}\n\nvoid freeMemory () {\n    deleteList();\n}\n\n// Sort Function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents () {\n    if (!head || !head->next) {\n        printf (\"Not enough records to sort. \\n\");\n        return;\n    }\n\n    int swapped;\n    Student* ptr1;\n    Student* lptr = NULL;\n\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                // Swap data\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, ptr1->name);\n                tempID = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempID;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            \n            ptr1 = ptr1->next;\n        }\n\n        lptr = ptr1;\n    } while (swapped);\n\n    printf (\"Records sorted by grade using Bubble sort. \\n\");\n}\n\n// Main function to drive the program\nint main () {\n\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf (\"\\n1. Insert Student Record\\n\");\n        printf (\"2. Display Student Records\\n\");\n        printf (\"3. Sort Records (choose sorting method)\\n\");\n        printf (\"4. Search Record by ID\\n\");\n        printf (\"5. Delete List\\n\");\n        printf (\"6. Exit\\n\");\n        printf (\"Enter your choice: \");\n        scanf (\"%d\", &choice);\n        getchar();  // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf (\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf (\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf (\"Enter Grade:\");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortStudents();\n                break;\n            \n            case 4:\n                printf (\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n\n                if (found) {\n                    printf (\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found. \\n\");\n                }\n                break;\n\n            case 5:\n                deleteList();\n                printf (\"List deleted.\\n\");\n                break;\n\n            case 6:\n                freeMemory();\n                printf (\"Exiting...\\n\");\n                break;\n            \n            default:\n                printf (\"Invalid choice! Please try again. \\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}",
    "feedback": "q1-In the dimension validation for Matrix B, the condition incorrectly checks colsA instead of colsB. \nq2-The choice variable in the main function is used without being initialized. This can cause undefined behavior when the program first checks the condition in the while loop. It should be initialized to a value (e.g., 0) before the loop begins.\nq3-    The bubble sort implementation correctly sorts the student records by grade. However, bubble sort has a time complexity of O(n?), making it inefficient for larger datasets. For better performance, consider using a more efficient sorting algorithm, such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20705932",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define max 10\r\n\r\nvoid inputTwoMatrices(int matrixA[max][max], int matrixB[max][max], int rowsA, int colsA, int rowsB, int colsB) {\r\n    for (int i = 0; i < rowsA; i++) {\r\n        for (int j = 0; j < colsA; j++) {\r\n            printf(\"Matrix A [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n    printf(\"=====================================\\n\");\r\n\r\n    for (int i = 0; i < rowsB; i++) {\r\n        for (int j = 0; j < colsB; j++) {\r\n            printf(\"Matrix B [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n \r\n}\r\n\r\nvoid DisplayMatrix(int matrix[max][max], int rows, int cols) {\r\n     printf(\"Matrix (%dx%d):\\n\", rows, cols);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid MatrixAdd(int matrix1[max][max], int matrix2[max][max], int FinalArray[max][max], int rows, int cols) { \r\n\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            FinalArray[i][j] = matrix1[i][j] + matrix2[i][j];\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid MatrixSubtract(int matrix1[max][max], int matrix2[max][max], int FinalArray[max][max], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            FinalArray[i][j] = matrix1[i][j] - matrix2[i][j];\r\n        }\r\n    } \r\n}\r\n\r\nvoid MatrixTranspose(int matrixT[max][max], int FinalArray[max][max], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            FinalArray[j][i] = matrixT[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int A[max][max];\r\n    int B[max][max];\r\n    int result[max][max];\r\n    int choice;\r\n    int rowsA;\r\n    int colsA;\r\n    int rowsB;\r\n    int colsB;\r\n\r\n    printf(\"Enter Matrix A(rows and columns):\\n\");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter Matrix B(rows and columns):\\n\");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    inputTwoMatrices(A, B, rowsA, colsA, rowsB, colsB);\r\n    DisplayMatrix(A, rowsA, colsA);\r\n    DisplayMatrix(B, rowsB, colsB);\r\n\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"=========================\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"Result of addition: \\n\");\r\n                    MatrixAdd(A, B, result, rowsA, colsA);\r\n                    DisplayMatrix(result, rowsA, colsA);\r\n                        \r\n                } \r\n                else {\r\n                    printf(\"Cant Add. Matrices dimensions must match.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"Result of subtraction: \\n\");\r\n                    MatrixSubtract(A, B, result, rowsA, colsA);\r\n                    DisplayMatrix(result, rowsB, colsB);\r\n\r\n                } \r\n                else {\r\n                    printf(\"Cant Subtract. Matrices dimensions must match.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                printf(\"Result of Transposing Matrix A: \\n\");\r\n                MatrixTranspose(A, result, rowsA, colsA);\r\n                DisplayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                printf(\"Result of Transposing Matrix B: \\n\");\r\n                MatrixTranspose(B, result, rowsB, colsB);\r\n                DisplayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Ending the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n        \r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[100];\r\n    int quantity;\r\n    float price;\r\n    bool availability;\r\n} GrocItem;\r\n\r\nGrocItem *items[100];\r\n\r\nvoid allocateMemory() {\r\n    for (int i = 0; i < 100; i++) {\r\n        items[i] = (GrocItem*)malloc(sizeof(GrocItem));\r\n        if (items[i] == NULL) {\r\n            printf(\"Memory allocation failed for item %d\\n\", i);\r\n            exit(1);\r\n        }\r\n    }\r\n}\r\n\r\nvoid freeMemory() {\r\n    for (int i = 0; i < 100; i++) {\r\n        free(items[i]);\r\n    }\r\n}\r\n\r\nvoid addItem(int *item_count) {\r\n    if (*item_count >= 100) {\r\n        printf(\"Inventory is full, cannot add more items.\\n\");\r\n        return;\r\n    }\r\n    getchar();  // Clear newline from input buffer\r\n    printf(\"Enter the name of the product: \");\r\n    scanf(\" %[^\\n]s\", items[*item_count]->name);\r\n    \r\n    printf(\"Enter the category of the item: \");\r\n    scanf(\" %[^\\n]s\", items[*item_count]->category);\r\n    \r\n    while (1) {\r\n        printf(\"Enter the quantity of the item: \");\r\n        scanf(\"%d\", &items[*item_count]->quantity);\r\n        if (items[*item_count]->quantity < 0) {\r\n            printf(\"Quantity cannot be negative. Try again.\\n\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    \r\n    printf(\"Enter the price of the item: \");\r\n    scanf(\"%f\", &items[*item_count]->price);\r\n    \r\n    items[*item_count]->availability = (items[*item_count]->quantity > 0);\r\n    printf(\"Item added!\\n\");\r\n    (*item_count)++;\r\n}\r\n\r\nvoid displayGroceryItem(int item_count) {\r\n    if (item_count == 0) {\r\n        printf(\"No items to display.\\n\");\r\n        return;\r\n    }\r\n    printf(\"=========== Grocery Items ===========\\n\");\r\n    for (int i = 0; i < item_count; i++) {\r\n        printf(\"Item %d\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", items[i]->name);\r\n        printf(\"  Category: %s\\n\", items[i]->category);\r\n        printf(\"  Quantity: %d\\n\", items[i]->quantity);\r\n        printf(\"  Price: %.2f\\n\", items[i]->price);\r\n        printf(\"  Availability: %s\\n\", items[i]->availability ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(int item_count) {\r\n    if (item_count == 0) {\r\n        printf(\"No items in inventory. Request failed.\\n\");\r\n        return;\r\n    }\r\n    getchar();  // Clear newline from input buffer\r\n    char search_name[100];\r\n    printf(\"Enter the name of the item whose quantity you'd like to change: \");\r\n    scanf(\" %[^\\n]s\", search_name);\r\n    \r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(items[i]->name, search_name) == 0) {\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &items[i]->quantity);\r\n            while (items[i]->quantity < 0) {\r\n                printf(\"Quantity cannot be negative. Enter a new quantity: \");\r\n                scanf(\"%d\", &items[i]->quantity);\r\n            }\r\n            items[i]->availability = (items[i]->quantity > 0);\r\n            printf(\"updated quantity!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item could not be found.\\n\");\r\n}\r\n\r\nvoid deleteItem(int *item_count) {\r\n    if (*item_count == 0) {\r\n        printf(\"No items in inventory. Nothing can be deleted.\\n\");\r\n        return;\r\n    }\r\n    char search_name[100];\r\n    printf(\"Enter the name of the item you'd like to delete: \");\r\n    scanf(\" %[^\\n]s\", search_name);\r\n\r\n    for (int i = 0; i < *item_count; i++) {\r\n        if (strcmp(items[i]->name, search_name) == 0) {\r\n            for (int j = i; j < *item_count - 1; j++) {\r\n                items[j] = items[j + 1];\r\n            }\r\n            printf(\"Item deleted successfully.\\n\");\r\n            (*item_count)--;  // Decrease the item count\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item could not be found.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice = 0;\r\n    int item_count = 0;\r\n    allocateMemory();\r\n    \r\n    do {\r\n        printf(\"=======================\\n\");\r\n        printf(\"Grocery Inventory Manager\\n\");\r\n        printf(\"=======================\\n\");\r\n        printf(\"1. Add\\n2. Display\\n3. Update\\n4. Remove\\n5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        int valid = scanf(\"%d\", &choice);\r\n        if (!valid) {\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            while (getchar() != '\\n'); // Clear invalid input\r\n            choice = 0; // Reset choice\r\n        }\r\n\r\n        switch(choice) {\r\n            case 1:\r\n                addItem(&item_count);\r\n                break;\r\n            case 2:\r\n                displayGroceryItem(item_count);\r\n                break;\r\n            case 3:\r\n                updateQuantity(item_count);\r\n                break;\r\n            case 4:\r\n                deleteItem(&item_count);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Please enter a valid input\\n\");\r\n        }\r\n    } while (choice != 5);\r\n    \r\n    freeMemory();\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* headnode = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation has failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (headnode == NULL) {\r\n        headnode = newStudent;\r\n        return;\r\n    }\r\n    Student* tempnode = headnode;\r\n    while (tempnode->next != NULL) {\r\n        tempnode = tempnode->next;\r\n    }\r\n    tempnode->next = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    int i = 1;\r\n    Student* tempnode = headnode;\r\n\r\n    if (tempnode == NULL) {\r\n        printf(\"The list is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    while (tempnode != NULL) {\r\n        printf(\"%d. Name: %s, ID: %d, Grade: %.2f\\n\", i++, tempnode->name, tempnode->id, tempnode->grade);\r\n        tempnode = tempnode->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentbyID(int id) {\r\n    Student* tempnode = headnode;\r\n    while (tempnode != NULL) {\r\n        if (tempnode->id == id) {\r\n            return tempnode;\r\n        }\r\n        tempnode = tempnode->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* currentnode = headnode;\r\n    Student* next;\r\n\r\n    while (currentnode != NULL) {\r\n        next = currentnode->next;\r\n        free(currentnode);\r\n        currentnode = next;\r\n    }\r\n    headnode = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Bubble sort function to sort the linked list based on grade\r\nvoid bubbleSort() {\r\n    if (headnode == NULL || headnode->next == NULL) {\r\n        printf(\"Can't sort an empty or one-node list.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swap;\r\n    Student* ptr1;\r\n    Student* lastptr = NULL;\r\n\r\n    do {\r\n        swap = 0;\r\n        ptr1 = headnode;\r\n\r\n        while (ptr1->next != lastptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the grades\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                // Swap the IDs\r\n                int tempID = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempID;\r\n\r\n                // Swap the names\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swap = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lastptr = ptr1;\r\n    } while (swap);\r\n\r\n    printf(\"Student records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Sort function for the menu\r\nvoid sortStudents() {\r\n    bubbleSort();\r\n}\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (Ascending Order)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentbyID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is straightforward and works for small datasets, but its time complexity of O(n?) can lead to inefficiencies with larger lists. For better performance, consider implementing more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20590530",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 //maximum size of an array\r\n\r\nint main() {\r\n    //Declaration of variables for dimensions\r\n    int dimensionA;\r\n    int dimensionB;\r\n    int rowA, rowB, columnA, columnB;\r\n\r\n    //array size limited by MAX\r\n    int matrixA[MAX][MAX];\r\n    int matrixB[MAX][MAX];\r\n\r\n    //Declare variable for switch case\r\n    int choice = 0;\r\n    int result[MAX][MAX];\r\n\r\n    //Prompt user to enter dimensions for Matrix A\r\n    printf(\"\\nEnter dimensions for Matrix A (rows and columns): \");\r\n    if (scanf(\"%d %d\", &rowA, &columnA) != 2) {\r\n        printf(\"\\nError: invalid input, program will be terminated\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //Prompt user to input elements for Matrix A after setting up dimensions\r\n    printf(\"Enter Elements for Matrix A: \\n\");\r\n\r\n    //Establish array (MatrixA) using inputs from user\r\n    for (int i = 0; i < rowA; i++) {\r\n        for (int j = 0; j < columnA; j++) {\r\n            printf(\"Element [%d][%d]: \", i, j);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    //Prompt user to enter dimensions for Matrix B\r\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\r\n    if (scanf(\"%d %d\", &rowB, &columnB) != 2) {\r\n        printf(\"\\nError: invalid input, program will be terminated\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //Prompt user to input elements for Matrix A after setting up dimensions\r\n    printf(\"Enter Elements for Matrix B: \\n\");\r\n\r\n    //Establish array (MatrixB) using inputs from user\r\n    for (int i = 0; i < rowB; i++) {\r\n        for (int j = 0; j < columnB; j++) {\r\n            printf(\"Element [%d][%d]: \", i, j);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n    while (1) {\r\n        //Prompt the user to choose options for calculation\r\n        printf(\"\\nMatrix Operations Menu: \\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid input. Exiting...\\n\");\r\n            break;\r\n        }\r\n\r\n        switch (choice) {\r\n            //create cases \r\n            case 1:\r\n                //Addition of matrices\r\n                printf(\"Result of Matrix A + Matrix B: \\n\");\r\n                if (rowA == rowB && columnA == columnB) {\r\n                    for (int i = 0; i < rowA; i++) {\r\n                        for (int j = 0; j < columnA; j++) {\r\n                            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n                            printf(\"%d \", result[i][j]);\r\n                        }\r\n                        printf(\"\\n\"); //prints a new row for next set of operations\r\n                    }\r\n                } else {\r\n                    //if the dimensions dont match\r\n                    printf(\"dimensions for both matrices dont match.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                //Subtraction of matrices\r\n                printf(\"Result of Matrix A - Matrix B: \\n\");\r\n                if (rowA == rowB && columnA == columnB) {\r\n                    for (int i = 0; i < rowA; i++) {\r\n                        for (int j = 0; j < columnA; j++) {\r\n                            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n                            printf(\"%d \", result[i][j]);\r\n                        }\r\n                        printf(\"\\n\"); \r\n                    }\r\n                } else {\r\n                    //if the dimensions dont match\r\n                    printf(\"dimensions for both matrices dont match.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                //Transpose Matrix A\r\n                printf(\"Transpose of Matrix A: \\n\");\r\n                for (int i = 0; i < columnA; i++) {\r\n                    for (int j = 0; j < rowA; j++) {\r\n                        result[i][j] = matrixA[j][i];\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                break;\r\n\r\n            case 4:\r\n                //Transpose Matrix B\r\n                printf(\"Transpose of Matrix B: \\n\");\r\n                for (int i = 0; i < columnB; i++) {\r\n                    for (int j = 0; j < rowB; j++) {\r\n                        result[i][j] = matrixB[j][i];\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\"); \r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Invalid Choice, please try again.\\n\");\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n//Create structs for managing grocery item info and item availability\r\n\r\ntypedef struct  {\r\n    char Name[100];         //limited to a size of 100\r\n    char Category[50];      //limited to a size of 50\r\n    int Quantity;\r\n    float Price;\r\n} GroceryItem;\r\n\r\ntypedef union  {\r\n    bool inStock;\r\n    bool outStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct GroceryInventory {\r\n    GroceryItem items[100];\r\n    AvailabilityStatus status[100];\r\n    int count;              //counter for total number of grocery items\r\n} GroceryInventory;\r\n\r\nint main() {\r\n    //Set counter to 0\r\n    GroceryInventory inventory = {.count = 0};\r\n\r\n    //Declare variables\r\n    int choice;\r\n\r\n    //Prompt user the options for the system\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n\r\n    while (1) {\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid Input. Exiting program...\\n\");\r\n            return 1;  // Terminating program if invalid input\r\n        }\r\n        getchar(); // clear the newline from the buffer\r\n\r\n        switch (choice) {\r\n            case 1: {\r\n                GroceryItem *item = &inventory.items[inventory.count];\r\n                AvailabilityStatus *status = &inventory.status[inventory.count];\r\n\r\n                //Prompt user to input name of item\r\n                printf(\"Enter Item Name: \");\r\n                fgets(item->Name, sizeof(item->Name), stdin);\r\n                item->Name[strcspn(item->Name, \"\\n\")] = '\\0'; //remove newline character\r\n\r\n                //Prompt user to input Category of item\r\n                printf(\"\\nEnter Category: \");\r\n                fgets(item->Category, sizeof(item->Category), stdin);\r\n                item->Category[strcspn(item->Category, \"\\n\")] = '\\0'; //remove newline character\r\n\r\n                //Prompt user to input Quantity of item\r\n                printf(\"\\nEnter Quantity: \");\r\n                if (scanf(\"%d\", &item->Quantity) != 1) {\r\n                    printf(\"Invalid input for Quantity.\\n\");\r\n                    while (getchar() != '\\n'); //clear the buffer\r\n                    break;  \r\n                }\r\n                getchar();\r\n\r\n                //Prompt user to input Price of item\r\n                printf(\"\\nEnter Price: \");\r\n                if (scanf(\"%f\", &item->Price) != 1) {\r\n                    printf(\"Invalid input for Price.\\n\");\r\n                    while (getchar() != '\\n'); //clear the buffer\r\n                    break;  \r\n                }\r\n                getchar();\r\n\r\n                //update status and availability based on item->Quantity\r\n                status->inStock = item->Quantity > 0;\r\n\r\n                //update the counter\r\n                inventory.count++;\r\n\r\n                //display output to user for confirmation\r\n                printf(\"\\nGrocery Item added successfully!\\n\");\r\n                break;\r\n            }\r\n\r\n            case 2: {\r\n                //Check if inventory is empty\r\n                if (inventory.count == 0) {\r\n                    printf(\"No Grocery Items in inventory.\\n\");\r\n                } else {\r\n                    //If inventory is not empty, display items to user\r\n                    for (int i = 0; i < inventory.count; i++) {\r\n                        GroceryItem item = inventory.items[i];\r\n                        AvailabilityStatus status = inventory.status[i];\r\n\r\n                        printf(\"\\nName: %s\\n\", item.Name);\r\n                        printf(\"Category: %s\\n\", item.Category);\r\n                        printf(\"Quantity: %d\\n\", item.Quantity);\r\n                        printf(\"Price: %.2f\\n\", item.Price);\r\n                        printf(\"Status: %s\\n\", status.inStock ? \"In Stock\" : \"Out of Stock\");\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n            case 3: {\r\n                //check if inventory is empty or not\r\n                if (inventory.count == 0) {\r\n                    printf(\"No Grocery Items in inventory to update.\\n\");\r\n                } else {\r\n                    //Prompt user to input name of item to update quantity\r\n                    char name[100];\r\n                    printf(\"Enter name of the grocery item to update quantity: \");\r\n                    fgets(name, sizeof(name), stdin);\r\n                    name[strcspn(name, \"\\n\")] = '\\0'; //Remove newline character\r\n\r\n                    int found = 0;\r\n                    for (int i = 0; i < inventory.count; i++) {\r\n                        GroceryItem *item = &inventory.items[i];\r\n                        AvailabilityStatus *status = &inventory.status[i];\r\n\r\n                        if (strcmp(item->Name, name) == 0) {\r\n                            found = 1;\r\n                            printf(\"Enter new quantity for %s: \", item->Name);\r\n                            if (scanf(\"%d\", &item->Quantity) != 1) {\r\n                                printf(\"Invalid input for Quantity.\\n\");\r\n                                while (getchar() != '\\n'); //clear buffer\r\n                                break;  \r\n                            }\r\n\r\n                            getchar();\r\n                            status->inStock = item->Quantity > 0;\r\n                            printf(\"Quantity updated for %s.\\n\", item->Name);\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!found) {\r\n                        printf(\"This item does not exist.\\n\");\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n            case 4: {\r\n                //Check if inventory is empty\r\n                if (inventory.count == 0) {\r\n                    printf(\"No Grocery Items in inventory to remove.\\n\");\r\n                } else {\r\n                    //Prompt user to input name of item to remove\r\n                    char name[100];\r\n                    printf(\"Enter name of the grocery item to remove: \");\r\n                    fgets(name, sizeof(name), stdin);\r\n                    name[strcspn(name, \"\\n\")] = '\\0'; //Remove newline character\r\n\r\n                    int found = 0;\r\n                    for (int i = 0; i < inventory.count; i++) {\r\n                        GroceryItem *item = &inventory.items[i];\r\n                        AvailabilityStatus *status = &inventory.status[i];\r\n\r\n                        if (strcmp(item->Name, name) == 0) {\r\n                            found = 1;\r\n                            printf(\"Grocery item '%s' has been removed successfully!\\n\", item->Name);\r\n\r\n                            //Update the inventory by shifting items\r\n                            for (int j = i; j < inventory.count - 1; j++) {\r\n                                inventory.items[j] = inventory.items[j + 1];\r\n                                inventory.status[j] = inventory.status[j + 1];\r\n                            }\r\n\r\n                            inventory.count--;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!found) {\r\n                        //if nothing was found\r\n                        printf(\"No such item exists in inventory.\\n\");\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Invalid Choice, please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\nStudent* head = NULL; //This is a singly linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    //First create the node using dynamic memory allocation and structure pointers\r\n    Student *newNode = (Student *)malloc(sizeof(Student));\r\n\r\n    //Check if memory allocation was successfull\r\n    if (newNode == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit (1);\r\n    }\r\n\r\n    //copy the name into new node\r\n    strncpy(newNode->name, name, sizeof(newNode->name) - 1);\r\n    newNode->name[sizeof(newNode->name) - 1] = '\\0'; //remove newline character\r\n\r\n    //assign id and grade\r\n    newNode->id = id;\r\n    newNode->grade = grade;\r\n\r\n    //Initialize next pointer to NULL\r\n    newNode->next = NULL;\r\n    \r\n    return newNode;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newNode = createStudent(name, id, grade);\r\n\r\n    //check if linked list is empty\r\n    if (head == NULL) {\r\n        //if list is empty\r\n        head = newNode;\r\n        return;\r\n    }\r\n\r\n    //if linked list is not empty, traverse to end of list\r\n    Student* temp = head;\r\n    while (temp->next != NULL) {\r\n        temp = temp->next;\r\n    }\r\n\r\n    //move on to inserting the next node\r\n    temp->next = newNode;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* temp = head;\r\n    //check if list is not empty\r\n    while (temp != NULL) {\r\n        //display list to user\r\n        printf(\"Name: %s,\\tID: %d, \\tGrade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n\r\n    if (temp == NULL) {\r\n        //if list is empty give user a prompt to notify user\r\n        printf(\"List is empty.\\n\");\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n\r\n    while(temp != NULL) {\r\n        if (temp->id == id) {   //if id matches\r\n            return temp;        //returns the matching node\r\n        }\r\n        temp = temp->next; // moves to the next node\r\n    }\r\n\r\n    //if no match return NULL\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm that you like\r\nvoid sortStudents() {\r\n    //check if list is empty\r\n    if (head == NULL) {\r\n        return;\r\n    } //No need to sort if list is empty\r\n\r\n    int swap; //temporary variable to keep track of swaps\r\n    Student* current;\r\n    Student* lastSorted = NULL;\r\n\r\n    do {\r\n        swap = 0; //reset the swapped flag for this pass\r\n        current = head;\r\n\r\n        //Traverse the list until the last sorted node\r\n        while (current->next != lastSorted) {\r\n            if (current->grade > current->next->grade) {\r\n\r\n                //Implemented bubble sort\r\n                //swap the data between two nodes\r\n                int tempID = current->id;\r\n                float tempGrade = current->grade;\r\n                char tempName[100];\r\n                strncpy(tempName, current->name, sizeof(tempName) - 1);\r\n                tempName[sizeof(tempName)- 1] = '\\0';\r\n\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade;\r\n                strncpy(current->name, current->next->name, sizeof(current->name) - 1);\r\n                current->name[sizeof(current->name) - 1] = '\\0';\r\n\r\n                current->next->id = tempID;\r\n                current->next->grade = tempGrade;\r\n                strncpy(current->next->name, tempName, sizeof(current->next->name) - 1);\r\n                current->next->name[sizeof(current->next->name) - 1] = '\\0';\r\n\r\n                swap = 1; //a swap occured\r\n            }\r\n            current = current->next; //move to the next node\r\n        }\r\n        lastSorted = current; //last node is now sorted\r\n    } while (swap);\r\n\r\n    printf(\"Records sorted using bubble sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n do {\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar(); // To consume the newline character\r\n    switch (choice) {\r\n        case 1:\r\n        printf(\"Enter Name: \");\r\n        fgets(name, sizeof(name), stdin);\r\n        strtok(name, \"\\n\");\r\n        printf(\"Enter ID: \");\r\n        scanf(\"%d\", &id);\r\n        printf(\"Enter Grade: \");\r\n        scanf(\"%f\", &grade);\r\n        insertStudent(name, id, grade);\r\n        break;\r\n        \r\n        case 2:\r\n        displayStudents();\r\n        break;\r\n\r\n        case 3:\r\n        sortStudents();\r\n        break;\r\n        \r\n        case 4:\r\n        printf(\"Enter ID to search: \");\r\n        scanf(\"%d\", &id);\r\n        Student* found = searchStudentByID(id);\r\n        \r\n        if (found) {\r\n            printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n            found->name, found->id, found->grade);\r\n        } else {\r\n            \r\n        }\r\n        break;\r\n\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n        break;\r\n\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n        break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n } while (choice != 6);\r\n    return 0;\r\n} \r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-In the displayStudents function, the check for an empty list is after the loop. It should be placed before the loop to notify the user immediately if the list is empty."
  },
  {
    "student_id": "20620222",
    "code": "\n/* --- 20620222_Selina Yeoh Yun Ci/Lab Assessment 3/Q1.c --- */\n#include <stdio.h>\r\n#define MAX 10\r\n\r\nvoid add(int rowA, int rowB, int colA, int colB, int arrA[rowA][colA], int arrB[rowB][colB]);\r\nvoid subtract(int rowA, int rowB, int colA, int colB, int arrA[rowA][colA], int arrB[rowB][colB]);\r\nvoid remove_whitespaces();\r\nvoid transposeA(int rowA, int colA, int arrA[rowA][colA]);\r\nvoid transposeB(int rowB, int colB, int arrB[rowB][colB]);\r\n\r\n//Variables\r\nint rowA, colA, rowB, colB;\r\nint i, j;\r\nint a[MAX][MAX], transpose[MAX][MAX];\r\n\r\nint main(){\r\n    char choice;\r\n    puts(\"***************************************************************\");\r\n    puts(\"                            Matrix\");\r\n    puts(\"***************************************************************\");\r\n\r\n    //Matrix A\r\n    printf(\"Enter number of rows for Matrix A: \");\r\n    scanf(\"%d\" ,&rowA);\r\n    printf(\"Enter number of columns for Matrix A: \");\r\n    scanf(\"%d\" ,&colA);\r\n\r\n    //Matrix B\r\n    printf(\"\\nEnter number of rows for Matrix B: \");\r\n    scanf(\"%d\" ,&rowB);\r\n    printf(\"Enter number of columns for Matrix B: \");\r\n    scanf(\"%d\" ,&colB);\r\n\r\n    //Check the possibility of matrix addition\r\n    if (rowA != rowB || colA != colB) {\r\n        printf(\"Matrix addition is not possible because matrix sizes don't match.\\n\");\r\n        return 0;\r\n    }\r\n\r\n    //Matrix cannot exceed size 10x10\r\n    if (rowA>10 || rowB>10 || colA>10 || colB>10){\r\n        printf(\"Number of rows and columns cannot exceed 10x10.\");\r\n        return 0;\r\n    }\r\n\r\n    int arrA[rowA][colA], arrB[rowB][colB], result[rowA][colA];\r\n\r\n    //Elements for Matrix A\r\n    printf(\"\\nPlease enter element in the matrix A:\\n\");\r\n    for(i=0; i<rowA; i++){\r\n        for(j=0; j<colA; j++){\r\n            printf(\"Element [%d],[%d]: \",i,j);\r\n            scanf(\"%d\", &arrA[i][j]);\r\n        }\r\n    }\r\n\r\n    //Elements of Matrix B\r\n    printf(\"\\nPlease enter element in matrix B:\\n\");\r\n    for(i=0; i<rowB; i++){\r\n        for(j=0; j<colB; j++){\r\n            printf(\"Element [%d],[%d]: \",i,j);\r\n            scanf(\"%d\", &arrB[i][j]);\r\n        }\r\n    }\r\n\r\n    //Display A\r\n    printf(\"\\nMatrix A:\\n\");\r\n    for (i = 0; i < rowA; i++) {\r\n        for (j = 0; j < colA; j++) {\r\n            printf(\"%d\\t\", arrA[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    //Display B\r\n    printf(\"\\nMatrix B:\\n\");\r\n    for (i = 0; i < rowB; i++) {\r\n        for (j = 0; j < colB; j++) {\r\n            printf(\"%d\\t\", arrB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    while(1){\r\n        puts(\"***************************************************************\");\r\n        puts(\"                            Main Menu\");\r\n        puts(\"***************************************************************\");\r\n        puts(\"                      1.   Add Matrices\");\r\n        puts(\"                      2. Subtract Matrices\");\r\n        puts(\"                      3. Transpose Matrix A\");\r\n        puts(\"                      4. Transpose Matrix B\");\r\n        puts(\"                      5.       Exit\");\r\n        puts(\"***************************************************************\");\r\n\r\n        printf(\"Please enter your choice: \");\r\n        scanf(\" %c\", &choice);\r\n        remove_whitespaces();\r\n\r\n        switch(choice){\r\n            case '1':\r\n                add(rowA, colA, rowB, colB, arrA, arrB);\r\n                break;\r\n            case '2':\r\n                subtract(rowA, colA, rowB, colB, arrA, arrB);\r\n                break;\r\n            case '3':\r\n                transposeA(rowA, colA, arrA);\r\n                break;\r\n            case '4':\r\n                transposeB(rowB, colB, arrB);\r\n                break;\r\n            case '5':\r\n                puts(\"Exiting...\");\r\n                return 0;\r\n            default:\r\n                puts(\"Please enter a number from 1 to 5.\");\r\n                break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n//Matrix Addition\r\nvoid add(int rowA, int rowB, int colA, int colB, int arrA[rowA][colA], int arrB[rowB][colB]){\r\n    int result[i][j];\r\n    //Add Matrices\r\n    for(i=0; i<rowA; i++){\r\n        for(j=0; j<colA; j++){\r\n            result[i][j] = arrA[i][j] + arrB[i][j];\r\n        }\r\n    }\r\n\r\n    //Display A+B\r\n    printf(\"\\nResultant Matrix (A + B):\\n\");\r\n    for (i = 0; i < rowA; i++) {\r\n        for (j = 0; j < colA; j++) {\r\n            printf(\"%d\\t\", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//Matrix Subtraction\r\nvoid subtract(int rowA, int rowB, int colA, int colB, int arrA[rowA][colA], int arrB[rowB][colB]){\r\n    int result[i][j];\r\n    //Subtract Matrices\r\n    for(i=0; i<rowA; i++){\r\n        for(j=0; j<colA; j++){\r\n            result[i][j] = arrA[i][j] - arrB[i][j];\r\n        }\r\n    }\r\n    //Display A-B\r\n    printf(\"\\nResultant Matrix (A - B):\\n\");\r\n    for (i = 0; i < rowA; i++) {\r\n        for (j = 0; j < colA; j++) {\r\n            printf(\"%d\\t\", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//Transpose Matrix A\r\nvoid transposeA(int rowA, int colA, int arrA[rowA][colA]){\r\n    //Transpose\r\n    for(i=0; i<rowA; ++i){\r\n        for(j=0; j<colA; ++j){\r\n        transpose[j][i] = arrA[i][j];\r\n        }\r\n    }\r\n\r\n    //Print Transpose\r\n    printf(\"\\nTranspose of the matrix:\\n\");\r\n    for(i=0; i<colA; ++i){\r\n        for(j=0; j<rowA; ++j){\r\n        printf(\"%d\\t\",transpose[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//Transpose Matrix B\r\nvoid transposeB(int rowB, int colB, int arrB[rowB][colB]){\r\n    //Transpose\r\n    for(i=0; i<rowB; ++i){\r\n        for(j=0; j<colB; ++j){\r\n        transpose[j][i] = arrB[i][j];\r\n        }\r\n    }\r\n\r\n    //Print Transpose\r\n    printf(\"\\nTranspose of the matrix:\\n\");\r\n    for(i=0; i<colB; ++i){\r\n        for(j=0; j<rowB; ++j){\r\n        printf(\"%d\\t\",transpose[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//Function to Remove Whitespaces\r\nvoid remove_whitespaces(){\r\n    int ch;\r\n        while((ch=getchar())!='\\n')\r\n            continue;\r\n}\n/* --- 20620222_Selina Yeoh Yun Ci/Lab Assessment 3/Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#define MAX_ITEMS 100\r\n#define NAME 100\r\n#define CATEGORY 50\r\n\r\nstruct groceries {\r\n    char name[NAME];\r\n    char category[CATEGORY];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\nvoid add(struct groceries *s, int *numGroceries);\r\nvoid list(struct groceries *groceryArray, int numGroceries);\r\nvoid update(struct groceries *groceryArray, int numGroceries);\r\nvoid remove_item(struct groceries *groceryArray, int *numGroceries);\r\nvoid remove_whitespaces();\r\n\r\nint main() {\r\n    struct groceries groceryArray[MAX_ITEMS];\r\n    int numGroceries = 0;\r\n    char choice;\r\n    while (1) {\r\n        puts(\"***************************************************************\");\r\n        puts(\"             Grocery Inventory Management System\");\r\n        puts(\"***************************************************************\");\r\n        puts(\"                   1.   Add Grocery Items\");\r\n        puts(\"                   2. List All Grocery Items\");\r\n        puts(\"                   3.    Update Quantity\");\r\n        puts(\"                   4. Remove Grocery Item\");\r\n        puts(\"                   5.         Exit\");\r\n        puts(\"***************************************************************\");\r\n        printf(\"Please enter your choice: \");\r\n        scanf(\" %c\", &choice);\r\n        remove_whitespaces();\r\n\r\n        switch (choice) {\r\n            case '1':\r\n                if (numGroceries < MAX_ITEMS) {\r\n                    add(&groceryArray[numGroceries], &numGroceries);\r\n                } else {\r\n                    printf(\"Inventory is full. Cannot add more items.\\n\");\r\n                }\r\n                break;\r\n            case '2':\r\n                list(groceryArray, numGroceries);\r\n                break;\r\n            case '3':\r\n                update(groceryArray, numGroceries);\r\n                break;\r\n            case '4':\r\n                remove_item(groceryArray, &numGroceries);\r\n                break;\r\n            case '5':\r\n                puts(\"Exiting...\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 to 5.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n//Function to add different groceries\r\nvoid add(struct groceries *s, int *numGroceries) {\r\n    printf(\"Enter Item Name: \");\r\n    if (fgets(s->name, NAME, stdin) == NULL) {\r\n        printf(\"Error reading name.\\n\");\r\n        return;\r\n    }\r\n    s->name[strcspn(s->name, \"\\n\")] = 0; \r\n\r\n    printf(\"Enter Category: \");\r\n    if (fgets(s->category, CATEGORY, stdin) == NULL) {\r\n        printf(\"Error reading category.\\n\");\r\n        return;\r\n    }\r\n    s->category[strcspn(s->category, \"\\n\")] = 0; \r\n\r\n    printf(\"Enter Quantity: \");\r\n    if (scanf(\"%d\", &s->quantity) != 1) {\r\n        printf(\"Invalid input. Quantity set to 0.\\n\");\r\n        s->quantity = 0;\r\n        remove_whitespaces(); \r\n    }\r\n\r\n    printf(\"Enter Price: \");\r\n    if (scanf(\"%f\", &s->price) != 1) {\r\n        printf(\"Invalid input. Price set to 0.0.\\n\");\r\n        s->price = 0.0;\r\n        remove_whitespaces(); \r\n    }\r\n\r\n    (*numGroceries)++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n//Function to list out all groceries\r\nvoid list(struct groceries *groceryArray, int numGroceries) {\r\n    if (numGroceries == 0) {\r\n        printf(\"No items found in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < numGroceries; i++) {\r\n        printf(\"\\n***Item %d***\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", groceryArray[i].name);\r\n        printf(\"Category: %s\\n\", groceryArray[i].category);\r\n        printf(\"Quantity: %d\\n\", groceryArray[i].quantity);\r\n        printf(\"Price: %.2f\\n\", groceryArray[i].price);\r\n    }\r\n}\r\n\r\n//Function to update quantity\r\nvoid update(struct groceries *groceryArray, int numGroceries) {\r\n    if (numGroceries == 0) {\r\n        printf(\"No items to update. Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    int index;\r\n    printf(\"Enter the item number to update quantity (1 to %d): \", numGroceries);\r\n    if (scanf(\"%d\", &index) != 1 || index < 1 || index > numGroceries) {\r\n        printf(\"Invalid item number.\\n\");\r\n        getchar(); // Clear invalid input\r\n        return;\r\n    }\r\n\r\n    index--; // Adjust to 0-based index\r\n\r\n    printf(\"Enter new Quantity: \");\r\n    if (scanf(\"%d\", &groceryArray[index].quantity) != 1) {\r\n        printf(\"Invalid input. Quantity not updated.\\n\");\r\n        getchar(); // Clear invalid input\r\n        return;\r\n    }\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n//Function to remove item\r\nvoid remove_item(struct groceries *groceryArray, int *numGroceries){\r\n    if (*numGroceries == 0) {\r\n        printf(\"No items to remove. Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    int index;\r\n    printf(\"Enter the item number to remove (1 to %d): \", *numGroceries);\r\n    if (scanf(\"%d\", &index) != 1 || index < 1 || index > *numGroceries) {\r\n        printf(\"Invalid item number.\\n\");\r\n        getchar(); // Clear invalid input\r\n        return;\r\n    }\r\n\r\n    index--; // Adjust to 0-based index\r\n\r\n    // Shift items to overwrite the removed item\r\n    for (int i = index; i < *numGroceries - 1; i++) {\r\n        groceryArray[i] = groceryArray[i + 1];\r\n    }\r\n\r\n    (*numGroceries)--;\r\n    printf(\"Item removed successfully!\\n\");\r\n}\r\n\r\n//Function to remove whitespaces\r\nvoid remove_whitespaces() {\r\n    int ch;\r\n    while ((ch = getchar()) != '\\n' && ch != EOF) {\r\n        continue;\r\n    }\r\n}\r\n\n/* --- 20620222_Selina Yeoh Yun Ci/Lab Assessment 3/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student*new = (Student*)malloc(sizeof(Student));\r\n    if(!new){\r\n        printf(\"Memory allocation failed. \\n\");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    strcpy(new -> name, name);\r\n    new -> id = id;\r\n    new -> grade = grade;\r\n    new -> next = NULL;\r\n    return new;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student*new = createStudent(name, id, grade);\r\n    if(head == NULL){\r\n        head = new;\r\n    }else{\r\n        Student* temp = head;\r\n        while(temp ->next !=NULL){\r\n            temp = temp -> next;\r\n        }\r\n        temp -> next = new;\r\n    }\r\n    printf(\"Student record successfully added.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head==NULL){\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    puts(\"*********************************************\");\r\n    puts(\"              Student Records\");\r\n    puts(\"*********************************************\");\r\n    while(temp!=NULL){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp -> name, temp -> id, temp -> grade);\r\n        temp = temp -> next;\r\n    }\r\n    puts(\"*********************************************\");\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while(temp!=NULL){\r\n        if(temp -> id ==id){\r\n            return temp;\r\n        }\r\n        temp = temp -> next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records deleted.\\n\");\r\n}\r\n\r\nvoid freeMemory() {\r\n deleteList();\r\n}\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the grades\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                // Swap the IDs\r\n                int tempID = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempID;\r\n\r\n                // Swap the names\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted successfully.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n   int choice, id;\r\n   char name[100];\r\n   float grade;\r\n       do {\r\n        puts(\"***************************************************************\");\r\n        puts(\"             Student Record Management System\");\r\n        puts(\"***************************************************************\");\r\n        puts(\"                   1.  Insert Student Record\");\r\n        puts(\"                   2.  Display Student Records\");\r\n        puts(\"                   3.  Sort Records\");\r\n        puts(\"                   4.  Search Record by ID\");\r\n        puts(\"                   5.  Delete List\");\r\n        puts(\"                   6.  Exit\");\r\n        puts(\"***************************************************************\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                    found->name, found->id, found->grade);\r\n                } \r\n                else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n                default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n}",
    "feedback": "q1-The program incorrectly defines the result array inside the add and subtract functions using i and j without initializing them. This can lead to undefined behavior. The result array should be defined with fixed dimensions or as a parameter to the function. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. It has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20610050",
    "code": "\n/* --- Q1.c --- */\n\r\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid addMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid subtractMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    printf(\"Enter dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsA < 1 || colsA < 1 || rowsB < 1 || colsB < 1) {\r\n        printf(\"Invalid matrix dimensions! Maximum size is 10x10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, matrixA);\r\n\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, matrixB);\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Addition not possible, dimensions mismatch.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Subtraction not possible, dimensions mismatch.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(rowsA, colsA, matrixA, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(rowsB, colsB, matrixB, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input a matrix\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtractMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    int inStock; // 1 if in stock, 0 if out of stock\r\n} AvailabilityStatus;\r\nGroceryItem inventory[MAX_ITEMS];\r\nAvailabilityStatus availability[MAX_ITEMS];\r\nint itemCount = 0;\r\nvoid addItem();\r\nvoid listItems();\r\nvoid updateQuantity();\r\nvoid removeItem();\r\nvoid printItem(int index);\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(inventory[itemCount].name, sizeof(inventory[itemCount].name), stdin);\r\n    strtok(inventory[itemCount].name, \"\\n\"); \r\n printf(\"Enter item category: \");\r\n    fgets(inventory[itemCount].category, sizeof(inventory[itemCount].category), stdin);\r\n    strtok(inventory[itemCount].category, \"\\n\");\r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &inventory[itemCount].quantity);\r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &inventory[itemCount].price);\r\n    getchar(); \r\n    availability[itemCount].inStock = (inventory[itemCount].quantity > 0) ? 1 : 0;\r\n\r\n    itemCount++;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\nvoid listItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Inventory:\\n\");\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printItem(i);\r\n    }\r\n}\r\nvoid updateQuantity() {\r\n    char itemName[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n            getchar(); // Consume newline character\r\n\r\n            inventory[i].quantity = newQuantity;\r\n            availability[i].inStock = (newQuantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\nvoid removeItem() {\r\n    char itemName[100];\r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n                availability[j] = availability[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\nvoid printItem(int index) {\r\n    printf(\"Name: %s\\n\", inventory[index].name);\r\n    printf(\"Category: %s\\n\", inventory[index].category);\r\n    printf(\"Quantity: %d\\n\", inventory[index].quantity);\r\n    printf(\"Price: %.2f\\n\", inventory[index].price);\r\n    printf(\"Status: %s\\n\", availability[index].inStock ? \"In Stock\" : \"Out of Stock\");\r\n}\r\n\n/* --- Q3.c --- */\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    // Set the values to the student\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp; // Student is available\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL; \r\n}\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL; \r\n}\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Sorting is not required for an empty or single-element list.\\n\");\r\n        return;\r\n    }\r\n    int swapped;\r\n    Student *i, *j = NULL;\r\n    do {\r\n        swapped = 0;\r\n        i = head;\r\n\r\n        while (i->next != j) {\r\n            if (i->grade > i->next->grade) {\r\n                // Swap grades of students\r\n                float tempGrade = i->grade;\r\n                i->grade = i->next->grade;\r\n                i->next->grade = tempGrade;\r\n\r\n                // Swap IDs of students\r\n                int tempID = i->id;\r\n                i->id = i->next->id;\r\n                i->next->id = tempID;\r\n\r\n                // Swap names of students\r\n                char tempName[100];\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, i->next->name);\r\n                strcpy(i->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            i = i->next;\r\n        }\r\n        j = i; \r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade.\\n\");\r\n}\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly and efficiently handles sorting student records by grade. However, its time complexity of O(n?) can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20601157",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\r\n\r\nint AddMatrices(int matrixA[20][20], int matrixB[20][20], int result[20][20], int matrixrowA, int matrixcolumnA, int matrixrowB, int matrixcolumnB) {\r\n\r\n    if (matrixrowA != matrixrowB || matrixcolumnA != matrixcolumnB){\r\n        return -1;\r\n    }\r\n\r\n    for (int i=0;i<matrixrowA;++i){\r\n        for (int j=0;j<matrixcolumnA;++j){\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nint SubtractMatrices(int matrixA[20][20], int matrixB[20][20], int result[20][20], int matrixrowA, int matrixcolumnA, int matrixrowB, int matrixcolumnB) {\r\n\r\n    if (matrixrowA != matrixrowB || matrixcolumnA != matrixcolumnB){\r\n        return -1;\r\n    }\r\n\r\n    for (int i=0;i<matrixrowA;++i){\r\n        for (int j=0;j<matrixcolumnA;++j){\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid TransposeMatrixA(int matrixA[20][20], int result[20][20], int matrixrowA, int matrixcolumnA) {\r\n\r\n    // transpose = swap row and column of elements in matrix \r\n\r\n    for (int i=0 ; i<matrixrowA; ++i){\r\n        for (int j=0; j<matrixcolumnA;++j){\r\n            result[j][i]=matrixA[i][j];\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid TransposeMatrixB(int matrixB[20][20], int result[20][20], int matrixrowB, int matrixcolumnB) {\r\n\r\n    // transpose = swap row and column of elements in matrix \r\n\r\n    for (int i=0 ; i<matrixrowB; ++i){\r\n        for (int j=0; j<matrixcolumnB;++j){\r\n            result[j][i]=matrixB[i][j];\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint main(){\r\n\r\n    int choice;\r\n    int matrixrowA;\r\n    int matrixcolumnA;\r\n    int matrixA[20][20];\r\n    int matrixrowB;\r\n    int matrixcolumnB;\r\n    int matrixB[20][20];\r\n    int result[20][20];\r\n\r\n    while (1){\r\n\r\n        printf(\"Enter dimensions for Matrix A (rows and columns), maximum dimension is 10x10 :\");\r\n        scanf(\"%d %d\", &matrixrowA, &matrixcolumnA);\r\n\r\n        if (matrixrowA > 10 || matrixcolumnA > 10){\r\n            printf(\"Matrix dimensions cannot exceed 10x10.\\n\");\r\n            continue;\r\n        }\r\n\r\n        for (int i = 0; i < matrixrowA; ++i){\r\n            for (int j = 0; j < matrixcolumnA; ++j){\r\n                printf(\"Element [%d][%d]:\", i + 1, j + 1);\r\n                scanf(\"%d\", &matrixA[i][j]);\r\n            }\r\n        }\r\n\r\n        printf(\"Enter dimensions for Matrix B (rows and columns), maximum dimension is 10x10 :\");\r\n        scanf(\"%d %d\", &matrixrowB, &matrixcolumnB);\r\n\r\n        if (matrixrowB > 10 || matrixcolumnB > 10){\r\n            printf(\"Matrix dimensions cannot exceed 10x10.\\n\");\r\n            continue;\r\n        }\r\n\r\n        for (int i = 0; i < matrixrowB; ++i){\r\n            for (int j = 0; j < matrixcolumnB; ++j){\r\n                printf(\"Element [%d][%d]:\", i + 1, j + 1);\r\n                scanf(\"%d\", &matrixB[i][j]);\r\n            }\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    while (1){\r\n\r\n        printf(\"\\n\");\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"\\n\");\r\n\r\n        printf(\"Enter your choice : \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n\r\n        case 1: // addition\r\n\r\n            if (AddMatrices(matrixA, matrixB, result, matrixrowA, matrixcolumnA, matrixrowB, matrixcolumnB) == -1){\r\n                printf(\"Matrix dimensions do not match for addition to be performed.\\n\");\r\n            } \r\n            else {\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                for (int i = 0; i < matrixrowA; i++) {\r\n                    for (int j = 0; j < matrixcolumnA; j++) {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            }\r\n\r\n            break;\r\n\r\n        case 2: // subtraction \r\n\r\n            if (SubtractMatrices(matrixA, matrixB, result, matrixrowA, matrixcolumnA, matrixrowB, matrixcolumnB) == -1){\r\n                printf(\"Matrix dimensions do not match for addition to be performed.\\n\");\r\n            } \r\n            else {\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                for (int i = 0; i < matrixrowA; i++) { \r\n                    for (int j = 0; j < matrixcolumnA; j++) { \r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            }\r\n            break;\r\n\r\n        case 3: // transpose matrix A\r\n\r\n            TransposeMatrixA(matrixA,result,matrixrowA,matrixcolumnA);\r\n           \r\n            printf(\"Transpose of Matrix A :\\n\");\r\n            for (int i = 0; i < matrixcolumnA; i++) { // transposed row = original column\r\n                    for (int j = 0; j < matrixrowA; j++) {  // transposed column = original row\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n\r\n            break;\r\n\r\n        case 4: // transpose matrix B\r\n            \r\n            TransposeMatrixB(matrixB,result,matrixrowB,matrixcolumnB);\r\n           \r\n            printf(\"Transpose of Matrix B :\\n\");\r\n            for (int i = 0; i < matrixcolumnB; i++) { // transposed row = original column\r\n                    for (int j = 0; j < matrixrowB; j++) {  // transposed column = original row\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n\r\n            break;\r\n\r\n        case 5: // exit program\r\n\r\n            printf(\"Exiting... \\n\");\r\n            return 0;\r\n\r\n        default: // invalid input\r\n\r\n            printf(\"Invalid choice entered. Please try again.\\n\");\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\n    \r\n        \n/* --- q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nstruct GroceryItem {\r\n\r\n    char name[101];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n\r\n};\r\n\r\nstruct AvailabilityStatus {\r\n\r\n    // 0 for false, 1 for true\r\n\r\n    int inStock;\r\n    int outofStock;\r\n\r\n};\r\n\r\nstruct GroceryInventory {\r\n\r\n    struct GroceryItem items [100];\r\n    struct AvailabilityStatus status [100];\r\n    int totalItems;\r\n\r\n};\r\n\r\nvoid addGroceryItem (struct GroceryInventory *modifyinventory){\r\n\r\n    if (modifyinventory->totalItems>100){\r\n        printf(\"Grocery Inventory is full! Unable to add more new items.\");\r\n    }\r\n\r\n    else{\r\n\r\n        struct GroceryItem newItemEntry; // newItemEntry having the struct of GroceryItem!\r\n\r\n        printf(\"Enter Item Name :\");\r\n        getchar(); // consume the newline character\r\n        fgets (newItemEntry.name, 101, stdin);\r\n        newItemEntry.name[strcspn(newItemEntry.name, \"\\n\")] = 0; // Remove trailing newline from name\r\n\r\n        printf(\"Enter Category :\");\r\n        fgets (newItemEntry.category, 101, stdin);\r\n        newItemEntry.category[strcspn(newItemEntry.category, \"\\n\")] = 0; // Remove trailing newline from category\r\n\r\n        printf(\"Enter Quantity :\");\r\n        scanf(\"%d\",&newItemEntry.quantity);\r\n        \r\n        printf(\"Enter Price :\");\r\n        scanf(\"%f\",&newItemEntry.price);\r\n\r\n        // Add the new item entry to inventory\r\n\r\n        modifyinventory->items[modifyinventory->totalItems]=newItemEntry;\r\n\r\n        // modifyinventory is pointing to address of items array in GroceryInventory struct\r\n        // modifyinventory->totalItems means modifyinventory is pointing to totalItems value in GroceryInventory\r\n        // totalItems will have an initial value of 0\r\n        // so basically modifyinventory points to items [0] in GroceryInventory, then newItemEntry values are stored there\r\n\r\n        modifyinventory->status[modifyinventory->totalItems].inStock = 1; // Initially mark the item as in stock\r\n        modifyinventory->status[modifyinventory->totalItems].outofStock = 0;\r\n        modifyinventory->totalItems++; \r\n\r\n        // Increment the totalItems counter after each item entry       \r\n\r\n        printf(\"%s has been successfully added into inventory.\\n\",newItemEntry.name);\r\n\r\n    }   \r\n\r\n}\r\n\r\nvoid listAllGroceryItems (struct GroceryInventory *modifyinventory){\r\n\r\n\r\n    if (modifyinventory->totalItems == 0){\r\n\r\n        printf(\"There are currently no items in inventory!\");\r\n\r\n    }\r\n\r\n    else{ // list out all current items in GroceryInventory\r\n\r\n        printf(\"All Grocery Items Stored: \\n\");\r\n        printf(\"\\n\");\r\n\r\n        for (int i=0; i<modifyinventory->totalItems; ++i){\r\n            printf(\"Item %d :\\n\", i+1);\r\n            printf(\"Name : %s\\n\",modifyinventory->items[i].name);\r\n            printf(\"Category : %s\\n\", modifyinventory->items[i].category);\r\n            printf(\"Quantity : %d\\n\", modifyinventory->items[i].quantity);\r\n            printf(\"Price : %.2f\\n\", modifyinventory->items[i].price);\r\n           \r\n            // Display status based on inStock or outOfStock flags\r\n\r\n            if (modifyinventory->status[i].inStock == 1) {\r\n                printf(\"Status: In Stock\\n\");\r\n\r\n            } \r\n            else if (modifyinventory->status[i].inStock == 0) {\r\n                printf(\"Status: Out of Stock\\n\");\r\n            }\r\n\r\n            printf(\"\\n\");\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\nvoid updateQuantity(struct GroceryInventory* modifyinventory) {\r\n\r\n    if (modifyinventory->totalItems == 0) {\r\n\r\n        printf(\"There are currently no items in inventory!\\n\");\r\n\r\n        return;\r\n    }\r\n\r\n    char searchItemName[101];\r\n    int newQuantity;\r\n    int foundFlag = 0; // flag for found items\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    getchar(); // consume the leftover newline character from previous input\r\n    fgets(searchItemName, 101, stdin);\r\n    searchItemName[strcspn(searchItemName, \"\\n\")] = 0; // remove trailing newline from searchItemName\r\n\r\n    // Searching code\r\n\r\n    for (int i = 0; i < modifyinventory->totalItems; ++i) {\r\n\r\n        if (strcmp(modifyinventory->items[i].name, searchItemName) == 0) {\r\n\r\n            printf(\"Enter new quantity for %s: \", modifyinventory->items[i].name);\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            // Validate the new quantity\r\n\r\n            if (newQuantity < 0) {\r\n                printf(\"Quantity cannot be negative. Please enter a valid quantity.\\n\");\r\n            } \r\n            \r\n            else {\r\n                modifyinventory->items[i].quantity = newQuantity;\r\n                printf(\"Quantity updated successfully!\\n\\n\");\r\n            }\r\n\r\n            // Stock status based on the quantity of item\r\n\r\n            if (modifyinventory->items[i].quantity > 0) {\r\n                modifyinventory->status[i].inStock = 1;  \r\n                modifyinventory->status[i].outofStock = 0;\r\n            } \r\n            else {\r\n                modifyinventory->status[i].inStock = 0;\r\n                modifyinventory->status[i].outofStock = 1;\r\n            }\r\n\r\n            foundFlag = 1; // mark that item was found and updated\r\n            break;  // exit loop after updating\r\n        }\r\n    }\r\n\r\n    if (!foundFlag) {\r\n        printf(\"Item not found in inventory.\\n\");\r\n    }\r\n}\r\n\r\nvoid removeGroceryItem (struct GroceryInventory *modifyinventory){\r\n\r\n    if (modifyinventory->totalItems == 0) {\r\n\r\n        printf(\"There are currently no items in inventory!\\n\");\r\n\r\n        return;\r\n    }\r\n\r\n    char removeItemName[101];\r\n    int foundFlag=0;\r\n\r\n    printf(\"Enter name of grocery item to remove: \");\r\n    getchar();\r\n    fgets(removeItemName,101,stdin);\r\n    removeItemName[strcspn(removeItemName, \"\\n\")] = 0;\r\n\r\n    \r\n\r\n    for (int i=0 ; i < modifyinventory->totalItems; ++i){\r\n        if (strcmp(modifyinventory->items[i].name, removeItemName) == 0){ // 0 returned = item found\r\n\r\n            printf(\"Grocery item %s removed successfully!\\n\",modifyinventory->items[i].name);\r\n\r\n            for (int j=i; j <modifyinventory->totalItems; ++j){\r\n\r\n                // replace the left element with the right element\r\n                modifyinventory->items[j]=modifyinventory->items[j+1];\r\n                modifyinventory->status[j]=modifyinventory->status[j+1];\r\n\r\n            }\r\n\r\n            modifyinventory->totalItems--; // remove 1 item = decrement in total items\r\n            \r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nint main(){\r\n\r\n    int choice;\r\n    struct GroceryInventory inventory = {0}; \r\n    // address for the GroceryInventory struct\r\n    // will be used to pass into functions for various function uses\r\n\r\n    while (1){\r\n        printf(\"\\n\");\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"\\n\");\r\n\r\n        printf(\"Enter your choice :\");\r\n        scanf(\"%d\",&choice);\r\n\r\n        switch (choice){\r\n\r\n        case 1:\r\n            addGroceryItem(&inventory);\r\n            break;\r\n\r\n        case 2:\r\n            listAllGroceryItems(&inventory);\r\n            break;\r\n\r\n        case 3:\r\n            updateQuantity(&inventory);\r\n            break;\r\n\r\n        case 4:\r\n            removeGroceryItem(&inventory);\r\n            break;\r\n            \r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            return 0;\r\n        \r\n        default:\r\n            printf(\"Invalid input, please re-enter choice!\\n\");\r\n            printf(\"\\n\");\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\n/* --- q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\n\r\ntypedef struct Student {\r\n\r\n    char name [100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n\r\n} Student;\r\n\r\nStudent* head = NULL; // initially list is empty, so head == NULL\r\n\r\n// Function to create a new student node\r\n\r\nStudent* createstudent (const char* name, int id, float grade ){\r\n\r\n    Student* newStudentEntry = (Student*)malloc(sizeof(Student));\r\n    // allocate memory dynamically for a new Student structure\r\n    // the allocated memory stored in newStudent pointer\r\n\r\n    if (!newStudentEntry){\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit (1);\r\n    }\r\n\r\n    strcpy (newStudentEntry->name,name);\r\n    newStudentEntry->id = id;\r\n    newStudentEntry->grade = grade;\r\n    newStudentEntry->next = NULL;\r\n    return newStudentEntry; // go back to the Student struct\r\n\r\n}\r\n\r\n// Function to insert a new student record (this always gets added at the LAST pos of linked list)\r\n\r\nvoid insertStudent(const char* name, int id, float grade){\r\n\r\n    Student* insertnewStudent = createstudent(name,id,grade); // use the previous linked list struct for student records\r\n\r\n    if (head == NULL){ // head = first node in linked list, if head = NULL insertnewStudent is the first node\r\n        head = insertnewStudent;\r\n    }\r\n\r\n    else{\r\n\r\n        Student* temp = head; // temporary pointer to traverse the linked list\r\n\r\n        while (temp->next !=NULL){ // goes through the list until next == NULL\r\n            temp = temp->next;\r\n        }\r\n\r\n        temp->next = insertnewStudent; // next == NUll means last node in list, append insertnewStudent here\r\n    }\r\n\r\n    printf(\"Student record added successfully.\\n\");\r\n\r\n}\r\n\r\n// Function to display all student records\r\n\r\nvoid displayStudents() {\r\n\r\n    if (head == NULL){ // this means empty linked list\r\n\r\n        printf(\"No student records available to display.\");\r\n        return;\r\n\r\n    }\r\n\r\n    printf(\"Student Records: \\n\");\r\n\r\n    Student* temp = head; // use temp as a counter\r\n\r\n    while (temp != NULL) { // print out all the nodes\r\n\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\",temp->name,temp->id,temp->grade);\r\n        temp = temp->next; // move on to next node\r\n\r\n    }\r\n\r\n}\r\n\r\n// Function to search for a student by ID\r\n\r\nStudent* searchStudentByID(int id) {\r\n\r\n    Student* temp = head; //set counter index\r\n\r\n    while (temp !=NULL){ // loop through the list\r\n\r\n        if (temp->id == id){ // look for the same id\r\n\r\n            return temp; // return match if found\r\n\r\n        }\r\n\r\n        temp=temp->next; // go to next node if not\r\n    }\r\n\r\n}\r\n\r\n// Function to delete the entire list\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n        }\r\n\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\n\r\nvoid sortStudents() { // bubble sort is used here\r\n\r\n    if (head == NULL || head->next == NULL){\r\n        printf(\"No sorting needed as list contains no records / one student record only.\");\r\n        return;\r\n    }\r\n\r\n    int swapped = 1; // needs to be true for loop to start\r\n\r\n    Student* currentpointer; // pointer used to compare 2 nodes\r\n    Student* lastpointer = NULL; // last node pointer\r\n\r\n    while (swapped){\r\n\r\n        swapped=0;\r\n        currentpointer = head;\r\n\r\n        while (currentpointer->next != lastpointer){\r\n\r\n            if (currentpointer->grade > currentpointer->next->grade){\r\n\r\n                // higher grade gets swapped to the back of the list\r\n\r\n                float tempStoreGrade = currentpointer->grade;\r\n                currentpointer->grade = currentpointer->next->grade;\r\n                currentpointer->next->grade = tempStoreGrade;\r\n\r\n                // id of higher grade gets swapped to the back of the list as well\r\n\r\n                int tempStoreId = currentpointer->id;\r\n                currentpointer->id = currentpointer->next->id;\r\n                currentpointer->next->id = tempStoreId;\r\n\r\n                // name of higher grade gets swapped to the back of the list as well\r\n\r\n                char tempStoreName [100];\r\n                strcpy (tempStoreName,currentpointer->name);\r\n                strcpy (currentpointer->name,currentpointer->next->name);\r\n                strcpy (currentpointer->next->name,tempStoreName);\r\n\r\n                swapped = 1; // flag showing a swap is done, this repeats until no swaps are made\r\n\r\n            }\r\n\r\n            currentpointer=currentpointer->next; // move to next node comparison\r\n\r\n        }\r\n\r\n        lastpointer=currentpointer; // update the last node of list to lastpointer\r\n\r\n    }\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort Algorithm.\\n\");\r\n} \r\n\r\n// Main function to drive the program \r\n\r\nint main() {\r\n\r\n    int choice, id;\r\n    char name[100];\r\n    float grade; \r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character \r\n\r\n    \r\n\r\n    switch (choice) {\r\n\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\");\r\n\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n\r\n            insertStudent(name, id, grade);\r\n\r\n            break;\r\n        \r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n\r\n            Student* found = searchStudentByID(id);\r\n\r\n            if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",found->name, found->id, found->grade);\r\n            } \r\n            else {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n\r\n            break;  \r\n\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");   \r\n \r\n    }\r\n\r\n    } while (choice!=6);\r\n\r\n    return 0;\r\n\r\n}\r\n",
    "feedback": "q1-   Transpose Output Dimensions: In the transpose output loops, the dimensions used in the inner loop should match the transposed matrix dimensions (i.e., swap rows with columns).\nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to sort student records by grade. While Bubble Sort is simple, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using a more efficient algorithm like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20703971",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char name);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid subtractMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    // Input dimensions and validate\r\n    do {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns, max 10): \"); //how many dimensions you want for Matrix A\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n    } while (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE);\r\n\r\n    do {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns, max 10): \"); //how many dimensions you want for Matrix B\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n    } while (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE);\r\n\r\n    // Input matrices\r\n    inputMatrix(rowsA, colsA, A, 'A');\r\n    inputMatrix(rowsB, colsB, B, 'B');\r\n\r\n    // Menu loop\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\"); //show the menu\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: //add Matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2: //subtract Matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3: //Transpose Matrix A\r\n                transposeMatrix(rowsA, colsA, A, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n\r\n            case 4: //Transpose Matrix B\r\n                transposeMatrix(rowsB, colsB, B, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n\r\n            case 5: //Exit program\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\"); //if you input the wrong number(no option from the menu)\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function definitions\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char name) { //for input the element for matrix A & B\r\n    printf(\"Enter elements for Matrix %c:\\n\", name); \r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]) { \r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) { //add Matrices option\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) { //sub matrices option\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) { //transpose matrix A/B option\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Struct definitions\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .itemCount = 0 }; \r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\"); //Show the menu\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume leftover newline character\r\n\r\n        switch (choice) { //Collect the input 1,2,3,4,5 \r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting ...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory) { //for adding grocery\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->itemCount]; \r\n\r\n    printf(\"Enter Item Name: \"); //item name\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter Quantity: \"); //item quantity\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \"); //item price\r\n    scanf(\"%f\", &item->price);\r\n\r\n    item->inStock = item->quantity > 0;\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems(GroceryInventory *inventory) { //show list of the grocery on the inventory\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory.\\n\"); //if there's nothing on inventory\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) { //show the item\r\n        GroceryItem *item = &inventory->items[i];\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\\n\", item->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) { //update the quantity\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar(); // Consume leftover newline character\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        if (strcmp(item->name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &item->quantity);\r\n            item->inStock = item->quantity > 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\"); //if there's nothing on inventory\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory) { //remove item\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove trailing newline\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Shift remaining items to overwrite the removed item\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item '%s' not found in inventory.\\n\", name); //if there's no item that you input on inventory\r\n}\r\n\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // Student not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() { \r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"List is empty or contains only one student. No sorting needed.\\n\");\r\n        return;\r\n    }\r\n    int swapped;\r\n    Student *i, *j;\r\n    Student temp;\r\n    do {\r\n        swapped = 0; \r\n        i = head;\r\n        while (i != NULL && i->next != NULL) {\r\n            j = i->next;\r\n            if (i->grade > j->grade) {\r\n                temp = *i;\r\n                *i = *j;\r\n                *j = temp;\r\n                swapped = 1;\r\n            }\r\n            i = i->next;\r\n        }\r\n    } while (swapped); // Continue until no more swaps are made\r\n\r\n    printf(\"Record sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character from input\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id); \r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                            found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    In the sortStudents function, sorting is done by swapping entire student structures. This approach can lead to incorrect behavior since it does not properly manage the linked list's next pointers, which can cause data corruption."
  },
  {
    "student_id": "20713832",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\n\n// The Function prototypes used for matrix operations\nvoid inputMatrix(int rows, int cols, int matrix[10][10], char name); // intializing a function called input matrix\nvoid printMatrix(int rows, int cols, int matrix[10][10]); // intializing a function called print matrix\nvoid addMatrices(int rows, int cols, int matrixA[10][10], int matrixB[10][10], int result[10][10]);// intializing a function called add matrix\nvoid subtractMatrices(int rows, int cols, int matrixA[10][10], int matrixB[10][10], int result[10][10]); // intializing a function called subtract matrix\nvoid transposeMatrix(int rows, int cols, int matrix[10][10], int result[10][10]); // intializing a function called transpose matrix\n\nint main() {\n    int rowsA, colsA, rowsB, colsB; // intializing rows and columns of Matrix A and Matrix B\n    int matrixA[10][10], matrixB[10][10]; \n    int result[10][10]; // intializing result\n    int choice;\n\n    \n    printf(\"Enter the dimensions for Matrix A (rows and columns): \"); //Asking the User to Input the dimensions for Matrix A\n    scanf(\"%d %d\", &rowsA, &colsA); // using scanf feature to read the input\n\n    \n    inputMatrix(rowsA, colsA, matrixA, 'A'); // Asking the user to Input the elements for Matrix A\n\n    \n    printf(\"Enter the dimensions for Matrix B (rows and columns): \"); // Asking the User to Input the dimensions for Matrix B\n    scanf(\"%d %d\", &rowsB, &colsB);//  using scanf feature to read the input\n\n    \n    inputMatrix(rowsB, colsB, matrixB, 'B'); // Asking the user to Input the elements for Matrix A\n\n    do {                                    // using a do loop so that the user can access the menu again until the exit choice is selected\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");  \n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \"); // Asking the user for the input\n        scanf(\"%d\", &choice); // using scanf to read the input\n\n        switch (choice) {               // using switch - case to use the respective functions\n            case 1: // Addition of Matrices\n                if (rowsA == rowsB && colsA == colsB) { // setting the rule that it is only possible to add matrix if the matrices are of the same dimention\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    printMatrix(rowsA, colsA, result); // The result of the addition is displayed.\n                } else {\n                    printf(\"Addition of the these Matrices is not possible. The Dimensions do not match.\\n\"); // If the dimention are not the same, the following message is displayed.\n                }\n                break;\n\n            case 2: // Subtraction of Matrices\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    printMatrix(rowsA, colsA, result); // The result of the subtraction is displayed.\n                } else {\n                    printf(\"Subtraction of these Matrices is not possible. The Dimensions do not match.\\n\");  // If the dimention are not the same, the following message is displayed.\n                }\n                \n                break;\n\n                case 3: // Transpose Matrix A\n                transposeMatrix(rowsA, colsA, matrixA, result);\n                printf(\"Transpose of Matrix A:\\n\");\n                printMatrix(colsA, rowsA, result); // inverting the rows and columns and the result is displayed\n                break;\n\n                case 4: // Transpose Matrix B\n                transposeMatrix(rowsB, colsB, matrixB, result);\n                printf(\"Transpose of Matrix B:\\n\");\n                printMatrix(colsB, rowsB, result); // inverting the rows and columns and the result is displayed\n                break;\n\n            case 5: // Exit\n                printf(\"Exiting the program ...\\n\"); \n                break;\n\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5); // as long as the choice is not 5 , the do loop keeps running\n\n    return 0;\n}\n\n// Function to input a matrix\nvoid inputMatrix(int rows, int cols, int matrix[10][10], char name) {\n    printf(\"Enter elements for Matrix %c:\\n\", name); // Asking the user to input the elements of the matrix\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]); // reading the input\n        }\n    }\n}\n\n// Function to print a matrix\nvoid printMatrix(int rows, int cols, int matrix[10][10]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]); // displaying the matrix\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to add two matrices\nvoid addMatrices(int rows, int cols, int matrixA[10][10], int matrixB[10][10], int result[10][10]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = matrixA[i][j] + matrixB[i][j]; // adding both the matrices\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int rows, int cols, int matrixA[10][10], int matrixB[10][10], int result[10][10]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = matrixA[i][j] - matrixB[i][j]; // subtracting both the matrices\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix(int rows, int cols, int matrix[10][10], int result[10][10]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j]; // transposing the matrices by swapping the rows and columns\n        }\n    }\n}\n\n/* --- q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    bool inStock;\n} GroceryItem; // defining a structure called GroceryItem which has functions like name,  category , quantity , price, instock.\n\n// Global variables\nGroceryItem inventory[100]; // Th Inventory array of the grocery\nint itemCount = 0;          // Count of items in inventory\n\n// The Function prototypes\nvoid addGroceryItem(); \nvoid listGroceryItems();\nvoid updateQuantity();\nvoid removeGroceryItem();\nvoid printItem(GroceryItem item);\n\nint main() {\n    int choice;\n\n    do {                                // using a do loop so that the user can access the menu again until the exit choice is selected\n        // Display menu\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \"); // asking the user to input\n        scanf(\"%d\", &choice);// to read the input of the user\n\n        // Process the user choice\n        switch (choice) {                    // using switch - case to use the respective functions\n            case 1:\n                addGroceryItem();\n                break;\n            case 2:\n                listGroceryItems();\n                break;\n            case 3:\n                updateQuantity();\n                break;\n            case 4:\n                removeGroceryItem();\n                break;\n            case 5:\n                printf(\"Exiting the program...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to add a grocery item\nvoid addGroceryItem() {\n    if (itemCount >= 100) {\n        printf(\"Inventory is full! Cannot add more items.\\n\"); // if the inventory is more than 100 items , the following message is displayed\n        return;\n    }\n\n    GroceryItem item;\n    printf(\"Enter name of the grocery item: \"); // asking the user to input the name of the grocery item \n    getchar(); // Clear the buffer\n    fgets(item.name, 100, stdin); // used to ensure the buffer is not overflowed\n    item.name[strcspn(item.name, \"\\n\")] = '\\0'; // Used to Remove the trailing newline\n\n    printf(\"Enter category of the grocery item: \"); // Asking the user to input the category \n    fgets(item.category, 50, stdin); // used to ensure the buffer is not overflowed\n    item.category[strcspn(item.category, \"\\n\")] = '\\0'; // Used to remove trailing newline\n\n    printf(\"Enter quantity of the grocery item: \"); // Asking the user to input the quantity of the grocery item\n    scanf(\"%d\", &item.quantity); // to read the input\n\n    printf(\"Enter price of the grocery item: \");\n    scanf(\"%f\", &item.price); // to read the input\n\n    // Set availability status\n    item.inStock = item.quantity > 0;\n\n    // Add to inventory\n    inventory[itemCount++] = item;\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items\nvoid listGroceryItems() {\n    if (itemCount == 0) {\n        printf(\"No grocery items in the inventory.\\n\"); // if there are no grocery item, the following message will be displayed\n        return;\n    }\n\n    for (int i = 0; i < itemCount; i++) {\n        printItem(inventory[i]);\n    }\n}\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity() {\n    char name[100];\n    int newQuantity;\n\n    printf(\"Enter name of the grocery item to update quantity: \");\n    getchar(); // Clear the buffer\n    fgets(name, 100, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    for (int i = 0; i < itemCount; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            printf(\"Enter new quantity for %s: \", name);\n            scanf(\"%d\", &newQuantity);\n\n            inventory[i].quantity = newQuantity;\n            inventory[i].inStock = newQuantity > 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Grocery item '%s' not found!\\n\", name);\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem() {\n    char name[100];\n\n    printf(\"Enter name of the grocery item to remove: \");\n    getchar(); // Clear the buffer\n    fgets(name, 100, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove trailing newline\n\n    for (int i = 0; i < itemCount; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            for (int j = i; j < itemCount - 1; j++) {\n                inventory[j] = inventory[j + 1];\n            }\n            itemCount--;\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\n            return;\n        }\n    }\n    printf(\"Grocery item '%s' not found!\\n\", name);\n}\n\n// Function to print a grocery item\nvoid printItem(GroceryItem item) {\n    printf(\"\\nName: %s\\n\", item.name);\n    printf(\"Category: %s\\n\", item.category);\n    printf(\"Quantity: %d\\n\", item.quantity);\n    printf(\"Price: %.2f\\n\", item.price);\n    printf(\"Status: %s\\n\", item.inStock ? \"In Stock\" : \"Out of Stock\");\n}\n\n/* --- q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next; // used to link one student node to the next node in a singly linked list\n} Student; //defining a structure named student which contains functions like name,id,grade\n\nStudent* head = NULL;\n\nvoid insertStudent(const char* name, int id, float grade); // Inserts a new student record into the linked list.\nvoid displayStudents(); // Displays all current student records in the linked list.\nStudent* searchStudentByID(int id); // Searches for student record by student ID and returns a pointer to the corresponding studentnode.\nvoid deleteList(); // Deletes the entire linked list and frees the allocated memory.\nvoid freeMemory(); // A utility function to ensure that all memory is freed when the program exits.\nStudent* createStudent(const char* name, int id, float grade); //Creates a new student node and returns a pointer to it.\nvoid sortStudents(); // Sort the student records by grade according to a sorting algorithm of your choice. \n\n\nStudent* createStudent(const char* name, int id, float grade) { // Initializing a function to create a new student node\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for the new student\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\"); //Checking memory allocation\n        return NULL;\n    }\n    strcpy(newStudent->name, name); // It Copies the name\n    newStudent->id = id;           // It Assigns the ID\n    newStudent->grade = grade;     // It Assigns the grade\n    newStudent->next = NULL;       // Initialize the next pointer\n    return newStudent;            \n}\n\n\nvoid insertStudent(const char* name, int id, float grade) { // Initializing a function to insert a new student record\n    Student* newStudent = createStudent(name, id, grade); // Creating a new student node\n    if (!newStudent) return; // checking if memory allocation was succesfull\n\n    if (head == NULL) { // If the list is empty,then make the new student the head\n        head = newStudent;\n    } else {\n        Student* temp = head;\n        while (temp->next != NULL) { // loop continues until the next pointer of the current node is NULL, indicating the last node in the list.\n            temp = temp->next;\n        }\n        temp->next = newStudent; // Adding the new student to the end of the list\n    }\n    printf(\"Student record has been inserted successfully.\\n\"); // the following message will be displayed\n}\n\n\nvoid displayStudents() {  // intialiazing a function to display all the student records\n    if (head == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n    Student* temp = head;\n    printf(\"Student Records:\\n\");\n    while (temp != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade); // For each student node, print their name, ID, and grade\n        temp = temp->next;  // Move to the next student in the list\n    }\n}\n\nStudent* searchStudentByID(int id) { // initializing a function to search for a student by ID\n    Student* temp = head;\n    while (temp != NULL) {\n        if (temp->id == id) { // If the ID matches, then return the student details\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL; // Return NULL if no student is found\n}\n\n\nvoid sortStudents() { // intializing a sort function to sort the student records by grade based on bubble sort\n    if (head == NULL || head->next == NULL) {\n        printf(\"No sorting is required. List is empty or has only one student.\\n\");\n        return; // No need to sort if the list is empty or contains only one node\n    }\n\n    Student* i;\n    Student* j;\n    for (i = head; i->next != NULL; i = i->next) { // Outer loop to traverse the list\n        for (j = head; j->next != NULL; j = j->next) { // Inner loop for pairwise comparisons\n            if (j->grade > j->next->grade) { // Compare grades\n                // Swap the data (name, ID, and grade) between adjacent nodes\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, j->name);\n                tempID = j->id;\n                tempGrade = j->grade;\n\n                strcpy(j->name, j->next->name);\n                j->id = j->next->id;\n                j->grade = j->next->grade;\n\n                strcpy(j->next->name, tempName);\n                j->next->id = tempID;\n                j->next->grade = tempGrade;\n            }\n        }\n    }\n    printf(\"Student records sorted by grade in ascending order (using bubble sort).\\n\");\n}\n\n\nvoid deleteList() { // initializing a function to delete the entire list\n Student* current = head;\n Student* next;\n\n while (current != NULL) {\n    next = current->next; // // Save the next node\n    free(current); // // Free the memory of the current node\n    current = next; // // Move to the next node in the list\n }\n head = NULL; // Set the head to NULL to indicate the list is empty\n}\n\nvoid freeMemory() { // to delete the entire linked list and free the associated memory\n deleteList();\n} \n\nint main() {\n int choice, id;\n char name[100];\n float grade;\n do {                                               // using a do loop so that the user can access the menu again until the exit choice is selected\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\"); //using bubble sort\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \"); // asking the user to input the choice\n        scanf(\"%d\", &choice); // using scanf to read the inpu\n        getchar(); // To consume the newline character\n\n\n switch (choice) {                           // using switch - case to use the respective functions\n    case 1:\n        printf(\"Enter the Name: \");\n        fgets(name, sizeof(name), stdin);\n        strtok(name, \"\\n\");\n        printf(\"Enter the ID: \");\n        scanf(\"%d\", &id);\n        printf(\"Enter the Grade: \");\n        scanf(\"%f\", &grade);\n        insertStudent(name, id, grade);\n    break;\n    case 2:\n    displayStudents();\n    break;\n    case 3:\n    sortStudents();\n    break;\n    case 4:\nprintf(\"Enter the ID to search: \");\nscanf(\"%d\", &id);\n\nStudent* found = searchStudentByID(id); \nif (found) {\n        printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n }\n    else {\nprintf(\"Student not found in records.\\n\");\n}\n    break;\n    case 5:\n        deleteList();\n        printf(\"List has been deleted.\\n\");\n    break;\n    case 6:\n    deleteList();  // This handles memory cleanup already\n    printf(\"Exiting the program...\\n\");\n    break;\n\n    \n    default:\n        printf(\"Invalid choice! Please try again.\\n\"); }\n}   while (choice != 6);\n\nreturn 0;\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is simple and works well for small datasets, but its time complexity of O(n?) can lead to inefficiencies with larger lists. For better performance, consider using more efficient sorting algorithms like Quick Sort or Merge Sort in future implementations."
  },
  {
    "student_id": "20590645",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Maximum matrix size\r\n#define MAX 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX];\r\n    int result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter dimensions of Matrix A (rows cols): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter dimensions of Matrix B (rows cols): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Validate matrix dimensions\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX || rowsA <= 0 || colsA <= 0 || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid dimensions. Maximum allowed is %dx%d.\\n\", MAX, MAX);\r\n        return 1;\r\n    }\r\n\r\n    // Input elements of Matrix A\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // Input elements of Matrix B\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Add matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible: Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // Subtract matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible: Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Transpose Matrix A\r\n                transposeMatrix(A, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                // Transpose Matrix B\r\n                transposeMatrix(B, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input a matrix\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i, j);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix neatly in a table format\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    printf(\"+\");\r\n    for (int j = 0; j < cols; j++) {\r\n        printf(\"-------+\");\r\n    }\r\n    printf(\"\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        printf(\"|\");\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\" %5d |\", matrix[i][j]);\r\n        }\r\n        printf(\"\\n+\");\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"-------+\");\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n\r\n// structure to represent grocery items\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n\r\n// structure to represent availability status of an item\r\ntypedef struct {\r\n    bool in_stock;\r\n    bool out_of_stock;\r\n} AvailabilityStatus;\r\n\r\n\r\n// structure to represent entire grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int total_items;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\n\r\n// interface\r\nint main() {\r\n    GroceryInventory inventory = {.total_items = 0};\r\n    int choice;\r\n    int valid_input;\r\n\r\n    do {\r\n        printf(\"\\n--- Grocery Inventory Management ---\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Item Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        valid_input = scanf(\"%d\", &choice);\r\n\r\n        if (valid_input != 1) {\r\n            printf(\"Invalid input! Please enter a valid number.\\n\");\r\n            // Clear the input buffer\r\n            while (getchar() != '\\n');\r\n            continue;\r\n        }\r\n\r\n        getchar(); // Consume leftover newline character from the input buffer\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please select a valid option.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n// function to add items to grocery list\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->total_items >= MAX_ITEMS) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n    AvailabilityStatus newStatus;\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    getchar();\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar();\r\n\r\n    newStatus.in_stock = newItem.quantity > 0;\r\n    newStatus.out_of_stock = newItem.quantity == 0;\r\n\r\n    inventory->items[inventory->total_items] = newItem;\r\n    inventory->status[inventory->total_items] = newStatus;\r\n    inventory->total_items++;\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n\r\n// function to list items in list\r\nvoid listGroceryItems(GroceryInventory inventory) {\r\n    if (inventory.total_items == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n--- Grocery Items ---\\n\");\r\n    for (int i = 0; i < inventory.total_items; i++) {\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", inventory.items[i].name);\r\n        printf(\"Category: %s\\n\", inventory.items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory.items[i].quantity);\r\n        printf(\"Price: $%.2f\\n\", inventory.items[i].price);\r\n        printf(\"Availability: %s\\n\", \r\n               inventory.status[i].in_stock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\n// function to adjust value of items\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    if (inventory->total_items == 0) {\r\n        printf(\"No items in inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->total_items; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            getchar();\r\n\r\n            inventory->status[i].in_stock = inventory->items[i].quantity > 0;\r\n            inventory->status[i].out_of_stock = inventory->items[i].quantity == 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n\r\n// function to remove items from grocery list\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->total_items == 0) {\r\n        printf(\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->total_items; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->total_items - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            inventory->total_items--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n\r\n// define structure for students\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function Prototypes\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid sortStudents();\r\nvoid swap(Student* a, Student* b);\r\nvoid bubbleSort(Student* head);\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    while (1) {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter student name: \");\r\n                getchar();  // to consume newline\r\n                fgets(name, 100, stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0';  // remove newline from string\r\n                printf(\"Enter student ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter student grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter student ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* student = searchStudentByID(id);\r\n                if (student != NULL) {\r\n                    printf(\"Student found: %s, ID: %d, Grade: %.2f\\n\", student->name, student->id, student->grade);\r\n                } else {\r\n                    printf(\"Student with ID %d not found.\\n\", id);\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                exit(0);\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n// Function Definitions\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted.\\n\");\r\n}\r\n\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        Student* toDelete = temp;\r\n        temp = temp->next;\r\n        free(toDelete);\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records deleted.\\n\");\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n    printf(\"Memory freed and program exited.\\n\");\r\n}\r\n\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\r\n    newStudent->name[sizeof(newStudent->name) - 1] = '\\0';\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Sort students by grade (Bubble Sort)\r\nvoid sortStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No records to sort.\\n\");\r\n        return;\r\n    }\r\n    bubbleSort(head);\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\nvoid bubbleSort(Student* head) {\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    if (head == NULL)\r\n        return;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                swap(ptr1, ptr1->next);\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n}\r\n\r\nvoid swap(Student* a, Student* b) {\r\n    int tempID = a->id;\r\n    float tempGrade = a->grade;\r\n    char tempName[100];\r\n    strncpy(tempName, a->name, sizeof(a->name));\r\n\r\n    // Swap values\r\n    a->id = b->id;\r\n    a->grade = b->grade;\r\n    strncpy(a->name, b->name, sizeof(a->name));\r\n\r\n    b->id = tempID;\r\n    b->grade = tempGrade;\r\n    strncpy(b->name, tempName, sizeof(b->name));\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20715960",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define SIZE 10 //maximum size of matrices\r\n\r\n//function to add matrices\r\nvoid addMatrices(int rows, int cols, int A[SIZE][SIZE], int B[SIZE][SIZE], int result[SIZE][SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//function to subtract matrices\r\nvoid subtractMatrices(int rows, int cols, int A[SIZE][SIZE], int B[SIZE][SIZE], int result[SIZE][SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//function to transpose a matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[SIZE][SIZE], int result[SIZE][SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];           //reverse the indices to transpose\r\n        }\r\n    }\r\n}\r\n\r\n//main function\r\nint main() {\r\n    int rows, cols; //matrix dimensions\r\n    int A[SIZE][SIZE], B[SIZE][SIZE], result[SIZE][SIZE]; //matrices\r\n    int choice; //user's menu choice\r\n\r\n    printf(\"Enter the number of rows and columns (max %d): \", SIZE);           //to enter matrix dimensions\r\n    scanf(\"%d %d\", &rows, &cols);\r\n\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    for (int i = 0; i < rows; i++) {                       //loop iterates over both rows and columns to populate matrix A\r\n        for (int j = 0; j < cols; j++) {\r\n        printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++){                        //loop iterates over both rows and columns to populate matrix B\r\n        for (int j = 0; j < cols; j++){\r\n        printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n    }\r\n    \r\n\r\n    do {                                                  //in a loop to ensure that menu repeats until user exits\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {                                 //using switch-case to call respective function based on user input\r\n            case 1:\r\n                addMatrices(rows, cols, A, B, result);\r\n                printf(\"Result of Addition:\\n\");\r\n                for (int i = 0; i < rows; i++) {\r\n                    for (int j = 0; j < cols; j++) {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                subtractMatrices(rows, cols, A, B, result);\r\n                printf(\"Result of Subtraction:\\n\");\r\n                for (int i = 0; i < rows; i++) {\r\n                    for (int j = 0; j < cols; j++) {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(rows, cols, A, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                for (int i = 0; i < cols; i++) {\r\n                    for (int j = 0; j < rows; j++) {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(rows, cols, B, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                for (int i = 0; i < cols; i++) {\r\n                    for (int j = 0; j < rows; j++) {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n        }\r\n    } while (choice != 5);                                  //to exit if the user enters 5\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>  //including string library to use funtions like strcmp\r\n\r\n#define MAX_ITEMS 100 //maximum number of items allowed in inventory\r\n\r\n//struct for grocery item\r\ntypedef struct {\r\n    char name[100];          //name of the item\r\n    char category[50];       //category of the item\r\n    int quantity;            //quantity available in stock\r\n    float price;             //price per unit of the item\r\n} GroceryItem;               //structure that stores details about each grocery item\r\n\r\n//struct for grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];      //array of grocery items to store all items in inventory\r\n    int count;                         //track number of items are currently in inventory\r\n} GroceryInventory;         //a structure that represents the inventory of all items\r\n\r\n//function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .count = 0 }; //initialize inventory\r\n    int choice;  //to store user's menu selection\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); //to consume newline character left in buffer\r\n\r\n        switch (choice) {      //calls appropriate function based on choice\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);     //loop continues until user selects 5\r\n\r\n    return 0;\r\n}\r\n\r\n//function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {        //exits with an error message if inventory is full\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->count];     //points to next available slot in the items array\r\n\r\n    //reads details for new items\r\n    printf(\"Enter item name: \");        \r\n    scanf(\" %[^\\n]%*c\", (*item).name);\r\n    printf(\"Enter category: \");\r\n    scanf(\" %[^\\n]%*c\", (*item).category);\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &(*item).quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &(*item).price);\r\n\r\n    inventory->count++;\r\n    printf(\"Item added successfully!\\n\");    //increments count after adding item\r\n}\r\n\r\n//function to list all grocery items\r\nvoid listGroceryItems(const GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n   //loops through all items and print their details\r\n    printf(\"\\nGrocery Items:\\n\");\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", (*item).name);\r\n        printf(\"  Category: %s\\n\", (*item).category);\r\n        printf(\"  Quantity: %d\\n\", (*item).quantity);\r\n        printf(\"  Price: %.2f\\n\", (*item).price);\r\n        printf(\"  Availability: %s\\n\", (*item).quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n//function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update quantity: \");\r\n    scanf(\" %[^\\n]%*c\", name);\r\n\r\n    //searches for items and updates its quantity\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        if (strcmp((*item).name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &(*item).quantity);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n//function to remove a grocery item\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");      //reads names of items to be removed\r\n    scanf(\" %[^\\n]%*c\", name);\r\n\r\n    //finds the item and shifts all subsequent items to close the gap\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->count--;           //decrements count after removing items\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>       //provides functions for dynamic memory management (malloc,free)\r\n#include <string.h>\r\n\r\n//structure for Student\r\ntypedef struct Student {\r\n    char name[100];     //string for name\r\n    int id;             //integer for id\r\n    float grade;        //floating-point for student grade\r\n    struct Student* next;      //pointer to next student node\r\n} Student;\r\n\r\nStudent* head = NULL;    //global pointer points to first node in linked list\r\n\r\n//function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));    //allocate memory for new student\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);      //copy provided name into new node\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n//function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n\r\n    if (!head) {               //if list is empty, new student becomes the head\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next) {       //if not empty,iterates thru list to find last node\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n//function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp) {                              //go thru loop and print details of each node\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n//function to sort student records by grade in ascending order\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {     //no need to sort if list empty or has one node\r\n        printf(\"No need to sort. Not enough records.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* i, *j;\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                //swap student details\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempID;\r\n                j->grade = tempGrade;\r\n            } //nested loopes compare grades of all pair of nodes\r\n        }\r\n    }\r\n    printf(\"Students sorted by grade.\\n\");\r\n}\r\n\r\n//function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) {      //compare id of each node with target\r\n            return temp;           //if match found, return a pointer to node\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//function to delete the entire list\r\nvoid deleteList() {\r\n    Student* temp = head;\r\n    while (temp) {        //iterates through list freeing each note\r\n        Student* next = temp->next;\r\n        free(temp);\r\n        temp = next;\r\n    }\r\n    head = NULL;       //sets head to NULL\r\n    printf(\"All student records deleted.\\n\");\r\n}\r\n\r\n//main function\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    //provides menu for user interaction\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Students by Grade\\n\");\r\n        printf(\"4. Search Student by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //used fgets for names and scanf for integers and floats\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                getchar(); // Clear input buffer\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = 0; // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);     //repeats until user selects 6\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-The transposition logic in the transposeMatrix function and its use in the main function is incorrect. The loop indices for printing the transposed matrix should be reversed. The outer loop should iterate over cols, and the inner loop should iterate over rows.\nq2-Meet requirement. \nq3-The program uses a nested loop structure similar to Bubble Sort to sort student records by grade. While simple and effective for small datasets, it has a time complexity of O(n?), which can be inefficient for larger datasets. For better efficiency, consider using algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20619586",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\nint main() {\r\n    int rowA, columnA;\r\n    printf(\"Enter dimensions for Matrix A (rows and column): \");\r\n    scanf(\"%d %d\", &rowA, &columnA);\r\n    int matrixA[rowA][columnA];\r\n    puts(\"Enter elements for Matrix A\");\r\n    for (int i = 0; i < rowA; i++) {\r\n        for (int j = 0; j < columnA; j++)\r\n        {\r\n            printf(\"Element [%d][%d]: \",i+1,j+1);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    int rowB, columnB;\r\n    printf(\"Enter dimensions for Matrix B (rows and column): \");\r\n    scanf(\"%d %d\", &rowB, &columnB);\r\n    int matrixB[rowB][columnB];\r\n    puts(\"Enter elements for Matrix B\");\r\n    for (int i = 0; i < rowB; i++) {\r\n        for (int j = 0; j < columnB; j++)\r\n        {\r\n            printf(\"Element [%d][%d]: \",i+1,j+1);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n    while (1) {\r\n        puts(\"Matrix Operation Menu: \");\r\n        puts(\"1. Add Matrice\");\r\n        puts(\"2. Subract Matrices\");\r\n        puts(\"3. Transpose Matrix A\");\r\n        puts(\"4. Transpose Matrix B\");\r\n        puts(\"5. Exit\");\r\n\r\n        int choice;\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        \r\n        switch (choice) {\r\n        case 1: //Add Matrix\r\n            if (rowA != rowB || columnA != columnB){\r\n                puts(\"Matrix of different sizes cannot add\");\r\n                break;\r\n            }\r\n            for (int i = 0; i < rowA; i++) {\r\n                for (int j = 0; j < columnA; j++){\r\n                    printf(\"%d \", matrixA[i][j] + matrixB[i][j]);\r\n                }\r\n                printf(\"\\n\");\r\n            }\r\n            puts(\"\");\r\n            break;\r\n\r\n        case 2: //Subtract Matrix\r\n            if (rowA != rowB || columnA != columnB){\r\n                puts(\"Matrix of different sizes cannot subtract\");\r\n                break;\r\n            }\r\n            for (int i = 0; i < rowA; i++) {\r\n                for (int j = 0; j < columnA; j++){\r\n                    printf(\"%d \", matrixA[i][j] - matrixB[i][j]);\r\n                }\r\n                printf(\"\\n\");\r\n            }    \r\n            puts(\"\");    \r\n            break;\r\n\r\n        case 3: //Transpose matrix A\r\n            for (int j = 0; j < rowA; j++){\r\n                for (int i = 0; i < columnA; i++) {\r\n                    printf(\"%d \", matrixA[i][j]);\r\n                }\r\n                printf(\"\\n\");\r\n            }    \r\n            puts(\"\");    \r\n            break;\r\n\r\n        case 4: //Transpose matrix B\r\n            for (int j = 0; j < rowB; j++){\r\n                for (int i = 0; i < columnB; i++) {\r\n                    printf(\"%d \", matrixB[i][j]);\r\n                }\r\n                printf(\"\\n\");\r\n            }    \r\n            puts(\"\");    \r\n            break;\r\n\r\n        case 5: \r\n            puts(\"Exiting...\");\r\n            return 0;\r\n            break;\r\n\r\n        default:\r\n            puts(\"Please enter between number 1-5\");\r\n            break;\r\n        }\r\n    }\r\n    \r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n#define SIZE 100 //max size of grocery list\r\n#define NAME 100\r\n#define CATEGORY 100\r\n\r\nvoid r_scan(){\r\n    int c;\r\n    while ((c = getchar()) != '\\n')\r\n    continue;\r\n}\r\nvoid strget(char* str, int constant){   //end \"/n in fgets\"\r\n    fgets(str, constant, stdin);\r\n    str[strcspn(str, \"\\n\")] = 0; \r\n}\r\n\r\ntypedef struct {\r\n    char name[NAME];  \r\n    char category[CATEGORY];\r\n    int quantity;\r\n    float price;\r\n}Item;\r\n\r\ntypedef struct {\r\n    bool in_stock;\r\n    bool out_of_stock;\r\n}Avaliability;\r\n\r\nItem item[SIZE];\r\nAvaliability avaliable[SIZE];\r\n\r\nint main() {\r\n    int total_items = 0;\r\n\r\n    while(1){\r\n        puts(\"Grocery Inventory Management Menu: \");\r\n        puts(\"1. Add Grocery Item\");\r\n        puts(\"2. List All Grocery Items\");\r\n        puts(\"3. Update Quantity\");\r\n        puts(\"4. Remove Grocery Item\");\r\n        puts(\"5. Exit\");\r\n\r\n        int choice;\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        r_scan();\r\n\r\n\r\n        switch (choice) {\r\n        case 1: //Add\r\n            printf(\"Enter Item Name: \");\r\n            strget(item[total_items].name, NAME);\r\n\r\n            printf(\"Enter Catergory: \");\r\n            strget(item[total_items].category, CATEGORY);\r\n\r\n            printf(\"Enter Quantity: \");\r\n            scanf(\"%d\",&item[total_items].quantity);\r\n            r_scan();\r\n\r\n            printf(\"Enter Price: \");\r\n            scanf(\"%f\",&item[total_items].price);\r\n            r_scan();\r\n\r\n            if (item[total_items].quantity <= 0){\r\n                avaliable[total_items].in_stock = false;\r\n                avaliable[total_items].out_of_stock = true;\r\n            }else{\r\n                avaliable[total_items].in_stock = true;\r\n                avaliable[total_items].out_of_stock = false;\r\n            }\r\n\r\n            printf(\"Grocery item added successfully!\\n\\n\");\r\n            total_items++;\r\n            \r\n            break;\r\n\r\n        case 2: //List All\r\n            if (total_items == 0){\r\n                puts(\"No grocery in inventory\");\r\n                break;\r\n            }\r\n            for (int i = 0; i < total_items; i++) {\r\n                printf(\"Name: %s\\n\", item[i].name);\r\n                printf(\"Category: %s\\n\", item[i].category);\r\n                printf(\"Quantity: %d\\n\", item[i].quantity);\r\n                printf(\"Price: %.2f\\n\", item[i].price);\r\n\r\n                if (avaliable[i].in_stock==true){\r\n                    printf(\"Status: In Stock\\n\\n\");\r\n                }else if (avaliable[i].out_of_stock==true){\r\n                    printf(\"Status: Out of Stock\\n\\n\");\r\n                }\r\n            }\r\n            break;\r\n\r\n        case 3: // update quantity\r\n            char name[NAME];\r\n            int found = 0;\r\n            printf(\"Enter the name of grocery item to update quantity: \");\r\n            strget(name, NAME);\r\n            for (int i = 0; i <= total_items; i++) {\r\n                if (strcmp(name, item[i].name)==0){\r\n                    found = 1;\r\n                    printf(\"Enter new quantity for %s: \", item[i].name);\r\n                    scanf(\"%d\",&item[i].quantity);\r\n                    puts(\"Quantity updated successfully!\\n\\n\");\r\n                    if (item[total_items].quantity <= 0){\r\n                        avaliable[i].in_stock = false;\r\n                        avaliable[i].out_of_stock = true;\r\n                    }else{\r\n                        avaliable[i].in_stock = true;\r\n                        avaliable[i].out_of_stock = false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (found == 0){\r\n                puts(\"Item not found\\n\");\r\n            }\r\n            break;\r\n\r\n        case 4: // remove item\r\n            printf(\"Enter the name of the grocery item to remove: \");\r\n            strget(name, NAME);\r\n\r\n            found = 0; \r\n            for (int i = 0; i < total_items; i++) {\r\n                if (strcmp(name, item[i].name) == 0) {\r\n                    found = 1;\r\n                    for (int j = i; j <= total_items - 1; j++) {        //<= cause after total item is empty so copy empty to last string\r\n                        item[j] = item[j + 1];\r\n                        avaliable[j] = avaliable[j + 1];\r\n                    }\r\n                    total_items--;\r\n                    printf(\"Grocery item '%s' removed successfully!\\n\\n\", name);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (found==0) {\r\n                printf(\"Item not found\");\r\n            }\r\n            break;\r\n        \r\n        case 5:\r\n            return 0;\r\n            break;\r\n\r\n        default:\r\n            puts(\"Please enter between number 1-5\");\r\n            break;\r\n        }\r\n    }\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    struct Student* new_student = (struct Student*) malloc(sizeof(struct Student));\r\n\r\n    strcpy(new_student->name, name);\r\n    new_student->id  = id;\r\n    new_student->grade  = grade;\r\n    new_student->next = NULL;\r\n\r\n    return new_student;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    struct Student *newStudent = (struct Student *)malloc(sizeof(struct Student));\r\n    newStudent = createStudent(name, id, grade);\r\n    newStudent -> next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL){\r\n        printf(\"No records found.\\n\");\r\n    }else{\r\n        Student* current = head;\r\n        while (current != NULL) {\r\n            printf(\"Name: %s, ID: %d, Grade: %.2f \\n\", current->name, current->id, current->grade);\r\n            current = current->next;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    if (head == NULL) {\r\n        printf(\"No records found.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {   \r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\n    //insertion sort, is efficient, only need to loop once (efficent) and use minimal extra memory\r\nvoid sortStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* sortHead = NULL;   //line 97, replace sort head and point node to null, prevent unlimited loop\r\n    Student* current = head;\r\n\r\n    while (current != NULL) {\r\n        Student* next = current->next;\r\n\r\n        if (sortHead == NULL || current->grade < sortHead->grade) {     // if is the first node\r\n            current->next = sortHead;               // node points to original first node to replace it\r\n            sortHead = current;\r\n            \r\n        } else {\r\n            Student* sort = sortHead;\r\n            while (sort->next != NULL && sort->next->grade <= current->grade) {\r\n                sort = sort->next;  \r\n            }\r\n\r\n            current->next = sort->next;\r\n            sort->next = current;\r\n        }\r\n\r\n        current = next;\r\n    }\r\n\r\n    head = sortHead;    //if first node was change, change head\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\");\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student* found = searchStudentByID(id);\r\n            if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                found->name, found->id, found->grade);\r\n            } else {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n} ",
    "feedback": "q1-Meet requirement. \nq2-    In the update quantity function, the loop condition should iterate until i < total_items instead of i <= total_items. This can lead to accessing an uninitialized element when trying to compare names.    In the remove item function, the loop that shifts items should also use j < total_items - 1 to avoid accessing out-of-bounds elements after the last item has been removed.\nq3-The implementation of Insertion Sort for sorting student records by grade is efficient for linked lists. It effectively maintains the sorted order with minimal additional memory usage. The approach is appropriate given the context."
  },
  {
    "student_id": "20611470",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define Max 10\r\n\r\n// Input matrix\r\nvoid inputMatrix(int mat[Max][Max], int rows, int cols) \r\n{ \r\n    printf(\"Enter elements of the matrix:\\n\"); \r\n    for (int i = 0; i < rows; i++) \r\n    { \r\n        for (int j = 0; j < cols; j++) \r\n        { \r\n            printf(\"Element[%d][%d] :\",i+1 ,j+1);\r\n            scanf(\"%d\", &mat[i][j]); \r\n        } \r\n    } \r\n}\r\n\r\n// Display matrix\r\nvoid printMatrix(int mat[Max][Max], int rows, int cols) \r\n{  \r\n    for (int i = 0; i < rows; i++) \r\n    { \r\n        for (int j = 0; j < cols; j++) \r\n        { \r\n            printf(\"%d \", mat[i][j]); \r\n        } \r\n        printf(\"\\n\");\r\n    } \r\n}\r\n\r\n// Function to perform addition\r\nvoid addMatrices(int matA[Max][Max], int matB[Max][Max], int result[Max][Max], int rows, int cols)\r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    { \r\n        for (int j = 0; j < cols; j++) \r\n        { \r\n            result[i][j] = matA[i][j] + matB[i][j];\r\n        } \r\n    } \r\n}\r\n\r\n// Function to perform subtraction\r\nvoid subMatrices(int matA[Max][Max], int matB[Max][Max], int result[Max][Max], int rows, int cols)\r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    { \r\n        for (int j = 0; j < cols; j++) \r\n        { \r\n            result[i][j] = matA[i][j] - matB[i][j];\r\n        } \r\n    } \r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int mat[Max][Max], int result[Max][Max], int rows, int cols) \r\n{  \r\n    for (int i = 0; i < rows; i++) \r\n    { \r\n        for (int j = 0; j < cols; j++) \r\n        { \r\n            result[j][i] = mat[i][j];\r\n        } \r\n    } \r\n}\r\n\r\n// Main\r\nint main()\r\n{\r\n    // Initialization\r\n    int matA[Max][Max], matB[Max][Max], result[Max][Max];\r\n    int choice, rowsA, colsA, rowsB, colsB;\r\n\r\n    // Input value for matrix A \r\n    printf(\"Enter the dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    if (rowsA > Max || colsA > Max || rowsA <= 0 || colsA <= 0)\r\n    {\r\n        printf(\"Invalid dimensions for Matrix A. Exiting.\\n\");\r\n        return 1;\r\n    }\r\n    inputMatrix(matA, rowsA, colsA);\r\n    \r\n    // Input value for matrix B\r\n    printf(\"Enter the dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    if (rowsB > Max || colsB > Max || rowsB <= 0 || colsB <= 0)\r\n    {\r\n        printf(\"Invalid dimensions for Matrix B. Exiting.\\n\");\r\n        return 1;\r\n    }\r\n    inputMatrix(matB, rowsB, colsB);\r\n\r\n    do\r\n    {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Switch case for choice\r\n        switch (choice)\r\n        {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB)\r\n                {\r\n                    addMatrices(matA, matB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B :\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Matrices dimensions are not compatible for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB)\r\n                {\r\n                    subMatrices(matA, matB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B :\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Matrices dimensions are not compatible for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(matA, result, rowsA, colsA);       \r\n                printf(\"Transpose of Matrix A:\\n\"); \r\n                printMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(matB, result, rowsB, colsB); \r\n                printf(\"Transpose of Matrix B:\\n\"); \r\n                printMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            \r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);      // when 5 exit\r\n    \r\n    return 0;   \r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100       // Let MAX_ITEMS = 100\r\n\r\n// Initialize variables\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    int inStock; // 1 for in stock, 0 for out of stock\r\n} AvailabilityStatus;\r\n\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus availability[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    AvailabilityStatus status;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", item.name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", item.category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n    // Check the quantity of the item quantity > 0. If true status.inStock = 1, false = 0\r\n    status.inStock = item.quantity > 0 ? 1 : 0;\r\n\r\n    inventory->items[inventory->itemCount] = item;      // Add the new items into item array in inventory\r\n    inventory->availability[inventory->itemCount] = status;     // Add the availability status of the new item to availability array in the inventory\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem item = inventory->items[i];\r\n        AvailabilityStatus status = inventory->availability[i];\r\n        printf(\"Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\\n\", status.inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter name of the grocery item to update: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {      // If the name of the i-th term is same as the inputed name.\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            inventory->items[i].quantity = newQuantity;         // Set the i-th term in inventory to newQuantity\r\n            inventory->availability[i].inStock = newQuantity > 0 ? 1 : 0;       // Update the instock status, then check is newQuantity > 0.\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found in the inventory.\\n\", name);\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {        // Remove the item from the iventory\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->itemCount--;     // Item count -1\r\n\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found in the inventory.\\n\", name);\r\n}\r\n\r\n// Main function with menu\r\nint main() {\r\n    GroceryInventory inventory = {0};\r\n\r\n    int choice;\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateGroceryItem(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program. Goodbye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));        // malloc returns a pointer to the allocated memory\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);     // copy name string into name field\r\n    newStudent->id = id;        // Assign id values to newStudent structure\r\n    newStudent->grade = grade;      // // Assign grade values to newStudent structure\r\n    newStudent->next = NULL;        // Set next pointer of newStudent structure to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n    if (!head) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next) {\r\n            temp = temp->next;      // Move to the next\r\n        }\r\n        temp->next = newStudent;    // Point to newStudent\r\n    }\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) return temp;        // Check if the pointed id matches teh give id, if yes, return temp\r\n        temp = temp->next;          // if not match, move to the next node\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);      // Remove the allocated memory\r\n        current = next;     // Point to the next one\r\n    }\r\n\r\n    head = NULL;\r\n    printf(\"All student records deleted.\\n\");\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (!head || !head->next) return;\r\n\r\n    for (Student* i = head; i->next; i = i->next) {\r\n        for (Student* j = i->next; j; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID = i->id;\r\n                float tempGrade = i->grade;\r\n\r\n                // Bubble sort\r\n                strcpy(tempName, i->name);      // i coppied to temp\r\n                strcpy(i->name, j->name);       // j is coppied to i\r\n                strcpy(j->name, tempName);      // temp is coppied to j\r\n\r\n                i->id = j->id;      // swap i and j id\r\n                j->id = tempID;     // swap j and tempid\r\n\r\n                i->grade = j->grade;        // swap i and j grade\r\n                j->grade = tempGrade;       // swap j and tempgrade\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found:\\n Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. While this algorithm is straightforward, it has a time complexity of O(n?), which may not be efficient for larger datasets. For a more optimal solution, consider using algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20607863",
    "code": "\n/* --- Q1(matrices).c --- */\n#include <stdio.h>\r\n\r\nint promptSize(int*, int*, char);\r\nint createMatrix(int[], int, int, char);\r\nvoid printMatrix(int*, int, int);\r\nvoid addMatrix(int*, int*, int, int);\r\nvoid subMatrix(int*, int*, int, int);\r\nvoid transposeMatrix(int*, int, int, char);\r\n\r\n// To clear input buffer until a newline\r\nvoid clearInput() {\r\n    scanf(\"%*[^\\n]\");scanf(\"%*c\");\r\n}\r\n\r\nint main() {\r\n    int rowA=0, colA=0, rowB=0, colB=0;\r\n    puts(\"Welcome to Matrix calculator\");\r\n    \r\n    // Prompts user for size of matrix A for initialization\r\n    while (1) {\r\n        if (promptSize(&rowA, &colA, 'A')==-1) {\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    // Initializes matrix A\r\n    int MatrixA[rowA*colA];\r\n    createMatrix(MatrixA, rowA, colA, 'A');\r\n\r\n    // Prompts user for size of matrix B for initialization\r\n    while (1) {\r\n        if (promptSize(&rowB, &colB, 'B')==-1) {\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    // Initializes matrix B\r\n    int MatrixB[rowB*colB];\r\n    createMatrix(MatrixB, rowB, colB, 'B');\r\n\r\n    int choice = 0;\r\n    int exit = 0;\r\n\r\n    while (!exit) {\r\n        printf(\"\\nMatrix Operations Menu\\n\"\r\n               \"1. Add matrices\\n\"\r\n               \"2. Subtract matrices\\n\"\r\n               \"3. Transpose of matrix A\\n\"\r\n               \"4. Transpose of matrix B\\n\"\r\n               \"5. Exit\\n\"\r\n               \"Enter you choice: \");\r\n        scanf(\"%d\",&choice);\r\n        getchar();\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowA != rowB || colA != colB) {\r\n                    printf(\"Error: Matrices need to be of the same dimension.\\n\");\r\n                    break;\r\n                }\r\n                addMatrix(MatrixA, MatrixB, rowA, colA);\r\n                break;\r\n            case 2:\r\n                if (rowA != rowB || colA != colB) {\r\n                    printf(\"Error: Matrices need to be of the same dimension.\\n\");\r\n                    break;\r\n                }\r\n                subMatrix(MatrixA, MatrixB, rowA, colA);\r\n                break;\r\n            case 3:\r\n                transposeMatrix(MatrixA, rowA, colA, 'A');\r\n                break;\r\n            case 4:\r\n                transposeMatrix(MatrixB, rowB, colB, 'B');\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                exit = 1;\r\n                break;\r\n            default:\r\n                printf(\"Invalid Choice\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\nint promptSize(int *rowptr, int *colptr, char name) {\r\n    int rows = 0, cols = 0;\r\n    printf(\"Enter dimensions for Matrix %c (rows and columns): \", name);\r\n    scanf(\"%d %d\", &rows, &cols);\r\n    clearInput();\r\n\r\n    // Checks for row and column max is 10\r\n    if (rows < 1 || 10 < rows) {\r\n        printf(\"Error: rows has to be between 1 and 10 inclusive.\\n\");\r\n        return -1;\r\n    }\r\n    if (cols < 1 || 10 < cols) {\r\n        printf(\"Error: columns has to be between 1 and 10 inclusive\\n\");\r\n        return -1;\r\n    }\r\n\r\n    *rowptr = rows;\r\n    *colptr = cols;\r\n    return 0;\r\n}\r\n\r\n// Creates Matrix returns error code and changes row and col by address\r\nint createMatrix(int matrix[], int rows, int cols, char name) {\r\n\r\n    // Matrix is of the form \"contiguous array of rows\"\r\n    printf(\"Enter elements for matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            // Because of the matrix storage, elements can be accessed with the formula, columns*rowIndex + colIndex\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[cols*i + j]);\r\n            clearInput();\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid printMatrix(int matrix[], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[cols*i + j]);\r\n        }\r\n        puts(\"\");\r\n    }\r\n}\r\n\r\nvoid addMatrix(int MatrixA[], int MatrixB[], int rows, int cols) {\r\n    int result[rows*cols];\r\n    // Adds matching indexes of matrix elements in each matrix\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[cols*i+j] = MatrixA[cols*i+j] + MatrixB[cols*i+j];\r\n        }\r\n    }\r\n    puts(\"Result of Matrix A + Matrix B:\");\r\n    printMatrix(result, rows, cols);\r\n}\r\n\r\nvoid subMatrix(int MatrixA[], int MatrixB[], int rows, int cols) {\r\n    int result[rows*cols];\r\n    // Subtracts matching indexes of matrix elements in each matrix\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[cols*i+j] = MatrixA[cols*i+j] - MatrixB[cols*i+j];\r\n        }\r\n    }\r\n    puts(\"Result of Matrix A + Matrix B:\");\r\n    printMatrix(result, rows, cols);\r\n}\r\n\r\nvoid transposeMatrix(int matrix[], int rows, int cols, char name) {\r\n    int result[rows*cols];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            // Switches from an array of rows to an array of columns\r\n            result[rows*j+i] = matrix[cols*i + j];\r\n        }\r\n    }\r\n    printf(\"Result of transpose Matrix %c\\n\", name);\r\n    printMatrix(result, cols, rows);\r\n}\r\n/*\r\n1 2 3\r\n4 5 6\r\n\r\n1 2 3 4 5 6\r\n\r\n1 4\r\n2 5\r\n3 6\r\n\r\n1 4 2 5 3 6\r\n*/\n/* --- Q2(Grocery).c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\nstruct GroceryItem {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\ntypedef struct GroceryItem GroceryItem;\r\n\r\n// Make bool type just an int\r\ntypedef int bool;\r\nstruct AvailabilityStatus {\r\n    bool inStock;\r\n};\r\ntypedef struct AvailabilityStatus AvailabilityStatus;\r\n\r\nstruct GroceryInventory {\r\n    GroceryItem* items[100];\r\n    AvailabilityStatus statuses[100];\r\n    int count;\r\n};\r\ntypedef struct GroceryInventory GroceryInventory;\r\n\r\nvoid addGroceryItem(GroceryInventory*);\r\nvoid listInventory(GroceryInventory*);\r\nvoid updateQuantity(GroceryInventory*);\r\nvoid rmvGroceryItem(GroceryInventory*);\r\n\r\n// To clear input buffer until a newline\r\nvoid clearInput() {\r\n    scanf(\"%*[^\\n]\");scanf(\"%*c\");\r\n}\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.count = 0;\r\n    int choice;\r\n\r\n    while (choice != 5) {\r\n        printf(\"\\nGrocery Inventory Management System\\n\"\r\n            \"1. Add Grocery Item\\n\"\r\n            \"2. List All Grocery Items\\n\"\r\n            \"3. Update quantity\\n\"\r\n            \"4. Remove Grocery Item\\n\"\r\n            \"5. Exit\\n\"\r\n            \"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        clearInput();\r\n\r\n        puts(\"\");\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listInventory(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                rmvGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice\\n\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory* invPtr) {\r\n    int index = invPtr->count;\r\n    char name[100], category[50];\r\n    int quantity;\r\n    float price;\r\n\r\n    // Initialize GroceryItem and space needed to store it\r\n    GroceryItem item;\r\n    invPtr->items[index] = malloc(sizeof(GroceryItem));\r\n\r\n    // Prompt for item details\r\n    printf(\"Enter Item Name: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name,\"\\n\")] = 0;\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(category, sizeof(category), stdin);\r\n    category[strcspn(category,\"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &price);\r\n\r\n    clearInput();\r\n\r\n    // Populating the GroceryItem with its values\r\n    strcpy(item.name, name);\r\n    strcpy(item.category, category);\r\n    item.quantity = quantity;\r\n    item.price = price;\r\n\r\n    // Copy the GroceryItem into the premade pointer in the inventory\r\n    memcpy(invPtr->items[index], &item, sizeof(item));\r\n\r\n    // Update the Availability array in inventory\r\n    AvailabilityStatus status;\r\n    status.inStock = (quantity > 0) ? 1 : 0;\r\n    memcpy(&(invPtr->statuses[index]), &status, sizeof(status));\r\n\r\n    // Update count of inventory\r\n    invPtr->count++;\r\n\r\n    puts(\"Item added successfully!\");\r\n}\r\n\r\nvoid listInventory(GroceryInventory* invPtr) {\r\n    GroceryItem* itemPtr;\r\n    int count = invPtr->count;\r\n\r\n    if (!count) {\r\n        puts(\"No items to list\");\r\n        return;\r\n    }\r\n\r\n    for (size_t i = 0; i < count; i++) {\r\n        itemPtr = invPtr->items[i];\r\n\r\n        printf(\"Name: %s\\n\", itemPtr->name);\r\n        printf(\"Category: %s\\n\", itemPtr->category);\r\n        printf(\"Quantity: %d\\n\", itemPtr->quantity);\r\n        printf(\"Price: %.2f\\n\", itemPtr->price);\r\n        printf(\"Status: %s\\n\", (invPtr->statuses[i].inStock) ? \"In Stock\" : \"Out Stock\");\r\n        puts(\"\");\r\n    }\r\n    \r\n}\r\n\r\nvoid updateQuantity(GroceryInventory* invPtr) {\r\n    char name[100];\r\n    int newQuantity;\r\n    int count = invPtr->count;\r\n\r\n    if (!count) {\r\n        puts(\"No items to update\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    // Iterate through the array of pointers checking each name\r\n    for (size_t i = 0; i < count; i++) {\r\n        if (strcmp(invPtr->items[i]->name, name)) {\r\n            continue;\r\n        }\r\n\r\n        printf(\"Enter new quantity for %s: \", name);\r\n        scanf(\"%d\", &newQuantity);\r\n        clearInput();\r\n\r\n        invPtr->items[i]->quantity = newQuantity;\r\n        invPtr->statuses[i].inStock = (newQuantity > 0) ? 1 : 0;\r\n        puts(\"Quantity updated successfully!\");\r\n        return;\r\n    }\r\n\r\n    puts(\"Item not found\");    \r\n}\r\n\r\nvoid rmvGroceryItem(GroceryInventory* invPtr) {\r\n    char name[100];\r\n    int newQuantity;\r\n    int count = invPtr->count;\r\n\r\n    if (!count) {\r\n        puts(\"No items to remove\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    // Iterate through items until matching name\r\n    for (size_t i = 0; i < count; i++) {\r\n        if (strcmp(invPtr->items[i]->name, name)) {\r\n            continue;\r\n        }\r\n\r\n        // Free pointer that points to the item to be removed\r\n        free(invPtr->items[i]);\r\n\r\n        // Shifts the pointers after it to the prevoius index by one\r\n        memcpy(&(invPtr->items[i]), &(invPtr->items[i+1]), sizeof(invPtr->items[i])*(count-i-1));\r\n\r\n        // Decrements counts\r\n        invPtr->count--;\r\n\r\n        puts(\"Successfully removed item!\");\r\n        return;\r\n    }\r\n\r\n    puts(\"Item not found\"); \r\n}\n/* --- Q3(Students).c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student student;\r\n    Student* studentPtr = malloc(sizeof(Student));\r\n\r\n    strcpy(student.name, name);\r\n    student.id = id;\r\n    student.grade = grade;\r\n    student.next = NULL;\r\n\r\n    memcpy(studentPtr, &student, sizeof(Student));\r\n\r\n    return studentPtr;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* studentPtr = createStudent(name, id, grade);\r\n    studentPtr->next = head;\r\n    head = studentPtr;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents(Student* head, int len) {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    if (head == NULL) {\r\n        puts(\"There are no students to display.\");\r\n    }\r\n\r\n    while (current != NULL && len!=0) {\r\n        next = current->next;\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = next;\r\n        len--;\r\n    }\r\n    \r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\nint countStudents(Student* headPtr) {\r\n    int counter=0;\r\n    Student* current = headPtr;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        counter++;\r\n        current = next;\r\n    }\r\n    return counter;\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    // Merge sort | Because it is stable, better time complexity than bubblesort or insertion sort that is simpler, appending the sublists when the other is empty is easy with linked lists\r\n    Student *bufhead, *buftail;\r\n    int k = 1;\r\n    Student *leftstart, *leftend, *rightstart, *rightend, *end;\r\n    Student *largerPtr;\r\n    int len = countStudents(head);\r\n\r\n    char dummy;\r\n\r\n    // Left sublist: [leftstart,...,leftend]\r\n    // Right sublist: [rightstart,...,rightend]\r\n\r\n    while (k < len) {\r\n        leftstart = head;\r\n        bufhead = NULL;\r\n        buftail = bufhead;\r\n\r\n        // Goes through list\r\n        while (leftstart != NULL) {\r\n\r\n            // Sets the start of right sublist to right after the leftsublist\r\n            leftend = leftstart;\r\n            for (int i = 0; i < k-1; i++) {\r\n                // Left sublist reaches end of list\r\n                if (leftend->next == NULL) {\r\n                    break;\r\n                } else {\r\n                    leftend = leftend->next;\r\n                }\r\n            }\r\n            // Left sublist reaches end of list\r\n            if (leftend->next == NULL) {\r\n                buftail->next = leftstart;\r\n                buftail = leftend;\r\n                break;\r\n            }\r\n            \r\n            rightstart = leftend->next;\r\n\r\n            // Adjusts end of right sublist, either until k moves or end of list\r\n            rightend = rightstart;\r\n            for (int i = 0; i < k-1; i++) {\r\n                // Left sublist reaches end of list\r\n                if (rightend->next == NULL) {\r\n                    break;\r\n                } else {\r\n                    rightend = rightend->next;\r\n                }\r\n            }\r\n\r\n            // Merging to buffer\r\n\r\n            // Sublists not empty\r\n            while (leftstart != leftend->next && rightstart != rightend->next) {\r\n                // Pointing largerPtr to larger\r\n                if (leftstart->grade >= rightstart->grade) {\r\n                    largerPtr = leftstart;\r\n                    leftstart = leftstart->next;\r\n                } else {\r\n                    largerPtr = rightstart;\r\n                    rightstart = rightstart->next;\r\n                }\r\n\r\n                // Appending larger to buffer\r\n                if (bufhead == NULL) {\r\n                    // Case of adding first item to buffer\r\n                    bufhead = largerPtr;\r\n                    buftail = bufhead;\r\n                } else {\r\n                    buftail->next = largerPtr;\r\n                    buftail = buftail->next;\r\n                }\r\n            }\r\n            \r\n\r\n            // if left empty\r\n            if (leftstart == leftend->next) {\r\n                // append right sublist to buffer\r\n                buftail->next = rightstart;\r\n                buftail = rightend;\r\n                leftstart = rightend->next;\r\n            }\r\n\r\n            // if right empty\r\n            if (rightstart == rightend->next) {\r\n                // append left sublist to buffer\r\n                buftail->next = leftstart;\r\n                buftail = leftend;\r\n                leftstart = rightstart;\r\n            }\r\n        }\r\n        // Point the head to buffer head\r\n        head = bufhead;\r\n        buftail->next = NULL;\r\n\r\n        k *= 2;\r\n    }\r\n\r\n    if (len) {\r\n        puts(\"Record has been sorted with merge sort\");\r\n    } else {\r\n        puts(\"No records to sort\");\r\n    }\r\n\r\n}\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents(head,100);\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                            found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n} \r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function implements Merge Sort to sort student records by grade. This choice is effective as Merge Sort has a time complexity of O(n log n) and is stable, making it suitable for linked lists. The implementation demonstrates a good understanding of sorting algorithms."
  },
  {
    "student_id": "20722972",
    "code": "\n/* --- Q1.c --- */\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#define ROW_MAX_SIZE 10\r\n#define COL_MAX_SIZE 10\r\n\r\n// function prototypes\r\nvoid print_menu(void);\r\nvoid print_matrix(int **matrix, size_t row, size_t col);\r\nint **add_matrix(int **m_a, int **m_b, size_t row_a, size_t col_a, size_t row_b, size_t col_b);\r\nint **subtract_matrix(int **m_a, int **m_b, size_t row_a, size_t col_a, size_t row_b, size_t col_b);\r\nint **transpose_matrix(int **matrix, size_t row, size_t col);\r\nint **alloc_mem(size_t row, size_t col);\r\nvoid free_mem(int **matrix, size_t row);\r\n\r\n// function main begins program execution\r\nint main(void){\r\n    // initialisation \r\n    int choice=0;\r\n    int row_A, col_A, row_B, col_B;\r\n\r\n    // prompt user to input dimensions of matrices A and B\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d%d\", &row_A, &col_A);\r\n    while(row_A>ROW_MAX_SIZE || col_A>ROW_MAX_SIZE){ // check if size is valid\r\n        puts(\"Error: Maximum size allowed is 10 x 10.\");\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d%d\", &row_A, &col_A);\r\n    }\r\n    int **matrix_A=alloc_mem(row_A, col_A);\r\n\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d%d\", &row_B, &col_B);\r\n    while(row_B>COL_MAX_SIZE || col_B>COL_MAX_SIZE){ // check if size is valid\r\n        puts(\"Error: Maximum size allowed is 10 x 10.\");\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d%d\", &row_B, &col_B);\r\n    }\r\n    int **matrix_B=alloc_mem(row_B, col_B);\r\n\r\n    // prompt user to input matrix elements\r\n    puts(\"Enter elements for Matrix A:\");\r\n    for(int i=0;i<row_A;i++){\r\n        for(int j=0;j<col_A;j++){\r\n            printf(\"Element [%d][%d]: \", i, j);\r\n            scanf(\"%d\",&matrix_A[i][j]);\r\n        }\r\n    }\r\n    //print_matrix(matrix_A, row_A, col_A); // for testing\r\n\r\n    puts(\"\\nEnter elements for Matrix B:\");\r\n    for(int i=0;i<row_B;i++){\r\n        for(int j=0;j<col_B;j++){\r\n            printf(\"Element [%d][%d]: \", i, j);\r\n            scanf(\"%d\",&matrix_B[i][j]);\r\n        }\r\n    }\r\n    //print_matrix(matrix_B, row_B, col_B); // for testing\r\n\r\n    // perform matrix operations according to user's choice\r\n    do{\r\n        print_menu();\r\n        printf(\"%s\", \"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice)\r\n        {\r\n        case 1: // add matrices\r\n            if(row_A==row_B && col_A==col_B){\r\n                int **result=add_matrix(matrix_A, matrix_B, row_A, col_A, row_B, col_B);\r\n                if(result==NULL){\r\n                    break;\r\n                }\r\n                print_matrix(result, row_A, col_A);\r\n            }else{\r\n                puts(\"Error: Invalid operation (matrix A and B have different dimensions).\");\r\n            }\r\n            \r\n            break;\r\n\r\n        case 2: // subtract matrices\r\n        if(row_A==row_B && col_A==col_B){\r\n                int **result=subtract_matrix(matrix_A, matrix_B, row_A, col_A, row_B, col_B);\r\n                if(result==NULL){\r\n                    break;\r\n                }\r\n                print_matrix(result, row_A, col_A);\r\n            }else{\r\n                puts(\"Error: Invalid operation (matrix A and B have different dimensions).\");\r\n            }\r\n\r\n            break;\r\n\r\n        case 3: // transpose matrix A\r\n            int **transpose_A=transpose_matrix(matrix_A, row_A, col_A);\r\n            if(transpose_A==NULL){\r\n                break;\r\n            }\r\n            print_matrix(transpose_A, col_A, row_A); // row and col invert after transpose\r\n            break;\r\n\r\n        case 4: // transpose matrix B\r\n            int **transpose_B=transpose_matrix(matrix_B, row_B, col_B);\r\n            if(transpose_B==NULL){\r\n                break;\r\n            }\r\n            print_matrix(transpose_B, col_B, row_B); // row and col invert after transpose\r\n            break;\r\n\r\n        case 5: // exit\r\n            puts(\"Exiting...\");\r\n            break;\r\n        \r\n        default:\r\n            puts(\"Error: Invalid input.\");\r\n            break;\r\n        }\r\n\r\n    }while(choice!=5);\r\n\r\n    free_mem(matrix_A, row_A);\r\n    free_mem(matrix_B, row_B);\r\n}\r\n\r\n// displays matrix operation menu\r\nvoid print_menu(void){\r\n    puts(\"\\n========== Matrix Operations Menu ==========\");\r\n    printf(\"%10s%s\\n\",\"1:\",\"Add Matrices.\");\r\n    printf(\"%10s%s\\n\",\"2:\",\"Subtract Matrices.\");\r\n    printf(\"%10s%s\\n\",\"3:\",\"Transpose Matrix A.\");\r\n    printf(\"%10s%s\\n\",\"4:\",\"Transpose Matrix B.\");\r\n    printf(\"%10s%s\\n\",\"5:\",\"Exit.\");\r\n    puts(\"============================================\");\r\n}\r\n\r\n// displays the matrix in a grid form\r\nvoid print_matrix(int **matrix, size_t row, size_t col){\r\n    puts(\"\");\r\n    for(int i=0;i<row;i++){\r\n        for(int j=0;j<col;j++){\r\n            printf(\"%-3d \", matrix[i][j]);\r\n        }\r\n        puts(\"\");\r\n    }\r\n}\r\n\r\n// adds two matrices together and returns a pointer to the result\r\nint **add_matrix(int **m_a, int **m_b, size_t row_a, size_t col_a, size_t row_b, size_t col_b){\r\n    int **result=alloc_mem(row_a, col_a);\r\n    for(int i=0;i<row_a;i++){\r\n        for(int j=0;j<col_a;j++){\r\n            result[i][j]=m_a[i][j]+m_b[i][j];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n// subtracts the second matrix from the first and returns a pointer to the result\r\nint **subtract_matrix(int **m_a, int **m_b, size_t row_a, size_t col_a, size_t row_b, size_t col_b){\r\n    int **result=alloc_mem(row_a, col_a);\r\n    for(int i=0;i<row_a;i++){\r\n        for(int j=0;j<col_a;j++){\r\n            result[i][j]=m_a[i][j]-m_b[i][j];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n// transpose the matrix and return a pointer to the result\r\nint **transpose_matrix(int **matrix, size_t row, size_t col){\r\n    int **result=alloc_mem(col, row);\r\n    for(int i=0;i<row;i++){\r\n        for(int j=0;j<col;j++){\r\n            result[j][i]=matrix[i][j];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n// allocate memory for a matrix and return a pointer to the matrix\r\nint **alloc_mem(size_t row, size_t col){\r\n    int **new_matrix=(int **)malloc(row*sizeof(int *));\r\n    if(new_matrix==NULL){\r\n        puts(\"Error: Unable to allocate memory.\");\r\n        return NULL;\r\n    }\r\n    for(int i=0;i<row;i++){\r\n        new_matrix[i]=(int *)malloc(col*sizeof(int));\r\n        if(new_matrix[i]==NULL){\r\n        puts(\"Error: Unable to allocate memory.\");\r\n        return NULL;\r\n    }\r\n    }\r\n    return new_matrix;\r\n}\r\n\r\n// free up allocated memory\r\nvoid free_mem(int **matrix, size_t row){\r\n    for(int i=0; i<row; i++){\r\n        free(matrix[i]);\r\n    }\r\n    free(matrix);\r\n}\n/* --- Q2.c --- */\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#include<ctype.h>\r\n#define MAX_ITEM 100\r\n#define MAX_NAME_BUFFER 100\r\n#define MAX_CAT_BUFFER 50\r\n\r\nstruct grocery_item{\r\n    char *name;\r\n    char *category;\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\nunion availability_status{\r\n    int in_stock;\r\n    int out_of_stock;\r\n};\r\n\r\n\r\ntypedef struct grocery_item Item;\r\ntypedef union availability_status Status;\r\n\r\nstruct grocery_inventory{\r\n    Item *item_arr;\r\n    Status *status_arr;\r\n    size_t total_item;\r\n};\r\n\r\ntypedef struct grocery_inventory Inventory;\r\n\r\n// function prototypes\r\nvoid print_menu(void);\r\nvoid add_item(Inventory *inv);\r\nvoid list_all_items(Inventory *inv);\r\nvoid list_one_item(Inventory *inv, size_t index);\r\nvoid update_quantity(Inventory *inv);\r\nsize_t search_item(Inventory *inv);\r\nvoid remove_item(Inventory *inv);\r\n\r\n\r\n// function main begins program execution\r\nint main(void){\r\n    // initialization\r\n    Inventory *inventory = malloc(sizeof(Inventory));\r\n    inventory->item_arr = malloc(MAX_ITEM * sizeof(Item));\r\n    inventory->status_arr = malloc(MAX_ITEM * sizeof(Status));\r\n    inventory->total_item = 0;\r\n    int choice=0;\r\n\r\n    do{\r\n        print_menu();\r\n\r\n        // prompt user to enter choice based on menu\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // clear leftover newline char\r\n\r\n        switch (choice) // perform actions according to user choice\r\n        {\r\n        case 1: // add grocery item\r\n            add_item(inventory);\r\n            break;\r\n\r\n        case 2: // list all grocery items\r\n            list_all_items(inventory);\r\n            break;\r\n\r\n        case 3: // update quantity\r\n            update_quantity(inventory);\r\n            break;\r\n\r\n        case 4: // remove grocery item\r\n            remove_item(inventory);\r\n            break;\r\n\r\n        case 5: // exit\r\n            break;\r\n        \r\n        default:\r\n            puts(\"Error: Invalid input.\");\r\n            break;\r\n        }\r\n    }while(choice!=5);\r\n\r\n    // free allocated memory\r\n    free(inventory->item_arr);\r\n    free(inventory->status_arr);\r\n    free(inventory);\r\n}\r\n\r\n// function that displays user guide \r\nvoid print_menu(void){\r\n    puts(\"\");\r\n    puts(\"========== Grocery Inventory Management System ==========\");\r\n    printf(\"%10s%s\\n\",\"1.\",\"Add grocery item.\");\r\n    printf(\"%10s%s\\n\",\"2.\",\"List all grocery items.\");\r\n    printf(\"%10s%s\\n\",\"3.\",\"Update quantity.\");\r\n    printf(\"%10s%s\\n\",\"4.\",\"Remove grocery item.\");\r\n    printf(\"%10s%s\\n\",\"5.\",\"Exit.\");\r\n    puts(\"=========================================================\");\r\n}\r\n\r\n// function that lets user to add new item into inventory\r\nvoid add_item(Inventory *inv){\r\n    // check if inventory is full\r\n    if(inv->total_item>=MAX_ITEM){\r\n        puts(\"Error: Inventory is full.\");\r\n        return;\r\n    }\r\n\r\n    // get index of new item\r\n    size_t index=inv->total_item;\r\n    Item *new_item=inv->item_arr+index;\r\n\r\n    // allocate memory for name and category of new item to be added\r\n    new_item->name=malloc(sizeof(char)*MAX_NAME_BUFFER);\r\n    new_item->category=malloc(sizeof(char)*MAX_CAT_BUFFER);\r\n    \r\n    // check if memory allocation was successful\r\n    if(new_item->name == NULL || new_item->category==NULL){\r\n        puts(\"Error: Memory allocation failed.\");\r\n        return;\r\n    }\r\n\r\n    // enter name\r\n    char buffer[MAX_NAME_BUFFER];\r\n    printf(\"Enter item name: \");\r\n    fgets(buffer, MAX_NAME_BUFFER, stdin);\r\n    buffer[strcspn(buffer,\"\\n\")]=0; // remove trailing newline\r\n    strcpy(new_item->name, buffer); \r\n    memset(buffer,0,sizeof(buffer)); // clear buffer\r\n\r\n    // enter category\r\n    printf(\"Enter item category: \");\r\n    fgets(buffer, MAX_CAT_BUFFER, stdin);\r\n    buffer[strcspn(buffer,\"\\n\")]=0; // remove trailing newline\r\n    strcpy(new_item->category, buffer);\r\n    memset(buffer,0,sizeof(buffer)); // clear buffer\r\n\r\n    // enter quantity\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &new_item->quantity);\r\n\r\n    // enter item price\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &new_item->price);\r\n\r\n    // availability status\r\n    (inv->status_arr+index)->in_stock=new_item->quantity>0; // returns 0 if false\r\n\r\n    inv->total_item++; \r\n    puts(\"Grocery item added successfully!\");\r\n}\r\n\r\n// function that lists all items and their details in a table\r\nvoid list_all_items(Inventory *inv){\r\n    // get index of last item\r\n    size_t total_index=inv->total_item-1;\r\n\r\n    // check if current inventory is empty\r\n    if(total_index==0){\r\n        puts(\"Error: Inventory is empty.\");\r\n        return;\r\n    }\r\n    \r\n    // table header\r\n    puts(\"===================================================================================================\");\r\n    printf(\"%-50s%-30s%-10s%-10s%-10s\",\"Name\", \"Category\", \"Quantity\", \"Price\", \"Status\");\r\n\r\n    for(size_t i=0; i<total_index+1; i++){\r\n        Item *item=inv->item_arr+i;\r\n        Status *status=inv->status_arr+i;\r\n        const char*available=status->in_stock ? \"In Stock\" : \"Out of Stock\";\r\n        printf(\"\\n%-50s%-30s%-10d%-10.2f%-10s\",item->name, item->category,item->quantity, item->price, available);\r\n    }\r\n}\r\n\r\n// asks user to enter name of item to search for, returns the index of the item in item_arr and status_arr\r\nsize_t search_item(Inventory *inv){\r\n    // initialisation\r\n    char buffer[MAX_NAME_BUFFER];\r\n    size_t index=inv->total_item; \r\n    Item *item=inv->item_arr;\r\n\r\n    // prompt user to enter name of item\r\n    printf(\"Enter name of the grocery item: \");\r\n    fgets(buffer, sizeof(buffer), stdin);\r\n    buffer[strcspn(buffer,\"\\n\")]=0; // remove trailing newline character\r\n\r\n    // loop through item_arr\r\n    for(int i=0; i<index; i++){\r\n        if(strcmp(buffer,(item+i)->name)==0){\r\n            return i;\r\n        }\r\n    }\r\n\r\n    // if item is found, return index of item, else return -1\r\n    return -1;\r\n}\r\n\r\n// function that displays information of one item given its index in item_arr and status_arr\r\nvoid list_one_item(Inventory *inv, size_t index){\r\n    // initialisation\r\n    Item *item=inv->item_arr+index;\r\n    Status *status=inv->status_arr+index;\r\n    char *available=status->in_stock ? \"In Stock\" : \"Out of Stock\";\r\n\r\n    // display info of item\r\n    printf(\"%-20s: %s\\n\", \"Name\", item->name);\r\n    printf(\"%-20s: %s\\n\", \"Category\", item->category);\r\n    printf(\"%-20s: %d\\n\", \"Quantity\", item->quantity);\r\n    printf(\"%-20s: %.2f\\n\", \"Price\", item->price);\r\n    printf(\"%-20s: %s\\n\", \"Status\", available);\r\n}\r\n\r\n// function that lets user update quantity of an item\r\nvoid update_quantity(Inventory *inv){\r\n    // get index of new item\r\n    size_t total_index=inv->total_item-1;\r\n\r\n    // check if current inventory is empty\r\n    if(total_index==-1){\r\n        puts(\"Error: Inventory is empty.\");\r\n        return;\r\n    }\r\n\r\n    // get index of item to be removed\r\n    size_t search_index=search_item(inv);\r\n    while(search_index==(size_t)-1){\r\n        puts(\"Error: Item not found.\");\r\n        search_index=search_item(inv);\r\n    }\r\n\r\n    // display current quantity\r\n    puts(\"Item found!\");\r\n    list_one_item(inv, search_index);\r\n\r\n    // prompt user to enter new quantity\r\n    Item *item=inv->item_arr+search_index;\r\n    Status *status=inv->status_arr+search_index;\r\n\r\n    printf(\"Enter new quantity of %s: \", item->name);\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    // update availability status\r\n    status->in_stock=item->quantity>0; // returns 0 if false\r\n\r\n    puts(\"Item quantity updated successfully!\");\r\n}\r\n\r\n// function that lets user search for an item and remove it\r\nvoid remove_item(Inventory *inv){\r\n    // get index of last item\r\n    size_t total_index=inv->total_item-1;\r\n\r\n    // check if current inventory is empty\r\n    if(total_index==-1){\r\n        puts(\"Error: Inventory is empty.\");\r\n        return;\r\n    }\r\n\r\n    // get index of item to be removed\r\n    size_t search_index=search_item(inv);\r\n    while(search_index==(size_t)-1){\r\n        puts(\"Error: Item not found.\");\r\n        search_index=search_item(inv);\r\n    }\r\n\r\n    // display item details and confirm\r\n    char confirm;\r\n\r\n    puts(\"Item found!\");\r\n    list_one_item(inv, search_index);\r\n\r\n    while(1){\r\n        printf(\"Are you sure you want to delete this item? (Y/N): \");\r\n        scanf(\"%c\", &confirm);\r\n\r\n        if(toupper(confirm)=='Y'){\r\n            // update array\r\n            Item *item=inv->item_arr;\r\n            Status *status=inv->status_arr;\r\n\r\n            free(item[search_index].name);\r\n            free(item[search_index].category);\r\n\r\n            for(size_t i=search_index; i<total_index; i++){\r\n                item[i]=item[i+1];\r\n                status[i]=status[i+1];\r\n            }\r\n\r\n            // clear last slot in array\r\n            item[total_index].name=NULL;\r\n            item[total_index].category=NULL;\r\n            \r\n            inv->total_item--;\r\n            puts(\"Grocery item removed successfully!\");\r\n            return;\r\n\r\n        }else if(toupper(confirm)=='N'){ // cancel\r\n            return;\r\n\r\n        }else{ // continue to loop\r\n            puts(\"Error: Invalid input.\");\r\n        }\r\n    }\r\n}\r\n\r\n\n/* --- Q3.c --- */\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#define MAX_NAME_BUFFER 100\r\n\r\nstruct student{\r\n    char *name;\r\n    int id;\r\n    float grade;\r\n};\r\n\r\nstruct list_node{\r\n    struct student *info; \r\n    struct list_node *next_node;\r\n    struct list_node *prev_node;\r\n};\r\n\r\nstruct list{\r\n    struct list_node *head;\r\n    struct list_node *tail;\r\n    int num_nodes; // number of nodes\r\n};\r\n\r\ntypedef struct student Student;\r\ntypedef struct list_node Node;\r\ntypedef struct list List;\r\n\r\n// function prototypes\r\nvoid print_menu(void);\r\nvoid insert_student(List *list);\r\nvoid display_students(List *list);\r\nvoid search_student(List *list);\r\nNode *search_by_id(List *list, const int id);\r\nvoid delete_list(List *list);\r\nvoid free_memory(List *list);\r\nNode *create_student_node(const char *name, int id, float grade);\r\nvoid sort_students(List *list);\r\n\r\nint main(void){\r\n    // initialisation \r\n    int choice=0;\r\n    List *s_list=malloc(sizeof(List)); // student list\r\n\r\n    if(s_list==NULL){ // check if memory allocation was successful\r\n        puts(\"Error: Unable to allocate memory.\");\r\n        choice=6; // exit program\r\n\r\n    }else{\r\n        s_list->head=NULL;\r\n        s_list->tail=NULL;\r\n        s_list->num_nodes=0;\r\n    }\r\n    \r\n    while(choice!=6){\r\n        print_menu();\r\n\r\n        // prompt user to enter choice\r\n        printf(\"%s\",\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // read trailing newline character\r\n\r\n        switch (choice)\r\n        {\r\n        case 1: // allow the user to insert new stuednt records into the list\r\n            insert_student(s_list);\r\n            break;\r\n        case 2: // display all current student records in the list\r\n            display_students(s_list);\r\n            break;\r\n        case 3: // sort list by grade\r\n            sort_students(s_list);\r\n            break;\r\n        case 4: // search for student by id\r\n            search_student(s_list);\r\n            break;\r\n        case 5: // delete list\r\n            delete_list(s_list);\r\n            puts(\"List deleted successfully!\");\r\n            break;\r\n        case 6: // exit program\r\n            puts(\"Exiting...\");\r\n            break;\r\n        \r\n        default:\r\n            puts(\"Error: Invalid input\");\r\n            break;\r\n        }\r\n    }\r\n\r\n    free_memory(s_list);\r\n}\r\n\r\n// function that displays user guide\r\nvoid print_menu(void){\r\n    puts(\"====================== MENU =====================\");\r\n    printf(\"%12s%s\\n\",\"[1]\",\"Insert student record.\");\r\n    printf(\"%12s%s\\n\",\"[2]\",\"Display student records.\");\r\n    printf(\"%12s%s\\n\",\"[3]\",\"Sort records.\");\r\n    printf(\"%12s%s\\n\",\"[4]\",\"Search record by ID.\");\r\n    printf(\"%12s%s\\n\",\"[5]\",\"Delete list.\");\r\n    printf(\"%12s%s\\n\",\"[6]\",\"Exit.\");\r\n    puts(\"=================================================\");\r\n}\r\n\r\n// create new node \r\nNode *create_student_node(const char *name, int id, float grade){\r\n    //Student *new_student=malloc(sizeof(Student *));\r\n    Node *new_node=malloc(sizeof(Node));\r\n    new_node->info=malloc(sizeof(Student));\r\n    new_node->info->name=malloc(strlen(name)+1);\r\n    Student *record=new_node->info;\r\n    if(record->name==NULL || record==NULL || new_node==NULL){ // check if memory allocation was successful\r\n        puts(\"Error: failed to allocate memory.\");\r\n        return NULL;\r\n    }\r\n    strcpy(record->name, name);\r\n\r\n    record->id=id;\r\n\r\n    record->grade=grade;\r\n\r\n    return new_node;\r\n}\r\n\r\n// function that prompts user to enter info of new record and inserts new node to end of list\r\nvoid insert_student(List *list){\r\n    // initialisation\r\n    int new_id=0;\r\n    float new_grade=0.0;\r\n    char *buffer=malloc(MAX_NAME_BUFFER*sizeof(char));\r\n    \r\n    if(buffer==NULL){ // check if memory allocation is successful\r\n        puts(\"Error: failed to allocate memory.\");\r\n        return;\r\n    }\r\n\r\n    puts(\"=========== [1] Insert Student Record ===========\");\r\n\r\n    // prompt user to enter name of new student\r\n    printf(\"\\nEnter student name: \");\r\n    fgets(buffer, MAX_NAME_BUFFER, stdin);\r\n    buffer[strcspn(buffer, \"\\n\")]='\\0'; // remove trailing newline character\r\n\r\n    // prompt user to enter ID of new student\r\n    printf(\"\\nEnter student ID: \");\r\n    scanf(\"%d\", &new_id);\r\n    while(search_by_id(list, new_id)!=NULL){\r\n        puts(\"Error: ID already exists. Please enter another ID.\");\r\n        printf(\"\\nEnter student ID: \");\r\n        scanf(\"%d\", &new_id);\r\n    }\r\n\r\n    // prompt user to enter grade of new student\r\n    printf(\"\\nEnter student grade: \");\r\n    scanf(\"%f\", &new_grade);\r\n\r\n    Node *new_node=create_student_node(buffer, new_id, new_grade);\r\n    free(buffer); // free allocated memory\r\n\r\n    if(new_node==NULL){ // memory allocation failed (error msg in other function)\r\n        return;\r\n    }\r\n\r\n    // insert node to the end of the list\r\n    if(list->num_nodes==0){\r\n        new_node->next_node=NULL;\r\n        new_node->prev_node=NULL;\r\n        list->head=new_node;\r\n        list->tail=new_node;\r\n    }else{\r\n        list->tail->next_node=new_node;\r\n        new_node->prev_node=list->tail;\r\n        new_node->next_node=NULL;\r\n        list->tail=new_node;\r\n    }\r\n    list->num_nodes++;\r\n\r\n    puts(\"Record added successfully!\");\r\n}\r\n\r\n// displays all current student records in the linked list \r\nvoid display_students(List *list){\r\n    Node *curr_node=list->head;\r\n    if(curr_node==NULL){ // check if list is empty\r\n        puts(\"Error: No records exist.\");\r\n        return;\r\n    }\r\n\r\n    // print student records in table format\r\n    puts(\"========== [2] Display Student Records ==========\");\r\n    printf(\"%-30s%-15s%-10s\\n\", \"Name\", \"Student ID\", \"Grade\");\r\n    while(curr_node!=NULL){\r\n        Student *record=curr_node->info;\r\n        printf(\"%-30s%-15d%-10.1f\\n\", record->name, record->id, record->grade);\r\n        curr_node=curr_node->next_node;\r\n    }\r\n}\r\n\r\n// searches for a student record by student ID and returns a pointer to the corresponding student node\r\nNode *search_by_id(List *list, const int id){\r\n    Node *curr_node=list->head;\r\n    while(curr_node!=NULL){\r\n        if(curr_node->info->id==id){\r\n            return curr_node;\r\n        }\r\n        curr_node=curr_node->next_node;\r\n    }\r\n    return curr_node;\r\n}\r\n\r\n// function that asks user to enter ID of student and then search for record and display\r\nvoid search_student(List *list){\r\n    int search_id;\r\n    if(list->head==NULL){ // check if list is empty\r\n        puts(\"Error: No records exist.\");\r\n        return;\r\n    }\r\n    puts(\"============ [4] Search Record by ID ============\");\r\n    printf(\"Enter ID of student to search for: \");\r\n    scanf(\"%d\", &search_id);\r\n    Node *search_node=search_by_id(list, search_id);\r\n    if(search_node==NULL){\r\n        puts(\"Record not found.\");\r\n        return;\r\n    }else{\r\n        Student *record=search_node->info;\r\n        puts(\"Record found!\");\r\n        printf(\"%10s: %s\\n\",\"Name\", record->name);\r\n        printf(\"%10s: %d\\n\",\"ID\", record->id);\r\n        printf(\"%10s: %.1f\\n\",\"Grade\", record->grade);\r\n    }\r\n}\r\n\r\n// delete the entire linked list and frees the allocated memory\r\nvoid delete_list(List *list){\r\n    puts(\"================ [5] Delete List ================\");\r\n    Node *curr_node=list->head;\r\n    if(curr_node==NULL){\r\n        puts(\"Error: List is empty.\");\r\n        return;\r\n    }\r\n    while(curr_node!=NULL){\r\n        Node *del=curr_node;\r\n        curr_node=curr_node->next_node;\r\n        free(del->info->name);\r\n        free(del->info);\r\n        free(del);\r\n    }\r\n    list->head=NULL;\r\n    list->tail=NULL;\r\n    list->num_nodes=0;\r\n    \r\n}\r\n\r\n// utility function that ensures that all memory is freed when the program exits\r\nvoid free_memory(List *list){\r\n    delete_list(list);\r\n    free(list);\r\n}\r\n\r\n// =========================== MERGE SORT =============================\r\nNode *split(Node *head){\r\n    Node* slow=head; // fall on middle node at the end\r\n    Node* fast=head->next_node; // go to end of list\r\n\r\n    while(fast!=NULL && fast->next_node!=NULL){\r\n        slow=slow->next_node; // one step\r\n        fast=fast->next_node->next_node; // two steps\r\n    }\r\n    Node *head_b=slow->next_node; // the start of second division\r\n    if(head_b!=NULL){ // head_b might be NULL if there is only one node in the left division\r\n        head_b->prev_node=NULL; \r\n    }\r\n    slow->next_node=NULL; // the end of first division\r\n\r\n    return head_b;\r\n}\r\n\r\nNode *merge(Node *list_a, Node *list_b){\r\n    // base case\r\n    if (list_a==NULL){\r\n        return list_b;\r\n    }\r\n    if (list_b==NULL){\r\n        return list_a;\r\n    } \r\n\r\n    // compare list_a and list_b\r\n    if (list_a->info->grade <= list_b->info->grade) {\r\n        list_a->next_node = merge(list_a->next_node, list_b);\r\n        list_a->next_node->prev_node = list_a;\r\n        list_a->prev_node = NULL;\r\n        return list_a;\r\n    } else {\r\n        list_b->next_node = merge(list_a, list_b->next_node);\r\n        list_b->next_node->prev_node = list_b;\r\n        list_b->prev_node = NULL;\r\n        return list_b;\r\n    }\r\n}\r\n\r\n// main function to perform merge sort recursively\r\nNode *merge_sort(Node *head){\r\n    if(head==NULL || head->next_node==NULL){ // base case\r\n        return head;\r\n    }\r\n\r\n    Node *middle=split(head);\r\n    Node *list_a=merge_sort(head); // call merge_sort recursively\r\n    Node *list_b=merge_sort(middle);\r\n\r\n    return merge(list_a, list_b); // merge together once the list has been split into one node per division\r\n}\r\n\r\n// sort the student records by grade in ascending order using merge sort\r\n/* merge sort is used because it runs in O(n log n) time in all cases\r\nhence it is suitable for large data structures or LINKED LISTS*/\r\nvoid sort_students(List *list){\r\n    Node *curr_node=list->head;\r\n    if(curr_node==NULL){\r\n        puts(\"Error: List is empty.\");\r\n        return;\r\n    }\r\n    if(curr_node->next_node==NULL){\r\n        return;\r\n    }\r\n    // sort list\r\n    list->head=merge_sort(list->head);\r\n\r\n    // update tail after sorting\r\n    Node* temp=list->head;\r\n    while(temp->next_node != NULL){\r\n        temp=temp->next_node;\r\n    }\r\n    list->tail=temp;\r\n\r\n    puts(\"Records successfully sorted by grades in ascending order using merge sort\");\r\n    return;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-In the remove_item function, after shifting items to fill the gap left by the removed item, the name and category pointers for the last item are set to NULL. This does not free the allocated memory properly, which can lead to memory leaks.\nq3-The Merge Sort algorithm is correctly implemented and is efficient with a time complexity of O(n log n). This is suitable for linked lists and larger datasets, making it a good choice for sorting student records."
  },
  {
    "student_id": "20591632",
    "code": "\n/* --- Q1.c --- */\n// Q1\r\n#include <stdio.h>\r\n\r\n#define MAX_DIM 10  // Since maximum of both columns and rows are 10 \r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_DIM][MAX_DIM], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX_DIM][MAX_DIM], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_DIM][MAX_DIM], int matrixB[MAX_DIM][MAX_DIM],\r\n                 int result[MAX_DIM][MAX_DIM], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_DIM][MAX_DIM], int matrixB[MAX_DIM][MAX_DIM],\r\n                      int result[MAX_DIM][MAX_DIM], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_DIM][MAX_DIM], int transposed[MAX_DIM][MAX_DIM],\r\n                     int rows, int cols);\r\n\r\nint main(void){\r\n    // Declare matrices and variables for dimensions and menu choice \r\n    int matrixA[MAX_DIM][MAX_DIM], matrixB[MAX_DIM][MAX_DIM];\r\n    int result[MAX_DIM][MAX_DIM];\r\n    int transposed[MAX_DIM][MAX_DIM];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Prompt user to input and program validates for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    if (scanf(\"%d %d\", &rowsA, &colsA) != 2 || rowsA <= 0 || colsA <= 0 || rowsA > MAX_DIM || colsA > MAX_DIM) {\r\n        printf(\"Error: Invalid dimensions for Matrix A. Must be between 1 and %d for both rows and columns.\\n\", MAX_DIM);\r\n        return 1; // Exit the program if user enter invalid input \r\n    }\r\n    printf(\"Enter elements for Matrix A: \\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    // Prompt user to input and program validates for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    if (scanf(\"%d %d\", &rowsB, &colsB) != 2 || rowsB <= 0 || colsB <= 0 || rowsB > MAX_DIM || colsB > MAX_DIM) {\r\n        printf(\"Error: Invalid dimensions for Matrix B. Must be between 1 and %d for both rows and columns.\\n\", MAX_DIM);\r\n        return 1; // Exit the program if user enter invalid input \r\n    }\r\n    printf(\"Enter elements for Matrix B: \\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    // Display the menu and loop back the menu until the user chooses to exit\r\n    while(1){\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        // Input choice and validate\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Error: Invalid input. Please enter a number.\\n\");\r\n            while(getchar() != '\\n'); // Clear invalid input\r\n            continue;\r\n        }\r\n\r\n        // Perform operation based on user's choice using switch \r\n        switch(choice){\r\n            case 1:\r\n                // Check if dimensions entered are compatible for addition\r\n                if (rowsA != rowsB && colsA != colsB){\r\n                    printf(\"Error: Dimensions of matrix must be same for addition\");\r\n                }\r\n                else{\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                // Check if dimensions entered are compatible for subtraction \r\n                if (rowsA != rowsB && colsA != colsB){\r\n                    printf(\"Error: Dimensions of matrix must be same for addition\");\r\n                }\r\n                else{\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                }\r\n                break;\r\n\r\n            case 3: \r\n                // Transpose Matrix A\r\n                transposeMatrix(matrixA, transposed, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(transposed, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                // Transpose Matrix B \r\n                transposeMatrix(matrixB, transposed, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(transposed, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;  // Exit the program\r\n\r\n            default: \r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to let user input matrix elements \r\nvoid inputMatrix(int matrix[MAX_DIM][MAX_DIM], int rows, int cols){\r\n    for (int i = 0; i < rows; i++){\r\n        for (int j = 0; j < cols; j++){\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print matrix elements \r\nvoid printMatrix(int matrix[MAX_DIM][MAX_DIM], int rows, int cols){\r\n    for (int i = 0; i < rows; i++){\r\n        for (int j = 0; j < cols; j++){\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to perform addition of two matrices \r\nvoid addMatrices(int matrixA[MAX_DIM][MAX_DIM], int matrixB[MAX_DIM][MAX_DIM],\r\n    int result[MAX_DIM][MAX_DIM], int rows, int cols){\r\n    for (int i = 0; i < rows; i++){\r\n        for (int j = 0; j < cols; j++){\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to perform subtraction of two matrices \r\nvoid subtractMatrices(int matrixA[MAX_DIM][MAX_DIM], int matrixB[MAX_DIM][MAX_DIM],\r\n    int result[MAX_DIM][MAX_DIM], int rows, int cols){\r\n    for (int i = 0; i < rows; i++){\r\n        for (int j = 0; j < cols; j++){\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose matrix \r\nvoid transposeMatrix(int matrix[MAX_DIM][MAX_DIM], int transposed[MAX_DIM][MAX_DIM],\r\n    int rows, int cols){\r\n    for (int i = 0; i < rows; i++){\r\n        for (int j = 0; j < cols; j++){\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n// Structure to define grocery item\r\nstruct groceryItem {\r\n    char name[100];  // Name of the item \r\n    char category[50];  // Category of the item\r\n    int quantity;  // Quantity of the item \r\n    float price;  // Price of the item \r\n};\r\n\r\n// Structure to track availability status of an item \r\nstruct availabilityStatus {\r\n    int inStock;  // 1 for in stock, 0 for out of stock (boolean)\r\n};\r\n\r\n// Structure to manage grocery inventory \r\nstruct groceryInventory {\r\n    struct groceryItem items[100];  // Array of grocery items \r\n    struct availabilityStatus status[100];  // Corresponding availability status \r\n    int count;  // Number of items in the inventory \r\n};\r\n\r\n// Function prototypes\r\nstruct groceryInventory addGroceryItem(struct groceryInventory inventory);\r\nvoid listGroceryItems(struct groceryInventory inventory);\r\nstruct groceryInventory updateQuantity(struct groceryInventory inventory);\r\nstruct groceryInventory removeGroceryItem(struct groceryInventory inventory);\r\n\r\nint main(void) {\r\n    struct groceryInventory inventory;\r\n    inventory.count = 0; // Initialize inventory\r\n    int choice;\r\n\r\n    while (1) {\r\n        // Display menu \r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        // Check if user enter valid input \r\n        if (scanf(\"%d\", &choice) == 1) {\r\n            switch (choice) {\r\n                case 1:\r\n                    inventory = addGroceryItem(inventory);\r\n                    break;\r\n                case 2:\r\n                    listGroceryItems(inventory);\r\n                    break;\r\n                case 3:\r\n                    inventory = updateQuantity(inventory);\r\n                    break;\r\n                case 4:\r\n                    inventory = removeGroceryItem(inventory);\r\n                    break;\r\n                case 5:\r\n                    printf(\"Exiting Program...\\n\");\r\n                    return 0;\r\n                default:\r\n                    printf(\"Please enter a valid choice.\\n\");\r\n                    continue;\r\n            }\r\n        } else {\r\n            printf(\"Error: Please enter a valid choice.\\n\");\r\n            while (getchar() != '\\n'); // Clear invalid input\r\n            continue;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to add grocery item \r\nstruct groceryInventory addGroceryItem(struct groceryInventory inventory) {\r\n    if (inventory.count >= 100) {  // Check if inventory is full \r\n        printf(\"Inventory is full!\\n\");\r\n        return inventory;\r\n    }\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %99[^\\n]\", inventory.items[inventory.count].name); // Read item name until newline\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %49[^\\n]\", inventory.items[inventory.count].category); // Read category until newline\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &inventory.items[inventory.count].quantity);  // Read quantity\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &inventory.items[inventory.count].price);  // Read price \r\n\r\n    if (inventory.items[inventory.count].quantity > 0){\r\n        inventory.status[inventory.count].inStock = 1;  // In stock\r\n    }\r\n    else{\r\n        inventory.status[inventory.count].inStock = 0;  // Out of stock \r\n    }\r\n\r\n    inventory.count++;  // increment item count \r\n    printf(\"Grocery item added successfully!\\n\");\r\n\r\n    return inventory;\r\n}\r\n\r\n// Function to list all grocery items in inventory \r\nvoid listGroceryItems(struct groceryInventory inventory) {\r\n    if (inventory.count == 0) {  // If inventory is empty\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n    } else {\r\n        // List all the items in inventory \r\n        for (int i = 0; i < inventory.count; i++) {\r\n            printf(\"\\nName: %s\\n\", inventory.items[i].name);\r\n            printf(\"Category: %s\\n\", inventory.items[i].category);\r\n            printf(\"Quantity: %d\\n\", inventory.items[i].quantity);\r\n            printf(\"Price: %.2f\\n\", inventory.items[i].price);\r\n            if (inventory.status[i].inStock == 1){\r\n                printf(\"Status: In Stock\\n\");\r\n            }\r\n            else{\r\n                printf(\"Status: Out of Stock\\n\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update quantity of grocery item \r\nstruct groceryInventory updateQuantity(struct groceryInventory inventory) {\r\n    char name[100];  // Item name to search for\r\n    int newQuantity;  // New quantity to set\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    scanf(\" %99[^\\n]\", name);\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, name) == 0) {  // Compare and match item name \r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);  // Update new quantity \r\n\r\n            // Update availability status \r\n            inventory.items[i].quantity = newQuantity;\r\n            if (newQuantity > 0){\r\n                inventory.status[i].inStock = 1;\r\n            }\r\n            else{\r\n                inventory.status[i].inStock = 0;\r\n            }\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return inventory;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");  // If item not searched \r\n    return inventory;\r\n}\r\n\r\n// Function to remove grocery item \r\nstruct groceryInventory removeGroceryItem(struct groceryInventory inventory) {\r\n    char name[100];\r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\" %99[^\\n]\", name);\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, name) == 0) {  // Compare and match item name\r\n            // Shift item to delete item selected \r\n            for (int j = i; j < inventory.count - 1; j++) {\r\n                inventory.items[j] = inventory.items[j + 1];\r\n                inventory.status[j] = inventory.status[j + 1];\r\n            }\r\n            inventory.count--;  // Decrement item count \r\n            printf(\"Grocery item '%s' removed successfully!\\n\", inventory.items);\r\n            return inventory;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");  // If item not searched \r\n    return inventory;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Global pointer to the head of the list\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate new memory for new student \r\n    Student* newStudent = (Student*)malloc(sizeof(Student));  \r\n    if (newStudent == NULL) {  // Check for allocation failure \r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name));  // Copy name\r\n    newStudent->id = id;  // Set ID\r\n    newStudent->grade = grade;  // Set a grade\r\n    newStudent->next = NULL;  // Initialize next pointer to NULL\r\n    return newStudent;  // Return the new student node \r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);  // Create a new student\r\n    if (newStudent == NULL) return;  // Return early if creation fails\r\n\r\n    newStudent->next = head;  // Point new student's next to head\r\n    head = newStudent;  // Update head to new student \r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;  // Start from head of list \r\n    if (current == NULL) {  // If list is empty \r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current != NULL) {\r\n        // Print details for each student \r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;  // Move to next student after printing \r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;  // Start from head of list \r\n    while (current != NULL) {\r\n        // If current student's ID matches\r\n        if (current->id == id) {\r\n            return current;  // Return current student \r\n        }\r\n        current = current->next;  // Move to next student \r\n    }\r\n    return NULL;  // Return NULL if not found \r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;  // Start from head of list \r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;  // Store next node\r\n        free(current);  // Free current node\r\n        current = next;  // Then move to the next node \r\n    }\r\n    head = NULL;  // Set head to NULL when list is empty \r\n    printf(\"List deleted successfully.\\n\");\r\n}\r\n\r\n// Free memory function\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    // If there is zero or only one student \r\n    if (head == NULL || head->next == NULL) {  \r\n        printf(\"No need to sort; not enough records.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* ptr2 = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != ptr2) {\r\n            if (ptr1->grade > ptr1->next->grade) {  // Compare grades\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strncpy(tempName, ptr1->name, sizeof(tempName));\r\n                tempID = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strncpy(ptr1->name, ptr1->next->name, sizeof(ptr1->name));\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strncpy(ptr1->next->name, tempName, sizeof(ptr1->next->name));\r\n                ptr1->next->id = tempID;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;  // Mark if swap occured \r\n            }\r\n            ptr1 = ptr1->next;  // Move to the next pair \r\n        }\r\n        ptr2 = ptr1;  // Update last pointer \r\n    } while (swapped);  // Repeat until no swaps left \r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n\r\nint main(void) {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            continue;\r\n        }\r\n\r\n        getchar();  // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove trailing newline\r\n                printf(\"Enter ID: \");\r\n                if (scanf(\"%d\", &id) != 1) {\r\n                    printf(\"Invalid input for ID.\\n\");\r\n                    while (getchar() != '\\n'); // Clear input buffer\r\n                    continue;\r\n                }\r\n                printf(\"Enter Grade: \");\r\n                if (scanf(\"%f\", &grade) != 1) {\r\n                    printf(\"Invalid input for grade. Please enter a number.\\n\");\r\n                    while (getchar() != '\\n'); // Clear input buffer\r\n                    continue;\r\n                }\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                if (scanf(\"%d\", &id) != 1) {\r\n                    printf(\"Invalid input for ID.\\n\");\r\n                    while (getchar() != '\\n'); // Clear input buffer\r\n                    continue;\r\n                }\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-In the removeGroceryItem function, the success message incorrectly attempts to print inventory.items instead of the specific item name. It should be name instead.\nq3-The sortStudents function implements Bubble Sort to arrange student records by grade. While Bubble Sort is straightforward and easy to understand, it has a time complexity of O(n?), which may become inefficient with larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20713727",
    "code": "\n/* --- lab-assignment-3/Q1/main.c --- */\n#include <stdio.h>\n#define MAX 10\n\n// Function prototypes\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols, char name);\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols);\nvoid addMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid subtractMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\n\nint main() {\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions for Matrix A\n    do {\n        printf(\"Enter dimensions for Matrix A (rows and columns, max 10): \");\n        scanf(\"%d %d\", &rowsA, &colsA);\n    } while (rowsA <= 0 || rowsA > MAX || colsA <= 0 || colsA > MAX);\n\n    // Input elements for Matrix A\n    inputMatrix(matrixA, rowsA, colsA, 'A');\n\n    // Input dimensions for Matrix B\n    do {\n        printf(\"Enter dimensions for Matrix B (rows and columns, max 10): \");\n        scanf(\"%d %d\", &rowsB, &colsB);\n    } while (rowsB <= 0 || rowsB > MAX || colsB <= 0 || colsB > MAX);\n\n    // Input elements for Matrix B\n    inputMatrix(matrixB, rowsB, colsB, 'B');\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    printMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\n                }\n                break;\n\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    printMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\n                }\n                break;\n\n            case 3:\n                transposeMatrix(matrixA, result, rowsA, colsA);\n                printf(\"Transpose of Matrix A:\\n\");\n                printMatrix(result, colsA, rowsA);\n                break;\n\n            case 4:\n                transposeMatrix(matrixB, result, rowsB, colsB);\n                printf(\"Transpose of Matrix B:\\n\");\n                printMatrix(result, colsB, rowsB);\n                break;\n\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n\n    } while (choice != 5);\n\n    return 0;\n}\n\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols, char name) {\n    printf(\"Enter elements for Matrix %c:\\n\", name);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n/* --- lab-assignment-3/Q2/main.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Struct for Grocery Item\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    int inStock; // 1 for In Stock, 0 for Out of Stock\r\n} GroceryItem;\r\n\r\n// Inventory Struct\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int totalItems;\r\n} GroceryInventory;\r\n\r\n// Function Prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .totalItems = 0 };\r\n    int choice;\r\n\r\n    while (1) {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                exit(0);\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->totalItems >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->totalItems];\r\n    printf(\"Enter Item Name: \");\r\n    getchar(); // Clear newline character from buffer\r\n    fgets(item->name, MAX_NAME_LENGTH, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline character\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, MAX_CATEGORY_LENGTH, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    item->inStock = (item->quantity > 0) ? 1 : 0;\r\n    inventory->totalItems++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        printf(\"\\nName: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", item->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar(); // Clear newline character from buffer\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity for %s: \", inventory->items[i].name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            inventory->items[i].inStock = (inventory->items[i].quantity > 0) ? 1 : 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found.\\n\", itemName);\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    getchar(); // Clear newline character from buffer\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            for (int j = i; j < inventory->totalItems - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->totalItems--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found.\\n\", itemName);\r\n}\n/* --- lab-assignment-3/Q3/main.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) return current;\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade (using Bubble Sort for simplicity)\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"No sufficient records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* current;\r\n    Student* prev = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != prev) {\r\n            if (current->grade > current->next->grade) {\r\n                // Swap the nodes\r\n                float tempGrade = current->grade;\r\n                current->grade = current->next->grade;\r\n                current->next->grade = tempGrade;\r\n\r\n                int tempId = current->id;\r\n                current->id = current->next->id;\r\n                current->next->id = tempId;\r\n\r\n                char tempName[100];\r\n                strcpy(tempName, current->name);\r\n                strcpy(current->name, current->next->name);\r\n                strcpy(current->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        prev = current;\r\n    } while (swapped);\r\n\r\n    printf(\"Student records sorted by grade in ascending order.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2- In the removeGroceryItem function, when shifting items after removal, the loop should run until inventory->totalItems - 1, but it currently runs until inventory->totalItems, which can lead to accessing out of bounds.\nq3-     The program uses bubble sort to sort student records by grade. While this method works correctly, it has a time complexity of O(n?), which can become inefficient for larger datasets. For improved performance, consider implementing a more efficient sorting algorithm like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20723718",
    "code": "\n/* --- 20723718_Cheng Hsiu Fung/Q1.c --- */\n#include <stdio.h>\n\n// Function prototypes\nvoid sumMatrices(size_t Row, size_t Col, int matrixA[Row][Col], int matrixB[Row][Col], int matrixSum[Row][Col]);\nvoid subMatrices(size_t Row, size_t Col, int matrixA[Row][Col], int matrixB[Row][Col], int matrixDiff[Row][Col]);\nvoid transpose(size_t Row, size_t Col, int transpose[Col][Row], int matrix[Row][Col]);\nvoid printM(size_t Row, size_t Col, int matrix[Row][Col]);\n\n// Function main\nint main() {\n    // Define and initialise dimensions\n    size_t sizeARow = 0, sizeACol = 0, sizeBRow = 0, sizeBCol = 0;\n\n    // Obtain matrix A\n    printf(\"Enter dimensions for matrix A (rows and columns): \");\n    scanf(\"%zu %zu\", &sizeARow, &sizeACol);\n    int matrixA[sizeARow][sizeACol];\n\n    puts(\"Enter the elements for matrix A:\");\n    for (size_t i = 0; i < sizeARow; i++) {\n        for (size_t j = 0; j < sizeACol; j++) {\n            printf(\"Element [%zu][%zu]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrixA[i][j]);\n        }\n    }\n\n    // Obtain matrix B\n    printf(\"Enter dimensions for matrix B (rows and columns): \");\n    scanf(\"%zu %zu\", &sizeBRow, &sizeBCol);\n    int matrixB[sizeBRow][sizeBCol];\n\n    puts(\"Enter the elements for matrix B:\");\n    for (size_t i = 0; i < sizeBRow; i++) {\n        for (size_t j = 0; j < sizeBCol; j++) {\n            printf(\"Element [%zu][%zu]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrixB[i][j]);\n        }\n    }\n\n    // Define and initialise more variables\n    int choice = 0;\n    int matrixAT[sizeACol][sizeARow];\n    int matrixBT[sizeBCol][sizeBRow]; // Transposed matrices have inverted rows and columns and are defined accordingly\n    int run = 1;\n    int AorB = 0;\n\n    // Run while 'run' is true\n    while (run == 1) {\n        // Display menu\n        printf(\"\\nMatrix operations menu:\\n1. Print matrix\\n2. Add matrices\\n\");\n        printf(\"3. Subtract matrices\\n4. Transpose matrix\\n\");\n        printf(\"5. Exit\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n\n        // Use switch case\n        switch(choice) {\n            case 1:\n                // Print matrix\n                printf(\"\\nWhich matrix do you want to print?\\n1. Matrix A\\n2. Matrix B\\nEnter your choice: \");\n                scanf(\"%d\", &AorB);\n                switch(AorB) {\n                    case 1:\n                        printM(sizeARow, sizeACol, matrixA);\n                        break;\n                    case 2:\n                        printM(sizeBRow, sizeBCol, matrixB);\n                        break;\n                    default:\n                        puts(\"Invalid option\");\n                        break;\n                }\n                break;\n            case 2:\n                // Ensure matrices are equal in dimensions\n                if ((sizeARow != sizeBRow) || (sizeACol != sizeBCol)) {\n                    printf(\"\\nError: Please ensure the dimensions of both matrices are equal.\\n\");\n                } else { // Sum matrices\n                    int matrixSum[sizeARow][sizeACol]; // Summed matrix can be defined using only matrix A's dimensions as A's and B's dimensions are equal\n                    sumMatrices(sizeARow, sizeACol, matrixA, matrixB, matrixSum);\n                    puts(\"The sum of matrix A and matrix B is\");\n                    printM(sizeARow, sizeACol, matrixSum);\n                }\n                break;\n            case 3:\n                // Ensure matrices are equal in dimensions\n                if ((sizeARow != sizeBRow) || (sizeACol != sizeBCol)) {\n                    printf(\"\\nError: Please ensure the dimensions of both matrices are equal.\\n\");\n                } else { // Subtract matrix B from A\n                    int matrixDiff[sizeARow][sizeACol]; \n                    subMatrices(sizeARow, sizeACol, matrixA, matrixB, matrixDiff);\n                    puts(\"The subtraction of matrix B from matrix A is\");\n                    printM(sizeARow, sizeACol, matrixDiff);\n                }\n                break;\n            case 4:\n                printf(\"\\nWhich matrix do you want to transpose?\\n1. Matrix A\\n2. Matrix B\\nEnter your choice: \");\n                scanf(\"%d\", &AorB);\n                // Nested switch case\n                switch(AorB) {\n                    case 1:\n                        transpose(sizeARow, sizeACol, matrixAT, matrixA);\n                        puts(\"The transpose of matrix A\");\n                        printM(sizeACol, sizeARow, matrixAT);\n                        break;\n                    case 2:\n                        transpose(sizeBRow, sizeBCol, matrixBT, matrixB);\n                        puts(\"The transpose of matrix B\");\n                        printM(sizeBCol, sizeBRow, matrixBT);                        \n                        break;\n                    default:\n                        puts(\"\\nInvalid option\");\n                        break;\n                }\n                break;\n            case 5:\n                run = 0;\n                puts(\"\\nExiting...\");\n                break;\n            default:\n                puts(\"\\nInvalid option\");\n                break;\n        }\n        continue;\n    }\n}\n\n// Function to sum matrices\nvoid sumMatrices(size_t Row, size_t Col, int matrixA[Row][Col], int matrixB[Row][Col], int matrixSum[Row][Col]) {\n    for (int i = 0; i < Row; i++) {\n        for (int j = 0; j < Col; j++) {\n            matrixSum[i][j] = matrixA[i][j] + matrixB[i][j];\n        }\n    }\n}\n\n// Function to subtract second matrix from first matrix\nvoid subMatrices(size_t Row, size_t Col, int matrixA[Row][Col], int matrixB[Row][Col], int matrixDiff[Row][Col]) {\n    for (int i = 0; i < Row; i++) {\n        for (int j = 0; j < Col; j++) {\n            matrixDiff[i][j] = matrixA[i][j] - matrixB[i][j];\n        }\n    }\n}\n\n// Function to transpose matrix\nvoid transpose(size_t Row, size_t Col, int transpose[Col][Row], int matrix[Row][Col]) {\n    for (size_t i = 0; i < Row; i++) {\n        for (size_t j = 0; j < Col; j++) {\n            transpose[j][i] = matrix[i][j];\n        }\n    }\n}\n\n// Function to print matrix\nvoid printM(size_t Row, size_t Col, int matrix[Row][Col]) {\n    puts(\"\");\n    for (size_t i = 0; i < Row; i++) {\n        for (size_t j = 0; j < Col; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        puts(\"\");\n    }\n}\n/* --- 20723718_Cheng Hsiu Fung/Q2.c --- */\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME 100\n#define MAX_CATE 50\n#define MAX_ITEM 100\n\n// struct for item\nstruct Item {\n    char name[MAX_NAME];\n    char cate[MAX_CATE];\n    int quant;\n    float price;\n    bool inStock;\n};\n\n// Nested struct for item\nstruct Inven {\n    struct Item items[MAX_ITEM];\n    int totalNum;\n};\n\n// Function prototypes\nvoid Trim(char *str);\nsize_t isPos(char *message);\n\n// Main function\nint main() {\n    // Define and initialise variables & strings\n    struct Inven Stock;\n    Stock.totalNum = 0;\n    char choiceC[10];\n    int choice;\n    char tempName[MAX_NAME];\n    char updtName[MAX_NAME];\n    char deleName[MAX_NAME];\n    int run = 1;\n\n    // Display menu\n    printf(\"\\nGrocery inventory management system\");\n    while (run != 0) {\n        puts(\"\\n1. Add grocery item\\n2. List all grocery items\\n3. Update quantity\\n4. Remove item\\n5. Exit\");\n        printf(\"Enter your choice: \");\n        if (fgets(choiceC, sizeof(choiceC), stdin) != NULL) {\n            Trim(choiceC);\n            choice = atoi(choiceC);\n        }\n        \n        // Use switch case\n        switch (choice) {\n            case 1:\n                if (Stock.totalNum >= MAX_ITEM) { // If inventory is full, end\n                    puts(\"\\nInventory is full.\");\n                    break;\n                }\n\n                // Obtain item name\n                printf(\"Enter item name: \");\n                if (fgets(tempName, MAX_ITEM, stdin) != NULL) {\n                    Trim(tempName);\n                    int checkDupe2 = 0;\n                    for (int i = 0; i < Stock.totalNum; i++) {\n                        // Reject if item already exists\n                        if (strcasecmp(Stock.items[i].name, tempName) == 0) {\n                            printf(\"This product already exists. Please update it.\\n\");\n                            checkDupe2 = 1;\n                            break;\n                        }\n                    }\n                    if (checkDupe2) {\n                        break;\n                    }\n\n                    // If item did not exist, move from temporary variable to struct\n                    struct Item *newItem = &Stock.items[Stock.totalNum];\n                    strcpy(newItem->name, tempName);\n                    \n                    // Obtain category\n                    printf(\"Enter category: \");\n                    if (fgets(newItem->cate, MAX_CATE, stdin) != NULL) {\n                        Trim(newItem->cate);\n                    }\n                    \n                    // Obtain quantity, ensuring it is 0 or more\n                    char buffer[10];\n                    int pos = 1;\n                    while (pos != 0) {\n                        printf(\"Enter quantity: \");\n                        if (fgets(buffer, sizeof(buffer), stdin) != NULL) {\n                            Trim(buffer);\n                            size_t posCheck = isPos(buffer);\n                            if (posCheck == 0) {\n                                newItem->quant = atoi(buffer);\n                                pos = 0;\n                                break;\n                            } else {\n                                puts(\"Please enter zero or positive values.\");\n                                continue;\n                            }\n                        }\n                    }\n\n                    // Obtain price, ensuring it is 0 or more\n                    pos = 1;                    \n                    while (pos != 0) {\n                        printf(\"Enter price: \");\n                        if (fgets(buffer, sizeof(buffer), stdin) != NULL) {\n                            Trim(buffer);\n                            size_t posCheck = isPos(buffer);\n                            if (posCheck == 0) {\n                                newItem->price = atof(buffer);\n                                pos = 0;\n                                break;\n                            } else {\n                                puts(\"Please enter zero or positive values.\");\n                                continue;\n                            }\n                        }\n                    }\n\n                    puts(\"Item added successfully!\");\n                    Stock.totalNum++; // Increment number of items in inventory\n                }\n                break;\n            case 2:\n                // Check if inventory is empty\n                if (Stock.totalNum == 0) {\n                    puts(\"\\nInventory is empty.\");\n                } else {\n                    char *inStock = \"In stock\";\n                    char *noStock = \"Out of stock\";\n                    char status[strlen(noStock)];\n                    puts(\"\\nInventory:\");\n                    for (int i = 0; i < Stock.totalNum; i++) {\n                        // Check if items are in stock\n                        if (Stock.items[i].quant == 0) {\n                            Stock.items[i].inStock = false;\n                        } else {\n                            Stock.items[i].inStock = true;\n                        }\n                        if (Stock.items[i].inStock == true) {\n                            strcpy(status, inStock);\n                        } else {\n                            strcpy(status, noStock);\n                        }\n                        printf(\"Item %d\\nName: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: %s\\n\", i + 1, Stock.items[i].name, Stock.items[i].cate, Stock.items[i].quant, Stock.items[i].price, status);\n                    }\n                }\n                break;\n            case 3:\n                // Search for item\n                printf(\"Enter name of item of which quantity to update: \");\n                if (fgets(updtName, MAX_NAME, stdin) != NULL) {\n                    Trim(updtName);\n                }\n                int found = 0;\n                for (int i = 0; i < Stock.totalNum; i++) {\n                    // Compare names insensitive to case\n                    if (strcasecmp(Stock.items[i].name, updtName) == 0) {\n                        found = 1;\n                        char buffer[10];\n                        int pos = 1;                    \n                        while (pos != 0) {\n                            printf(\"Enter new quantity: \");\n                            if (fgets(buffer, sizeof(buffer), stdin) != NULL) {\n                                Trim(buffer);\n                                size_t posCheck = isPos(buffer);\n                                if (posCheck == 0) {\n                                    Stock.items[i].quant = atoi(buffer);\n                                    pos = 0;\n                                    break;\n                                } else {\n                                    puts(\"Please enter zero or positive values.\");\n                                    continue;\n                                }\n                            }\n                        }\n                        puts(\"\\nStock updated.\");\n                        break;\n                    } \n                }\n                if (!found) {\n                    puts(\"Item not found.\");\n                }\n                break;\n            case 4:\n                // Delete item\n                printf(\"Enter name of item to delete: \");\n                if (fgets(deleName, MAX_NAME, stdin) != NULL) {\n                    Trim(deleName);\n                }\n                found = 0;\n                for (int i = 0; i < Stock.totalNum; i++) {\n                    if (strcasecmp(Stock.items[i].name, deleName) == 0) {\n                        found = 1;\n                        // Shift inventory to the left from j + 1 to j\n                        for (int j = i; j < Stock.totalNum - 1; j++) {\n                            Stock.items[j] = Stock.items[j + 1];\n                        }\n                        Stock.totalNum--; // Decrement stock number\n                        puts(\"Item deleted successfully.\");\n                        break;\n                    } \n                }\n                if (!found) {\n                    puts(\"Item not found.\");\n                }\n                break;\n            case 5:\n                puts(\"\\nExiting...\");\n                run = 0;\n                break;\n            default:\n                puts(\"\\nInvalid option.\");\n                break;\n        }\n        continue;\n    }\n}\n\n// Trim function to remove newline character\nvoid Trim(char *str) {\n    size_t length = strlen(str);\n    if (length > 0 && str[length - 1] == '\\n') {\n        str[length - 1] = '\\0';\n    }\n}\n\n// Function to ensure input is only positive number\nsize_t isPos(char *message) {\n    while (*message != '\\0') {\n        if ((*message < '0' || *message > '9') && *message != '.') {\n            return 1;\n            break;\n        }\n        message++;\n    }\n    return 0;\n}\n/* --- 20723718_Cheng Hsiu Fung/Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    // Allocate memory space for new student structure\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    // Copy/Assign strings/variables to their respective fields\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    // Add new studdent record to the front (LIFO)\n    Student* addStudent = createStudent(name, id, grade);\n    addStudent->next = head;\n    head = addStudent;\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    // Assign head struct to student\n    Student* student = head;\n    // Print student records while pointer is not 'NULL'\n    while (student != NULL) {\n        printf(\"Name: %s\\nID: %d\\nGrade: %.2f\\n\", student->name, student->id, student->grade);\n        student = student->next;\n    }\n}\n\n// Sort function to sort the student record by grade based on algorithm of choice\nvoid sortStudents() {\n    // Count how many students are in the list by incrementing a variable 'count'\n    int count = 0;\n    Student* studentCount = head;\n    while (studentCount != NULL) {\n        count++;\n        studentCount = studentCount->next;\n    }\n\n    // Use a bubble sort as algorithm for its simplicity\n    for (int pass = 1; pass < count; pass++) {\n        int swapped = 0;\n        // Define and initialise current and previous student\n        Student* currentStudent = head;\n        Student* previousStudent = NULL;\n\n        // Loop\n        for (int i = 0; i < count - pass; i++) {\n            // Create a pointer to the next student\n            Student* temp = currentStudent->next;\n            // Compare adjacent names insensitive to case — temp->name is essentially (currentStudent->next)'s name\n            // If the first student and second student's names are not in ordder\n            if (strcasecmp(currentStudent->name, temp->name) > 0) {\n                // If a swap is made, update the head pointer to point to the temporary pointer (assign temp to head)\n                if (previousStudent == NULL) {\n                    head = temp;\n                } else { // Otherwise, update the previous's next pointer to the temporary pointer\n                    previousStudent->next = temp;\n                }\n\n                // Either way, reassign the pointers\n                currentStudent->next = temp->next;  // Skip the temp node\n                temp->next = currentStudent;        // 'Move' temp in front of currentStudent\n                swapped = 1;\n            } else {\n                // Increment pointers. The 'front' student's pointer is assigned to the back, next immediate pointer is now the front. \n                previousStudent = currentStudent;\n                currentStudent = temp;\n            }\n            if (swapped) {\n                // If a swap has occured, the 'back' student's pointer is the next immediate pointer\n                previousStudent = temp;\n            }\n        }\n\n        // List is sorted if no swaps are made\n        if (!swapped) {\n            break;\n        }\n    }\n    displayStudents();\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* foundStud = head;\n    while (foundStud != NULL) {\n        // Return student struct if ID is equal\n        if (foundStud->id == id) {\n            return foundStud;\n        }\n        // Increment struct pointer\n        foundStud = foundStud->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n\n// Main function\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert student record\\n2. Display student records\\n3. Sort records\\n\");\n        printf(\"4. Search by ID\\n5. Delete list\\n6. Exit\\nEnter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    }\n    while (choice != 6);\n\n    return 0;\n}\n/* --- 20723718_Cheng Hsiu Fung/__MACOSX/._Q1.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0000q\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0015com.apple.provenance\u0000\u0001\u0000\u0000\u0014:8\u0001\u0015wx\n/* --- 20723718_Cheng Hsiu Fung/__MACOSX/._Q2.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0000q\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0015com.apple.provenance\u0000\u0001\u0000\u0000\u0014:8\u0001\u0015wx\n/* --- 20723718_Cheng Hsiu Fung/__MACOSX/._Q3.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0000q\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u000b\u0000\u0000\u0015com.apple.provenance\u0000\u0001\u0000\u0000\u0014:8\u0001\u0015wx",
    "feedback": "q1-Meet requirement\nq2-The isPos function checks if a string represents a positive number but does not handle negative numbers correctly. It incorrectly allows decimal points in quantity, which should be integers. The status of each item is determined during listing but is not stored persistently. The inStock boolean is set based on quantity during listing instead of during item addition or quantity updates, which could lead to discrepancies in status reporting.\nq3-    The bubble sort implementation is correct and sorts the students by name. However, its time complexity of O(n?) makes it inefficient for larger datasets. For better performance, consider using a more efficient sorting algorithm, such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20712881",
    "code": "\n/* --- Q1.C --- */\n#include <stdio.h>\n\n#define SIZE 10 // Maximum size of matrices\n\n// Function to add two matrices\nvoid addMatrices(int rows, int cols, int A[SIZE][SIZE], int B[SIZE][SIZE], int result[SIZE][SIZE]) {\n    // Loop through each element of the matrices and add corresponding elements\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int rows, int cols, int A[SIZE][SIZE], int B[SIZE][SIZE], int result[SIZE][SIZE]) {\n    // Loop through each element of the matrices and subtract corresponding elements\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\n// Function to transpose a matrix (rows become columns and vice versa)\nvoid transposeMatrix(int rows, int cols, int matrix[SIZE][SIZE], int result[SIZE][SIZE]) {\n    // Switch the row and column indices to transpose the matrix\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j]; // Transposing by swapping indices\n        }\n    }\n}\n\n// Main function where program execution starts\nint main() {\n    int rows, cols; // Matrix dimensions\n    int A[SIZE][SIZE], B[SIZE][SIZE], result[SIZE][SIZE]; // Matrices for operations\n    int choice; // Variable to store user's menu choice\n\n    // Prompt user to enter matrix dimensions\n    printf(\"Enter the number of rows and columns (max %d): \", SIZE);\n    scanf(\"%d %d\", &rows, &cols);\n\n    // Get matrix A elements from the user\n    printf(\"Enter elements of Matrix A:\\n\");\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n\n    // Get matrix B elements from the user\n    printf(\"Enter elements of Matrix B:\\n\");\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n\n    // Display the menu and handle user input in a loop\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                // Call function to add matrices A and B\n                addMatrices(rows, cols, A, B, result);\n                printf(\"Result of Addition:\\n\");\n                // Display the result of the addition\n                for (int i = 0; i < rows; i++) {\n                    for (int j = 0; j < cols; j++) {\n                        printf(\"%d \", result[i][j]);\n                    }\n                    printf(\"\\n\");\n                }\n                break;\n\n            case 2:\n                // Call function to subtract matrix B from A\n                subtractMatrices(rows, cols, A, B, result);\n                printf(\"Result of Subtraction:\\n\");\n                // Display the result of the subtraction\n                for (int i = 0; i < rows; i++) {\n                    for (int j = 0; j < cols; j++) {\n                        printf(\"%d \", result[i][j]);\n                    }\n                    printf(\"\\n\");\n                }\n                break;\n\n            case 3:\n                // Call function to transpose matrix A\n                transposeMatrix(rows, cols, A, result);\n                printf(\"Transpose of Matrix A:\\n\");\n                // Display the transposed matrix A\n                for (int i = 0; i < cols; i++) {\n                    for (int j = 0; j < rows; j++) {\n                        printf(\"%d \", result[i][j]);\n                    }\n                    printf(\"\\n\");\n                }\n                break;\n\n            case 4:\n                // Call function to transpose matrix B\n                transposeMatrix(rows, cols, B, result);\n                printf(\"Transpose of Matrix B:\\n\");\n                // Display the transposed matrix B\n                for (int i = 0; i < cols; i++) {\n                    for (int j = 0; j < rows; j++) {\n                        printf(\"%d \", result[i][j]);\n                    }\n                    printf(\"\\n\");\n                }\n                break;\n\n            case 5:\n                // Exit the program\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                // Handle invalid menu choices\n                printf(\"Invalid choice. Try again.\\n\");\n        }\n    } while (choice != 5); // Repeat the menu until the user chooses to exit\n\n    return 0; // End of program\n}\n\n/* --- Q2.C --- */\n#include <stdio.h>\n#include <string.h>  // For string manipulation functions like strcmp\n\n#define MAX_ITEMS 100 // Maximum number of items allowed in the inventory\n\n// Structure to represent each grocery item\ntypedef struct {\n    char name[100];          // Name of the item\n    char category[50];       // Category of the item (e.g., dairy, produce, etc.)\n    int quantity;            // Available stock quantity\n    float price;             // Price per unit of the item\n} GroceryItem;               // Structure that stores details about a single grocery item\n\n// Structure to represent the grocery inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS]; // Array to store all grocery items in the inventory\n    int count;                    // Keeps track of how many items are in the inventory\n} GroceryInventory;             // Structure to represent the inventory of all items\n\n// Function prototypes\nvoid addGroceryItem(GroceryInventory *inventory);  // Add a new grocery item\nvoid listGroceryItems(const GroceryInventory *inventory);  // List all grocery items\nvoid updateQuantity(GroceryInventory *inventory);  // Update the quantity of an existing item\nvoid removeGroceryItem(GroceryInventory *inventory);  // Remove an item from the inventory\n\nint main() {\n    GroceryInventory inventory = { .count = 0 }; // Initialize the inventory with zero items\n    int choice;  // Store user's menu selection\n\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Consume newline character left in input buffer\n\n        // Execute the appropriate function based on user's choice\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory);  // Add a new item to inventory\n                break;\n            case 2:\n                listGroceryItems(&inventory);  // Display all items in the inventory\n                break;\n            case 3:\n                updateQuantity(&inventory);  // Update the quantity of an existing item\n                break;\n            case 4:\n                removeGroceryItem(&inventory);  // Remove an item from the inventory\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);  // Continue looping until the user selects 'Exit'\n\n    return 0;\n}\n\n// Function to add a new grocery item to the inventory\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) {  // Check if inventory is full\n        printf(\"Inventory is full! Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem *item = &inventory->items[inventory->count];  // Get the next available slot\n\n    // Prompt user to enter details of the new item\n    printf(\"Enter item name: \");\n    scanf(\" %[^\\n]%*c\", item->name);\n    printf(\"Enter category: \");\n    scanf(\" %[^\\n]%*c\", item->category);\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &item->quantity);\n    printf(\"Enter price: \");\n    scanf(\"%f\", &item->price);\n\n    inventory->count++;  // Increment the count of items in inventory\n    printf(\"Item added successfully!\\n\");\n}\n\n// Function to list all grocery items in the inventory\nvoid listGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->count == 0) {  // If there are no items in inventory\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    // Loop through the inventory and print details of each item\n    printf(\"\\nGrocery Items:\\n\");\n    for (int i = 0; i < inventory->count; i++) {\n        const GroceryItem *item = &inventory->items[i];\n        printf(\"Item %d:\\n\", i + 1);\n        printf(\"  Name: %s\\n\", item->name);\n        printf(\"  Category: %s\\n\", item->category);\n        printf(\"  Quantity: %d\\n\", item->quantity);\n        printf(\"  Price: %.2f\\n\", item->price);\n        printf(\"  Availability: %s\\n\", item->quantity > 0 ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of an existing grocery item\nvoid updateQuantity(GroceryInventory *inventory) {\n    char name[100];\n    printf(\"Enter the name of the item to update quantity: \");\n    scanf(\" %[^\\n]%*c\", name);\n\n    // Search for the item in the inventory\n    for (int i = 0; i < inventory->count; i++) {\n        GroceryItem *item = &inventory->items[i];\n        if (strcmp(item->name, name) == 0) {  // Check if the item matches the name\n            printf(\"Enter new quantity: \");\n            scanf(\"%d\", &item->quantity);  // Update the quantity\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory.\\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    char name[100];\n    printf(\"Enter the name of the item to remove: \");\n    scanf(\" %[^\\n]%*c\", name);\n\n    // Search for the item and shift subsequent items to fill the gap\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {  // Check if the item matches the name\n            for (int j = i; j < inventory->count - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];  // Shift items left\n            }\n            inventory->count--;  // Decrease the item count\n            printf(\"Item removed successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory.\\n\");\n}\n\n/* --- Q3.C --- */\n#include <stdio.h>\n#include <stdlib.h>       // provides functions for dynamic memory management (malloc, free)\n#include <string.h>       // provides functions for string manipulation\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];     // string for name\n    int id;             // integer for id\n    float grade;        // floating-point for student grade\n    struct Student* next;      // pointer to next student node\n} Student;\n\nStudent* head = NULL;    // global pointer points to first node in linked list\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));    // allocate memory for new student\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        return NULL;\n    }\n    strcpy(newStudent->name, name);      // copy provided name into new node\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    if (!newStudent) return;\n\n    if (!head) {               // if list is empty, new student becomes the head\n        head = newStudent;\n    } else {\n        Student* temp = head;\n        while (temp->next) {       // if not empty, iterate through list to find last node\n            temp = temp->next;\n        }\n        temp->next = newStudent;\n    }\n    printf(\"Student record added successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (!head) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n\n    Student* temp = head;\n    printf(\"\\nStudent Records:\\n\");\n    while (temp) {                              // go through loop and print details of each node\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to sort student records by grade in ascending order\nvoid sortStudents() {\n    if (!head || !head->next) {     // no need to sort if list empty or has one node\n        printf(\"No need to sort. Not enough records.\\n\");\n        return;\n    }\n\n    Student* i, *j;\n    for (i = head; i != NULL; i = i->next) {\n        for (j = i->next; j != NULL; j = j->next) {\n            if (i->grade > j->grade) {\n                // Swap student details\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, i->name);\n                tempID = i->id;\n                tempGrade = i->grade;\n\n                strcpy(i->name, j->name);\n                i->id = j->id;\n                i->grade = j->grade;\n\n                strcpy(j->name, tempName);\n                j->id = tempID;\n                j->grade = tempGrade;\n            } // nested loops compare grades of all pairs of nodes\n        }\n    }\n    printf(\"Students sorted by grade.\\n\");\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp) {\n        if (temp->id == id) {      // compare id of each node with target\n            return temp;           // if match found, return a pointer to node\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* temp = head;\n    while (temp) {        // iterates through list freeing each node\n        Student* next = temp->next;\n        free(temp);\n        temp = next;\n    }\n    head = NULL;       // sets head to NULL\n    printf(\"All student records deleted.\\n\");\n}\n\n// Main function\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    Student* found = NULL;  // Declare the `found` pointer before the switch statement\n\n    // Provides menu for user interaction\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Students by Grade\\n\");\n        printf(\"4. Search Student by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        // Used fgets for names and scanf for integers and floats\n        switch (choice) {\n            case 1:\n                // Clear buffer before reading the name\n                printf(\"Enter Name: \");\n                getchar(); // Clear input buffer\n                fgets(name, sizeof(name), stdin);\n                name[strcspn(name, \"\\n\")] = 0; // Remove newline character\n\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortStudents();\n                break;\n\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n\n            case 5:\n                deleteList();\n                break;\n\n            case 6:\n                deleteList();\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);     // repeats until user selects 6\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The program employs a Bubble Sort algorithm to sort student records by grade. While this method works correctly, it has a time complexity of O(n?), which can lead to inefficiencies with larger datasets. For better performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20606861",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Function to input the elements of a matrix\r\nvoid inputMatrix(int rows, int cols, int mat[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            scanf(\"%d\", &mat[i][j]); // Take input for each element\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int rows, int cols, int mat[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", mat[i][j]); // Print each element\r\n        }\r\n        printf(\"\\n\"); // Move to the next row\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int rows, int cols, int mat1[10][10], int mat2[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = mat1[i][j] + mat2[i][j]; // Add corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract one matrix from another\r\nvoid subtractMatrices(int rows, int cols, int mat1[10][10], int mat2[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = mat1[i][j] - mat2[i][j]; // Subtract corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int rows, int cols, int mat[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = mat[i][j]; // Swap rows and columns\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int row1, col1, row2, col2; // Dimensions of the matrices\r\n    int matA[10][10], matB[10][10], matResult[10][10];\r\n    int choice;\r\n\r\n    // Input the size of the matrices\r\n    printf(\"Enter dimensions of Matrix A (rows cols): \");\r\n    scanf(\"%d %d\", &row1, &col1);\r\n    printf(\"Enter dimensions of Matrix B (rows cols): \");\r\n    scanf(\"%d %d\", &row2, &col2);\r\n\r\n    // Validate matrix sizes\r\n    if (row1 > 10 || col1 > 10 || row2 > 10 || col2 > 10) {\r\n        printf(\"Error: Maximum size of matrices is 10x10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input the elements of both matrices\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(row1, col1, matA);\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(row2, col2, matB);\r\n\r\n    do {\r\n        // Display menu for user actions\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Check if dimensions match for addition\r\n                if (row1 == row2 && col1 == col2) {\r\n                    addMatrices(row1, col1, matA, matB, matResult);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(row1, col1, matResult);\r\n                } else {\r\n                    printf(\"Error: Matrices dimensions must match for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                // Check if dimensions match for subtraction\r\n                if (row1 == row2 && col1 == col2) {\r\n                    subtractMatrices(row1, col1, matA, matB, matResult);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    printMatrix(row1, col1, matResult);\r\n                } else {\r\n                    printf(\"Error: Matrices dimensions must match for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                // Transpose Matrix A\r\n                transposeMatrix(row1, col1, matA, matResult);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(col1, row1, matResult);\r\n                break;\r\n\r\n            case 4:\r\n                // Transpose Matrix B\r\n                transposeMatrix(row2, col2, matB, matResult);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(col2, row2, matResult);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\"); // Exit the loop\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Structure to represent a grocery item\r\ntypedef struct {\r\n    char name[100];       // Name of the item\r\n    char category[50];    // Category of the item\r\n    int quantity;         // Quantity in stock\r\n    float price;          // Price of the item\r\n} GroceryItem;\r\n\r\n// Structure to represent the availability status of an item\r\ntypedef struct {\r\n    int inStock;          // 1 for true, 0 for false\r\n} AvailabilityStatus;\r\n\r\n// Structure to manage the inventory of grocery items\r\ntypedef struct {\r\n    GroceryItem items[100];          // Array to store grocery items\r\n    AvailabilityStatus statuses[100]; // Array for availability statuses\r\n    int count;                       // Number of items in inventory\r\n} GroceryInventory;\r\n\r\n// Global inventory variable\r\nGroceryInventory inventory = { .count = 0 };\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addGroceryItem() {\r\n    if (inventory.count >= 100) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter item name: \");\r\n    scanf(\" %[^\\n]\", inventory.items[inventory.count].name); // Read item name\r\n    printf(\"Enter item category: \");\r\n    scanf(\" %[^\\n]\", inventory.items[inventory.count].category); // Read category\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &inventory.items[inventory.count].quantity); // Read quantity\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &inventory.items[inventory.count].price); // Read price\r\n\r\n    // Determine availability based on quantity\r\n    inventory.statuses[inventory.count].inStock = (inventory.items[inventory.count].quantity > 0) ? 1 : 0;\r\n    inventory.count++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all items with their details and availability\r\nvoid listGroceryItems() {\r\n    if (inventory.count == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nInventory:\\n\");\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", inventory.items[i].name);\r\n        printf(\"  Category: %s\\n\", inventory.items[i].category);\r\n        printf(\"  Quantity: %d\\n\", inventory.items[i].quantity);\r\n        printf(\"  Price: %.2f\\n\", inventory.items[i].price);\r\n        printf(\"  Availability: %s\\n\", inventory.statuses[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a specific grocery item\r\nvoid updateGroceryQuantity() {\r\n    char name[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter the name of the item to update: \");\r\n    scanf(\" %[^\\n]\", name); // Read item name\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity); // Read new quantity\r\n\r\n            inventory.items[i].quantity = newQuantity;\r\n            inventory.statuses[i].inStock = (newQuantity > 0) ? 1 : 0; // Update availability\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\" %[^\\n]\", name); // Read item name\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, name) == 0) {\r\n            // Shift all subsequent items to fill the gap\r\n            for (int j = i; j < inventory.count - 1; j++) {\r\n                inventory.items[j] = inventory.items[j + 1];\r\n                inventory.statuses[j] = inventory.statuses[j + 1];\r\n            }\r\n            inventory.count--; // Decrease item count\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\r\n// Main function to drive the inventory management program\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Grocery Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); // Read user choice\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateGroceryQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];         // Student's name\r\n    int id;                 // Student's ID\r\n    float grade;            // Student's grade\r\n    struct Student* next;   // Pointer to the next student in the list\r\n} Student;\r\n\r\nStudent* head = NULL; // Head pointer for the linked list (initially empty)\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name); // Copy name\r\n    newStudent->id = id;            // Assign ID\r\n    newStudent->grade = grade;      // Assign grade\r\n    newStudent->next = NULL;        // Set next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    if (head == NULL) { // If list is empty, make new student the head\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next != NULL) { // Traverse to the end of the list\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent; // Add the new student at the end\r\n    }\r\n    printf(\"Student added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    printf(\"Student Records:\\n\");\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next; // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) return temp; // Return student if ID matches\r\n        temp = temp->next;              // Move to the next student\r\n    }\r\n    return NULL; // Return NULL if not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next; // Save the next student\r\n        free(current);        // Free the current student's memory\r\n        current = next;       // Move to the next student\r\n    }\r\n    head = NULL; // Reset the list to empty\r\n    printf(\"All records deleted successfully.\\n\");\r\n}\r\n\r\n// Function to sort students by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student *i;\r\n    Student *j = NULL;\r\n\r\n    // Perform Bubble Sort\r\n    do {\r\n        swapped = 0;\r\n        i = head;\r\n\r\n        while (i->next != j) {\r\n            if (i->grade > i->next->grade) {\r\n                // Swap student details (name, ID, grade)\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, i->next->name);\r\n                i->id = i->next->id;\r\n                i->grade = i->next->grade;\r\n\r\n                strcpy(i->next->name, tempName);\r\n                i->next->id = tempID;\r\n                i->next->grade = tempGrade;\r\n\r\n                swapped = 1; // Mark as swapped\r\n            }\r\n            i = i->next; // Move to the next node\r\n        }\r\n        j = i; // Reduce the unsorted portion of the list\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        // Handle user input based on menu choice\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin); // Get name input\r\n                strtok(name, \"\\n\");              // Remove trailing newline\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id); // Get ID input\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade); // Get grade input\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents(); // Display all students\r\n                break;\r\n            case 3:\r\n                sortStudents(); // Sort students by grade\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id); // Get ID to search\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList(); // Delete all records\r\n                break;\r\n            case 6:\r\n                deleteList(); // Cleanup memory before exiting\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6); // Loop until the user chooses to exit\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation correctly uses Bubble Sort to sort student records by grade. While it works, Bubble Sort has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20613314",
    "code": "\n/* --- Q1.c --- */\n\r\n#include <stdio.h>\r\n#include <stdlib.h> \r\n\r\ntypedef struct matrix{\r\n    int RowCount;\r\n    int ColCount;\r\n    int** values;\r\n} Matrix;\r\n\r\n\r\n//for clear scanf buffer if smth wrong was entered before\r\n// use before scanf\r\nvoid clear_scanf_buffer(){\r\n    char c;\r\n    // read until end of input\r\n    do {\r\n        c = getchar();\r\n    } while (c != '\\n' && c != EOF);\r\n}\r\n\r\nMatrix* input_matrix(char name);   // input matrix dimentions and cells\r\nvoid malloc_values(Matrix* matrix); // allocates memory for matrix cells\r\nvoid print_m(Matrix* matrix);   // prints matrix\r\nvoid input_cell(Matrix* matrix, int row, int col);  // input one cell of matrix\r\nMatrix* add_m(Matrix* A, Matrix* B);    // perform matrix addition\r\nMatrix* sub_m(Matrix* A, Matrix* B);    // perform matrix substraction\r\nMatrix* tr_m(Matrix* matrix);   // perform matrix transposition\r\nvoid free_m(Matrix* matrix); // free memory of matrix\r\n\r\nint menu_func(Matrix* A, Matrix* B, Matrix* C); // menu function to loop in main()\r\n\r\n\r\n\r\nint main(){\r\n    Matrix* A;\r\n    Matrix* B;\r\n    Matrix* C; //result matrix\r\n\r\n    A = input_matrix('A');\r\n    //print_m(A); // for debugging\r\n\r\n    clear_scanf_buffer();\r\n    printf(\"\\n\");\r\n\r\n    B = input_matrix('B');\r\n    //print_m(B); // for debugging\r\n    printf(\"\\n\\n\");\r\n\r\n    //menu loop\r\n    int flag = 1; // 1 - continue, 0 - exit\r\n    while (flag) {\r\n        flag = menu_func(A, B, C);\r\n        printf(\"\\n\\n\");\r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n\r\n// returns 0 if Exit option (to stop the loop in main()) , returns 1 for other options\r\nint menu_func(Matrix* A, Matrix* B, Matrix* C){\r\n    int option;  // option index\r\n    int error;  // error for scanf\r\n\r\n    printf(\"Matrix Operations Menu:\\n\" \\\r\n            \"1. Add Matrices\\n\" \\\r\n            \"2. Subtract Matrices\\n\" \\\r\n            \"3. Transpose Matrix A\\n\" \\\r\n            \"4. Transpose Matrix B\\n\" \\\r\n            \"5. Exit (Loop back to the menu until the user chooses to exit.\\n\"\r\n            \"Enter your choice: \");\r\n\r\n    //scan option\r\n    clear_scanf_buffer();\r\n    error = scanf(\"%d\", &option);\r\n\r\n    // error handling and input validation\r\n    while ((error <= 0) || (option > 5 || option < 1)){\r\n        if (error <= 0) printf(\"Invalid input. Try again.\\n\");  //input failed error\r\n        else printf(\"Invalid input. There is no option %d. Try again.\\n\", option); // input option out of bound\r\n        printf(\"Enter your choice: \");\r\n\r\n        clear_scanf_buffer();\r\n        error = scanf(\"%d\", &option);\r\n    }\r\n\r\n    // option processing\r\n    switch (option)\r\n    {\r\n    case 1: // addition\r\n        C = add_m(A, B);\r\n\r\n        // if different matrix sizes\r\n        if (C == NULL){ \r\n            printf(\"Cannot add. Matrices sizes do not correspond.\\nSize(A) = (%d, %d)\\nSize(B) = (%d, %d)\\n\", \r\n                    A->RowCount, A->ColCount, B->RowCount, B->ColCount);\r\n            return 1;\r\n        }\r\n\r\n        // if sizes correspond\r\n        printf(\"Result of  A + B:\\n\");\r\n        print_m(C);\r\n        free_m(C);  // free matrix\r\n        return 1;\r\n    case 2: // substraction\r\n        C = sub_m(A, B);\r\n\r\n        // if different matrix sizes\r\n        if (C == NULL){\r\n            printf(\"Cannot substract. Matrices sizes do not correspond.\\nSize(A) = (%d, %d)\\nSize(B) = (%d, %d)\\n\", \r\n                    A->RowCount, A->ColCount, B->RowCount, B->ColCount);\r\n            return 1;\r\n        }\r\n\r\n        //if sizes correspond\r\n        printf(\"Result of A - B:\\n\");\r\n        print_m(C);\r\n        free_m(C); // free matrix\r\n        return 1;\r\n    case 3: // transpose A\r\n        C = tr_m(A);\r\n        printf(\"Result of tr(A):\\n\");\r\n        print_m(C);\r\n        free_m(C);  // free matrix\r\n        return 1;\r\n    case 4: // transpose B\r\n        C = tr_m(B);\r\n        printf(\"Result of tr(B):\\n\");\r\n        print_m(C);\r\n        free_m(C);  // free matrix\r\n        return 1;\r\n    case 5: // exit\r\n        return 0;\r\n    default:    // option validation has already been performed before\r\n        perror(\"Impossible case\"); //for debugging\r\n        break;\r\n    }\r\n}\r\n\r\n\r\n\r\nMatrix* input_matrix(char name){\r\n\r\n    // name of matrix to be entered (for printf)\r\n    // name can be only 'A' or 'B'\r\n    if (name != 'A' && name != 'B') perror(\"impossible name\"); \r\n\r\n    //memory allocation for matrix struct\r\n    Matrix* matrix = (Matrix*)malloc(sizeof(Matrix));\r\n\r\n\r\n\r\n    //entering dimentions\r\n    printf(\"Enter dimentions for matrix %c:\\n\", name);\r\n\r\n    //rows\r\n    printf(\"Number of Rows: \");\r\n\r\n    int error = scanf(\"%d\", &(matrix->RowCount));\r\n\r\n    // rows validation and invalid input handling\r\n    while ((error <= 0) || (matrix->RowCount > 10 || matrix->RowCount < 1)){\r\n        if (error <= 0) {// if scanning failed\r\n            printf(\"Invalid input. Try again.\\n\");\r\n            printf(\"Number of Rows: \");\r\n            clear_scanf_buffer();  \r\n        }\r\n        else { // if size is out of bound [1, 10]\r\n            printf(\"Invalid input. Number of rows must satisfy: 1 < rows < 10. Try again.\\n\");  \r\n            printf(\"Number of Columns: \");\r\n        }\r\n\r\n        error = scanf(\"%d\", &(matrix->RowCount));\r\n    }\r\n\r\n    //columns\r\n    printf(\"Number of Columns: \");\r\n    clear_scanf_buffer();\r\n    error = scanf(\"%d\", &(matrix->ColCount));\r\n\r\n    // columns validation and invalid input handling\r\n    while ((error <= 0) || (matrix->ColCount > 10 || matrix->ColCount < 1)){\r\n        if (error <= 0) {// if scanning failed\r\n            printf(\"Invalid input. Try again.\\n\");\r\n            printf(\"Number of Columns: \");\r\n            clear_scanf_buffer();  \r\n        }\r\n        else { // if size is out of bound [1, 10]\r\n            printf(\"Invalid input. Number of columns must satisfy: 1 < columns < 10. Try again.\\n\");  \r\n            printf(\"Number of Columns: \");\r\n        }\r\n\r\n        //scan again\r\n        error = scanf(\"%d\", &(matrix->ColCount));\r\n    }\r\n\r\n\r\n\r\n    // memory allocation for matrix cell values\r\n    malloc_values(matrix);\r\n    \r\n    //input cells\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int row = 0; row < matrix->RowCount; row++){\r\n        for (int col = 0; col < matrix->ColCount; col++){\r\n            input_cell(matrix, row, col);\r\n        }\r\n    }\r\n\r\n\r\n    return matrix;\r\n}\r\n\r\n\r\n// inputs one cell\r\nvoid input_cell(Matrix* matrix, int row, int col){\r\n\r\n    printf(\"Element [%d][%d]: \", row, col);\r\n\r\n    int error; // error for scanf\r\n\r\n    // enter cell value\r\n    clear_scanf_buffer();\r\n    error = scanf(\"%d\", &matrix->values[row][col]);\r\n\r\n    // invalid input handling\r\n    while (error <= 0){\r\n        printf(\"Invalid input. Try again.\\n\");\r\n        printf(\"Element [%d][%d]: \", row, col);\r\n\r\n        clear_scanf_buffer();\r\n        error = scanf(\"%d\", &matrix->values[row][col]);\r\n    }\r\n}\r\n\r\n\r\n// print matrix\r\nvoid print_m(Matrix* matrix){\r\n    for (int row = 0; row < matrix->RowCount; row++){\r\n        for (int col = 0; col < matrix->ColCount; col++){\r\n            printf(\"%d \", matrix->values[row][col]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\n// perform matrix addition\r\n// returns NULL if sizes do not correspond\r\nMatrix* add_m(Matrix* A, Matrix* B){\r\n    //check for same sizes\r\n    if ((A->ColCount != B->ColCount) || (A->RowCount != B->RowCount)) return NULL;\r\n\r\n    // memory allocation for matrix struct\r\n    Matrix* C = (Matrix*)malloc(sizeof(Matrix)); // C - result matrix pointer\r\n\r\n    // setting size of result matrix\r\n    C->ColCount = A->ColCount;\r\n    C->RowCount = A->RowCount;\r\n\r\n    // memory allocation for matrix cell values\r\n    malloc_values(C);\r\n\r\n    // summing matrices\r\n    for (int row = 0; row < C->RowCount; row++){\r\n        for (int col = 0; col < C->ColCount; col++){\r\n            C->values[row][col] = A->values[row][col] + B->values[row][col];\r\n        }\r\n    }\r\n\r\n    return C;\r\n}\r\n\r\n\r\n\r\n// perform matrix substraction\r\n// returns NULL if sizes do not correspond\r\nMatrix* sub_m(Matrix* A, Matrix* B){\r\n    //check for same sizes\r\n    if ((A->ColCount != B->ColCount) || (A->RowCount != B->RowCount)) return NULL;\r\n\r\n    // memory allocation for matrix struct\r\n    Matrix* C = (Matrix*)malloc(sizeof(Matrix));  // C - result matrix pointer\r\n\r\n    // setting size of result matrix\r\n    C->ColCount = A->ColCount;\r\n    C->RowCount = A->RowCount;\r\n\r\n    // memory allocation for matrix cell values\r\n    malloc_values(C);\r\n\r\n    // substracting matrices\r\n    for (int row = 0; row < C->RowCount; row++){\r\n        for (int col = 0; col < C->ColCount; col++){\r\n            C->values[row][col] = A->values[row][col] - B->values[row][col];\r\n        }\r\n    }\r\n\r\n    return C;\r\n}\r\n\r\n\r\nMatrix* tr_m(Matrix* matrix){\r\n    // memory allocation for matrix struct\r\n    Matrix* A = (Matrix*)malloc(sizeof(Matrix));\r\n\r\n    // setting size of result matrix\r\n    A->ColCount = matrix->RowCount;\r\n    A->RowCount = matrix->ColCount;\r\n\r\n    // memory allocation for matrix cell values\r\n    malloc_values(A);\r\n\r\n    for (int row = 0; row < A->RowCount; row++){\r\n        for (int col = 0; col < A->ColCount; col++){\r\n            A->values[row][col] = matrix->values[col][row];\r\n        }\r\n    }\r\n\r\n    return A;\r\n}\r\n\r\n\r\n// memory allocation for matrix values\r\nvoid malloc_values(Matrix* matrix){\r\n    matrix->values = (int**)malloc(matrix->RowCount * sizeof(size_t));\r\n    for (int row = 0; row < matrix->RowCount; row++){\r\n        matrix->values[row] = (int*)malloc(matrix->ColCount * sizeof(int));\r\n    }\r\n    \r\n}\r\n\r\n\r\n// free matrix\r\nvoid free_m(Matrix* matrix){\r\n    for (int i = 0; i < matrix->RowCount; i++){\r\n        free(matrix->values[i]);\r\n    }\r\n    free(matrix);\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n\r\ntypedef struct item{\r\n    char name[101];\r\n    char category[51];\r\n    int quantity;\r\n    float price;\r\n}Item;\r\n\r\nItem array[100];\r\nItem *to_insert = array; // pointer to address where to add a new item\r\n\r\nbool is_quantity(const char *s);\r\nbool is_price(const char *s);\r\nbool is_option(const char *s);\r\n\r\nvoid add_item();\r\nItem* find_by_name(char *s);\r\nvoid update_quantity();\r\nvoid list_all_items();\r\nvoid delete_item();\r\nint menu();\r\n\r\n\r\nint main(){\r\n    int status;\r\n    do\r\n    {\r\n        status = menu();\r\n    } while (status);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\nbool is_option(const char *s){\r\n    // first character is digit\r\n    if (!isdigit(s[0])) return false;\r\n\r\n    // len(s) == 1\r\n    if (s[1] != '\\0') return false;\r\n\r\n    // available options\r\n    if (s[0] > '5' || s[0] < '1') return false;\r\n\r\n    return true;\r\n}\r\n\r\n\r\nbool is_quantity(const char *s){\r\n    // all digits\r\n    for (int i = 0; s[i] != '\\0'; i++){\r\n        if (!isdigit(s[i])) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\n\r\nbool is_price(const char *s){\r\n\r\n    // only digits and '.' are allowed\r\n    for (int i = 0; s[i] != '\\0'; i++){\r\n        if (!isdigit(s[i]) && (s[i] != '.')) return false;\r\n    }\r\n\r\n    // if all digits and no '.' then valid\r\n    if (strchr(s, '.') == NULL) return true;\r\n\r\n    // only 1 or 0 '.'\r\n    if (strchr(s, '.') != strrchr(s, '.')) return false;\r\n\r\n    // 1 or 2 fractional digits\r\n    int frac_digits = strlen(s) - (strchr(s, '.') - s) - 1;\r\n    if (frac_digits > 2 || frac_digits < 1) return false;\r\n\r\n    // first character is not '.'\r\n    if (s[0] == '.') return false;\r\n\r\n    return true;\r\n}\r\n\r\n\r\n// returns pointer to searched item, NULL if not found\r\nItem* find_by_name(char *s){\r\n    for (Item *item = array; item < to_insert; item++)\r\n    {\r\n        if (strcmp(item->name, s) == 0) return item;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n\r\n// add item option\r\nvoid add_item(){\r\n\r\n    // check if possible to add\r\n    if(to_insert - 100 == array){\r\n        printf(\"Maximum number of items (100) in the list exceeded. Cannot add an item.\\n\");\r\n        return;\r\n    }\r\n\r\n    char buffer[101];\r\n\r\n    // Enter name\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar(); // here and further used to to flush '\\n' after scanf\r\n    buffer[100] = '\\0';\r\n\r\n    // check if already exists\r\n    if (find_by_name(buffer) != NULL){\r\n        printf(\"There already exist an item with name: %s\\n\", buffer);\r\n        printf(\"Contact was not added.\\n\");\r\n        return;\r\n    }\r\n\r\n    // address where to write\r\n    Item * item = to_insert;\r\n\r\n    // Put name\r\n    strcpy(item->name, buffer);\r\n\r\n    // Enter Category\r\n    printf(\"Enter Item Category: \");\r\n    scanf(\"%[^\\n]s\", item->category);\r\n    getchar();\r\n    item->category[50] = '\\0';\r\n\r\n    // Enter and validate quantity\r\n    printf(\"Enter Item Quantity: \");\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar();\r\n    buffer[19] = '\\0'; // maximum 20 characters for price\r\n    while (!is_quantity(buffer)){\r\n        printf(\"Invalid input. Try again.\\n\");\r\n        printf(\"Enter Item Quantity: \");\r\n        scanf(\"%[^\\n]s\", buffer);\r\n        getchar();\r\n        buffer[19] = '\\0';\r\n    }\r\n    sscanf(buffer, \"%d\", &(item->quantity));\r\n\r\n\r\n    // Enter and validate price\r\n    printf(\"Enter Item Price: $\");\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar();\r\n    buffer[19] = '\\0';\r\n    while (!is_price(buffer)){\r\n        printf(\"Invalid input. Try again.\\n\");\r\n        printf(\"Enter Item Price: $\");\r\n        scanf(\"%[^\\n]s\", buffer);\r\n        getchar();\r\n        buffer[19] = '\\0';\r\n    }\r\n    sscanf(buffer, \"%d\", &(item->price));\r\n\r\n    // increment pointer for the next free space\r\n    to_insert++;\r\n\r\n    printf(\"Item has been successfully added\\n\\n\");\r\n}\r\n\r\n\r\n//print all items\r\nvoid list_all_items(){\r\n    for (Item *item = array; item < to_insert; item++)\r\n    {\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %d\\n\", item->price);\r\n        printf(\"Status: %s\\n\\n\", item->quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n\r\n// updates quantity of entered item\r\nvoid update_quantity(){\r\n    char buffer[101];\r\n\r\n    // Enter name\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar();\r\n    buffer[100] = '\\0';\r\n\r\n    // check if exists\r\n    Item *item = find_by_name(buffer);\r\n    while (item == NULL){\r\n        printf(\"There is no item with name: %s\\n\", buffer);\r\n        printf(\"Try again.\\n\");\r\n\r\n        //enter again\r\n        printf(\"Enter Item Name: \");\r\n        scanf(\"%[^\\n]s\", buffer);\r\n        getchar();\r\n        buffer[100] = '\\0';\r\n\r\n        item = find_by_name(buffer);\r\n    }\r\n\r\n    // enter new quantity\r\n    printf(\"Enter new quantity for %s: \", item->name);\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar();\r\n    buffer[100] = '\\0';\r\n\r\n\r\n    // validate input\r\n    while (!is_quantity(buffer)){\r\n        printf(\"Invalid input. Try again.\\n\");\r\n\r\n        // enter again\r\n        printf(\"Enter new quantity for %s: \", item->name);\r\n        scanf(\"%[^\\n]s\", buffer);\r\n        getchar();\r\n        buffer[100] = '\\0';\r\n    }\r\n\r\n    sscanf(buffer, \"%d\", &(item->quantity));\r\n\r\n    printf(\"Quantity has been updated.\\n\\n\");\r\n}\r\n\r\n\r\n// delete entered item\r\nvoid delete_item(){\r\n    char buffer[101];\r\n\r\n    // check if list is not empty\r\n    if (to_insert = array){\r\n        printf(\"List is empty. There is nothing to delete\\n\");\r\n        return;\r\n    }\r\n\r\n    // Enter name\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar();\r\n    buffer[100] = '\\0';\r\n\r\n    Item *item_to_delete = find_by_name(buffer);\r\n\r\n    // check if exists\r\n    while (item_to_delete == NULL){\r\n        printf(\"There is no item with name: %s\\n\", buffer);\r\n        printf(\"Try again.\\n\");\r\n\r\n        //enter again\r\n        printf(\"Enter Item Name: \");\r\n        scanf(\"%[^\\n]s\", buffer);\r\n        getchar();\r\n        buffer[100] = '\\0';\r\n\r\n        item_to_delete = find_by_name(buffer);\r\n    }\r\n\r\n    // shift remaining items one position left\r\n    for (Item *item = item_to_delete; item < to_insert - 1; item++){\r\n        strcpy(item->name, (item + 1)->name);\r\n        strcpy(item->category, (item + 1)->category);\r\n        item->quantity = (item + 1)->quantity;\r\n        item->price = (item + 1)->price;\r\n    }\r\n\r\n    // shift insert poition\r\n    to_insert--;\r\n\r\n    printf(\"Item has been deleted.\\n\\n\");\r\n}\r\n\r\n\r\n\r\n// menu function to loop. Returns 0 to stop, 1 to continue\r\nint menu(){\r\n    int option;\r\n    char buffer[10];\r\n\r\n    printf(\"Grocery Management System.\\n\" \r\n           \"    1. Add Grocery Item\\n\"\r\n           \"    2. List All Grocery Items\\n\"\r\n           \"    3. Update Quantity\\n\"\r\n           \"    4. Remove Grocery Item\\n\"\r\n           \"    5. Exit\\n\");\r\n\r\n    //enter option\r\n    printf(\"Your option: \");\r\n    scanf(\"%[^\\n]s\", buffer);\r\n    getchar();\r\n    buffer[9] = '\\0';\r\n\r\n    // validate input\r\n    while (!is_option(buffer)){\r\n        printf(\"Invalid input. Try again.\\n\");\r\n\r\n        printf(\"Your option: \");\r\n        scanf(\"%[^\\n]s\", buffer);\r\n        getchar();\r\n        buffer[9] = '\\0';\r\n    }\r\n    sscanf(buffer, \"%d\", &option);\r\n\r\n\r\n    // process option\r\n    switch (option)\r\n    {\r\n    case 1:\r\n        add_item();\r\n        break;\r\n    case 2:\r\n        list_all_items();\r\n        break;\r\n    case 3:\r\n        update_quantity();\r\n        break;\r\n    case 4:\r\n        delete_item();\r\n        break;\r\n    case 5:\r\n        printf(\"Exiting...\");\r\n        return 0; // exit status\r\n    default:\r\n        perror(\"Impossible.\");  // option validation has already been performed before\r\n        break;\r\n    }\r\n\r\n    return 1; // continue status\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n\r\n\r\ntypedef struct Student{\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next; //pointer to the next student (The list is sorted by name)\r\n}Student;\r\n\r\nStudent* head = NULL; // list entry\r\n\r\n\r\nvoid insertStudent(const char* name, int id, float grade); // Inserts a new student record into the linked list. \r\nvoid displayStudents(); // Displays all current student records in the linked list.\r\nStudent* searchStudentByID(int id); // Searches for a student record by student ID and returns a pointer to the corresponding student node.\r\nvoid deleteList(); // Deletes the entire linked list and frees the allocated memory.\r\nvoid freeMemory(); // A utility function to ensure that all memory is freed when the program exits.\r\nStudent* createStudent(const char* name, int id, float grade); // Creates a new student node and returns a pointer to it.\r\nvoid sortStudents(); // Sort the student records by grade according to a sorting algorithm of your choice. \r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                printf(\"Student has been added to the list.\\n\");\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                    found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student *stud = (Student*)malloc(sizeof(Student));\r\n    strcpy(stud->name, name);\r\n    stud->id = id;\r\n    stud->grade = grade;\r\n    stud->next = NULL;\r\n    return stud;\r\n}\r\n\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    //allocate memory\r\n    Student* stud = createStudent(name, id, grade);\r\n\r\n    // if list is empty\r\n    if (head == NULL) {\r\n        head = stud;\r\n        return;\r\n    }\r\n\r\n    // if list is not empty\r\n    Student* next = head;\r\n    head = stud;\r\n    stud->next = next;\r\n}\r\n\r\n\r\n\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) printf(\"List is empty.\\n\");\r\n\r\n    for (Student* curr = head; curr != NULL; curr = curr->next){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", curr->name, curr->id, curr->grade);\r\n    }\r\n}\r\n\r\n\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    if (head == NULL) return NULL; // if list is empty\r\n\r\n    for (Student* curr = head; curr != NULL; curr = curr->next){\r\n        if (curr->id == id) return curr;\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n\r\n// compare function for quick sort\r\nint compare(const void* aP, const void* bP){\r\n    Student* a = *(Student**)aP; // cast double-pointer to single-pointer\r\n    Student* b = *(Student**)bP; // cast double-pointer to single-pointer\r\n    float grade1 = a->grade;\r\n    float grade2 = b->grade;\r\n    float dif = grade1 - grade2;\r\n    if (dif > 0) return 1;\r\n    if (dif == 0) return 0;\r\n    if (dif < 0) return -1;\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    //quick sort using an array of pointers to nodes\r\n\r\n\r\n    // find number of elements in the list\r\n    int n = 0; // number of students in the list\r\n    for (Student* curr = head; curr != NULL; curr = curr->next, n++);\r\n\r\n\r\n    // if the list is too small and no need to sort\r\n    if (n < 2){\r\n        printf(\"List is sorted.\\n\");\r\n        return;\r\n    }\r\n\r\n    // allocate array of pointers to nodes\r\n    Student** array = (Student**)malloc(n * sizeof(Student*));\r\n\r\n    // fill the array\r\n    int i = 0;\r\n    for (Student* curr = head; curr != NULL; curr = curr->next){\r\n        array[i] = curr;\r\n        i++;\r\n    }\r\n\r\n    // sort it\r\n    qsort(array, n, sizeof(Student*), compare); // cast compare() to prevent warning\r\n\r\n    //change node links\r\n    head = array[0];\r\n    for (int i = 0; i < n - 1; i++){\r\n        array[i]->next = array[i + 1];\r\n    }\r\n    array[n - 1]->next = NULL;\r\n\r\n\r\n    printf(\"List is sorted.\\n\");\r\n}",
    "feedback": "q1-Meet requirement\nq2-In the delete_item function, the condition if (to_insert = array) should use == for comparison instead of = for assignment. This will always evaluate to true, leading to incorrect behavior.\nq3-    The program implements Quick Sort effectively to sort student records by grade. This is a suitable choice as Quick Sort has an average time complexity of O(n log n), which is efficient for larger datasets."
  },
  {
    "student_id": "20612661",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint arrA[10][10] = {0};\r\nint arrB[10][10] = {0};\r\nint rowA, colA, rowB, colB;\r\nvoid clearInputBuffer();\r\nvoid readMatrix();\r\nvoid printOperationMenu();\r\nint checkDimension();\r\nvoid addMatrices();\r\nvoid subtractMatrices();\r\nvoid transposeMatrixA();\r\nvoid transposeMatrixB();\r\n\r\n\r\nvoid clearInputBuffer() {\r\n    int ch;\r\n    while ((ch = getchar()) != '\\n' && ch != EOF){}\r\n}\r\n\r\nvoid readMatrix(){\r\n\r\n\r\n    // Enter value for Matrix A\r\n    do{\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowA, &colA);\r\n    }while(rowA > 10 || colA > 10);\r\n    printf(\"Enter elements for Matrix A: \\n\");\r\n    for (int i = 0; i<rowA; i++){\r\n        for(int j = 0; j<colA; j++){\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &arrA[i][j]);\r\n            clearInputBuffer();\r\n        }\r\n    }\r\n\r\n    // Enter value for Matrix B\r\n    do{\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowB, &colB);\r\n    }while(rowB > 10 || colB > 10);\r\n    printf(\"Enter elements for Matrix B: \\n\");\r\n    for (int i = 0; i<rowB; i++){\r\n        for(int j = 0; j<colB; j++){\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &arrB[i][j]);\r\n            clearInputBuffer();\r\n        }\r\n    }\r\n}\r\n\r\nvoid printOperationMenu(){\r\n    puts(\"Matrix Operations Menu: \");\r\n    puts(\"1. Add Matrices\");\r\n    puts(\"2. Subtract Matrices\");\r\n    puts(\"3. Transpose Matrix A\");\r\n    puts(\"4. Transpose Matrix B\");\r\n    puts(\"5. Exit\");\r\n    printf(\"Enter Your Choice: \");\r\n}\r\n\r\nint checkDimension(){\r\n    //printf(\"check: %d\\n\\n\", (rowA == rowB) && (colA == colB));\r\n    return ((rowA == rowB) && (colA == colB));\r\n}\r\n\r\nvoid addMatrices(){\r\n    //Check dimension is similar\r\n    if(checkDimension() == 0){\r\n        puts(\"The matrix dimension are not similar, addition unable to occur.\");\r\n        puts(\"Return to menu.\");\r\n        return;\r\n    }\r\n\r\n    //Print result seperately\r\n    printf(\"Result of Matrix A + Matrix B: \\n\");\r\n    for (int i = 0; i< rowA; i++ ){\r\n        for (int j = 0; j < colA; j ++){\r\n            printf(\"%d \", arrA[i][j] + arrB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(){\r\n    //Check dimension is similar\r\n    if(checkDimension() == 0){\r\n        puts(\"The matrix dimension are not similar, subtraction unable to occur.\");\r\n        puts(\"Return to menu.\");\r\n        return;\r\n    }\r\n\r\n    //Print result seperately\r\n    printf(\"Result of Matrix A - Matrix B: \\n\");\r\n    for (int i = 0; i< rowA; i++ ){\r\n        for (int j = 0; j < colA; j ++){\r\n            printf(\"%d \", arrA[i][j] - arrB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid transposeMatrixA(){\r\n    printf(\"Transpose of Matrix A: \\n\");\r\n    // Reverse the row and column when reading \r\n    for (int j = 0; j< colA; j++ ){\r\n        for (int i = 0; i < rowA; i ++){\r\n            printf(\"%d \", arrA[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid transposeMatrixB(){\r\n    // Reverse the row and column when reading \r\n    printf(\"Transpose of Matrix B: \\n\");\r\n    for (int j = 0; j< colB; j++ ){\r\n        for (int i = 0; i < rowB; i ++){\r\n            printf(\"%d \", arrB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid main(){\r\n    int choice = 0;\r\n    readMatrix();\r\n    do{\r\n        printOperationMenu();\r\n        scanf(\"%d\", &choice);\r\n        switch (choice){\r\n            case 1:\r\n                addMatrices();\r\n                break;\r\n            case 2:\r\n                subtractMatrices();\r\n                break;\r\n            case 3:\r\n                transposeMatrixA();\r\n                break;\r\n            case 4:\r\n                transposeMatrixB();\r\n                break;\r\n            case 5:\r\n                puts(\"Exiting...\");\r\n                break;\r\n        }\r\n    }while(choice != 5);\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#define MAX_LENGTH 50\r\n#define MAX_SIZE 100\r\n\r\n//Prototype\r\nvoid clearBufferInput();\r\nvoid displayMenu();\r\nvoid addGrocery();\r\nvoid listGrocery();\r\nvoid updateQuantity();\r\nvoid removeGrocery();\r\n\r\nstruct Item{\r\n    char name[MAX_LENGTH];\r\n    char category[MAX_LENGTH];\r\n    int quantity;\r\n    float price; \r\n};\r\nstruct Item itemNo[MAX_SIZE];\r\nint itemCount =0;\r\nint avaibility[MAX_SIZE] = {0};\r\n\r\n\r\nvoid clearBufferInput(){\r\n    int ch;\r\n    while((ch = getchar()) != '\\n' && ch != EOF){}\r\n}\r\n\r\nvoid displayMenu(){\r\n    puts(\"Grocery Inventory Management System\");\r\n    puts(\"1. Add Grocery Item\");\r\n    puts(\"2. List All Grocery Items\");\r\n    puts(\"3. Update Qunality\");\r\n    puts(\"4. Remove Grocery Item\");\r\n    puts(\"5. Exit\");\r\n    printf(\"Enter your choice: \");\r\n}\r\n\r\nvoid addGrocery(){\r\n\r\n    // Ask the user the data and directly save into itemNo struct\r\n    // Increase the counter for total item\r\n    printf(\"Enter Item Name: \");\r\n    fgets(itemNo[itemCount].name, MAX_LENGTH, stdin);\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(itemNo[itemCount].category, MAX_LENGTH, stdin);\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &itemNo[itemCount].quantity);\r\n    clearBufferInput();\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &itemNo[itemCount].price);\r\n\r\n    clearBufferInput();\r\n    printf(\"\\n\");\r\n\r\n    itemCount++;\r\n}\r\n\r\nvoid listGrocery(){\r\n    printf(\"\\n\");\r\n    // Display by looping and increment of i.\r\n    // Print the item sequencely\r\n    for(int i = 0; i<itemCount; i++){\r\n        printf(\"----  Item %d  ----\\n\", i+1); //The number of item\r\n        printf(\"Name: %s\", itemNo[i].name);\r\n        printf(\"Category: %s\", itemNo[i].category);\r\n        printf(\"Quantity: %d\\n\", itemNo[i].quantity);\r\n        printf(\"Price: %.2f\\n\", itemNo[i].price);\r\n        printf(\"Status: \");\r\n        (itemNo[i].quantity > 0) ?\r\n        puts(\"In Stock\") : puts(\"Out of Stock\"); //Based on quantity to print in or out stock\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\" ---- End List ----\\n\\n\");\r\n}\r\n\r\nvoid updateQuantity(){\r\n    char itemName[MAX_LENGTH];\r\n    int found =0;\r\n    int newQuantity = 0;\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, MAX_LENGTH, stdin);\r\n    // Search similar item name and update it quanlity\r\n    for (int i =0; i<itemCount; i++){ \r\n        if (!(strcmp(itemName,itemNo[i].name))){\r\n            itemName[strcspn(itemName, \"\\n\")] = '\\0'; // Remove the new line character\r\n            printf(\"Enter the new quantity for %s: \", itemName);\r\n            scanf(\"%d\", &newQuantity);\r\n            itemNo[i].quantity = newQuantity;\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    //Print sentences if updated or not updated.\r\n    if (found){\r\n        puts(\"Quantity updated successfully! \\n\");\r\n    }\r\n    else{\r\n        puts(\"Error, Item name doesn't exist!! \\n\");\r\n    }\r\n}\r\n\r\nvoid removeGrocery(){\r\n    char nameGrocery[MAX_LENGTH];\r\n    int numGrocery = 0;\r\n    int found = 0;\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(nameGrocery, MAX_LENGTH, stdin);\r\n    \r\n    // Save the number of item that want to delete\r\n    for (int i = 0; i<itemCount; i++){\r\n        if (!(strcmp(nameGrocery, itemNo[i].name))){\r\n            numGrocery = i;\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    //If no item found, back to main menu\r\n    if (found == 0){\r\n        printf(\"Item name doesn't exist! \\n\\n\");\r\n        return;\r\n    }\r\n\r\n    // Rewrite the current item into next item\r\n    // Reduce the counter for total item\r\n    for (int i = numGrocery; i < itemCount; i++){\r\n        itemNo[i] = itemNo[i+1];\r\n    }\r\n    itemCount--;\r\n\r\n    nameGrocery[strcspn(nameGrocery, \"\\n\")] = '\\0';\r\n    printf(\"Grocery item '%s' removed successfully!\\n\\n\", nameGrocery);\r\n}\r\n\r\nint main(){\r\n    int choice = 0;\r\n    do{\r\n        displayMenu();\r\n        scanf(\"%d\", &choice);\r\n        clearBufferInput();\r\n\r\n        switch (choice){\r\n            case 1:\r\n                addGrocery();\r\n                break;\r\n            case 2:\r\n                listGrocery();\r\n                break;\r\n\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n\r\n            case 4:\r\n                removeGrocery();\r\n                break;\r\n\r\n            case 5:\r\n                puts(\"Exiting\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid input, pls enter (1/2/3/4/5) \\n\");\r\n                break;\r\n        }\r\n\r\n    }while (choice != 5);\r\n\r\n\r\n}\r\n\n/* --- Q3 .c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n// Structure for Student \r\ntypedef struct Student { \r\n char name[100]; \r\n int id; \r\n float grade; \r\n struct Student* next; \r\n} Student; \r\nStudent* head = NULL; \r\n\r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    // Define a memory spacefor with student* data type\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL){ //If define memory size error\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->name[strcspn(newStudent->name, \"\\n\")] = '\\0';\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n\r\n    return newStudent;\r\n} \r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = createStudent(name, id, grade);\r\n    \r\n    //If errror\r\n    if(newStudent == NULL){\r\n        puts(\"Memory allocation error\");\r\n        return;\r\n    }\r\n\r\n    // Adjust pointer\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n} \r\n\r\n\r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    Student* curStudent = head;\r\n    while(curStudent != NULL){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", curStudent->name, curStudent->id, curStudent->grade);\r\n        curStudent = curStudent->next;\r\n    }\r\n} \r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice \r\nvoid sortStudents(){\r\n\r\n    if(head == NULL){\r\n        printf(\"Error, at least two students to sort list.\\n\");\r\n        return;\r\n    }\r\n    else if(head->next == NULL){\r\n        printf(\"Error, at least two students to sort list.\\n\");\r\n        return;\r\n    }\r\n    \r\n    int swapped = 0;\r\n    Student* lastStd = NULL;\r\n    Student* temp1;\r\n    Student* temp2;\r\n    Student* Std1;\r\n    Student* Std2;\r\n\r\n    do{\r\n        swapped =0;\r\n        Std1 = head;\r\n        Std2 = Std1->next;\r\n        \r\n        while(Std2 != lastStd){\r\n            if (Std1->grade > Std2 ->grade){\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strncpy(tempName, Std1 -> name, sizeof(Std1 -> name));\r\n                tempId = Std1 ->id;\r\n                tempGrade = Std1 ->grade;\r\n\r\n                strncpy(Std1->name, Std2 ->name, sizeof(Std2->name));\r\n                Std1 ->id = Std2 ->id;\r\n                Std1 ->grade = Std2 ->grade;\r\n\r\n                strncpy(Std2->name, tempName, sizeof(tempName));\r\n                Std2 ->id = tempId;\r\n                Std2 ->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            Std1 = Std1->next;\r\n            Std2 = Std1->next;\r\n        }\r\n        lastStd = Std1;\r\n        //Move the lastStd forward\r\n    }while(swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n\r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) {\r\n    Student* Std1 = head; \r\n    while(Std1 != NULL){\r\n        if (Std1->id == id){\r\n            return Std1;\r\n        }\r\n        Std1 = Std1->next;\r\n    }\r\n} \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n Student* current = head; \r\n Student* next; \r\n while (current != NULL) { \r\n next = current->next; \r\n free(current); \r\n current = next; \r\n } \r\n head = NULL; \r\n} \r\n\r\nvoid freeMemory() { \r\n deleteList(); \r\n} \r\n\r\n\r\n// Main function to drive the program \r\nint main() { \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n        switch (choice) {\r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                 break; \r\n              case 3: \r\n                sortStudents(); \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\");\r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n return 0; \r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-    The sort function correctly implements bubble sort to arrange student records by grade. While effective, bubble sort has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for improved performance."
  },
  {
    "student_id": "20595032",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Define maximum size of the matrix (10x10)\r\n#define MAX 10\r\n\r\nvoid input(int matrix[MAX][MAX], int rows, int cols);\r\nvoid print(int matrix[MAX][MAX], int rows, int cols);\r\nvoid add(int a[MAX][MAX], int b[MAX][MAX], int rows, int cols);\r\nvoid sub(int a[MAX][MAX], int b[MAX][MAX], int rows, int cols);\r\nvoid transpose(int matrix[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int rowA, rowB;\r\n    int colsA, colsB;\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX];\r\n    int prompt;\r\n\r\n    // Prompt user to enter the dimensions of matrix A and B\r\n\r\n    printf(\"Please enter the dimensions of matrix A (rows cols): \");\r\n    scanf(\"%d %d\", &rowA, &colsA);\r\n\r\n    //ensure it is within a 10x10\r\n    if (rowA > MAX || colsA > MAX || rowA <= 0 || colsA <= 0) {\r\n        printf(\"Dimensions must be between 1 and 10.(Digits only)\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Please enter the dimensions of matrix B (rows cols): \");\r\n    scanf(\"%d %d\", &rowB, &colsB);\r\n\r\n    if (rowB > MAX || colsB > MAX || rowB <= 0 || colsB <= 0) {\r\n        printf(\"Dimensions must be between 1 and 10.(Digits only)\\n\");\r\n        return 1;\r\n    }\r\n    \r\n    // Prompt users to enter the elements for matrix A and B \r\n\r\n    printf(\"\\nEnter elements for Matrix A:\\n\");\r\n    input(matrixA, rowA, colsA);\r\n\r\n    printf(\"\\nEnter elements for Matrix B:\\n\");\r\n    input(matrixB, rowB, colsB);\r\n\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &prompt);\r\n\r\n        // Set case 1-5, loop it for ease of use\r\n\r\n        switch (prompt) {\r\n            case 1:\r\n                if (rowA == rowB && colsA == colsB) {\r\n                    add(matrixA, matrixB, rowA, colsA);\r\n                } else {\r\n                    printf(\"Matrices require the same rows and columns for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowA == rowB && colsA == colsB) {\r\n                    sub(matrixA, matrixB, rowA, colsA);\r\n                } else {\r\n                    printf(\"Matrices require the same rows and columns for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transpose(matrixA, rowA, colsA);\r\n                break;\r\n            case 4:\r\n                transpose(matrixB, rowB, colsB);\r\n                break;\r\n            case 5:\r\n                printf(\"\\nExiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please select between 1-5.\\n\");\r\n        }\r\n    } while (prompt != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid input(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid print(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid add(int a[MAX][MAX], int b[MAX][MAX], int rows, int cols) {\r\n    int result[MAX][MAX];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n    printf(\"\\nResult of Addition:\\n\");\r\n    print(result, rows, cols);\r\n}\r\n\r\nvoid sub(int a[MAX][MAX], int b[MAX][MAX], int rows, int cols) {\r\n    int result[MAX][MAX];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n    printf(\"\\nResult of Subtraction:\\n\");\r\n    print(result, rows, cols);\r\n}\r\n\r\nvoid transpose(int matrix[MAX][MAX], int rows, int cols) {\r\n    int transposed[MAX][MAX];\r\n    for (int i = 0; i < cols; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            transposed[i][j] = matrix[j][i];\r\n        }\r\n    }\r\n    printf(\"\\nResult of Transposition:\\n\");\r\n    print(transposed, cols, rows);\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    bool in_stock;\r\n} GroceryItem;\r\n\r\n\r\n// Store up to MAX_ITEMS in grocery\r\nGroceryItem inventory[MAX_ITEMS];\r\nint item_count = 0;\r\n\r\n// Functions\r\nvoid addITEM();\r\nvoid listITEM();\r\nvoid updateITEM();\r\nvoid removeITEM();\r\n\r\nint main() {\r\n    int choice;\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addITEM();\r\n                break;\r\n            case 2:\r\n                listITEM();\r\n                break;\r\n            case 3:\r\n                updateITEM();\r\n                break;\r\n            case 4:\r\n                removeITEM();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid. Please enter a number from 1-5.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addITEM() {\r\n    if (item_count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Please remove an item first.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newITEM;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newITEM.name, sizeof(newITEM.name), stdin);\r\n    newITEM.name[strcspn(newITEM.name, \"\\n\")] = 0; \r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(newITEM.category, sizeof(newITEM.category), stdin);\r\n    newITEM.category[strcspn(newITEM.category, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newITEM.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newITEM.price);\r\n\r\n    newITEM.in_stock = (newITEM.quantity > 0);\r\n\r\n    inventory[item_count++] = newITEM;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listITEM() {\r\n    if (item_count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        printf(\"\\nName: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].in_stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateITEM() {\r\n    char itemName[100];\r\n    int newITEM;\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity for %s: \", inventory[i].name);\r\n            scanf(\"%d\", &newITEM);\r\n            getchar();\r\n\r\n            inventory[i].quantity = newITEM;\r\n            inventory[i].in_stock = (newITEM > 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nvoid removeITEM() {\r\n    char itemName[100];\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            for (int j = i; j < item_count - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            item_count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocation of memory for new student is crucial\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory Invalid.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Assign values to the student node\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // New student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    // New students will show up first \r\n    newStudent->next = head;\r\n    head = newStudent;\r\n\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n\r\n    if (current == NULL) {\r\n        printf(\"No records.\\n\");\r\n        return;\r\n    }\r\n\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on Bubble Sort\r\nvoid sortStudents() {\r\n        if (head == NULL||head->next == NULL)return; //sorting not needed if empty\r\n\r\n    int swapped;\r\n    Student *current,*last = NULL;\r\n\r\n    do {\r\n        // reser the swapped flag at start of every outer loop\r\n        swapped = 0;\r\n        current = head;\r\n        // ensures starting at head of list\r\n         \r\n        // ensures looping until last element \r\n        while (current->next != last) {\r\n\r\n\r\n            if (current->grade > current->next->grade) {\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n\r\n                // copy data stored from temporary var into next node\r\n                strcpy(tempName, current->name);\r\n                tempID = current->id;\r\n                tempGrade = current->grade;\r\n\r\n                strcpy(current->name, current->next->name);\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n\r\n            // move to next node\r\n            current = current->next;\r\n        }\r\n        last = current;\r\n    } while (swapped); // ensures looping until no more swaps are needed\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is implemented correctly. While it works for small datasets and is easy to understand, it has a time complexity of O(n?), making it inefficient for larger datasets. For better performance, consider using a more efficient algorithm like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20723677",
    "code": "\n/* --- L3Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10\n\n// Function prototypes\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n    int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE];\n    int result[MAX_SIZE][MAX_SIZE];\n    int transposed[MAX_SIZE][MAX_SIZE];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions of matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsA <= 0 || colsA <= 0) {\n        printf(\"Invalid dimensions for Matrix A. Exiting program...\\n\");\n        return 1;\n    }\n\n    // Input elements of matrix A\n    printf(\"Enter elements for Matrix A:\\n\");\n    inputMatrix(a, rowsA, colsA);\n\n    // Input dimensions of matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    if (rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsB <= 0 || colsB <= 0) {\n        printf(\"Invalid dimensions for Matrix B. Exiting program...\\n\");\n        return 1;\n    }\n\n    // Input elements of matrix B\n    printf(\"Enter elements for Matrix B:\\n\");\n    inputMatrix(b, rowsB, colsB);\n\n    // Menu loop\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(a, b, result, rowsA, colsA);\n                    printf(\"\\nResult of Matrix A + Matrix B:\\n\");\n                    printMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"\\nMatrix addition not possible (dimensions mismatch).\\n\");\n                }\n                break;\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(a, b, result, rowsA, colsA);\n                    printf(\"\\nResult of Matrix A - Matrix B:\\n\");\n                    printMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"\\nMatrix subtraction not possible (dimensions mismatch).\\n\");\n                }\n                break;\n            case 3:\n                transposeMatrix(a, transposed, rowsA, colsA);\n                printf(\"\\nTranspose of Matrix A:\\n\");\n                printMatrix(transposed, colsA, rowsA);\n                break;\n            case 4:\n                transposeMatrix(b, transposed, rowsB, colsB);\n                printf(\"\\nTranspose of Matrix B:\\n\");\n                printMatrix(transposed, colsB, rowsB);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = a[i][j] + b[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = a[i][j] - b[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\n/* --- L3Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LEN 100\n#define MAX_CATEGORY_LEN 50\n\n// Struct to store grocery item details\ntypedef struct {\n    char name[MAX_NAME_LEN];\n    char category[MAX_CATEGORY_LEN];\n    int quantity;\n    float price;\n} GroceryItem;\n\n// Struct to store availability status\ntypedef struct {\n    bool inStock;\n    bool outOfStock;\n} AvailabilityStatus;\n\n// Struct to store the grocery inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    AvailabilityStatus status[MAX_ITEMS];\n    int count;\n} GroceryInventory;\n\n// Function prototypes\nvoid addGroceryItem(GroceryInventory *inventory);\nvoid listGroceryItems(const GroceryInventory *inventory);\nvoid updateItemQuantity(GroceryInventory *inventory);\nvoid removeGroceryItem(GroceryInventory *inventory);\n\nint main() {\n    GroceryInventory inventory = { .count = 0 };\n    int choice;\n\n    do {\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Consume newline\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory);\n                break;\n            case 2:\n                listGroceryItems(&inventory);\n                break;\n            case 3:\n                updateItemQuantity(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) {\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem *item = &inventory->items[inventory->count];\n    AvailabilityStatus *status = &inventory->status[inventory->count];\n\n    printf(\"Enter item name: \");\n    fgets(item->name, MAX_NAME_LEN, stdin);\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline\n\n    printf(\"Enter item category: \");\n    fgets(item->category, MAX_CATEGORY_LEN, stdin);\n    item->category[strcspn(item->category, \"\\n\")] = '\\0'; // Remove newline\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &item->quantity);\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &item->price);\n\n    getchar(); // Consume newline\n\n    status->inStock = (item->quantity > 0);\n    status->outOfStock = !status->inStock;\n\n    inventory->count++;\n    printf(\"Grocery item added successfully!\\n\");\n}\n\nvoid listGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < inventory->count; i++) {\n        const GroceryItem *item = &inventory->items[i];\n        const AvailabilityStatus *status = &inventory->status[i];\n\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\nvoid updateItemQuantity(GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No items in the inventory to update.\\n\");\n        return;\n    }\n    char name[MAX_NAME_LEN];\n    printf(\"Enter the name of the grocery item to update quantity: \");\n    fgets(name, MAX_NAME_LEN, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0';   // Remove newline\n\n    for (int i = 0; i < inventory->count; i++) {\n        GroceryItem *item = &inventory->items[i];\n        AvailabilityStatus *status = &inventory->status[i];\n\n        if (strcspn(item->name, name) == 0){\n            printf(\"Enter new quantity for %s: \", item->name);\n            scanf(\"%d\", &item->quantity);\n\n            status->inStock = (item->quantity > 0);\n            status->outOfStock = !status->inStock;\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Item not found in the inventory.\\n\");\n}\n\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No items in the inventory to remove.\\n\");\n        return;\n    }\n\n    char name[MAX_NAME_LEN];\n    printf(\"Enter the name of the grocery item to remove: \");\n    fgets(name, MAX_NAME_LEN, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0';\n\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcspn(inventory->items[i].name, name) == 0) {\n            printf(\"Grocery item '%s' removed successfully!\\n\", inventory->items[i].name);\n            for (int j = i; j < inventory->count - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n                inventory->status[j] = inventory->status[j + 1];\n            }\n\n            inventory->count--;\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\");\n\n}\n\n/* --- L3Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;   // Pointer to the next student in the list\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    // Allocate memory for the new student node\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (newStudent == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        exit(1);\n    }\n\n    // Copy the student details into the ode\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;    // Initialize the next pointer to NULL\n\n    return newStudent;  // Return the newly created student node\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    // Create a new student node\n    Student* newStudent = createStudent(name, id, grade);\n\n    // Insert the node at the beginnning of the list\n    newStudent->next = head;\n    head = newStudent;\n\n    printf(\"Student record inserted successfully.\\n\");\n}\n\n// Function to display all student ecords\nvoid displayStudents() {\n    // Check is the list is empty\n    if (head == NULL) {\n        printf(\"No student records found.\\n\");\n        return;\n    }\n\n    // Tranverse the list and print each student record\n    Student* current = head;\n    printf(\"\\nStudent Records:\\n\");\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    // Trancerse the list to find the student with the given ID\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current; // Return the student ode if found\n        }\n        current = current->next;\n    }\n    return NULL;    // Return NULL if the student node if found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    // Free each node in the list\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    head = NULL;    //Reset the head pointer to NULL\n    printf(\"All student records deleted.\\n\");\n}\n\n// Utility function to free memory (alias for deleteList)\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade using based on Bubble sort\nvoid sortStudents() {\n    // Check if the list is empty or has only one element\n    if (head == NULL || head-> next == NULL) {\n        return;\n    }\n\n    int swapped;\n    Student* ptr1;\n    Student* lptr = NULL;\n\n    // Bubble Sort implementation\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                // Swap the student details\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, ptr1->name);\n                tempID = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempID;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n\n    printf(\"Student records sorted by grade.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();  // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\"); // Remove newline character\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortStudents();\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\n                break;\n\n            case 4:\n            printf(\"Enter ID to search: \");\n            scanf(\"%d\", &id);\n            Student* found = searchStudentByID(id);\n            if (found) {\n                printf(\"Student Found: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n            } else {\n                printf(\"Student with ID %d, not found.\\n\", id);\n            }\n            break;\n\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-In the updateItemQuantity function, the condition used to check for the item name (if (strcspn(item->name, name) == 0)) is incorrect. It should use strcmp to compare the names instead. The current method may lead to incorrect behavior when checking for matches. In the removeGroceryItem function, similar to the previous error, the check for item name should also use strcmp. The current method may not correctly identify items to be removed, which can lead to items not being found.\nq3-    The bubble sort implementation correctly sorts the student records by grade. However, it is inefficient for larger datasets, with a time complexity of O(n?). For better performance on larger lists, consider using a more efficient sorting algorithm, such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20607620",
    "code": "\n/* --- Q1(1).c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 // Max matrix size\r\n\r\n// Input elements\r\nvoid inputMatrix(int matrix[MAX][MAX], int numRows, int numCols) {\r\n    for (int row = 0; row < numRows; row++) { // Loop through rows\r\n        for (int col = 0; col < numCols; col++) { // Loop through columns\r\n            printf(\"Element [%d][%d]: \", row + 1, col + 1); \r\n            scanf(\"%d\", &matrix[row][col]); \r\n        }\r\n    }\r\n}\r\n\r\n// Addition matrix\r\nvoid sumMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int resultMatrix[MAX][MAX], int numRows, int numCols) {\r\n    for (int row = 0; row < numRows; row++) { // Loop through rows\r\n        for (int col = 0; col < numCols; col++) { // Loop through columns\r\n            resultMatrix[row][col] = matrixA[row][col] + matrixB[row][col]; \r\n        }\r\n    }\r\n}\r\n\r\n// Subtraction matrix\r\nvoid diffMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int resultMatrix[MAX][MAX], int numRows, int numCols) {\r\n    for (int row = 0; row < numRows; row++) { // Loop through rows\r\n        for (int col = 0; col < numCols; col++) { // Loop through columns\r\n            resultMatrix[row][col] = matrixA[row][col] - matrixB[row][col]; \r\n        }\r\n    }\r\n}\r\n\r\n// Transpose function\r\nvoid computeTranspose(int original[MAX][MAX], int transposed[MAX][MAX], int numRows, int numCols) {\r\n    for (int row = 0; row < numRows; row++) { // Loop through rows\r\n        for (int col = 0; col < numCols; col++) { // Loop through columns\r\n            transposed[col][row] = original[row][col]; // Swap rows and columns\r\n        }\r\n    }\r\n}\r\n\r\n// Display matrix\r\nvoid printMatrix(int matrix[MAX][MAX], int numRows, int numCols) {\r\n    for (int row = 0; row < numRows; row++) { // Loop through rows\r\n        for (int col = 0; col < numCols; col++) { // Loop through columns\r\n            printf(\"%d \", matrix[row][col]); \r\n        }\r\n        printf(\"\\n\"); \r\n    }\r\n}\r\n\r\n\r\nint main() {\r\n    int rowsMatrixA, colsMatrixA, rowsMatrixB, colsMatrixB; // Dimensions of matrices\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], resultMatrix[MAX][MAX]; // Matrices for input and results\r\n    int transposedMatrix[MAX][MAX]; // Transposed matrix\r\n    int userChoice; // User's menu choice\r\n\r\n    // Input dimensions and elements of Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsMatrixA, &colsMatrixA);\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsMatrixA, colsMatrixA);\r\n\r\n    // Input dimensions and elements of Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsMatrixB, &colsMatrixB);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsMatrixB, colsMatrixB);\r\n\r\n    \r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &userChoice); \r\n\r\n        switch (userChoice) {\r\n            case 1: // Add matrices\r\n                if (rowsMatrixA == rowsMatrixB && colsMatrixA == colsMatrixB) { // Check if dimensions match\r\n                    sumMatrices(matrixA, matrixB, resultMatrix, rowsMatrixA, colsMatrixA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(resultMatrix, rowsMatrixA, colsMatrixA); \r\n                } else {\r\n                    printf(\"Error: Matrices dimensions do not match for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2: // Subtract matrices\r\n                if (rowsMatrixA == rowsMatrixB && colsMatrixA == colsMatrixB) { // Check if dimensions match\r\n                    diffMatrices(matrixA, matrixB, resultMatrix, rowsMatrixA, colsMatrixA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(resultMatrix, rowsMatrixA, colsMatrixA); \r\n                } else {\r\n                    printf(\"Error: Matrices dimensions do not match for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3: // Transpose Matrix A\r\n                computeTranspose(matrixA, transposedMatrix, rowsMatrixA, colsMatrixA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(transposedMatrix, colsMatrixA, rowsMatrixA); \r\n                break;\r\n            case 4: // Transpose Matrix B\r\n                computeTranspose(matrixB, transposedMatrix, rowsMatrixB, colsMatrixB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(transposedMatrix, colsMatrixB, rowsMatrixB); \r\n                break;\r\n            case 5: \r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (userChoice != 5); // Loop until the user chooses to exit\r\n\r\n    return 0; // Exit the program\r\n}\n/* --- Q2(1).c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define NAME_LENGTH 100\r\n#define CATEGORY_LENGTH 50\r\n\r\n\r\ntypedef struct {\r\n    char name[NAME_LENGTH];\r\n    char category[CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    int inStock; \r\n} GroceryItem;\r\n\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int itemCount; \r\n} GroceryInventory;\r\n\r\n// Add function\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) { // Check if the inventory is full\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n    GroceryItem *item = &inventory->items[inventory->itemCount];\r\n    \r\n    // Take input for the new item\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", item->name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", item->category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n    \r\n    // Set item availability based on quantity\r\n    item->inStock = (item->quantity > 0);\r\n    inventory->itemCount++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Listing function\r\nvoid listGroceryItems(const GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) { // Check if the inventory is empty\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", item->inStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Update quantity function\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char itemName[NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        if (strcmp(item->name, itemName) == 0) { // If item is found\r\n            printf(\"Enter new quantity for %s: \", item->name);\r\n            scanf(\"%d\", &item->quantity);\r\n            item->inStock = (item->quantity > 0); // Update stock status\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    // If item is not found in the inventory\r\n    printf(\"Grocery item not found.\\n\");\r\n}\r\n\r\n// Remove function\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char itemName[NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) { // If item is found\r\n            // Shift all subsequent items one position forward to remove the item\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->itemCount--; // Decrease the item count\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n            return;\r\n        }\r\n    }\r\n    // If item is not found\r\n    printf(\"Grocery item not found.\\n\");\r\n}\r\n\r\n// Main function\r\nint main() {\r\n    GroceryInventory inventory = { .itemCount = 0 }; // Initialize inventory\r\n    int choice;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory); // Add item to inventory\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory); // Display all items\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory); // Update item quantity\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory); // Remove item from inventory\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5); // Keep running until exit option is selected\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3(1).c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocation of memory for new student:\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {  // Check if malloc succeeded\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Copy detials to new student node\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    //Next pointer NULL\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Creation of new node\r\n    Student* newStudent = createStudent(name, id, grade); \r\n    if (!newStudent) {  // Checking successful allocation of memeory\r\n        return; // If failed, return early\r\n    }\r\n\r\n    // Insert at the beginning of the list\r\n    newStudent->next = head;\r\n    head = newStudent; \r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    // Check if list is empty\r\n    if (head == NULL) { \r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    //traverse list and display details\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Move to next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    //Start at head of list\r\n    Student* current = head;\r\n    // Traverse the list\r\n    while (current != NULL) {\r\n        if (current->id == id) {// ID checking\r\n            return current;\r\n        }\r\n        current = current->next; // Move to next student\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to free memory when program exits\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return; // No need to sort if there's 0 or 1 student\r\n    }\r\n\r\n    \r\n    printf(\"Sorting grades using Bubble Sort...\\n\");\r\n\r\n    int swapped; // Flag to check if a swap occurred\r\n    Student* ptr1;\r\n    Student* ptr2 = NULL;\r\n\r\n\r\n    // Bubble sort\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != ptr2) {\r\n            // Compare grades\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap grades, IDs, and names\r\n                float tempGrade = ptr1->grade;\r\n                int tempID = ptr1->id;\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempID;\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1; // Set flag when when swap occurrs\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        ptr2 = ptr1;\r\n    } while (swapped);\r\n\r\n    // Display the sorted records\r\n    displayStudents();\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid input! Please enter a valid number.\\n\");\r\n            while (getchar() != '\\n');  // Clear invalid input\r\n            continue;\r\n        }\r\n\r\n\r\n\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n\r\n                printf(\"Enter ID: \");\r\n                if (scanf(\"%d\", &id) != 1) {\r\n                    printf(\"Invalid input! Please enter a valid ID.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    continue;\r\n                }\r\n\r\n                printf(\"Enter Grade (between 0 - 100): \");\r\n                if (scanf(\"%f\", &grade) != 1 || grade < 0 || grade > 100) {\r\n                    printf(\"Invalid grade! Please enter a value between 0 and 100.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    continue;\r\n                }\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                if (scanf(\"%d\", &id) != 1) {\r\n                    printf(\"Invalid input! Please enter a valid ID.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    continue;\r\n                }\r\n\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory(); // free remainming allocated memory\r\n                printf(\"Exiting...\\n\"); \r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\"); // error handling\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is used here for sorting student records by grade. While it's straightforward and easy to implement, it has a time complexity of O(n?), making it inefficient for larger datasets. For better performance, consider more efficient algorithms like Merge Sort or Quick Sort, especially if the number of records increases."
  },
  {
    "student_id": "20701628",
    "code": "",
    "feedback": "q1-When prompting for the dimensions of Matrix B, the prompt message incorrectly states \"Enter rows for Matrix A\" instead of \"Enter rows for Matrix B\".\nq2-Meet requirement. \nq3-The sorting algorithm is implemented correctly. However, it has a time complexity of O(n?), which may be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20697136",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n// Function prototypes\nvoid addMatrices(int a[10][10], int rowsA, int colsA, int b[10][10]);\nvoid subtractMatrices(int a[10][10], int rowsA, int colsA, int b[10][10]);\nvoid transposeA(int a[10][10], int rowsA, int colsA);\nvoid transposeB(int b[10][10], int rowsB, int colsB);\n\nint main(){\n    // initialising rows, columns, arrays\n    int rowsA;\n    int colsA;\n    int rowsB;\n    int colsB;\n    int matrixA[10][10];\n    int matrixB[10][10];\n    do{\n    // get user input for MatrixA dimensions\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    if(rowsA > 10 || colsA > 10){\n        // case if dimensions > 10, error message\n        printf(\"Invalid Input. Maximum size is 10x10.\\n\");\n        continue;\n    }\n    // get user input for the elements of the matrix\n    printf(\"Enter elements for Matrix A: \\n\");\n    for(int i = 1; i<=rowsA; i++){\n        for(int j = 1; j<=colsA; j++){\n        printf(\"Element [%d][%d]: \", i, j);\n        scanf(\"%d\", &matrixA[i-1][j-1]);\n        }\n    }\n    }while(rowsA > 10 || colsA > 10);   // loop if user input is invalid\n    \n    do{\n    // get user input for MatrixB dimensions\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    if(rowsB > 10 || colsB > 10){\n        // case if dimensions > 10, error message\n        printf(\"Invalid Input. Maximum size is 10x10.\\n\");\n        continue;\n    }\n    // get user input for the elements of the matrix\n    printf(\"Enter elements for Matrix B: \\n\");\n    for(int i = 1; i<=rowsB; i++){\n        for(int j = 1; j<=colsB; j++){\n            printf(\"Element [%d][%d]: \", i, j);\n            scanf(\"%d\", &matrixB[i-1][j-1]);\n        }\n    }\n    }while(rowsB > 10 || colsB > 10);   // loop if user input is invalid\n\n    int choice;\n    do{\n    // print main menu display\n    printf(\"\\t----------------------------------------\\n\");\n    printf(\"\\tMatrix Operations Menu:\\n\");\n    printf(\"\\t1. Add Matrices\\n\");\n    printf(\"\\t2. Subtract Matrices\\n\");\n    printf(\"\\t3. Transpose Matrix A\\n\");\n    printf(\"\\t4. Transpose Matrix B\\n\");\n    printf(\"\\t5. Exit\\n\");\n    printf(\"\\t----------------------------------------\\n\");\n\n        printf(\"\\tEnter your choice: \");\n        // Get input from user\n        scanf(\"%d\", &choice);\n        getchar(); // read newline\n        // switch case handling different user inputs\n        switch (choice) {\n            case 1:\n                addMatrices(matrixA, rowsA, colsA, matrixB);\n                break;\n            case 2:\n                subtractMatrices(matrixA, rowsA, colsA, matrixB);\n                break;\n            case 3:\n                transposeA(matrixA, rowsA, colsA);\n                break;\n            case 4: \n                transposeB(matrixB, rowsB, colsB);\n                break;\n            case 5:\n                printf(\"\\n\\t----------------------------------------------------------\\n\");\n                printf(\"\\tExiting the Program...\");\n                printf(\"\\n\\t----------------------------------------------------------\\n\");\n                break;\n            default:\n                printf(\"\\tInvalid input. Please input a number from 1 - 5.\\n\");\n                break;\n        }\n    }while(choice != 5); // loop while user input is not the exit code\n    return 0;\n}\n\n// Function for addition of Matrices\nvoid addMatrices(int a[10][10], int rowsA, int colsA, int b[10][10]){\n    printf(\"Result of Matrix A + Matrix B\\n\");\n    for(int i = 1; i<=rowsA; i++){\n        for(int j = 1; j<=colsA; j++){\n            printf(\"%d \", a[i-1][j-1] + b[i-1][j-1]); // print each element from A and B, added to eachother\n        }\n        printf(\"\\n\"); // newline for proper matrix format\n    }\n}\n// Function for subtraction of Matrices\nvoid subtractMatrices(int a[10][10], int rowsA, int colsA, int b[10][10]){\n    printf(\"Result of Matrix A - Matrix B\\n\");\n    for(int i = 1; i<=rowsA; i++){\n        for(int j = 1; j<=colsA; j++){\n            printf(\"%d \", a[i-1][j-1] - b[i-1][j-1]); // print each element from A and B, subtracted from eachother\n        }\n        printf(\"\\n\"); // newline for proper matrix format\n    }\n}\n// Function for transpositon of Matrix A\nvoid transposeA(int a[10][10], int rowsA, int colsA){\n    printf(\"Transpose of Matrix A: \\n\");\n    for(int i = 1; i<=rowsA; i++){\n        for(int j = 1; j<=colsA; j++){\n            printf(\"%d \", a[j-1][i-1]); // print [i] of matrixA as [j], and vice versa\n        }\n        printf(\"\\n\"); // newline for proper formatting\n    }\n}\n// Function for transposition of Matrix B\nvoid transposeB(int b[10][10], int rowsB, int colsB){\n    printf(\"Transpose of Matrix B: \\n\");\n    for(int i = 1; i<=rowsB; i++){\n        for(int j = 1; j<=colsB; j++){\n            printf(\"%d \", b[j-1][i-1]); // print [i] of matrixB as [j], and vice versa\n        }\n        printf(\"\\n\"); // newline for proper formatting\n    }\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <stdbool.h>\n#include <ctype.h>\n#include <string.h>\n\n// structs\ntypedef struct { // struct for individual items\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n} item;\ntypedef struct { // struct for availability status\n    bool inStock;\n    bool outStock;\n} availability;\nstruct i{ // struct for inventory as a whole\n    item list[100];\n    availability status[100];\n    int counter;\n} inventory;\n\n// function prototypes\nvoid addItem();\nvoid displayItems();\nvoid updateItem();\nvoid deleteItem();\n\n// main function\nint main(){\n    int mainChoice = 0;\n\n    // main menu\n    do{    \n    printf(\"\\t----------------------------------------\\n\");\n    printf(\"\\tGrocery Inventory Management System\\n\");\n    printf(\"\\t1. Add Grocery Item\\n\");\n    printf(\"\\t2. List All Grocery Items\\n\");\n    printf(\"\\t3. Update Quantity\\n\");\n    printf(\"\\t4. Remove Grocery Item\\n\");\n    printf(\"\\t5. Exit\\n\");\n    printf(\"\\t----------------------------------------\\n\");\n\n        printf(\"\\tEnter your choice: \");\n        // Get input from user\n        scanf(\"%d\", &mainChoice);\n        getchar(); // read new line\n\n        // switch case handling user inputs\n        switch (mainChoice) {\n            case 1:\n                addItem();\n                break;\n            case 2:\n                displayItems();\n                break;\n            case 3:\n                updateItem();\n                break;\n            case 4: \n                deleteItem();\n                break;\n            case 5:\n                printf(\"\\n\\t----------------------------------------------------------\\n\");\n                printf(\"\\tThank you for using the Grocery Inventory Management System!\\n\\tExiting the Program.\");\n                printf(\"\\n\\t----------------------------------------------------------\\n\");\n                break;\n            default:\n                printf(\"\\tInvalid input. Please input a number from 1 - 5.\\n\");\n                break;\n        }\n    }while(mainChoice != 5); // loop while user input is not exit code\n    return 0;\n}    \n// add grocery item\nvoid addItem(){\n    // prompt for and get user input for name\n    printf(\"\\n\\tEnter Item Name: \");\n    fgets(inventory.list[inventory.counter].name, 100, stdin);\n    // remove new line\n    inventory.list[inventory.counter].name[strcspn(inventory.list[inventory.counter].name, \"\\n\")] = '\\0';\n\n    // prompt for and get user input for email\n    printf(\"\\tEnter Category: \");\n    fgets(inventory.list[inventory.counter].category, 50, stdin);\n    // remove new line\n    inventory.list[inventory.counter].category[strcspn(inventory.list[inventory.counter].category, \"\\n\")] = '\\0';\n\n    // prompt for and get user input for quantity\n    printf(\"\\tEnter Quantity: \");\n    scanf(\"%d\", &inventory.list[inventory.counter].quantity);\n    getchar(); // read new line\n\n    // prompt for and get user input for price\n    printf(\"\\tEnter Price: \");\n    scanf(\"%f\", &inventory.list[inventory.counter].price);\n    getchar(); // read new line\n\n    // success message\n    printf(\"\\tGrocery Item added successfully!\\n\");\n    inventory.counter++; // increment item counter\n}\n// list all grocery items and their availability\nvoid displayItems(){\n    if(inventory.counter == 0){ // base case if there are no items saved\n        printf(\"\\n\\tNo grocery items in the inventory.\\n\");\n    }\n    for(int i=0; i<inventory.counter; i++){\n        char currentStatus[15];\n        printf(\"\\n\\t----------------------------------------\\n\");\n        // printf name, category, quantity, price of each item\n        printf(\"\\tName: %s\\n\", inventory.list[i].name);\n        printf(\"\\tCategory: %s\\n\", inventory.list[i].category);\n        printf(\"\\tQuantity: %d\\n\", inventory.list[i].quantity);\n        printf(\"\\tPrice: %.2f\\n\", inventory.list[i].price);        \n        // set general condition for in/out of stock\n        if (inventory.list[i].quantity == 0){ // if quantity of item is 0\n            inventory.status[i].outStock = true; // set out of stock as true\n        }\n        else{\n            inventory.status[i].inStock = true; // else if it has quantity>0, set in stock as true\n        }\n        // print status of each item\n        if(inventory.status[i].outStock){ // if out of stock = true\n            printf(\"\\tStatus: Out of stock\\n\"); // print status\n        }\n        else if(inventory.status[i].inStock){ // if in stock = true\n            printf(\"\\tStatus: In Stock\\n\"); // print status\n        }\n    }\n}\n// update the quantity of a grocery item\nvoid updateItem(){\n    char updateChoice[100];\n    printf(\"\\tEnter the name of the item to update quantity: \");\n    // user enters name of item to edit\n    fgets(updateChoice, 100, stdin);\n    updateChoice[strcspn(updateChoice, \"\\n\")] = '\\0'; // remove new line\n\n    for(int i=0; i<inventory.counter; i++){\n        // if user input matches any saved item:\n        if(strcmp(inventory.list[i].name, updateChoice) == 0){\n            // enter new quantity\n            printf(\"\\tEnter new quantity for %s: \", inventory.list[i].name);\n            scanf(\"%d\", &inventory.list[i].quantity);\n            getchar(); // read new line\n            printf(\"\\n\\tQuantity updated successfully!\\n\"); // success message\n            break;\n        }\n        // if user input does not match any saved item:\n        else if((i==inventory.counter-1) && strcmp(inventory.list[i].name, updateChoice) != 0){\n            printf(\"\\n\\tGrocery item not found. \\n\"); // print error message\n        }\n    }\n} \n// remove a grocery item from the inventory\nvoid deleteItem(){\n    char deleteChoice[100];\n    printf(\"\\tEnter the name of the item to delete: \");\n    // user enters name of item to delete\n    fgets(deleteChoice, 100, stdin);\n    deleteChoice[strcspn(deleteChoice, \"\\n\")] = '\\0'; // remove new line\n\n    for(int i=0; i<inventory.counter; i++){\n        // if user input matches any saved item:\n        if(strcmp(inventory.list[i].name, deleteChoice) == 0){\n            // delete item\n            inventory.list[i] = inventory.list[i+1];\n            inventory.counter--; // decrement item counter\n            printf(\"\\tGrocery item removed successfully!\\n\\n\"); // success message\n            break;\n        }\n        // if user input does not match any saved item:\n        else if((i==inventory.counter-1) && strcmp(inventory.list[i].name, deleteChoice) != 0){\n            printf(\"\\n\\tGrocery item not found. \\n\"); // print error message\n        }\n    }\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents(Student* head);\nStudent* searchStudentByID(int id);\nvoid sortStudents();\nvoid deleteList();\nvoid freeMemory();\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (choose sorting method)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents(head);\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                searchStudentByID(id);\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n            }\n        } while (choice != 6);\n    return 0;\n}\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    head = (Student*) malloc(sizeof(Student)); // allocate memory space\n    if (head == NULL){\n        printf(\"No Memory Available. \\n\"); // error message\n    } \n    else {\n        // defining elements\n        strcpy(head->name,name); \n        head->id = id;\n        head->grade = grade;\n        head->next = NULL;\n    }\n    return head;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    createStudent(name, id, grade);\n}\n\n// Function to display all student records\nvoid displayStudents(Student* head) {\n    Student * current = head;\n    if(current == NULL){\n        printf(\"No student records to display.\\n\");\n    }\n    while(current != NULL){ // while there are elements\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", head->name, head->id, head->grade); // print their data\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    if (id == head->id){ // if user input is equal to an ID\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", head->name, head->id, head->grade); // print the student's data\n    }\n    else {\n        printf(\"Student not found.\\n\"); // if it is not equal, print error message\n    }\n    return 0;\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() {\n    //qsort(, , sizeof(), );\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\nvoid freeMemory() {\n    deleteList();\n}",
    "feedback": "q1-The transposeA and transposeB functions incorrectly access the matrix elements. The loop indices should be swapped when printing the transposed values.\nq2-In the deleteItem function, after deleting an item, the remaining items are not properly shifted. The loop only shifts one item, which can lead to data inconsistency. It should shift all items from the deleted index to the end of the list.\nq3-    Memory Management: The createStudent function reassigns head every time it's called, which means only the last student created will be referenced in the list. You should append new students instead of overwriting head.    Display Function: In the displayStudents function, the wrong pointer is used (head instead of current) to print student details.    Search Function: The searchStudentByID function only checks against the head's ID. It should iterate through the entire list to find the student.    Sorting Function: The sortStudents function is incomplete and lacks implementation.Sorting Algorithm: None implemented yet."
  },
  {
    "student_id": "20609412",
    "code": "\n/* --- Q1.c --- */\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n\r\nvoid getMatrixElement(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char name);\r\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid subMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\n\r\n\r\n// Main function\r\nint main(void) {\r\n\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n\r\n    char choice[2];\r\n\r\n    // Input dimensions of matrices A\r\n    do {\r\n        printf(\"Enter the dimensions of Matrix A (rows cols): \");\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n    } while (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE);\r\n\r\n    // Input elements of matrices A\r\n    getMatrixElement(rowsA, colsA, matrixA, 'A');\r\n\r\n    // Input dimensions of matrices B\r\n    do {\r\n        printf(\"Enter the dimensions of Matrix B (rows cols): \");\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n    } while (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE);\r\n    \r\n    // Input elements of matrices B\r\n    getMatrixElement(rowsB, colsB, matrixB, 'B');\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"\\n1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"\\nEnter your choice: \");\r\n        scanf(\"%s\", choice);  // Read input as string\r\n \r\n        \r\n        if (strlen(choice) != 1) {\r\n            printf(\"Invalid choice! Please select a valid option (1-5).\\n\");\r\n            continue;\r\n        }\r\n\r\n        switch (choice[0]) {\r\n            case '1': \r\n                //check if rows of A and B and columns of A and B are the same for addition\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Error: Matrices dimensions do not match for addition.\\n\");  \r\n                }\r\n                break;\r\n            case '2': \r\n                //check if rows of A and B and columns of A and B are the same for subtraction\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Error: Matrices dimensions do not match for subtraction.\\n\");  \r\n                } \r\n                break;\r\n            case '3': \r\n                transposeMatrix(rowsA, colsA, matrixA, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n            case '4': \r\n                transposeMatrix(rowsB, colsB, matrixB, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n            case '5':\r\n                printf(\"Exiting the program. Goodbye!\\n\"); \r\n                break;\r\n            default: \r\n                printf(\"Invalid choice! Please select a valid option (1-8).\\n\");\r\n        }\r\n\r\n    }  while (choice[0] != '5');  // Loop until user chooses to exit\r\n\r\n\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n// get elements of the matrices\r\nvoid getMatrixElement(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char name) {\r\n    printf(\"Enter elements of Matrix %c:\\n\", name);\r\n\r\n    // Loop through each row and column to get the matrix elements\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element Matrix %c[%d][%d]: \", name, i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// add matrices function\r\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    // Loop through each element of the matrices A and B\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n\r\n            // Add corresponding elements of A and B, store the result in the result matrix\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// add matrices function\r\nvoid subMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    // Loop through each element of the matrices A and B\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            // Subtract corresponding elements of B from A and store the result\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to transpose matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    // Loop through each element of the matrices A and B\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            // Transpose the element by swapping rows and columns\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// print out the matrix results function\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    // Loop through each element of the matrices A and B\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%4d\", matrix[i][j]); // Allocate 4-character width for each number\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\n\n/* --- Q2.c --- */\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n\r\n// Structure for all contact information\r\nstruct groceryItem {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\nstruct availabilityStatus {\r\n    bool inStock;\r\n    bool outOfStock;\r\n};\r\n\r\nstruct groceryInventory {\r\n    struct groceryItem items[MAX_ITEMS];\r\n    struct availabilityStatus availability[MAX_ITEMS];\r\n    int totalGroceries;\r\n};\r\n\r\nvoid addGroceryItem(struct groceryInventory *inventory);\r\nvoid listGroceryItem(struct groceryInventory *inventory);\r\nvoid updateGroceryQuantity(struct groceryInventory *inventory);\r\nvoid removeGroceryItem(struct groceryInventory *inventory);\r\n\r\nint main(void) {\r\n\r\n    struct groceryInventory inventory = {0};\r\n\r\n    char choice[2];  \r\n    \r\n    do {\r\n        // Display menu\r\n        printf(\"\\nGrocery Inventory Management System\");\r\n        printf(\"\\n1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"\\nEnter your choice: \");\r\n        scanf(\"%s\", choice);  // Read input as string\r\n \r\n        \r\n        if (strlen(choice) != 1) {\r\n            printf(\"Invalid choice! Please select a valid option (1-5).\\n\");\r\n            continue;\r\n        }\r\n\r\n        switch (choice[0]) {\r\n            case '1': \r\n                addGroceryItem(&inventory); \r\n                break;\r\n            case '2': \r\n                listGroceryItem(&inventory);\r\n                break;\r\n            case '3': \r\n                updateGroceryQuantity(&inventory); \r\n                break;\r\n            case '4': \r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case '5':\r\n                printf(\"Exiting the program. Goodbye!\\n\"); \r\n                break;\r\n            default: \r\n                printf(\"Invalid choice! Please select a valid option (1-5).\\n\");\r\n        }\r\n\r\n    }  while (choice[0] != '5');  // Loop until user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\r\n// Add a grocery item to the inventory\r\nvoid addGroceryItem(struct groceryInventory *inventory) {\r\n\r\n    //check if inventory is full\r\n    if (inventory->totalGroceries >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Get the details for the grocery item\r\n    struct groceryItem item;\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", item.name);\r\n\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", item.category);\r\n\r\n    // Get and validate quantity (must be a number)\r\n    printf(\"Enter Quantity: \");\r\n\r\n    while (scanf(\"%d\", &item.quantity) != 1) {\r\n        // Invalid input for integer\r\n        printf(\"Please input a valid integer for quantity: \");\r\n        while (getchar() != '\\n');  // Clear the buffer\r\n    }\r\n\r\n    // Get and validate price (must be a number)\r\n    printf(\"Enter Price: \");\r\n    while (scanf(\"%f\", &item.price) != 1) {\r\n        // Invalid input for float\r\n        printf(\"Please input a valid number for price: \");\r\n        while (getchar() != '\\n');  // Clear the buffer\r\n    }\r\n\r\n    // Determine availability based on quantity\r\n    struct availabilityStatus status = {item.quantity > 0};\r\n\r\n    // Add the item to the inventory\r\n    inventory->items[inventory->totalGroceries] = item;\r\n    inventory->availability[inventory->totalGroceries] = status;\r\n    inventory->totalGroceries++;\r\n\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n\r\n// List all the grocery items\r\nvoid listGroceryItem(struct groceryInventory *inventory) {\r\n\r\n    // Check if the inventory is empty\r\n    if (inventory->totalGroceries == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n\r\n    } else {\r\n        //print out the inventory list\r\n        for (int i = 0; i < inventory->totalGroceries; i++) {\r\n\r\n            // Determine item status is in stock or out stock\r\n            const char *status = inventory->availability[i].inStock ? \"In Stock\" : \"Out of Stock\";\r\n    \r\n            printf(\"Name:\\t\\t %s\\n\", inventory->items[i].name);\r\n            printf(\"Category:\\t %s\\n\", inventory->items[i].category);\r\n            printf(\"Quantity:\\t %d\\n\", inventory->items[i].quantity);\r\n            printf(\"Price:\\t\\t %.2f\\n\", inventory->items[i].price);\r\n            printf(\"Status:\\t\\t %s\\n\", status);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n// Update a grocery's quantity\r\nvoid updateGroceryQuantity(struct groceryInventory *inventory) {\r\n\r\n    // Check if the inventory is empty\r\n    if (inventory->totalGroceries == 0) {\r\n        printf(\"Inventory is empty. No items found.\\n\");\r\n        return;\r\n    }\r\n\r\n    //get the item name to update\r\n    char name[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    // Loop through all items and find the one that matches the user input\r\n    for (int i = 0; i < inventory->totalGroceries; i++) {\r\n\r\n        // if matches, get the new quantity\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            // update the quantity and availability status  \r\n            inventory->items[i].quantity = newQuantity;\r\n            inventory->availability[i].inStock = newQuantity > 0;\r\n            inventory->availability[i].outOfStock = newQuantity == 0;\r\n\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n\r\n// remove grocery item from inventory\r\nvoid removeGroceryItem(struct groceryInventory *inventory) {\r\n    // Check if the inventory is empty\r\n    if (inventory->totalGroceries == 0) {\r\n        printf(\"Inventory is empty. No items found.\\n\");\r\n        return;\r\n    }\r\n\r\n    //get the item name to remove\r\n    char name[100];\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    // Loop through all items and find the one that matches the user input\r\n    for (int i = 0; i < inventory->totalGroceries; i++) {\r\n\r\n        // if matches, shift all subsequent items one position to the left to delete the item\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->totalGroceries - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->totalGroceries--; //decrement the total groceries number\r\n\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n\r\n    //allocate memory for pointer\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    //copy the input values into the new student nodes\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student\r\n    Student* newStudent = createStudent(name, id, grade);\r\n\r\n    // Check if memory allocation for the new student failed\r\n    if (!newStudent) {\r\n        printf(\"Error: Memory allocation failed for the new student.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Insert the new student at the beginning of the list\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n\r\n    // Confirm the successful insertion\r\n    printf(\"Student '%s' with ID %d has been successfully added.\\n\", name, id);\r\n}\r\n\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    //set the head to a temp pointer\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    printf(\"--------------------------------------------------\\n\");\r\n    while (temp) {\r\n        printf(\"Name: %-15s ID: %-10d Grade: %-3.2f\\n\", temp->name, temp->id, temp->grade);\r\n        //make temp pointer to the next node in the link list\r\n        temp = temp->next;\r\n    }\r\n    printf(\"--------------------------------------------------\\n\");\r\n}\r\n\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n\r\n    //set the head to a temp pointer\r\n    Student* temp = head;\r\n    //continue looping if it is not the end of the link list\r\n    while (temp){\r\n\r\n        // If the student ID matches the input, return the corresponding student node\r\n        if (temp->id == id){\r\n            return temp;\r\n        } else {\r\n            temp = temp->next;\r\n        }\r\n        return NULL;\r\n    }\r\n\r\n}\r\n\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n    next = current->next;\r\n    free(current);\r\n    current = next;\r\n    }\r\n\r\n    head = NULL;\r\n}\r\n\r\n\r\nvoid freeMemory() {\r\n deleteList();\r\n}\r\n\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr;\r\n    Student* last = NULL;\r\n\r\n    // Continue looping until no more swaps are needed\r\n    do {\r\n        swapped = 0;\r\n        ptr = head;\r\n\r\n        //continue looping if pointer is not pointing the last node\r\n        while (ptr->next != last) {\r\n\r\n            //if current node is greater than the next node\r\n            if (ptr->grade > ptr->next->grade) {\r\n                \r\n                // Swap the grade, ID, and name of the current and next nodes\r\n                float tempGrade = ptr->grade;\r\n                int tempID = ptr->id;\r\n                char tempName[100];\r\n                strcpy(tempName, ptr->name);\r\n\r\n                ptr->grade = ptr->next->grade;\r\n                ptr->id = ptr->next->id;\r\n                strcpy(ptr->name, ptr->next->name);\r\n\r\n                ptr->next->grade = tempGrade;\r\n                ptr->next->id = tempID;\r\n                strcpy(ptr->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr = ptr->next;    // Move to the next node\r\n        }\r\n        last = ptr; // Update the last node to mark the boundary for the next pass\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar(); // To consume the newline character\r\n    \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                found->name, found->id, found->grade);\r\n                } else {\r\n                printf(\"Student not found.\\n\");\r\n                }\r\n            break;\r\n\r\n            case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n} \r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The return NULL; statement in the searchStudentByID function is incorrectly placed inside the loop. It should be outside the while loop to ensure it only executes if the end of the list is reached without finding a match."
  },
  {
    "student_id": "20705878",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10   // Define the maximum matrix size as 10x10 to restrict input.\n\n// Function prototypes for every function\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int A[MAX_SIZE][MAX_SIZE], int T[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], C[MAX_SIZE][MAX_SIZE];   // Declare matrices A, B, and C\n    int T_A[MAX_SIZE][MAX_SIZE], T_B[MAX_SIZE][MAX_SIZE];                      // Declare matrices to store transposed matrices\n    int rowsA, colsA, rowsB, colsB;                       // Variables to store dimensions of matrices A and B\n    int choice;                                           // Variable to store user's choice from the menu\n\n    // Input dimensions for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);                                            // Read dimensions for Matrix A\n    while (rowsA < 1 || rowsA > 10 || colsA < 1 || colsA > 10) {               // Validate dimensions\n        printf(\"Invalid dimensions. Enter dimensions for Matrix A (rows and columns): \");\n        scanf(\"%d %d\", &rowsA, &colsA);                  // Re-read dimensions if invalid\n    }\n\n    // Input elements for Matrix A\n    printf(\"Enter elements for Matrix A:\\n\");\n    for (int i = 0; i < rowsA; i++) {            // Iterate through each row\n        for (int j = 0; j < colsA; j++) {        // Iterate through each column.\n            printf(\"Element [%d][%d]: \", i+1, j+1);     // Prompt user for input at position (i+1, j+1)\n            scanf(\"%d\", &A[i][j]);                      // Read the element into the matrix\n        }\n    }\n\n    // Input dimensions for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    while (rowsB < 1 || rowsB > 10 || colsB < 1 || colsB > 10) {\n        printf(\"Invalid dimensions. Enter dimensions for Matrix B (rows and columns): \");\n        scanf(\"%d %d\", &rowsB, &colsB);\n    }\n\n    // Input elements for Matrix B\n    printf(\"Enter elements for Matrix B:\\n\");\n    for (int i = 0; i < rowsB; i++) {\n        for (int j = 0; j < colsB; j++) {\n            printf(\"Element [%d][%d]: \", i+1, j+1);\n            scanf(\"%d\", &B[i][j]);\n        }\n    }\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);     // Read user's choice\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) {               // Check if matrices have the same dimensions\n                    addMatrices(A, B, C, rowsA, colsA);               // Call function to add matrices\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    printMatrix(C, rowsA, colsA);                     // Print the result\n                } else {\n                    printf(\"Error! Matrices must have the same dimensions for addition.\\n\");\n                }\n                break;\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(A, B, C, rowsA, colsA);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    printMatrix(C, rowsA, colsA);\n                } else {\n                    printf(\"Error! Matrices must have the same dimensions for subtraction.\\n\");\n                }\n                break;\n            case 3:\n                transposeMatrix(A, T_A, rowsA, colsA);\n                printf(\"Transpose of Matrix A:\\n\");\n                printMatrix(T_A, colsA, rowsA);\n                break;\n            case 4:\n                transposeMatrix(B, T_B, rowsB, colsB);\n                printf(\"Transpose of Matrix B:\\n\");\n                printMatrix(T_B, colsB, rowsB);\n                break;\n            case 5:\n                printf(\"Exiting program. Goodbye!\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);         // Loop until user chooses to exit\n\n    return 0;\n}\n\n// Function to add two matrices\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {                // Iterate through each row\n        for (int j = 0; j < cols; j++) {            // Iterate through each column\n            C[i][j] = A[i][j] + B[i][j];            // Add corresponding elements of A and B and store in C\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            C[i][j] = A[i][j] - B[i][j];           // Subtract corresponding elements of B from A and store in C\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix(int A[MAX_SIZE][MAX_SIZE], int T[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            T[j][i] = A[i][j];                    // Swap rows and columns to transpose the matrix\n        }\n    }\n}\n\n// Function to print a matrix\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);          // Print each element\n        }\n        printf(\"\\n\");                             // Move to the next row\n    }\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100 // Maximum number of grocery items\n\n// Structure for a grocery item\ntypedef struct {\n    char name[100];  // Name of the item\n    char category[50];  // Category of the item\n    int quantity;  // Quantity of the item\n    float price;  // Price of the item\n    bool inStock;  // Availability status\n} GroceryItem;\n\n// Array to store grocery items and the count of items\nGroceryItem inventory[MAX_ITEMS];\nint itemCount = 0;\n\n// Function to add a new grocery item\nvoid addGroceryItem() {\n    if (itemCount >= MAX_ITEMS) { // Check if inventory is full\n        printf(\"Error: Inventory is full!\\n\");\n        return;\n    }\n    \n    GroceryItem newItem; // Create a new grocery item\n    \n    printf(\"Enter name: \");\n    scanf(\" %[^\\n]\", newItem.name); // Read item name\n    printf(\"Enter category: \");\n    scanf(\" %[^\\n]\", newItem.category); // Read category\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &newItem.quantity); // Read quantity\n    printf(\"Enter price: \");\n    scanf(\"%f\", &newItem.price); // Read price\n    \n    // Set availability status based on quantity\n    newItem.inStock = (newItem.quantity > 0);\n    \n    inventory[itemCount++] = newItem; // Add item to the inventory\n    printf(\"Item added successfully!\\n\");\n}\n\n// Function to list all grocery items\nvoid listGroceryItems() {\n    if (itemCount == 0) { // Check if inventory is empty\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n    \n    printf(\"\\nGrocery Inventory:\\n\");\n    printf(\"-------------------------------------------------\\n\");\n    for (int i = 0; i < itemCount; i++) { // Iterate through all items\n        printf(\"Item %d:\\n\", i + 1);\n        printf(\"Name: %s\\n\", inventory[i].name);\n        printf(\"Category: %s\\n\", inventory[i].category);\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\n        printf(\"Price: %.2f\\n\", inventory[i].price);\n        printf(\"Availability: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\n        printf(\"-------------------------------------------------\\n\");\n    }\n}\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity() {\n    char name[100];\n    int newQuantity;\n    \n    printf(\"Enter the name of the item to update: \");\n    scanf(\" %[^\\n]\", name); // Read item name\n    \n    for (int i = 0; i < itemCount; i++) { // Search for the item\n        if (strcmp(inventory[i].name, name) == 0) {\n            printf(\"Enter new quantity: \");\n            scanf(\"%d\", &newQuantity); // Read new quantity\n            \n            inventory[i].quantity = newQuantity;\n            inventory[i].inStock = (newQuantity > 0); // Update availability\n            \n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    \n    printf(\"Error: Item not found.\\n\");\n}\n\n// Function to remove a grocery item\nvoid removeGroceryItem() {\n    char name[100];\n    \n    printf(\"Enter the name of the item to remove: \");\n    scanf(\" %[^\\n]\", name); // Read item name\n    \n    for (int i = 0; i < itemCount; i++) { // Search for the item\n        if (strcmp(inventory[i].name, name) == 0) {\n            // Shift remaining items\n            for (int j = i; j < itemCount - 1; j++) {\n                inventory[j] = inventory[j + 1];\n            }\n            itemCount--; // Decrement item count\n            printf(\"Item removed successfully!\\n\");\n            return;\n        }\n    }\n    \n    printf(\"Error: Item not found.\\n\");\n}\n\nint main() {\n    int choice;\n    \n    do {\n        printf(\"\\nGrocery Inventory Management:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            case 1:\n                addGroceryItem();\n                break;\n            case 2:\n                listGroceryItems();\n                break;\n            case 3:\n                updateQuantity();\n                break;\n            case 4:\n                removeGroceryItem();\n                break;\n            case 5:\n                printf(\"Exiting program. Goodbye!\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n    return 0;\n}\n\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for a student node\ntypedef struct Student {\n    char name[100];       // Student name\n    int id;               // Student ID\n    float grade;          // Student grade\n    struct Student* next; // Pointer to the next node\n} Student;\n\nStudent* head = NULL;     // Pointer to the head of the linked list\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));      // Allocate memory for the new student\n    strcpy(newStudent->name, name); // Copy name to the new student\n    newStudent->id = id;            // Set ID\n    newStudent->grade = grade;      // Set Grade\n    newStudent->next = NULL;        // Initialize next pointer to NULL\n    return newStudent;              // Return the new student node\n}\n\n// Function to insert a student record into the linked list\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);         // Create a new student node\n    newStudent->next = head;                                      // Insert at the beginning of the list\n    head = newStudent;                                            // Update head to point to the new student\n    printf(\"Student record inserted successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    Student* temp = head;            // Start from the head of the list\n    if (temp == NULL) {\n        printf(\"No student records available.\\n\");\n        return;\n    }\n    printf(\"\\nStudent Records:\\n\");\n    while (temp != NULL) {           // Traverse the list\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;           // Move to the next node\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;                        // Start from the head of the list\n    while (temp != NULL) {                       // Traverse the list\n        if (temp->id == id) return temp;         // Return the student if ID matches\n        temp = temp->next;                       // Move to the next node\n    }\n    return NULL;                                 // Return NULL if not found\n}\n\n// Function to delete the entire linked list\nvoid deleteList() {\n    Student* temp = head;\n    while (temp != NULL) {                // Traverse the list\n        Student* next = temp->next;       // Save the next node\n        free(temp);                       // Free the current node\n        temp = next;                      // Move to the next node\n    }\n    head = NULL; // Reset head\n    printf(\"All student records deleted successfully.\\n\");\n}\n\n// Function to sort students by grade using bubble sort\nvoid sortStudents() {\n    if (!head || !head->next) return;                          // No sorting needed for 0 or 1 element\n    int swapped;\n    do {\n        swapped = 0;\n        Student* current = head;\n        Student* prev = NULL;\n        while (current->next != NULL) {                        // Traverse the list\n            if (current->grade > current->next->grade) {       // Swap if out of order\n                // Swap logic\n                Student* temp = current->next;\n                current->next = temp->next;\n                temp->next = current;\n                if (prev == NULL) head = temp;                 // Update head if swapping the first node\n                else prev->next = temp;\n                swapped = 1;\n            }\n            prev = current;        // Move to the next node\n            current = current->next;\n        }\n    } while (swapped);             // Repeat until no swaps\n    printf(\"Student records sorted by grade successfully!\\n\");\n}\n\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n    do {\n        printf(\"\\nStudent Records Management:\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete All Records\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();    // Consume newline\n        \n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");  \n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                else printf(\"Student not found.\\n\");\n                break;\n            case 5:\n                deleteList();\n                break;\n            case 6:\n                deleteList();\n                printf(\"Exiting program. Goodbye!\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation correctly sorts student records by grade. While bubble sort is straightforward, its time complexity of O(n?) can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance in larger applications."
  },
  {
    "student_id": "20613139",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Function declarations\r\nvoid inputMatrix(int matrix[10][10], int rows, int cols);    // Function to input matrix elements\r\nvoid displayMatrix(int matrix[10][10], int rows, int cols); // Function to display a matrix\r\nvoid addMatrices(int a[10][10], int b[10][10], int result[10][10], int rows, int cols);   // Add two matrices\r\nvoid subtractMatrices(int a[10][10], int b[10][10], int result[10][10], int rows, int cols); // Subtract two matrices\r\nvoid transposeMatrix(int matrix[10][10], int result[10][10], int rows, int cols); // Transpose a matrix\r\n\r\nint main() {\r\n    // Declare matrices and their dimensions\r\n    int a[10][10], b[10][10], result[10][10];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for matrices\r\n    printf(\"Enter dimensions of Matrix A (rows and columns, max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    printf(\"Enter dimensions of Matrix B (rows and columns, max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Check if dimensions exceed limits\r\n    if (rowsA > 10 || colsA > 10 || rowsB > 10 || colsB > 10) {\r\n        printf(\"Matrix dimensions exceed the limit (10x10).\\n\");\r\n        return 1; // Exit program if dimensions are invalid\r\n    }\r\n\r\n    // Input matrices\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(a, rowsA, colsA);\r\n\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(b, rowsB, colsB);\r\n\r\n    // Menu-driven operations\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Perform addition if dimensions match\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(a, b, result, rowsA, colsA);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible due to dimension mismatch.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // Perform subtraction if dimensions match\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(a, b, result, rowsA, colsA);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible due to dimension mismatch.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Transpose Matrix A\r\n                transposeMatrix(a, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                // Transpose Matrix B\r\n                transposeMatrix(b, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input elements of a matrix\r\nvoid inputMatrix(int matrix[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]); \r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int matrix[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int a[10][10], int b[10][10], int result[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract one matrix from another\r\nvoid subtractMatrices(int a[10][10], int b[10][10], int result[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[10][10], int result[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Define maximum sizes for arrays\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Struct to store grocery item information\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];       // Name of the item\r\n    char category[MAX_CATEGORY_LEN]; // Category of the item\r\n    int quantity;                 // Quantity of the item\r\n    float price;                  // Price of the item\r\n    int inStock;                  // Availability status (1 = in stock, 0 = out of stock)\r\n} GroceryItem;\r\n\r\n// Function declarations\r\nvoid addItem(GroceryItem inventory[], int* count);\r\nvoid listItems(GroceryItem inventory[], int count);\r\nvoid updateQuantity(GroceryItem inventory[], int count);\r\nvoid removeItem(GroceryItem inventory[], int* count);\r\n\r\nint main() {\r\n    GroceryItem inventory[MAX_ITEMS]; // Array to store grocery items\r\n    int itemCount = 0;                // Current number of items in inventory\r\n    int choice;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nGrocery Inventory Management\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(inventory, &itemCount); // Add a new item to the inventory\r\n                break;\r\n            case 2:\r\n                listItems(inventory, itemCount); // List all items with their details\r\n                break;\r\n            case 3:\r\n                updateQuantity(inventory, itemCount); // Update the quantity of an existing item\r\n                break;\r\n            case 4:\r\n                removeItem(inventory, &itemCount); // Remove an item from the inventory\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a new item to the inventory\r\nvoid addItem(GroceryItem inventory[], int* count) {\r\n    if (*count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    // Input details for the new item\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, MAX_NAME_LEN, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LEN, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Set availability based on quantity\r\n    newItem.inStock = (newItem.quantity > 0);\r\n\r\n    // Add the new item to the inventory\r\n    inventory[*count] = newItem;\r\n    (*count)++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all items in the inventory\r\nvoid listItems(GroceryItem inventory[], int count) {\r\n    if (count == 0) {\r\n        printf(\"No Grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nCurrent Inventory:\\n\");\r\n    for (int i = 0; i < count; i++) {\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", inventory[i].name);\r\n        printf(\"  Category: %s\\n\", inventory[i].category);\r\n        printf(\"  Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"  Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"  Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an existing item\r\nvoid updateQuantity(GroceryItem inventory[], int count) {\r\n    char itemName[MAX_NAME_LEN];\r\n    int newQuantity;\r\n\r\n    // Input the name of the item to update\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(itemName, MAX_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    // Search for the item in the inventory\r\n    for (int i = 0; i < count; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            // Update the item's quantity and availability status\r\n            inventory[i].quantity = newQuantity;\r\n            inventory[i].inStock = (newQuantity > 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove an item from the inventory\r\nvoid removeItem(GroceryItem inventory[], int* count) {\r\n    char itemName[MAX_NAME_LEN];\r\n\r\n    // Input the name of the item to remove\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, MAX_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    // Search for the item in the inventory\r\n    for (int i = 0; i < *count; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            // Shift all items after the removed item\r\n            for (int j = i; j < *count - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n\r\n            (*count)--; // Decrease the count of items\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define the structure for a student record\r\ntypedef struct Student {\r\n    char name[100];        // Name of the student\r\n    int id;                // Student ID\r\n    float grade;           // Grade of the student\r\n    struct Student* next;  // Pointer to the next student in the linked list\r\n} Student;\r\n\r\n// Head pointer to the linked list\r\nStudent* head = NULL;\r\n\r\n// Function declarations\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid sortStudents();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nStudent Records Management\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Input details for the new student\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"All records deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                deleteList(); // Ensure memory is freed before exiting\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n\r\n    // Insert at the beginning of the list\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current; // Return pointer to the student record if found\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // Return NULL if not found\r\n}\r\n\r\n// Function to delete the entire linked list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n\r\n    head = NULL;\r\n}\r\n\r\n// Function to sort student records by grade using bubble sort\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return; // No sorting needed for empty or single-node lists\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr = head;\r\n\r\n        while (ptr->next != lptr) {\r\n            if (ptr->grade > ptr->next->grade) {\r\n                // Swap data of adjacent nodes\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr->name);\r\n                tempID = ptr->id;\r\n                tempGrade = ptr->grade;\r\n\r\n                strcpy(ptr->name, ptr->next->name);\r\n                ptr->id = ptr->next->id;\r\n                ptr->grade = ptr->next->grade;\r\n\r\n                strcpy(ptr->next->name, tempName);\r\n                ptr->next->id = tempID;\r\n                ptr->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr = ptr->next;\r\n        }\r\n        lptr = ptr;\r\n    } while (swapped);\r\n}\r\n",
    "feedback": "q1-In the transposeMatrix function, the displayMatrix call after transposing uses colsA and rowsA instead of the correct dimensions of the transposed matrix. It should display with the new dimensions, which are swapped.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly but has a time complexity of O(n?), making it inefficient for larger datasets. For better performance, consider using algorithms like Merge Sort or Quick Sort, which have better average-case complexities."
  },
  {
    "student_id": "20718618",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX 10 // Defining the maximum size of matrices\n\n// Function prototypes\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]); // Fucntion to input a matrix\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]); // Function to print a matrix\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]); // Function to add two matrices\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]); // Function to subtract two matrices\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]); // Function to find the transpose of a matrix.\n\nint main() {\n    int rowsA, colsA, rowsB, colsB; // Variable for storing dimensions of both matrices\n    int matrixA[MAX][MAX], matrixB[MAX][MAX]; // Arrays to store elements of both matices\n    int result[MAX][MAX]; // Storing result of operations \n    int choice; // Varaible to store the user's menu choice\n\n    // Input dimensions and validate\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0) { // Validate dimensions (useful)\n        printf(\"Invalid dimensions! Maximum size is %dx%d.\\n\", MAX, MAX);\n        return 1; // Exit if invalid\n    }\n\n    // Input elements for Matrix A\n    printf(\"Enter elements for Matrix A:\\n\");\n    inputMatrix(rowsA, colsA, matrixA);\n\n    // Input dimensions for Matrix B \n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) {\n        printf(\"Invalid dimensions! Maximum size is %dx%d.\\n\", MAX, MAX);\n        return 1;\n    }\n\n    // Input elements for Matrix B\n    printf(\"Enter elements for Matrix B:\\n\");\n    inputMatrix(rowsB, colsB, matrixB);\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1: // Add Matrices \n                if (rowsA == rowsB && colsA == colsB) { // Check if dimensions match\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result); // Perform addition \n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    printMatrix(rowsA, colsA, result); // Print result \n                } else {\n                    printf(\"Matrices must have the same dimensions for addition.\\n\");\n                }\n                break;\n            case 2: // Subtract Matrices\n                if (rowsA == rowsB && colsA == colsB) { // Check if dimensions match\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result); // Peform subtarction\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    printMatrix(rowsA, colsA, result); // Print result \n                } else {\n                    printf(\"Matrices must have the same dimensions for subtraction.\\n\");\n                }\n                break;\n            case 3: //Transpose Matrix A \n                transposeMatrix(rowsA, colsA, matrixA, result); // Find transpose of Matrix A \n                printf(\"Transpose of Matrix A:\\n\");\n                printMatrix(colsA, rowsA, result); // Print result \n                break;\n            case 4: // Transpose Matrix B \n                transposeMatrix(rowsB, colsB, matrixB, result); // Find transpose of Matrix B \n                printf(\"Transpose of Matrix B:\\n\");\n                printMatrix(colsB, rowsB, result); // Print result \n                break;\n            case 5: // Exit \n                printf(\"Exiting...\\n\");\n                break;\n            default: // Handle invalid choice \n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5); // Repeat until user chooses to exit \n\n    return 0; // End program \n}\n\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) { // Loop through rows \n        for (int j = 0; j < cols; j++) { // Loop through columns\n            printf(\"Element [%d][%d]: \", i + 1, j + 1); // Prompt for each element\n            scanf(\"%d\", &matrix[i][j]); // Read element\n        }\n    }\n}\n\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) { // Loop through rows\n        for (int j = 0; j < cols; j++) { // Loop through columns\n            printf(\"%d \", matrix[i][j]); // Print element \n        }\n        printf(\"\\n\"); // New line after each row\n    }\n}\n\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) { // Loop through rows\n        for (int j = 0; j < cols; j++) { // Loop through coloumns\n            result[i][j] = a[i][j] + b[i][j]; // Add corresponding elements\n        }\n    }\n}\n\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) { // Loop through rows\n        for (int j = 0; j < cols; j++) { // Loop through coloumns \n            result[i][j] = a[i][j] - b[i][j]; // Subtract corresponding elements\n        }\n    }\n}\n\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) { // Loop through rows \n        for (int j = 0; j < cols; j++) { // Loop through columns \n            result[j][i] = matrix[i][j]; // Transpose element\n        }\n    }\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100 // Maximum number of grocery items\n\n// Struct for Grocery Item\ntypedef struct {\n    char name[100]; // Name of the item\n    char category[50]; // Category of the item\n    int quantity; // Quantity of the item\n    float price; // Price of the item\n} GroceryItem;\n\n// Struct for Availability Status\ntypedef struct {\n    bool inStock; // Availability status\n} AvailabilityStatus;\n\n// Struct for Grocery Inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS]; // Array of grocery items\n    AvailabilityStatus availability[MAX_ITEMS]; // Array of availability statuses\n    int count; // Number of items in the inventory\n} GroceryInventory;\n\n// Function prototypes\nvoid addGroceryItem(GroceryInventory *inventory); // Add a new grocery item\nvoid listGroceryItems(const GroceryInventory *inventory); // List all grocery items\nvoid updateQuantity(GroceryInventory *inventory); // Update the quantity of an item \nvoid removeGroceryItem(GroceryInventory *inventory); // Remove a grocery item\n\nint main() {\n    GroceryInventory inventory = { .count = 0 }; // Initialize inventory\n    int choice;\n\n    do {\n        // Display menu\n        printf(\"\\nGrocery Inventory Management System:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Clear newline character from input buffer\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory); // add a new item \n                break;\n            case 2:\n                listGroceryItems(&inventory); // list all items \n                break;\n            case 3:\n                updateQuantity(&inventory); // Update item quantity \n                break;\n            case 4:\n                removeGroceryItem(&inventory); // Remove an item \n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to add a grocery item\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) { // Check if inventory is full\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem *item = &inventory->items[inventory->count]; // Get next available item slot \n    AvailabilityStatus *status = &inventory->availability[inventory->count]; // Get corresponding availability slot\n\n    // Input item details \n    printf(\"Enter item name: \");\n    fgets(item->name, sizeof(item->name), stdin);\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline character\n\n    printf(\"Enter category: \");\n    fgets(item->category, sizeof(item->category), stdin);\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &item->quantity);\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &item->price);\n    getchar(); // Clear newline character\n\n    status->inStock = item->quantity > 0; // Set availability status\n\n    inventory->count++; // Increment inventory count\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items\nvoid listGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->count == 0) { // Check if inventory is empty \n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\nGrocery Items:\\n\");\n    for (int i = 0; i < inventory->count; i++) {\n        const GroceryItem *item = &inventory->items[i]; // Get current item \n        const AvailabilityStatus *status = &inventory->availability[i]; // Get current availability status\n\n        // Print item details \n        printf(\"%d.\\n\", i + 1);\n        printf(\"   Name: %s\\n\", item->name);\n        printf(\"   Category: %s\\n\", item->category);\n        printf(\"   Quantity: %d\\n\", item->quantity);\n        printf(\"   Price: %.2f\\n\", item->price);\n        printf(\"   Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity(GroceryInventory *inventory) {\n    if (inventory->count == 0) { // Check if inventory is empty\n        printf(\"No items in inventory to update.\\n\");\n        return;\n    }\n\n    listGroceryItems(inventory);\n    printf(\"Enter the item number to update: \");\n    int itemNumber;\n    scanf(\"%d\", &itemNumber);\n    getchar(); // Clear newline character\n\n    if (itemNumber < 1 || itemNumber > inventory->count) {\n        printf(\"Invalid item number.\\n\");\n        return;\n    }\n\n    GroceryItem *item = &inventory->items[itemNumber - 1];\n    AvailabilityStatus *status = &inventory->availability[itemNumber - 1];\n\n    printf(\"Enter new quantity for %s: \", item->name);\n    scanf(\"%d\", &item->quantity);\n    getchar(); // Clear newline character\n\n    status->inStock = item->quantity > 0; // Update availability status\n    printf(\"Quantity updated successfully!\\n\");\n}\n\n// Function to remove a grocery item\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No items in inventory to remove.\\n\");\n        return;\n    }\n\n    listGroceryItems(inventory);\n    printf(\"Enter the item number to remove: \");\n    int itemNumber;\n    scanf(\"%d\", &itemNumber);\n    getchar(); // Clear newline character\n\n    if (itemNumber < 1 || itemNumber > inventory->count) {\n        printf(\"Invalid item number.\\n\");\n        return;\n    }\n\n    // Shift items to remove the selected item\n    for (int i = itemNumber - 1; i < inventory->count - 1; i++) {\n        inventory->items[i] = inventory->items[i + 1];\n        inventory->availability[i] = inventory->availability[i + 1];\n    }\n\n    inventory->count--; // Decrease count\n    printf(\"Item removed successfully!\\n\");\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];  // Student name\n    int id;          // Student ID\n    float grade;     // Student grade\n    struct Student* next; // Pointer to the next student node\n} Student;\n\nStudent* head = NULL; // Head pointer for the linked list\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\n    if (!newStudent) {\n        printf(\"Memory allocation failed!\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name); // Set student name\n    newStudent->id = id;           // Set student ID\n    newStudent->grade = grade;     // Set student grade\n    newStudent->next = NULL;       // Initialize next pointer to NULL\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade); // Create a new student node\n    newStudent->next = head; // Insert at the beginning of the list\n    head = newStudent;       // Update head pointer\n    printf(\"Student record inserted successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) { // Check if the list is empty\n        printf(\"No student records found.\\n\");\n        return;\n    }\n\n    Student* current = head; // Pointer to traverse the list\n    printf(\"\\nStudent Records:\\n\");\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next; // Move to the next node\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head; // Pointer to traverse the list\n    while (current != NULL) {\n        if (current->id == id) { // Check if the current node matches the ID\n            return current; // Return the matching node\n        }\n        current = current->next; // Move to the next node\n    }\n    return NULL; // Return NULL if not found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head; // Pointer to traverse the list\n    Student* next;\n    while (current != NULL) {\n        next = current->next; // Store the next node\n        free(current);        // Free the current node\n        current = next;       // Move to the next node\n    }\n    head = NULL; // Set head pointer to NULL\n    printf(\"All student records deleted successfully!\\n\");\n}\n\n// Utility function to free memory (calls deleteList)\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade in ascending order\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        printf(\"No sorting needed.\\n\");\n        return;\n    }\n\n    // Using Bubble Sort for simplicity\n    Student* i;\n    Student* j;\n    for (i = head; i != NULL; i = i->next) {\n        for (j = head; j->next != NULL; j = j->next) {\n            if (j->grade > j->next->grade) { // Compare grades\n                // Swap student records\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, j->name);\n                tempID = j->id;\n                tempGrade = j->grade;\n\n                strcpy(j->name, j->next->name);\n                j->id = j->next->id;\n                j->grade = j->next->grade;\n\n                strcpy(j->next->name, tempName);\n                j->next->id = tempID;\n                j->next->grade = tempGrade;\n            }\n        }\n    }\n\n    printf(\"Student records sorted by grade successfully!\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1: \n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\"); // Remove newline character\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortStudents();\n                break;\n\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n\n            case 5:\n                deleteList();\n                break;\n\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation of Bubble Sort is straightforward and correctly swaps student records based on grades. However, it has a time complexity of O(n?), which is not efficient for larger datasets. For better performance, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20710617",
    "code": "",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The sorting function correctly implements a bubble sort algorithm to arrange student records based on grades. While it works well, bubble sort has a time complexity of O(n?). For larger datasets, you might consider more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20703544",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\nvoid addMatrix(int matrix1[10][10], int matrix2[10][10], int row1, int column1);\r\nvoid subMatrix(int matrix1[10][10], int matrix2[10][10], int row1, int column1);\r\nvoid tranMatrix(int matrix1[10][10], int row1, int column1);\r\nint main()\r\n{   \r\n    int i = 0;\r\n    int j = 0;\r\n    int m = 0;\r\n    int n = 0;\r\n    int matrixA[10][10];\r\n    int matrixB[10][10];\r\n    int choice = 0;\r\n    printf(\"Enter the dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &i, &j);\r\n    while(1) {\r\n    if((i>0 && i<=10) && (j>0 && j<=10)) {\r\n    printf(\"Enter the elements of Matrix A: \\n\");\r\n    for(int a = 0; a < i; a++) {\r\n        for(int b = 0; b < j; b++){\r\n            printf(\"Element[%d][%d]: \", a+1, b+1);\r\n            scanf(\"%d\", &matrixA[a][b]);\r\n            }\r\n        }\r\n        break;\r\n    } else {\r\n        printf(\"The maximum dimensions for this matrix is 10 x 10\\n\");\r\n        printf(\"Re-enter the rows and columns: \");\r\n        scanf(\"%d %d\", &i, &j);\r\n        }\r\n    }\r\n    printf(\"Enter the dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &m, &n);\r\n    while(1) {\r\n    if((m>0 && m<=10) && (n>0 && n<=10)) {\r\n    printf(\"Enter the elements of Matrix B: \\n\");\r\n    for(int a = 0; a < m; a++) {\r\n        for(int b = 0; b < n; b++){\r\n            printf(\"Element[%d][%d]: \", a+1, b+1);\r\n            scanf(\"%d\", &matrixB[a][b]);\r\n        }\r\n      }\r\n      break;\r\n    } else {\r\n        printf(\"The maximum dimensions for this matrix is 10 x 10\\n\");\r\n        printf(\"Re-enter the rows and columns: \");\r\n        scanf(\"%d %d\", &m, &n);\r\n        }\r\n    }\r\n    while(choice != 5) {\r\n    printf(\"\\nMatrix Operations Menu: \\n\");\r\n    printf(\"1. Adds Matrices\\n\");\r\n    printf(\"2. Subtracts Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    switch(choice) {\r\n        case 1 : \r\n        if((i==m) && (j==n)) {\r\n        addMatrix(matrixA, matrixB, i, j);\r\n        } else {\r\n            printf(\"Matrices with different dimensions cannot be added.\\n\");\r\n            printf(\"Please try again by exit and restart the program.\\n\");\r\n        }\r\n        break;\r\n        case 2:if((i==m) && (j==n)) {\r\n        subMatrix(matrixA, matrixB, i, j);\r\n        } else {\r\n            printf(\"Matrices with different dimensions cannot be subtracted.\\n\");\r\n            printf(\"Please try again by exit and restart the program.\\n\");\r\n        }\r\n        break;\r\n        case 3:\r\n        tranMatrix(matrixA, i, j);\r\n        break;\r\n        case 4:\r\n        tranMatrix(matrixB, m, n);\r\n        break;\r\n        case 5:\r\n        break;\r\n        default:\r\n        printf(\"Your choice is undefinded. Please try again.\\n\");\r\n        break;\r\n    }\r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\nvoid addMatrix(int matrix1[10][10], int matrix2[10][10], int row1, int column1) {\r\n         int matrix[10][10];\r\n        // Add the matrices\r\n        for (int i = 0; i < row1; i++) {\r\n            for (int j = 0; j < column1; j++) {\r\n                matrix[i][j] = matrix1[i][j] + matrix2[i][j];\r\n            }\r\n        }\r\n        // Print the matrix\r\n        printf(\"The result of the added matrix:\\n\");\r\n        for (int i = 0; i < row1; i++) {\r\n            for (int j = 0; j < column1; j++) {\r\n                printf(\"%d \", matrix[i][j]);\r\n            }\r\n            puts(\"\");\r\n        }\r\n    \r\n}\r\nvoid subMatrix(int matrix1[10][10], int matrix2[10][10], int row1, int column1) {\r\n         int matrix[10][10];\r\n        // Add the matrices\r\n        for (int i = 0; i < row1; i++) {\r\n            for (int j = 0; j < column1; j++) {\r\n                matrix[i][j] = matrix1[i][j] - matrix2[i][j];\r\n            }\r\n        }\r\n        // Print the matrix\r\n        printf(\"The result of the added matrix:\\n\");\r\n        for (int i = 0; i < row1; i++) {\r\n            for (int j = 0; j < column1; j++) {\r\n                printf(\"%d \", matrix[i][j]);\r\n            }\r\n            puts(\"\");\r\n        }\r\n    \r\n}\r\n\r\nvoid tranMatrix(int matrix1[10][10], int row1, int column1) {\r\n    int matrix[10][10] = {0};\r\n    //revert matrix1 and assign to temporary matrix\r\n    for (int i = 0; i < row1; i++) {\r\n            for (int j = 0; j < column1; j++) {\r\n                matrix[j][i] = matrix1[i][j];\r\n            }\r\n        }\r\n    //copy temp matrix back to original matrix\r\n    for (int i = 0; i < column1; i++) {\r\n            for (int j = 0; j < row1; j++) {\r\n                matrix1[i][j] = matrix[i][j];\r\n            }\r\n        }\r\n    // Print the matrix\r\n        printf(\"The result of the transposed matrix:\\n\");\r\n        for (int i = 0; i < column1; i++) {\r\n            for (int j = 0; j < row1; j++) {\r\n                printf(\"%d \", matrix1[j][i]);\r\n            }\r\n            puts(\"\");\r\n        }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>  \r\n#include <string.h> \r\n#include <stdlib.h>\r\n#include <stdbool.h> \r\n\r\n#define MAX_CONTACT 100\r\n\r\nint compareItem(const void *a, const void *b);\r\n\r\nstruct GroceryItem {\r\n    int quantity;  \r\n    char name[100], category[50];\r\n    float price;\r\n} new_item, grocery_item[MAX_CONTACT];\r\n\r\nint main() {\r\n    FILE *fPtr = NULL;\r\n    int choice = 0;\r\n    while(choice != 5) {\r\n    printf(\"GROCERY INVENTORY MANAGEMENT SYSTEM\\n\");\r\n    printf(\"[1]ADD GROCERY ITEM\\n\");\r\n    printf(\"[2]LIST ALL GROCERY ITEM\\n\");\r\n    printf(\"[3]UPDATE QUANTITY\\n\");\r\n    printf(\"[4]REMOVE GROCERY ITEM\\n\");\r\n    printf(\"[5]EXIT\\n\");\r\n    printf(\"Please enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar();\r\n\r\n    switch(choice) {\r\n        case 1:\r\n        printf(\"Enter Item Name: \");\r\n        fgets(new_item.name, 100, stdin);\r\n        new_item.name[strcspn(new_item.name, \"\\n\")] = '\\0';\r\n        printf(\"Enter Category: \");\r\n        fgets(new_item.category, 50, stdin);\r\n        new_item.category[strcspn(new_item.category, \"\\n\")] = '\\0';\r\n        printf(\"Enter Quantity: \");\r\n        scanf(\"%d\", &new_item.quantity);\r\n        getchar();\r\n        printf(\"Enter Price: \");\r\n        scanf(\"%f\", &new_item.price);\r\n        getchar();\r\n        fPtr = fopen(\"GroceryItem.txt\", \"a+\");\r\n        if (fPtr == NULL) {\r\n        printf(\"Error opening file!\\n\");\r\n        }\r\n        fwrite(&new_item, sizeof(struct GroceryItem), 1, fPtr);\r\n        fclose(fPtr);\r\n        printf(\"Item added succesfully.\\n\\n\");\r\n        break;\r\n        case 2:\r\n        fPtr = fopen (\"GroceryItem.txt\", \"r\");\r\n        while(fread(&new_item, sizeof(struct GroceryItem), 1, fPtr)) {\r\n        if(fread(&new_item, sizeof(struct GroceryItem), 1, fPtr)==0) {\r\n            printf(\"No item in the inventory.\\n\\n\");\r\n        } else if(new_item.quantity > 0) {\r\n            printf(\"Grocery Item Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: In Stock\\n\\n\", new_item.name, new_item.category, new_item.quantity, new_item.price);\r\n        } else {\r\n            printf(\"Grocery Item Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: Out of Stock\\n\\n\", new_item.name, new_item.category, new_item.quantity, new_item.price); \r\n        }\r\n        }\r\n        if(fread(&new_item, sizeof(struct GroceryItem), 1, fPtr)==0) {\r\n            printf(\"No item in the inventory.\\n\\n\");\r\n        }\r\n        fclose(fPtr);\r\n        break;\r\n        case 3:\r\n        fPtr = fopen(\"GroceryItem.txt\", \"r\");\r\n        if (fPtr == NULL) {\r\n        printf(\"Error opening file!\\n\");\r\n        }\r\n\r\n        FILE *newFile = fopen(\"NEW.txt\", \"w\");\r\n        if (newFile == NULL) {\r\n        printf(\"Error opening temporary file!\\n\");\r\n        fclose(fPtr);\r\n        }\r\n\r\n        char searchName[100];\r\n        int found = 0;\r\n    \r\n        printf(\"Enter the name of the item to update: \");\r\n        fgets(searchName, 100, stdin);\r\n        searchName[strcspn(searchName, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n        while (fread(&new_item, sizeof(struct GroceryItem), 1, fPtr)) {\r\n        if (strcmp(new_item.name, searchName) == 0) {\r\n        found = 1;\r\n        printf(\"Enter Quantity: \");\r\n        scanf(\"%d\", &new_item.quantity);\r\n        getchar();\r\n        }\r\n        fwrite(&new_item, sizeof(struct GroceryItem), 1, newFile);\r\n        }\r\n\r\n        fclose(fPtr);\r\n        fclose(newFile);\r\n\r\n        if (found) {\r\n        remove(\"GroceryItem.txt\");\r\n        rename(\"NEW.txt\", \"GroceryItem.txt\");\r\n        printf(\"Quantity updated successfully.\\n\\n\");\r\n        } else {\r\n        remove(\"NEW.txt\");\r\n        printf(\"Item not found.\\n\\n\");\r\n        }\r\n        \r\n        break;\r\n        case 4:\r\n        fPtr = fopen(\"GroceryItem.txt\", \"r\");\r\n        if (fPtr == NULL) {\r\n        printf(\"Error opening file!\\n\");\r\n        }\r\n\r\n        FILE *new_File = fopen(\"NEW.txt\", \"w\");\r\n        if (new_File == NULL) {\r\n        printf(\"Error opening temporary file!\\n\");\r\n        fclose(fPtr);\r\n        }\r\n\r\n        char search_Name[100];\r\n        int FOUND = 0;\r\n    \r\n        printf(\"Enter the name of the item to remove: \");\r\n        fgets(search_Name, 100, stdin);\r\n        search_Name[strcspn(search_Name, \"\\n\")] = '\\0'; \r\n        \r\n        while (fread(&new_item, sizeof(struct GroceryItem), 1, fPtr)) {\r\n        if (strcmp(new_item.name, search_Name) != 0) {\r\n            fwrite(&new_item, sizeof(struct GroceryItem), 1, new_File);\r\n        } else {\r\n            FOUND = 1;\r\n        }\r\n        }\r\n        fclose(fPtr);\r\n        fclose(new_File);\r\n        if (FOUND) {\r\n        remove(\"GroceryItem.txt\");\r\n        rename(\"NEW.txt\", \"GroceryItem.txt\");\r\n        printf(\"Item removed successfully.\\n\\n\");\r\n        } else {\r\n        remove(\"NEW.txt\");\r\n        printf(\"Item not found.\\n\\n\");\r\n        }\r\n        break;\r\n        case 5:\r\n        printf(\"Exiting program.\\n\");\r\n        break;\r\n        default:\r\n        printf(\"Undefined choice. PLease try again.\\n\");\r\n        break;\r\n\r\n        fclose(fPtr);\r\n            \r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n char name[100];\r\n int id;\r\n float grade;\r\n struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* temp = (Student*)malloc(sizeof(Student));\r\n    strcpy(temp->name, name);\r\n    temp->id = id;\r\n    temp->grade = grade;\r\n    temp->next = NULL;\r\n    return temp;\r\n}\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* new = createStudent(name, id, grade);\r\n    if(new != NULL) {\r\n        Student* previous = NULL;\r\n        Student* current = head;\r\n        //loop to fint the correct location in list\r\n        while(current != NULL && id > current->id) {\r\n            previous = current;\r\n            current = current->next;\r\n        }\r\n        \r\n        if(previous ==NULL) { //insert new node at the head\r\n            new->next = head;\r\n            head = new;\r\n        } else { //insert new node between previous and current\r\n            previous->next = new;\r\n            new->next = current;\r\n        }\r\n    }\r\n\r\n}\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    printf(\"ID\\tName\\t\\t\\tGrade\\n\");\r\n    while (current != NULL) {\r\n        printf(\"%d\\t%-s\\t\\t\\t%.2f\\n\", current->id, current->name, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* previous = NULL;\r\n    Student* current = head;\r\n    while(current != NULL && id != current->id) {\r\n            previous = current;\r\n            current = current->next;\r\n        }\r\n    return current;\r\n}\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n    next = current->next;\r\n    free(current);\r\n    current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n deleteList();\r\n}\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() { //selection sort algorithm\r\n    Student *current = head;\r\n    while (current != NULL) {\r\n        Student *smallerNode = current; //set the min to the current node\r\n        Student *nextNode = current->next; \r\n\r\n        while (nextNode != NULL) {\r\n            if (nextNode->grade < smallerNode->grade) {\r\n                smallerNode = nextNode; //set the node to be smaller node when the grade of the next node is smaller \r\n            }\r\n            nextNode = nextNode->next; //move to next node\r\n        }\r\n        //Swap the data of the current node with the minimum node\r\n        if (smallerNode != current) {\r\n            //Swap name\r\n            char tempName[100];\r\n            strcpy(tempName, current->name);\r\n            strcpy(current->name, smallerNode->name);\r\n            strcpy(smallerNode->name, tempName);\r\n            //Swap ID\r\n            int tempId = current->id;\r\n            current->id = smallerNode->id;\r\n            smallerNode->id = tempId;\r\n            //Swap grade\r\n            float tempGrade = current->grade;\r\n            current->grade = smallerNode->grade;\r\n            smallerNode->grade = tempGrade;\r\n        }\r\n        //Move to the next node in the list\r\n        current = current->next;\r\n    }\r\n}\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records (choose sorting method)\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar(); // To consume the newline character\r\n    switch (choice) {\r\n    case 1:\r\n    printf(\"Enter Name: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n    printf(\"Enter ID: \");\r\n    scanf(\"%d\", &id);\r\n    printf(\"Enter Grade: \");\r\n    scanf(\"%f\", &grade);\r\n    insertStudent(name, id, grade);\r\n    break;\r\n    case 2:\r\n    displayStudents();\r\n    break;\r\n    case 3:\r\n    sortStudents();\r\n    break;\r\n    case 4:\r\n    printf(\"Enter ID to search: \");\r\n    scanf(\"%d\", &id);\r\n    Student* found = searchStudentByID(id);\r\n\r\n    if (found) {\r\n    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n    found->name, found->id, found->grade);\r\n    } else {\r\n    printf(\"Student not found.\\n\");\r\n    }\r\n    break;\r\n    case 5:\r\n    deleteList();\r\n    printf(\"List deleted.\\n\");\r\n    break;\r\n    case 6:\r\n    freeMemory();\r\n    printf(\"Exiting...\\n\");\r\n    break;\r\n    default:\r\n    printf(\"Invalid choice! Please try again.\\n\");\r\n    }\r\n    } while (choice != 6);\r\n\r\n return 0;\r\n} \r\n",
    "feedback": "q1-The message printed after the subtraction operation incorrectly states \"The result of the added matrix\" instead of \"The result of the subtracted matrix.\" In the tranMatrix function, the transposed matrix is printed incorrectly. The dimensions in the print loop should reflect the new dimensions after transposition.\nq2-    In the case 2 section, the logic for checking if no items exist appears twice, leading to potential misinterpretation of the inventory being empty.\n    In the case 3 and case 4, the use of fwrite should occur after reading and processing the record. The program might not update the quantity or remove items correctly if the file read stops prematurely.\nq3-In the displayStudents function, the format specifier for the name should use %s instead of %-s. The Selection Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While Selection Sort works well for small datasets, it has a time complexity of O(n?), which can be inefficient for larger lists. For improved efficiency, consider using algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20700412",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n    int N, *ptr;\r\n    int indice1, indice2;\r\n    int num1,num2,sum;\r\n    \r\n    do{\r\n        printf(\"\\nEnter the size of the array (N>=5): \");\r\n        scanf(\"%d\",&N);\r\n        if (N<5){\r\n            printf(\"Array size must greater equal than 5!\\n\");\r\n        }\r\n    }while(N<5);\r\n    \r\n    ptr=(int*)malloc(N*sizeof(int));\r\n    printf(\"Enter the array elements: \\n\");\r\n    for (int i=0;i<N;i++){\r\n        printf(\"Element %d: \",i);\r\n        scanf(\"%d\",ptr+i);\r\n    }\r\n    \r\n    do{\r\n        printf(\"Enter the indices of the two elements (0 <= index1, index2 < %d): \",N);\r\n        scanf(\"%d %d\",&indice1,&indice2);\r\n        if (indice1<0||indice1>=N || indice2<0||indice2>=N){\r\n            printf(\"Error: Indices must be within the range of the array elements. Please try again.\\n\\n\");\r\n        }\r\n    }while (indice1<0||indice1>=N || indice2<0||indice2>=N);\r\n    \r\n    num1=*(ptr+indice1);\r\n    num2=*(ptr+indice2);\r\n    \r\n    printf(\"The sum of the values at indices %d and %d is: %d\",indice1,indice2,num1+num2);\r\n    \r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#define NAME_LENGTH 50\r\n\r\nfloat calculateAverage(const float marks[]){\r\n    float sum=0;\r\n    float average;\r\n    for (int a=0;a<3;a++){\r\n        sum+=marks[a];\r\n    }\r\n    average=sum/3;\r\n    return average;\r\n}\r\n\r\nvoid displayStudentData(const char name[][NAME_LENGTH],const float marks[]){\r\n    printf(\"Student Names and Marks: \\n\");\r\n    for (int a=0;a<3;a++){\r\n        printf(\"%s: %.2f\\n\",name[a],marks[a]);\r\n    }\r\n}\r\n\r\nint main(){\r\n    char name[3][NAME_LENGTH];\r\n    float marks[3];\r\n    \r\n    for (int i=0;i<3;i++){\r\n        printf(\"Enter the name of student %d: \",i+1);\r\n        if (i!=0){\r\n            while (getchar()!='\\n');\r\n        }\r\n        scanf(\"%[^\\n]\",name[i]);\r\n        printf(\"Enter the mark of student %d: \",i+1);\r\n        scanf(\"%f\",&marks[i]);\r\n    }\r\n    puts(\"\");\r\n    displayStudentData(name,marks);\r\n    puts(\"\");\r\n    printf(\"Average Mark: %.2f\",calculateAverage(marks));\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int bider;\r\n    do{\r\n        printf(\"Enter The number of bids: \");\r\n        scanf(\"%d\",&bider);\r\n        if (bider<2){\r\n            printf(\"Error: Number of bids must be at least 2. Please try again\\n\\n\");\r\n        }\r\n    }while (bider<2);    \r\n    \r\n    printf(\"Enter the bids (must be at least $100000)\\n\");\r\n    int bits[bider];\r\n    for (int i=0;i<bider;i++){\r\n        do{\r\n            printf(\"Bid %d: \",i+1);\r\n            scanf(\"%d\",&bits[i]);\r\n            if (bits[i]<100000){\r\n                printf(\"Error: Bid must be at least $100000. Please try again\\n\");\r\n            }\r\n        }while (bits[i]<100000);\r\n    }\r\n    \r\n    int max=0;\r\n    for (int i=0;i<bider;i++){\r\n        if (bits[i]>max){\r\n            max=bits[i];\r\n        }\r\n    }\r\n    \r\n    printf(\"The highest bid is: $%d\",max);\r\n}\r\n",
    "feedback": "q1-The arithmetic operations in the Arimatrices function incorrectly use the loop indices when accessing the matrix elements. The correct formula for accessing the elements should account for both row and column indices properly.\nq2-Meet requirement. \nq3-    Sorting Algorithm: Selection Sort (referred to as \"Linear Sort\" in the menu).The sorting algorithm is implemented correctly. However, while it works, the time complexity is O(n?), which may not be efficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20611068",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Function to get matrix dimensions \r\nvoid dimensions(int *rows, int *cols) {\r\n    scanf(\"%d %d\", rows, cols); // Read rows and columns\r\n}\r\n\r\n// Function to get matrix elements\r\nvoid elements(int rows, int cols, int matrix[rows][cols]) {\r\n    // Loop through each element of the matrix and get input\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]); // Read each element\r\n        }\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid add(int rows, int cols, int matrixA[rows][cols], int matrixB[rows][cols], int result[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtract(int rows, int cols, int matrixA[rows][cols], int matrixB[rows][cols], int result[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose matrix\r\nvoid transpose(int rows, int cols, int matrix[rows][cols], int transposed[cols][rows]) {\r\n    // Swap rows with columns\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int rows, int cols, int matrix[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]); // Print each element\r\n        }\r\n        printf(\"\\n\"); // Newline after each row\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[10][10], matrixB[10][10], result[10][10], transposed[10][10];\r\n    int choice;\r\n\r\n    // Get dimensions and elements for both matrices\r\n    printf(\"Enter dimensions for Matrix A (rows and columns):\");\r\n    dimensions(&rowsA, &colsA); // Get dimensions for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    elements(rowsA, colsA, matrixA); // Get elements for Matrix A\r\n\r\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns):\");\r\n    dimensions(&rowsB, &colsB); // Get dimensions for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    elements(rowsB, colsB, matrixB); // Get elements for Matrix B\r\n\r\n    // Display menu \r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: // Add Matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    add(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Matrices cannot be added. Dimensions must be the same.\\n\");\r\n                }\r\n                break;\r\n            case 2: // Subtract Matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtract(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Matrices cannot be subtracted. Dimensions must be the same.\\n\");\r\n                }\r\n                break;\r\n            case 3: // Transpose of Matrix A\r\n                transpose(rowsA, colsA, matrixA, transposed);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, transposed); \r\n                break;\r\n            case 4: // Transpose of Matrix B\r\n                transpose(rowsB, colsB, matrixB, transposed);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, transposed);  \r\n                break;\r\n            case 5: // Exit\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default: // Invalid input\r\n                printf(\"Invalid choice. Please enter again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Define structures for Grocery Item and Availability Status\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Define Grocery Inventory\r\ntypedef struct {\r\n    GroceryItem items[100];\r\n    AvailabilityStatus availability[100];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n\r\n// Function to add a grocery item\r\nvoid addItem(GroceryInventory *inventory) {\r\n    if (inventory->count < 100) {\r\n        printf(\"Enter item name: \");\r\n        fgets(inventory->items[inventory->count].name, sizeof(inventory->items[inventory->count].name), stdin);\r\n        inventory->items[inventory->count].name[strcspn(inventory->items[inventory->count].name, \"\\n\")] = 0; //remove trailing newline\r\n\r\n        printf(\"Enter item category: \");\r\n        fgets(inventory->items[inventory->count].category, sizeof(inventory->items[inventory->count].category), stdin);\r\n        inventory->items[inventory->count].category[strcspn(inventory->items[inventory->count].category, \"\\n\")] = 0; //remove trailing newline\r\n\r\n        printf(\"Enter quantity: \");\r\n        scanf(\"%d\", &inventory->items[inventory->count].quantity);\r\n        \r\n        printf(\"Enter price: \");\r\n        scanf(\"%f\", &inventory->items[inventory->count].price);\r\n        getchar();  //To consume the newline character\r\n\r\n        inventory->availability[inventory->count].inStock = (inventory->items[inventory->count].quantity > 0);\r\n        inventory->availability[inventory->count].outOfStock = !inventory->availability[inventory->count].inStock;\r\n        inventory->count++;\r\n        printf(\"Grocery item added successfully!\\n\");\r\n    } else {\r\n        printf(\"Inventory is full!\\n\");\r\n    }\r\n}\r\n\r\n// Function to list all grocery items with their availability \r\nvoid listItems(const GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        printf(\"Item Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\", inventory->availability[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char itemName[100];\r\n    int quantity;\r\n    int index = -1;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  //remove trailing newline\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1) {\r\n        printf(\"Item not found!\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter new quantity: \");\r\n    scanf(\"%d\", &quantity);\r\n    getchar(); // To consume the newline character\r\n\r\n    inventory->items[index].quantity = quantity;\r\n    inventory->availability[index].inStock = (quantity > 0);\r\n    inventory->availability[index].outOfStock = !inventory->availability[index].inStock;\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n\r\n// Function to remove grocery item \r\nvoid removeItem(GroceryInventory *inventory) {\r\n    char itemName[100];\r\n    int index = -1;\r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0; //remove trailing newline\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1) {\r\n        printf(\"Item not found!\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift remaining items to fill the gap\r\n    for (int i = index; i < inventory->count - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->availability[i] = inventory->availability[i + 1];\r\n    }\r\n    inventory->count--;\r\n    printf(\"Item removed successfully!\\n\");\r\n}\r\n\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .count = 0 };\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management\\n\");\r\n        printf(\"1. Add grocery item\\n\");\r\n        printf(\"2. List all grocery items\\n\");\r\n        printf(\"3. Update item quantity\\n\");\r\n        printf(\"4. Remove grocery item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice:\");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1: addItem(&inventory); break;\r\n            case 2: listItems(&inventory); break;\r\n            case 3: updateQuantity(&inventory); break;\r\n            case 4: removeItem(&inventory); break;\r\n            case 5: printf(\"Exiting program...\\n\"); break;\r\n            default: printf(\"Invalid choice. Please enter again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;   // Pointer to the next student \r\n} Student;\r\n\r\nStudent* head = NULL;   // Head pointer for linked list of students\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;    // Initially, the next pointer is set to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;  // Set new student as head if list is empty\r\n    } else {\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent; // Link new student to the end of the list\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n     Student* current = head;\r\n    if (current == NULL) {\r\n        printf(\"No students in the list.\\n\");\r\n        return;\r\n    }\r\n    printf(\"Student Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;    // Return to student node when ID is found\r\n    }\r\n    return NULL; \r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);      // Free the memory of the current node\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) return; //Nothing to sort\r\n\r\n    Student *current, *next;\r\n    int swapped;\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n        next = current->next;\r\n\r\n        while (next != NULL) {\r\n            if (current->grade > next->grade) {\r\n                // Swap the nodes if current student's grade is greater than next\r\n                char tempName[50];\r\n                strcpy(tempName, current->name);\r\n                strcpy(current->name, next->name);\r\n                strcpy(next->name, tempName);\r\n\r\n                int tempID = current->id;\r\n                current->id = next->id;\r\n                next->id = tempID;\r\n\r\n                float tempGrade = current->grade;\r\n                current->grade = next->grade;\r\n                next->grade = tempGrade;\r\n\r\n                swapped = 1; // Swap one by one\r\n            }\r\n            current = next;\r\n            next = next->next;\r\n        }\r\n    } while (swapped); // Continue until no more swaps\r\n\r\n    printf(\"\\nRecords sorted by bubble sort.\\n\");    // Bubble Sort is chosen for its simplicity and ease of implementation for small data\r\n                                                     // It is stable and performs in-place sorting, making it suitable for this question\r\n\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    \r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Student found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation uses Bubble Sort to sort student records by grade. This algorithm is simple and effective for small datasets, but it has a time complexity of O(n?), which may not perform well with larger datasets. For efficiency, consider using more advanced sorting algorithms like Quick Sort or Merge Sort in future implementations."
  },
  {
    "student_id": "20606888",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n// Function prototypes\nvoid menu();\nvoid addMatrices();\nvoid substractMatrices();\nvoid transposeMatrixA();\nvoid transposeMatrixB();\n\nint r, c, a[100][100], b[100][100], i, j, sum[100][100], minus[100][100], transpose[100][100];\n\nint main() {\n    // matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d%d\", &r, &c);\n    printf(\"\\nEnter elements for Matrix A: \\n\");\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; ++j) {\n            printf(\"Element [%d][%d]: \", i + 1, j+ 1);\n            scanf(\"%d\", &a[i][j]);\n        }\n    }\n    // matrix B\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d%d\", &r, &c);\n    printf(\"\\nEnter elements for Matrix B: \\n\");\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; ++j) {\n            printf(\"Element [%d][%d]: \", i + 1, j+ 1);\n            scanf(\"%d\", &b[i][j]);\n        }\n    }\n\n    menu();  // Display menu\n    \n    return 0;\n}\n\n// Menu\nvoid menu() {\n    int choice;\n    do {\n        printf(\"\\nMatrix Operations Menu: \\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Substract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            case 1:\n                addMatrices();\n                break;\n            case 2:\n                substractMatrices();\n                break;\n            case 3:\n                transposeMatrixA();\n                break;\n            case 4:\n                transposeMatrixB();\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Try again.\\n\");\n        }\n    } while (choice != 5);\n}\n\n// Add matrices\nvoid addMatrices() {\n    // Add \n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; j++){\n            sum[i][j] = a[i][j] + b[i][j];\n        }\n    }\n\n    // Print results\n    printf(\"\\nResult of Matrix A + Matrix B: \\n\");\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; j++) {\n            printf(\"%d  \", sum[i][j]);\n            if (j == c - 1) {\n                printf(\"\\n\");\n            }\n        }\n    }\n}\n\n// Substract matrices\nvoid substractMatrices() {\n    // Substract\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; j++){\n            minus[i][j] = a[i][j] - b[i][j];\n        }\n    }\n\n    // Print results\n    printf(\"\\nResult of Matrix A - Matrix B: \\n\");\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; j++) {\n            printf(\"%d  \", minus[i][j]);\n            if (j == c - 1) {\n                printf(\"\\n\");\n            }\n        }\n    }\n}\n\n// Transpose Matrix A\nvoid transposeMatrixA() {\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; j++) {\n            transpose[j][i] = a[i][j];\n        }\n    }\n    \n    // Print results\n    printf(\"\\nTranspose of Matrix A:\\n\");\n    for (i = 0; i < r; i++) {\n        for (j = 0; j <c; j++) {\n            printf(\"%d  \", transpose[i][j]);\n            if (j == r - 1) {\n                printf(\"\\n\");\n            }\n        }\n    }\n}\n\n// Transpose Matrix B\nvoid transposeMatrixB() {\n    for (i = 0; i < r; i++) {\n        for (j = 0; j < c; j++) {\n            transpose[j][i] = b[i][j];\n        }\n    }\n    \n    // Print results\n    printf(\"\\nTranspose of Matrix B:\\n\");\n    for (i = 0; i < r; i++) {\n        for (j = 0; j <c; j++) {\n            printf(\"%d  \", transpose[i][j]);\n            if (j == r - 1) {\n                printf(\"\\n\");\n            }\n        }\n    }\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define NAME_LENGTH 100\n#define CATEGORY_LENGTH 50\n#define MAX_ITEMS 100\n\n// Grocery structure\ntypedef struct {\n    char name[NAME_LENGTH];\n    char category[CATEGORY_LENGTH];\n    int quantity;\n    float price;\n    int inStock;\n} Grocery;\n\nGrocery items[MAX_ITEMS];\nint itemCount = 0;\n\n// Function prototypes\nvoid addItem();\nvoid listItem();\nvoid updateQuantity();\nvoid removeItem();\nvoid menu();\n\nint main() {\n    menu();\n    return 0;\n}\n\nvoid addItem() {\n    if (itemCount >= MAX_ITEMS) {\n        printf(\"Inventory full! Cannot add more items.\\n\");\n        return;\n    }\n\n    Grocery newItem;\n\n    // Add item\n    printf(\"Enter Item Name: \");\n    scanf(\" %[^\\n]\", newItem.name);\n    printf(\"Enter Category: \");\n    scanf(\" %[^\\n]\", newItem.category);\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &newItem.price);\n\n    // Set availability status based on quantity\n    newItem.inStock = (newItem.quantity > 0) ? 1 : 0;\n\n    items[itemCount++] = newItem;\n    printf(\"Item added successfully.\\n\");\n}\n\nvoid listItem() {\n    if (itemCount == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\nGrocery List:\\n\");\n    for (int i = 0; i < itemCount; i++) {\n        printf(\"Name: %s\\n Category: %s\\n Quantity: %d\\n Price: %.2f\\n Status: %s\\n\",\n               i + 1, items[i].name, items[i].category, items[i].quantity, items[i].price, items[i].inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\nvoid updateQuantity() {\n    if (itemCount == 0) {\n        printf(\"No items to update.\\n\");\n        return;\n    }\n\n    char name[NAME_LENGTH];\n    int newQuantity;\n    int found = 0;\n\n    printf(\"Enter name of the grocery item to update quantity: \");\n    scanf(\" %[^\\n]\", name);\n\n    // Search for item\n    for (int i = 0; i< itemCount; i++) {\n        if (strcmp(items[i].name, name) == 0) {\n            // Match found\n            printf(\"Enter new Quantity for %s: \", items[i].name);\n            scanf(\"%d\", &newQuantity);\n\n            // Update quantity and availability status\n            items[i].quantity = newQuantity;\n            items[i].inStock = (newQuantity > 0) ? 1 : 0;\n\n            printf(\"Quantity updated successfully.\\n\");\n            found = 1;\n            break;\n        }\n    }\n\n    if (!found) {\n        printf(\"Item '%s' not found in the inventory.\\n\", name);\n    }\n}\n\nvoid removeItem() {\n    if (itemCount == 0) {\n        printf(\"No items to remove.\\n\");\n        return;\n    }\n\n    char name[NAME_LENGTH];\n    int found = 0;\n\n    printf(\"Enter name of the grocery item to remove: \");\n    scanf(\" %[^\\n]\", name);\n\n    // Search for item\n    for (int i = 0; i< itemCount; i++) {\n        if (strcmp(items[i].name, name) == 0) {\n            // Match found\n            found = 1;\n\n            // Remove the found item\n            for (int j = i; j < itemCount - 1; j++) {\n                items[j] = items[j + 1];\n            }\n\n            itemCount--;\n            printf(\"Grocery item '%s' removed successfully.\\n\", name);\n            break;\n        }\n    }\n\n    if (!found) {\n        printf(\"Item '%s' not found in the inventory.\\n\", name);\n    }\n}\n\n// Menu\nvoid menu() {\n    int choice;\n    do {\n        printf(\"\\nGrocery Inventory Management System: \\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            case 1:\n                addItem();\n                break;\n            case 2:\n                listItem();\n                break;\n            case 3:\n                updateQuantity();\n                break;\n            case 4:\n                removeItem();\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Try again.\\n\");\n        }\n    } while (choice != 5);\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function prototypes\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nvoid deleteList();\nvoid freeMemory();\nvoid sortStudents();\nStudent* searchStudentByID(int id);\n\n// Main function to drive the program\nint main() {\n\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2: \n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n            printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (newStudent == NULL) {\n        printf(\"Memory allocation failed.\\n\");\n        return NULL;\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n     Student* newStudent = createStudent(name, id, grade);\n    if (!newStudent) return;\n\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student inserted successfully.\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n     if (head == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n\n    printf(\"\\nStudent List:\\n\");\n    Student* current = head;\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents(){\n    if (head == NULL || head->next == NULL) {\n        printf(\"Not enough records to sort.\\n\");\n        return;\n    }\n\n    Student *i, *j;\n    for (i = head; i != NULL; i = i->next) {\n        for (j = i->next; j != NULL; j = j->next) {\n            if (i->grade > j->grade) { // Ascending order\n                // Swap data\n                float tempGrade = i->grade;\n                i->grade = j->grade;\n                j->grade = tempGrade;\n\n                int tempID = i->id;\n                i->id = j->id;\n                j->id = tempID;\n\n                char tempName[100];\n                strcpy(tempName, i->name);\n                strcpy(i->name, j->name);\n                strcpy(j->name, tempName);\n            }\n        }\n    }\n    printf(\"Students sorted by grade in ascending order.\\n\");\n}\n\n",
    "feedback": "q1-The dimensions for the transposed matrices are incorrectly used when printing. In transposeMatrixA and transposeMatrixB, the loops for printing should use the transposed dimensions (i.e., c for rows and r for columns).The variable r and c are reused for both matrices, which can lead to confusion. It's better to define separate variables for the dimensions of matrix A and B.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly but has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort, especially for linked lists."
  },
  {
    "student_id": "20722404",
    "code": "",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is straightforward and works well for small datasets but has a time complexity of O(n?). This can lead to inefficiency for larger lists. For improved performance, consider implementing more efficient algorithms like Merge Sort or Quick Sort in the future."
  },
  {
    "student_id": "20615031",
    "code": "\n/* --- 20615031_Yew Xin Nie_LA3/20615031_Yew Xin Nie_LA3/Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Declare FUnction Prototypes// \r\nint inputMatrix();\r\nint displayMatrix();\r\nint additionMatrix();\r\nint subtractMatrix();\r\nint transposeMatrix();\r\n\r\n\r\nint main(void){\r\n    // Declare variable zone //\r\n    int rowA, rowB, columnA, columnB = 0;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result [MAX_SIZE] [MAX_SIZE];\r\n    int choice = 0;\r\n    \r\n    //Matrix A//\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowA, &columnA);\r\n\r\n    // Output for invalid range from 1 to 10 //\r\n    while(rowA < 1 || rowA > 10 || columnA < 1 || columnA > 10){\r\n        printf(\"Invalid dimension.\");\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowA, &columnA);\r\n    }\r\n\r\n     // Ask user to enter the elements for matrix //\r\n        printf(\"Enter elements for Matrix A:\\n\");\r\n        inputMatrix(rowA, columnA, matrixA);\r\n\r\n    //Matrix B//\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowB, &columnB);\r\n\r\n    // Output for invalid range from 1 to 10 //\r\n     while(rowB < 1 || rowB > 10 || columnB < 1 || columnB > 10){\r\n        printf(\"Invalid dimension.\");\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowB, &columnB);\r\n    }\r\n\r\n    // Ask user to enter the elements for matrix //\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(rowA, rowB, matrixB);\r\n\r\n    do{\r\n\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice){\r\n            case 1:\r\n                if (rowA == rowB && columnA == columnB){\r\n                    additionMatrix(rowA, columnA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(rowA, columnA, result);\r\n                }\r\n                else{\r\n                    printf(\"Addition is not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowA == rowB && columnA == columnB){\r\n                    subtractMatrix(rowA, columnA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(rowA, columnA, result);\r\n                }\r\n                else{\r\n                    printf(\"Subtraction is not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(rowA, columnA, matrixA, result);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                displayMatrix(columnA, rowA, result);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(rowB, columnB, matrixB, result);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                displayMatrix(columnB, rowB, result);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            \r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n\r\n    }while(choice != 5);\r\n\r\n\r\n\r\n}\r\n\r\n// FUNCTIONS //\r\nint inputMatrix (int rows, int cols, int mat[MAX_SIZE][MAX_SIZE]){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            printf(\"Enter element [%d][%d]: \", i + 1 , j + 1);\r\n            scanf(\"%d\", &mat[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nint displayMatrix (int rows, int cols, int mat[MAX_SIZE][MAX_SIZE]){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            printf(\"%d\\t\", mat[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n}\r\n\r\nint additionMatrix (int rows, int cols, int a [MAX_SIZE][MAX_SIZE], int b [MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]){\r\n    for (int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint subtractMatrix (int rows, int cols, int a [MAX_SIZE][MAX_SIZE], int b [MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]){\r\n    for (int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint transposeMatrix(int rows, int cols, int mat[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]){\r\n    for (int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            result[j][i] = mat[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n\n/* --- 20615031_Yew Xin Nie_LA3/20615031_Yew Xin Nie_LA3/Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>    // for boolean\r\n\r\n#define MAX_ITEMS 100   // MAX SIZE for Grocery Items\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Struct definitions //\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];   // array of GroceryItem (all grocery list in array)\r\n    int itemCount;  // track how many items are currently in the inventory\r\n} GroceryInventory;\r\n\r\n// Function prototypes //\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateItemQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    // Initialize the inventory //\r\n    GroceryInventory inventory = { .itemCount = 0 };    \r\n    int choice = 0;\r\n\r\n\r\n    do {\r\n        // Display Menu //\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity of Grocery Item\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateItemQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program. Have a nice day, Bye bye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item //\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    // Check the inventory does not exceed the maximum size //\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n    \r\n    // Create a pointer (item) directly points the next slot in the array //\r\n    GroceryItem *item = &inventory->items[inventory->itemCount];\r\n\r\n    printf(\"Enter item name: \");\r\n    getchar(); // Clear newline from input buffer \r\n    fgets(item->name, MAX_NAME_LENGTH, stdin); // Recieve data input for item name\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove trailing newline\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(item->category, MAX_CATEGORY_LENGTH, stdin); // Receive data input of category\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0'; \r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    // Automatically update the stock availability status //\r\n    // inStock = true : item > 0 \r\n    // inStock = false: item < 0 (Out of stock)\r\n    item->inStock = (item->quantity > 0);\r\n\r\n    // increment of itemCount as each time the user add\r\n    inventory->itemCount++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    // Check if inventory is empty or not\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\tListing All Grocery Items\\t\\n\");\r\n    printf(\"\\nGrocery Items:\\n\");\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory -> items[i];\r\n\r\n        printf(\"Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: %s\\n\",\r\n               item->name, item->category, item->quantity, item->price,\r\n               item->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateItemQuantity(GroceryInventory *inventory) {\r\n    //Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to update: \");\r\n    getchar(); // Clear newline from input buffer\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';   // remove new line character from the input string\r\n\r\n    // Search grocery item in inventory //\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory -> items[i];\r\n        if (strcmp(item->name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &item->quantity);\r\n            item->inStock = (item->quantity > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    //Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar(); // Clear newline from input buffer\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    // Search grocery item in inventory //\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->itemCount--;     // removing item from inventory\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return; // return value to the function\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- 20615031_Yew Xin Nie_LA3/20615031_Yew Xin Nie_LA3/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Struct definition for a student node\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Head pointer for the linked list //\r\nStudent* head = NULL;\r\n\r\n                // Function prototypes //\r\n// Function to create a new student node//\r\nStudent* createStudent(const char* name, int id, float grade){\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a student into the linked list\r\nvoid insertStudent(const char* name, int id, float grade){\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records in the linked list\r\nvoid displayStudents(){\r\n    if (!head) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id){\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire linked list and frees the allocated memory\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to ensure all memory is freed \r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort the student records by grades using bubble sorting alogrithm\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return; // No sorting needed for empty or single-node list\r\n    }\r\n\r\n    // Bubble Sort for simplicity\r\n    int swapped; // keep track of swaps were made during an iteration\r\n    Student* pass;  // a pointer that traverses the lsit during each pass\r\n    Student* last_pass = NULL;  // marks the last sorted position in the list\r\n\r\n// Ensure sorting until no swaps until end of the list\r\n    do {\r\n        swapped = 0;    // Reset swapped flag for each pass\r\n        pass = head;    // Starting of the list\r\n\r\n        // Make sure the list is in the correct order\r\n        while (pass->next != last_pass) {\r\n            if (pass -> grade > pass -> next -> grade) {\r\n                // Swap grades\r\n                float tempGrade = pass ->grade;\r\n                pass ->grade = pass -> next -> grade;\r\n                pass-> next -> grade = tempGrade;\r\n\r\n                // Swap IDs\r\n                int tempID = pass -> id;\r\n                pass -> id = pass -> next -> id;\r\n                pass -> next -> id = tempID;\r\n\r\n                // Swap names\r\n                char tempName[100];\r\n                strcpy(tempName, pass -> name);\r\n                strcpy(pass -> name, pass -> next -> name);\r\n                strcpy(pass -> next -> name, tempName);\r\n\r\n                swapped = 1; // Shows that list is unsorted\r\n            }\r\n            pass = pass -> next;\r\n        }\r\n        last_pass = pass;   // the last node is in the correct position\r\n    } while (swapped == 0); \r\n}\r\n\r\nint main() {\r\n    // Decalre variable and intialize zone//\r\n    int choice, id = 0;\r\n    char name[100];\r\n    float grade = 0.0;\r\n    Student* foundStudent;\r\n\r\n    do {\r\n        printf(\"\\nStudent Records Management System\\n\");\r\n        printf(\"\\t1. Insert Student Record\\n\");\r\n        printf(\"\\t2. Display Student Records\\n\");\r\n        printf(\"\\t3. Sort Records by Grade\\n\");\r\n        printf(\"\\t4. Search Record by ID\\n\");\r\n        printf(\"\\t5. Delete All Records\\n\");\r\n        printf(\"\\t6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  // To consume the newline character\r\n\r\n        switch (choice) {\r\n            // Insert Student Record //\r\n            case 1:\r\n                printf(\"Enter student's name: \");\r\n                getchar();              // Clear newline from input buffer\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");     // Remove newline\r\n\r\n                printf(\"Enter student's ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter student's grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                printf(\"Student record inserted successfully.\\n\");\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Student records sorted by grade.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter the ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Student Found:\\n\");\r\n                    printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting program. Goodbye!\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "feedback": "q1-In the inputMatrix function, the parameter types are not declared correctly in the function prototype. Function prototypes should match their definitions. In the menu option for transposing Matrix B, the printed message incorrectly indicates \"Transpose of Matrix A\" instead of \"Transpose of Matrix B\".\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is correctly implemented and sorts the student records by grade in ascending order. While it is simple to understand, its time complexity of O(n?) can be inefficient for larger datasets. Consider implementing more efficient algorithms like Quick Sort or Merge Sort for better performance."
  },
  {
    "student_id": "20612965",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\n\n#define MAX 10\n\nvoid inputMatrix(const char *name, int rows, int cols, int matrix[MAX][MAX]) {\n    printf(\"Enter elements for Matrix %s:\\n\", name);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1); // 1-based indexing for user-friendly input\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\nint main() {\n    int rowsA, colsA, rowsB, colsB, choice;\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\n\n    // Input for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    inputMatrix(\"A\", rowsA, colsA, A);\n\n    // Input for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    inputMatrix(\"B\", rowsB, colsB, B);\n\n    // Ensure matrices are compatible for addition and subtraction\n    if (rowsA != rowsB || colsA != colsB) {\n        printf(\"Matrix operations are only possible for matrices of the same dimensions.\\n\");\n        return 1;\n    }\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n        case 1:\n            addMatrices(rowsA, colsA, A, B, result);\n            printf(\"Result of Matrix A + Matrix B:\\n\");\n            printMatrix(rowsA, colsA, result);\n            break;\n        case 2:\n            subtractMatrices(rowsA, colsA, A, B, result);\n            printf(\"Result of Matrix A - Matrix B:\\n\");\n            printMatrix(rowsA, colsA, result);\n            break;\n        case 3:\n            transposeMatrix(rowsA, colsA, A, result);\n            printf(\"Transpose of Matrix A:\\n\");\n            printMatrix(colsA, rowsA, result);\n            break;\n        case 4:\n            transposeMatrix(rowsB, colsB, B, result);\n            printf(\"Transpose of Matrix B:\\n\");\n            printMatrix(colsB, rowsB, result);\n            break;\n        case 5:\n            printf(\"Exiting...\\n\");\n            break;\n        default:\n            printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n/* --- q2.c --- */\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n\n// Structure for Grocery Item\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    int inStock; // 1 for In Stock, 0 for Out of Stock\n} GroceryItem;\n\n// Structure for Inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    int itemCount; // Number of items currently in the inventory\n} GroceryInventory;\n\n// Function to add a grocery item to the inventory\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->itemCount >= MAX_ITEMS) {\n        printf(\"Inventory is full! Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem *item = &inventory->items[inventory->itemCount];\n\n    printf(\"Enter Item Name: \");\n    scanf(\" %[^\\n]\", item->name);\n    printf(\"Enter Category: \");\n    scanf(\" %[^\\n]\", item->category);\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &item->quantity);\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &item->price);\n\n    item->inStock = (item->quantity > 0) ? 1 : 0; // Determine availability based on quantity\n    inventory->itemCount++;\n\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items in the inventory\nvoid listGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->itemCount == 0) {\n        printf(\"No grocery items in inventory.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < inventory->itemCount; i++) {\n        const GroceryItem *item = &inventory->items[i]; // Add 'const' here\n        printf(\"\\nName: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\", item->inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity(GroceryInventory *inventory) {\n    char name[100];\n    printf(\"Enter name of the grocery item to update quantity: \");\n    scanf(\" %[^\\n]\", name);\n\n    for (int i = 0; i < inventory->itemCount; i++) {\n        if (strcasecmp(inventory->items[i].name, name) == 0) { // Case-insensitive comparison\n            printf(\"Enter new quantity for %s: \", inventory->items[i].name);\n            scanf(\"%d\", &inventory->items[i].quantity);\n            inventory->items[i].inStock = (inventory->items[i].quantity > 0) ? 1 : 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Grocery item not found.\\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    char name[100];\n    printf(\"Enter name of the grocery item to remove: \");\n    scanf(\" %[^\\n]\", name);\n\n    for (int i = 0; i < inventory->itemCount; i++) {\n        if (strcasecmp(inventory->items[i].name, name) == 0) { // Case-insensitive comparison\n            printf(\"Grocery item '%s' removed successfully!\\n\", inventory->items[i].name); // Updated message\n            for (int j = i; j < inventory->itemCount - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n            }\n            inventory->itemCount--;\n            return;\n        }\n    }\n\n    printf(\"Grocery item not found.\\n\");\n}\n\n// Main function\nint main() {\n    GroceryInventory inventory = {.itemCount = 0};\n    int choice;\n\n    do {\n        // Display menu\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n        case 1:\n            addGroceryItem(&inventory);\n            break;\n        case 2:\n            listGroceryItems(&inventory);\n            break;\n        case 3:\n            updateQuantity(&inventory);\n            break;\n        case 4:\n            removeGroceryItem(&inventory);\n            break;\n        case 5:\n            printf(\"Exiting program.\\n\");\n            break;\n        default:\n            printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n/* --- q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL; // Head of the linked list\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted successfully.\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records found.\\n\");\n        return;\n    }\n\n    Student* temp = head;\n    while (temp != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp != NULL) {\n        if (temp->id == id) {\n            return temp; // Found the student\n        }\n        temp = temp->next;\n    }\n    return NULL; // Student not found\n}\n\n// Function to sort the student records by grade using Bubble Sort\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        printf(\"No sorting needed for an empty or single-node list.\\n\");\n        return;\n    }\n\n    int swapped;\n    Student *ptr1, *lptr = NULL;\n\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                // Swap the data\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, ptr1->name);\n                tempID = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempID;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Function to delete the entire linked list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n\n    head = NULL;\n    printf(\"List deleted.\\n\");\n}\n\n// Function to free memory (utility function)\nvoid freeMemory() {\n    deleteList();\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\"); // Remove the newline character\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n\n/* --- __MACOSX/._q1.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0001\u0000\u0000\u0000\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0001$\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0001$\u0000\u0000\u0000\u000f\u0000\u0000\u0017com.apple.TextEncoding\u0000\u0000\u0000\u0000\u0000\u00013\u0000\u0000\u0000\u0010\u0000\u0000\u001acom.apple.lastuseddate#PS\u0000\u0000\u0000\u0000\u0000\u0000\u0001C\u0000\u0000\u0000H\u0000\u0000\u000fcom.apple.macl\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000Y\u0000\u00007com.apple.metadata:kMDLabel_m65d675oassfducdmkx3zllscu\u0000\u0000\u0000utf-8;134217984\u0018]g\u0000\u0000\u0000\u0000C \u0004\u0000\u0000\u0000\u0000\u0006\u0000\u0015GNӱwy\u000b3\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000䘜<\u0000?\u001a9zw\u00101_,\u001bM9\u0007^V)d\u000f/x\u001e_mr\u0010Ί&\\\u001dA \u0014]\u0014\u0003\u0002RVG~\tZ",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation uses Bubble Sort to sort student records by grade. While it works properly, it has a time complexity of O(n?), which may not be efficient for larger datasets. Consider using more efficient sorting algorithms like Merge Sort or Quick Sort for better performance in future implementations."
  },
  {
    "student_id": "20596548",
    "code": "\n/* --- question1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10\r\n\r\n// Function prototypes\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int A[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid printMatrix(int A[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\r\n    int rows, cols;\r\n    int choice;\r\n\r\n    // Input matrix dimensions with validation\r\n    do {\r\n        printf(\"Enter the number of rows and columns (max 10x10): \");\r\n        scanf(\"%d %d\", &rows, &cols);\r\n        if (rows < 1 || rows > MAX || cols < 1 || cols > MAX) {\r\n            printf(\"Invalid dimensions! Please enter values between 1 and 10.\\n\");\r\n        }\r\n    } while (rows < 1 || rows > MAX || cols < 1 || cols > MAX);\r\n\r\n    // Input matrix A\r\n    printf(\"Enter elements of matrix A:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"A[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input matrix B\r\n    printf(\"Enter elements of matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"B[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n    }\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addMatrices(A, B, result, rows, cols);\r\n                printf(\"Result of A + B:\\n\");\r\n                printMatrix(result, rows, cols);\r\n                break;\r\n            case 2:\r\n                subtractMatrices(A, B, result, rows, cols);\r\n                printf(\"Result of A - B:\\n\");\r\n                printMatrix(result, rows, cols);\r\n                break;\r\n            case 3:\r\n                transposeMatrix(A, result, rows, cols);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, cols, rows); // Transposed matrix has swapped dimensions\r\n                break;\r\n            case 4:\r\n                transposeMatrix(B, result, rows, cols);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, cols, rows); // Transposed matrix has swapped dimensions\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Add corresponding elements of matrices A and B\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Subtract corresponding elements of matrices A and B\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Transpose matrix A\r\nvoid transposeMatrix(int A[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = A[i][j]; // Swap rows with columns\r\n        }\r\n    }\r\n}\r\n\r\n// Print matrix elements\r\nvoid printMatrix(int A[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", A[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\n/* --- Question2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int itemCount;\r\n} Inventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(Inventory *inv);\r\nvoid listGroceryItems(const Inventory *inv);\r\nvoid updateQuantity(Inventory *inv);\r\nvoid removeGroceryItem(Inventory *inv);\r\n\r\nint main() {\r\n    Inventory inv = {{}, 0}; // Initialize empty inventory\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inv);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inv);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inv);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inv);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Add a new grocery item to inventory\r\nvoid addGroceryItem(Inventory *inv) {\r\n    if (inv->itemCount < MAX_ITEMS) {\r\n        GroceryItem item;\r\n        printf(\"Enter item name: \");\r\n        scanf(\" %[^\\n]\", item.name); // Read full line for string input\r\n        printf(\"Enter item category: \");\r\n        scanf(\" %[^\\n]\", item.category);\r\n        printf(\"Enter quantity: \");\r\n        scanf(\"%d\", &item.quantity);\r\n        printf(\"Enter price: \");\r\n        scanf(\"%f\", &item.price);\r\n\r\n        inv->items[inv->itemCount++] = item; // Add item to inventory\r\n    } else {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n    }\r\n}\r\n\r\n// List all grocery items with their details\r\nvoid listGroceryItems(const Inventory *inv) {\r\n    if (inv->itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    printf(\"Grocery Inventory:\\n\");\r\n    for (int i = 0; i < inv->itemCount; i++) {\r\n        printf(\"Name: %s, Category: %s, Quantity: %d, Price: %.2f\\n\",\r\n               inv->items[i].name, inv->items[i].category,\r\n               inv->items[i].quantity, inv->items[i].price);\r\n    }\r\n}\r\n\r\n// Update the quantity of an existing grocery item\r\nvoid updateQuantity(Inventory *inv) {\r\n    char name[100];\r\n    printf(\"Enter item name to update quantity: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < inv->itemCount; i++) {\r\n        if (strcmp(inv->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inv->items[i].quantity);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Remove a grocery item from the inventory\r\nvoid removeGroceryItem(Inventory *inv) {\r\n    char name[100];\r\n    printf(\"Enter item name to remove: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < inv->itemCount; i++) {\r\n        if (strcmp(inv->items[i].name, name) == 0) {\r\n            for (int j = i; j < inv->itemCount - 1; j++) {\r\n                inv->items[j] = inv->items[j + 1]; // Shift items\r\n            }\r\n            inv->itemCount--;\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Question3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student;\r\n\r\nStudent* head = NULL; // Head pointer to the linked list\r\n\r\n// Function prototypes as per the skeleton\r\nStudent* createStudent(const char* name, int id, float grade); \r\nvoid insertStudent(const char* name, int id, float grade); \r\nvoid displayStudents(); \r\nStudent* searchStudentByID(int id); \r\nvoid deleteList(); \r\nvoid freeMemory();  \r\nvoid sortStudents();  \r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); \r\n    strcpy(newStudent->name, name); \r\n    newStudent->id = id; \r\n    newStudent->grade = grade; \r\n    newStudent->next = NULL; \r\n    return newStudent; \r\n} \r\n\r\n// Function to insert a new student record into the linked list\r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = createStudent(name, id, grade); \r\n    newStudent->next = head; \r\n    head = newStudent; \r\n} \r\n\r\n// Function to display all student records\r\nvoid displayStudents() { \r\n    if (head == NULL) { \r\n        printf(\"No students found!\\n\"); \r\n        return; \r\n    } \r\n\r\n    Student* current = head; \r\n    while (current != NULL) { \r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade); \r\n        current = current->next; \r\n    } \r\n} \r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) { \r\n    Student* current = head; \r\n    while (current != NULL) { \r\n        if (current->id == id) { \r\n            return current; // Found the student \r\n        } \r\n        current = current->next; \r\n    } \r\n    return NULL; // Student not found \r\n} \r\n\r\n// Function to delete the entire linked list and free memory\r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); // Free the current node \r\n        current = next; \r\n    } \r\n    head = NULL; // Set head to NULL after deletion \r\n} \r\n\r\n// Function to ensure all memory is freed before the program exits\r\nvoid freeMemory() { \r\n    deleteList(); // Free all the allocated memory for the list \r\n} \r\n\r\n// Function to sort the student records by grade using a simple sorting algorithm (Bubble Sort)\r\nvoid sortStudents() { \r\n    if (head == NULL || head->next == NULL) { \r\n        return; // No need to sort if the list is empty or has only one student \r\n    } \r\n\r\n    for (Student* i = head; i != NULL; i = i->next) { \r\n        for (Student* j = i->next; j != NULL; j = j->next) { \r\n            if (i->grade > j->grade) { \r\n                // Swap the grades, IDs, and names of the students\r\n                float tempGrade = i->grade; \r\n                i->grade = j->grade; \r\n                j->grade = tempGrade; \r\n\r\n                int tempId = i->id; \r\n                i->id = j->id; \r\n                j->id = tempId; \r\n\r\n                char tempName[100]; \r\n                strcpy(tempName, i->name); \r\n                strcpy(i->name, j->name); \r\n                strcpy(j->name, tempName); \r\n            } \r\n        } \r\n    } \r\n}\r\n\r\nint main() { \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n\r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records by Grade\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); // Remove newline character from name \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents(); \r\n                printf(\"Records sorted by grade.\\n\"); \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n\r\n    return 0; \r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to sort the student records by grade. While this algorithm is easy to implement, it has a time complexity of O(n?), making it inefficient for larger datasets. Consider using a more efficient sorting algorithm, like Merge Sort or Quick Sort, for improved performance."
  },
  {
    "student_id": "20714775",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n\r\n#define MAX 10\r\n\r\n\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX];\r\n    int result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    \r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    \r\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    \r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrices dimensions do not match for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrices dimensions do not match for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\nvoid addMatrices(int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid subtractMatrices(int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} GroceryItem;\r\n\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = {.count = 0};\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item.name, sizeof(item.name), stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, sizeof(item.category), stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n    getchar();\r\n\r\n    item.inStock = item.quantity > 0;\r\n    inventory->items[inventory->count++] = item;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        GroceryItem item = inventory->items[i];\r\n        printf(\"\\nName: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\", item.inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            getchar();\r\n\r\n            inventory->items[i].inStock = inventory->items[i].quantity > 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n\r\n    if (!head) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;\r\n    while (temp) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Insufficient records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempID = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempID;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1: {\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            }\r\n            case 2: {\r\n                displayStudents();\r\n                break;\r\n            }\r\n            case 3: {\r\n                sortStudents();\r\n                break;\r\n            }\r\n            case 4: {\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            }\r\n            case 5: {\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            }\r\n            case 6: {\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            }\r\n            default: {\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n            }\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. However, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20704944",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function declarations\r\nvoid inputMatrix(int matrix[][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int C[][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int C[][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols);\r\nvoid printMatrix(int matrix[][MAX_SIZE], int rows, int cols);\r\nint getMenuChoice();\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n    \r\n    // Input dimensions for Matrix A\r\n    do {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n    } while (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE);\r\n    \r\n    // Input elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n    \r\n    // Input dimensions for Matrix B\r\n    do {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n    } while (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE);\r\n    \r\n    // Input elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n    \r\n    // Main menu loop\r\n    while (1) {\r\n        choice = getMenuChoice();\r\n        \r\n        switch (choice) {\r\n            case 1: // Addition\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error: Matrices dimensions must be equal for addition\\n\");\r\n                }\r\n                break;\r\n                \r\n            case 2: // Subtraction\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error: Matrices dimensions must be equal for subtraction\\n\");\r\n                }\r\n                break;\r\n                \r\n            case 3: // Transpose Matrix A\r\n                transposeMatrix(A, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA);\r\n                break;\r\n                \r\n            case 4: // Transpose Matrix B\r\n                transposeMatrix(B, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB);\r\n                break;\r\n                \r\n            case 5: // Exit\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n// Input matrix elements\r\nvoid inputMatrix(int matrix[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Matrix addition\r\nvoid addMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int C[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Matrix subtraction\r\nvoid subtractMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int C[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Matrix transpose\r\nvoid transposeMatrix(int matrix[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Print matrix\r\nvoid printMatrix(int matrix[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Display menu and get user choice\r\nint getMenuChoice() {\r\n    int choice;\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n    } while (choice < 1 || choice > 5);\r\n    \r\n    return choice;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n#define MAX_ITEMS 100\r\n\r\n// Structure for grocery item\r\nstruct GroceryItem {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Structure for availability status\r\nstruct AvailabilityStatus {\r\n    bool inStock;\r\n};\r\n\r\n// Structure for grocery inventory\r\nstruct GroceryInventory {\r\n    struct GroceryItem items[MAX_ITEMS];\r\n    struct AvailabilityStatus status[MAX_ITEMS];\r\n    int itemCount;\r\n};\r\n\r\n// Function declarations\r\nvoid initializeInventory(struct GroceryInventory *inventory);\r\nvoid addGroceryItem(struct GroceryInventory *inventory);\r\nvoid listGroceryItems(struct GroceryInventory *inventory);\r\nvoid updateQuantity(struct GroceryInventory *inventory);\r\nvoid removeGroceryItem(struct GroceryInventory *inventory);\r\nint findItem(struct GroceryInventory *inventory, char *name);\r\n\r\nint main() {\r\n    struct GroceryInventory inventory;\r\n    initializeInventory(&inventory);\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Clear input buffer\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid initializeInventory(struct GroceryInventory *inventory) {\r\n    inventory->itemCount = 0;\r\n}\r\n\r\nvoid addGroceryItem(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n\r\n    struct GroceryItem *item = &inventory->items[inventory->itemCount];\r\n    \r\n    printf(\"Enter Item Name: \");\r\n    fgets(item->name, MAX_NAME_LENGTH, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0;\r\n    \r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, MAX_CATEGORY_LENGTH, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0;\r\n    \r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    \r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    inventory->status[inventory->itemCount].inStock = (item->quantity > 0);\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\", inventory->status[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    int index = findItem(inventory, itemName);\r\n    if (index == -1) {\r\n        printf(\"Item not found!\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter new quantity for %s: \", itemName);\r\n    scanf(\"%d\", &inventory->items[index].quantity);\r\n    inventory->status[index].inStock = (inventory->items[index].quantity > 0);\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    int index = findItem(inventory, itemName);\r\n    if (index == -1) {\r\n        printf(\"Item not found!\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift remaining items\r\n    for (int i = index; i < inventory->itemCount - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->status[i] = inventory->status[i + 1];\r\n    }\r\n    inventory->itemCount--;\r\n    printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n}\r\n\r\nint findItem(struct GroceryInventory *inventory, char *name) {\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX_NAME 50\r\n\r\n// Student structure definition\r\ntypedef struct Student {\r\n    char name[MAX_NAME];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Global variable - List head\r\nStudent* head = NULL;\r\n\r\n// Function declarations\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\nvoid sortStudents();\r\nint getMenuChoice();\r\n\r\nint main() {\r\n    int choice;\r\n    char name[MAX_NAME];\r\n    int id;\r\n    float grade;\r\n    Student* found;\r\n\r\n    while (1) {\r\n        choice = getMenuChoice();\r\n        \r\n        switch (choice) {\r\n            case 1: // Insert student record\r\n                printf(\"Enter Name: \");\r\n                scanf(\"%s\", name);\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n                \r\n            case 2: // Display student records\r\n                displayStudents();\r\n                break;\r\n                \r\n            case 3: // Sort records\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n                break;\r\n                \r\n            case 4: // Search record\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found student: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n                \r\n            case 5: // Delete list\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n                \r\n            case 6: // Exit\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n// Create new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    \r\n    strncpy(newStudent->name, name, MAX_NAME - 1);\r\n    newStudent->name[MAX_NAME - 1] = '\\0';\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    \r\n    return newStudent;\r\n}\r\n\r\n// Insert student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    \r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        newStudent->next = head;\r\n        head = newStudent;\r\n    }\r\n}\r\n\r\n// Display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    \r\n    if (current == NULL) {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    \r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", \r\n               current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Search student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    \r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    \r\n    return NULL;\r\n}\r\n\r\n// Delete entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    \r\n    head = NULL;\r\n}\r\n\r\n// Free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Bubble sort implementation\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n    \r\n    int swapped;\r\n    Student* current;\r\n    Student* last = NULL;\r\n    \r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n        \r\n        while (current->next != last) {\r\n            if (current->grade > current->next->grade) {\r\n                // Swap data\r\n                char tempName[MAX_NAME];\r\n                strcpy(tempName, current->name);\r\n                int tempId = current->id;\r\n                float tempGrade = current->grade;\r\n                \r\n                strcpy(current->name, current->next->name);\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade;\r\n                \r\n                strcpy(current->next->name, tempName);\r\n                current->next->id = tempId;\r\n                current->next->grade = tempGrade;\r\n                \r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        last = current;\r\n    } while (swapped);\r\n}\r\n\r\n// Display menu and get user choice\r\nint getMenuChoice() {\r\n    int choice;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n    } while (choice < 1 || choice > 6);\r\n    \r\n    return choice;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to arrange student records by grade. While this algorithm is easy to understand and implement, it has a time complexity of O(n?), which may not be efficient for larger datasets. Consider implementing a more efficient sorting algorithm like Merge Sort or Quick Sort for improved performance."
  },
  {
    "student_id": "20612641",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define ROWS 10\r\n#define COLUMNS 10\r\n\r\n// Function prototypes\r\nvoid matrixAdd(int matA[ROWS][COLUMNS], int matB[ROWS][COLUMNS], int sum[ROWS][COLUMNS], int row, int col);\r\nvoid matrixSub(int matA[ROWS][COLUMNS], int matB[ROWS][COLUMNS], int diff[ROWS][COLUMNS], int row, int col);\r\nvoid transposeMatrix(int mat[ROWS][COLUMNS], int transpose[ROWS][COLUMNS], int row, int col);\r\nvoid printMatrix(int matrix[ROWS][COLUMNS], int row, int col, const char *title);\r\n\r\nint main() {\r\n    // Declare matrices and variables\r\n    int matA[ROWS][COLUMNS];\r\n    int matB[ROWS][COLUMNS];\r\n    int sum[ROWS][COLUMNS];\r\n    int diff[ROWS][COLUMNS];\r\n    int transposeA[ROWS][COLUMNS];\r\n    int transposeB[ROWS][COLUMNS];\r\n    int rowA, colA, rowB, colB;\r\n\r\n    // Input dimensions and elements for Matrix A\r\n    do {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowA, &colA);\r\n        if (rowA <= 0 || colA <= 0 || rowA > 10 || colA > 10) {\r\n            printf(\"Invalid dimensions. Please enter values between 1 and 10.\\n\");\r\n        }\r\n    } while (rowA <= 0 || colA <= 0 || rowA > 10 || colA > 10);\r\n\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rowA; i++) {\r\n        for (int j = 0; j < colA; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matA[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input dimensions and elements for Matrix B\r\n    do {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowB, &colB);\r\n        if (rowB <= 0 || colB <= 0 || rowB > 10 || colB > 10) {\r\n            printf(\"Invalid dimensions. Please enter values between 1 and 10.\\n\");\r\n        } else if (rowA != rowB || colA != colB) {\r\n            printf(\"Error: Matrices must have the same dimensions for addition and subtraction.\\n\");\r\n        }\r\n    } while (rowB <= 0 || colB <= 0 || rowB > 10 || colB > 10 || rowA != rowB || colA != colB);\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < rowB; i++) {\r\n        for (int j = 0; j < colB; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matB[i][j]);\r\n        }\r\n    }\r\n\r\n    int choice;\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                matrixAdd(matA, matB, sum, rowA, colA);\r\n                printMatrix(sum, rowA, colA, \"Result of Matrix A + Matrix B\");\r\n                break;\r\n            case 2:\r\n                matrixSub(matA, matB, diff, rowA, colA);\r\n                printMatrix(diff, rowA, colA, \"Result of Matrix A - Matrix B\");\r\n                break;\r\n            case 3:\r\n                transposeMatrix(matA, transposeA, rowA, colA);\r\n                printMatrix(transposeA, colA, rowA, \"Transpose of Matrix A\");\r\n                break;\r\n            case 4:\r\n                transposeMatrix(matB, transposeB, rowB, colB);\r\n                printMatrix(transposeB, colB, rowB, \"Transpose of Matrix B\");\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add two matrices\r\nvoid matrixAdd(int matA[ROWS][COLUMNS], int matB[ROWS][COLUMNS], int sum[ROWS][COLUMNS], int row, int col) {\r\n    for (int i = 0; i < row; i++) {\r\n        for (int j = 0; j < col; j++) {\r\n            sum[i][j] = matA[i][j] + matB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract Matrix B from Matrix A\r\nvoid matrixSub(int matA[ROWS][COLUMNS], int matB[ROWS][COLUMNS], int diff[ROWS][COLUMNS], int row, int col) {\r\n    for (int i = 0; i < row; i++) {\r\n        for (int j = 0; j < col; j++) {\r\n            diff[i][j] = matA[i][j] - matB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int mat[ROWS][COLUMNS], int transpose[ROWS][COLUMNS], int row, int col) {\r\n    for (int i = 0; i < row; i++) {\r\n        for (int j = 0; j < col; j++) {\r\n            transpose[j][i] = mat[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix with a title\r\nvoid printMatrix(int matrix[ROWS][COLUMNS], int row, int col, const char *title) {\r\n    printf(\"\\n%s:\\n\", title);\r\n    for (int i = 0; i < row; i++) {\r\n        for (int j = 0; j < col; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Define a structure for Grocery Item\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} GroceryItem;\r\n\r\n// Array to hold all grocery items\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0; // Total number of items in the inventory\r\n\r\n// Function prototypes\r\nvoid addItem();\r\nvoid listItems();\r\nvoid updateQuantity();\r\nvoid removeItem();\r\nvoid menu();\r\n\r\nint main() {\r\n    menu();\r\n    return 0;\r\n}\r\n\r\n// Function to display the menu and handle user choices\r\nvoid menu() {\r\n    int choice;\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity \\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character after the choice\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n}\r\n\r\n// Function to add a grocery item to the inventory\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar();\r\n\r\n    // Determine availability based on quantity\r\n    newItem.inStock = (newItem.quantity > 0);\r\n\r\n    // Add the item to the inventory\r\n    inventory[itemCount++] = newItem;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their details\r\nvoid listItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nInventory:\\n\");\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"  Name: %s\\n\", inventory[i].name);\r\n        printf(\"  Category: %s\\n\", inventory[i].category);\r\n        printf(\"  Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"  Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"  Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a specific grocery item\r\nvoid updateQuantity() {\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[100];\r\n    printf(\"Enter the name of the item to update quantity: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            getchar();\r\n\r\n            // Update availability status\r\n            inventory[i].inStock = (inventory[i].quantity > 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeItem() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery ite\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            // Shift items down to fill the gap\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid sortStudents();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                printf(\"Exiting...\\n\");\r\n                deleteList(); // Free memory before exiting\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!head) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    printf(\"Name\\tID\\tGrade\\n\");\r\n    while (temp) {\r\n        printf(\"%s\\t%d\\t%.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to sort student records by grade\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n    for (Student* i = head; i->next; i = i->next) {\r\n        for (Student* j = head; j->next; j = j->next) {\r\n            if (j->grade > j->next->grade) {\r\n                // Swap nodes\r\n                float tempGrade = j->grade;\r\n                j->grade = j->next->grade;\r\n                j->next->grade = tempGrade;\r\n\r\n                int tempID = j->id;\r\n                j->id = j->next->id;\r\n                j->next->id = tempID;\r\n\r\n                char tempName[100];\r\n                strcpy(tempName, j->name);\r\n                strcpy(j->name, j->next->name);\r\n                strcpy(j->next->name, tempName);\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade.\\n\");\r\n}\r\n\r\n",
    "feedback": "q1-Meet requirement\nq2-In the removeItem function, the message \"No grocery ite\" is truncated and should indicate that there are no grocery items to remove.\nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While this algorithm works well for small datasets, it has a time complexity of O(n?), making it inefficient for larger lists. For better performance, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20612918",
    "code": "\n/* --- q1lab3.c --- */\n#include <stdio.h>\r\n#define MAXROWS  10\r\n#define MAXCOLS 10\r\n\r\n//functions for matrix menu options\r\nvoid matrix(int arr[MAXROWS][MAXCOLS], int *row, int *col, char matrixName);\r\nvoid addMatrices(int row, int col, int matrixA[MAXROWS][MAXCOLS], int matrixB[MAXROWS][MAXCOLS]);\r\nvoid subMatrices(int row, int col, int matrixA[MAXROWS][MAXCOLS], int matrixB[MAXROWS][MAXCOLS]);\r\nvoid transposeMatrix(int row, int col, int matrix[MAXROWS][MAXCOLS], int transpose[MAXROWS][MAXCOLS], char matrixName);\r\n\r\n\r\nint main(){\r\n    int matrixA[MAXROWS][MAXCOLS], matrixB[MAXROWS][MAXCOLS], transposeA[MAXROWS][MAXCOLS], transposeB[MAXROWS][MAXCOLS];\r\n    int rowA, colA, rowB, colB, choice;\r\n\r\n    //matrix A\r\n    matrix(matrixA, &rowA, &colA, 'A');\r\n\r\n    //matrixB\r\n    matrix(matrixB, &rowB, &colB, 'B');\r\n\r\n   do{\r\n        //printing menu\r\n        printf(\"Matrix Operations Menus:\\n1. Add Matrices\\n2. Substract Matrices\\n3. Transpose Matrix A\\n4. Transpose Matrix B\\n5. Exit\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice){\r\n            case 1:\r\n                //checking if number of rows and columns are equal\r\n                if (rowA == rowB && colA == colB){\r\n                    addMatrices(rowA, colA, matrixA, matrixB);\r\n                }\r\n                else{\r\n                    printf(\"Matrices cannot be added\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowA == rowB && colA == colB){\r\n                    subMatrices(rowA, rowB, matrixA, matrixB);\r\n                }\r\n                else{\r\n                    printf(\"Matrices cannot be substracted\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // transpose matrix A\r\n                transposeMatrix(rowA, colA, matrixA, transposeA, 'A');\r\n                break;\r\n            case 4:\r\n                //transpose matrix B\r\n                transposeMatrix(rowB,  colB, matrixB, transposeB, 'B');\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Enter again...\");\r\n        }\r\n   }while (choice != 5);\r\n}\r\n\r\n//input matrix function\r\nvoid matrix(int arr[MAXROWS][MAXCOLS], int *row, int *col, char matrixName){ \r\n    do{    \r\n        // loop to enter number of rows and columns\r\n        printf(\"Enter dimensions for  Matrix %c: \", matrixName);\r\n        scanf(\"%d %d\", row, col);\r\n        if(*row > MAXROWS || *col > MAXCOLS){\r\n            printf(\"Exceeded matrix dimensions\");\r\n        }\r\n    } while (*row > MAXROWS || *col > MAXCOLS);\r\n\r\n    //loop to enter elements in each position in the matrix\r\n    printf(\"Enter elements for Matrix %c\\n\", matrixName);\r\n    for (int i=0; i < *row; ++i){\r\n        for (int j=0; j < *col; ++j){\r\n            printf(\"Element[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\",  &arr[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//function to add matrices\r\nvoid addMatrices(int row, int col, int matrixA[MAXROWS][MAXCOLS], int matrixB[MAXROWS][MAXCOLS]){\r\n    printf(\"Result of Matrix A + Matrix B:\\n \");\r\n    int addMatrix[MAXROWS][MAXCOLS];\r\n\r\n    //loop to add and display\r\n    for (int i=0; i<row; i++){\r\n        for (int j=0; j<col; j++){\r\n            addMatrix[i][j] = matrixA[i][j] + matrixB[i][j];\r\n            printf(\"%d \", addMatrix[i][j]);    \r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n\r\n}\r\n\r\n//function to subtract matrices\r\nvoid subMatrices(int row, int col, int matrixA[MAXROWS][MAXCOLS], int matrixB[MAXROWS][MAXCOLS]) {\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    int subMatrix[MAXROWS][MAXCOLS];\r\n\r\n    //loop to subtract and display\r\n    for (int i = 0; i < row; i++) {\r\n        for (int j = 0; j < col; j++) {\r\n            subMatrix[i][j] = matrixA[i][j] - matrixB[i][j];\r\n            printf(\"%d \", subMatrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\nvoid transposeMatrix(int row, int col, int matrix[MAXROWS][MAXCOLS], int transpose[MAXROWS][MAXCOLS], char matrixName){\r\n    printf(\"Transpose of Matrix %c:\\n\", matrixName);\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < col; j++)\r\n        transpose[j][i] = matrix[i][j];\r\n    }\r\n\r\n    for (int i=0; i<row; i++){\r\n        for (int  j=0; j<col; j++){\r\n            printf(\"%d \", transpose[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n\r\n}\r\n\r\n\n/* --- q2lab3.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n#define NAME_LENGTH 100\r\n#define CATEGORY_LENGTH 50\r\n#define MAXGROCERY 100\r\n\r\ntypedef struct {\r\n    char name[NAME_LENGTH];\r\n    char category[CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} groceryItem;\r\n\r\ntypedef struct {\r\n    groceryItem items[MAXGROCERY];\r\n    int total;\r\n} groceryInventory;\r\n\r\nvoid addGrocery(groceryInventory *inventory);\r\nvoid listGrocery(const groceryInventory *inventory);\r\nvoid updateQuantity(groceryInventory *inventory);\r\nvoid removeGrocery(groceryInventory *inventory);\r\n\r\n\r\n\r\nint main(){\r\n    groceryInventory inventory = {0};\r\n    int choice;\r\n\r\n    do{\r\n        //display menu\r\n        printf(\"\\nGrocery Inventory Management System\\n1. Add Grocery Item\\n2. List all Grocery Items\\n3. Update Quanitity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice){\r\n        case 1:\r\n            addGrocery(&inventory);\r\n            break;\r\n        case 2:\r\n            listGrocery(&inventory);\r\n            break;\r\n        case 3:\r\n            updateQuantity(&inventory);\r\n            break;\r\n        case 4:\r\n            removeGrocery(&inventory);\r\n            break;\r\n        case 5:\r\n            printf(\"Exiting..\");\r\n            break;\r\n        }\r\n    }while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n//function to add item to grocery\r\nvoid addGrocery(groceryInventory *inventory){\r\n    //checking if number of items exceeds maximum\r\n    if ((*inventory).total >= MAXGROCERY){\r\n        printf(\"Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    groceryItem newItem;\r\n\r\n    getchar(); //clear leftover newline from previous input\r\n    \r\n    //input new item namw\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.name, NAME_LENGTH, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0';\r\n\r\n    //input new item category\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, CATEGORY_LENGTH, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';\r\n\r\n    //input new item quantity\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    getchar(); // Clear newline after scanf\r\n\r\n    //input new  item  price\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar(); // Clear newline after scanf\r\n\r\n    newItem.inStock = (newItem.quantity > 0);\r\n\r\n    //adding new item to inventory structure\r\n    (*inventory).items[(*inventory).total] = newItem;  \r\n    (*inventory).total++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n//function to display all items in grocery inventory\r\nvoid listGrocery(const groceryInventory *inventory){\r\n    if ((*inventory).total == 0){\r\n        printf(\"No grocery items in inventory. \\n\");\r\n        return;\r\n    }\r\n\r\n    //loop to display all items in the grocery\r\n    for (int i = 0; i < (*inventory).total; i++){\r\n        printf(\"Name: %s\\n\", (*inventory).items[i].name);\r\n        printf(\"Category: %s\\n\", (*inventory).items[i].category);\r\n        printf(\"Quantity: %d\\n\", (*inventory).items[i].quantity);\r\n        printf(\"Price: %.2f\\n\\n\", (*inventory).items[i].price);\r\n         printf(\"Stock Status: %s\\n\", (*inventory).items[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n//function to update quantity of a grocery item\r\nvoid updateQuantity(groceryInventory *inventory){\r\n    char updateItem[NAME_LENGTH];\r\n\r\n    if ((*inventory).total == 0){\r\n        printf(\"No grocery items in inventory. \\n\");\r\n        return;\r\n    }\r\n\r\n    getchar();\r\n\r\n    //input name of grocery item to be updated\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(updateItem, NAME_LENGTH, stdin);\r\n    updateItem[strcspn(updateItem, \"\\n\")] = '\\0';\r\n\r\n    //loop to find the name\r\n    for (int i = 0; i < (*inventory).total; i++) {\r\n        if (strcmp((*inventory).items[i].name, updateItem) == 0) {\r\n            //input new item quantity\r\n            printf(\"Enter new quantity for %s: \", (*inventory).items[i].name);\r\n            scanf(\"%d\", &(*inventory).items[i].quantity);\r\n            getchar(); \r\n\r\n            (*inventory).items[i].inStock = ((*inventory).items[i].quantity > 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    //if item is not found\r\n    printf(\"Item with the name '%s' not found in the inventory.\\n\", updateItem);\r\n}\r\n\r\n//function to remove an item from grocery structure\r\nvoid removeGrocery(groceryInventory *inventory) {\r\n    if ((*inventory).total == 0) {\r\n        printf(\"No grocery items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    getchar();\r\n\r\n    char removeName[NAME_LENGTH];\r\n    //input  name of grocery item to be removed\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(removeName, NAME_LENGTH, stdin);\r\n    removeName[strcspn(removeName, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    //loop to find item\r\n    for (int i = 0; i < (*inventory).total; i++) {\r\n        if (strcmp((*inventory).items[i].name, removeName) == 0) {\r\n            //removing item \r\n            for (int j = i; j < (*inventory).total - 1; j++) {\r\n                (*inventory).items[j] = (*inventory).items[j + 1];\r\n            }\r\n            //reducing number of items\r\n            (*inventory).total--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", removeName);\r\n            return;\r\n        }\r\n    }\r\n        //if item not found\r\n        printf(\"Item with the name '%s' not found in the inventory.\\n\", removeName);\r\n}\r\n\n/* --- q3lab3.c --- */\n \r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student; \r\n \r\nStudent* head = NULL; \r\n \r\n// Function to create new student node\r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    (*newStudent).id = id;\r\n    (*newStudent).grade = grade;\r\n    (*newStudent).next = NULL;\r\n    return newStudent;\r\n \r\n} \r\n \r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = createStudent(name, id, grade);\r\n    (*newStudent).next = head;\r\n    head = newStudent;\r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    if (head == NULL) {\r\n        //if student struct is empty\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    //printing student records\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", (*temp).name, (*temp).id, (*temp).grade);\r\n        temp = (*temp).next;\r\n    }\r\n}\r\n \r\n \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n   // Write your code (1 mark) \r\n   Student* temp = head;\r\n    while (temp != NULL) {\r\n        if ((*temp).id == id) {\r\n            return temp;\r\n        }\r\n        temp = (*temp).next;\r\n    }\r\n    return NULL; // Student not found\r\n}\r\n\r\n \r\n \r\n// Function to delete all the entire list\r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n    head = NULL; \r\n} \r\n\r\n \r\n \r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n//Sort function to sort the student records by grade based on an algorithm of your choice \r\nvoid sortStudents() { \r\n// Write your code (1 mark) \r\n    if (head == NULL || (*head).next == NULL) {\r\n            return; // No need to sort if there are fewer than two students\r\n        }\r\n\r\n        int swapped;\r\n        Student* temp;\r\n        Student* last = NULL;\r\n\r\n        //bubble swap is used because its simple to use for small datasets and its easy to use for linked lists\r\n        do {\r\n            swapped = 0;\r\n            temp = head;\r\n\r\n            while ((*temp).next != last) {\r\n                if ((*temp).grade > (*(*temp).next).grade) {\r\n                    // Swap grades, names, and IDs\r\n                    char tempName[100];\r\n                    int tempID;\r\n                    float tempGrade;\r\n\r\n                    tempGrade = (*temp).grade;\r\n                    tempID = (*temp).id;\r\n                    strcpy(tempName, (*temp).name);\r\n\r\n                    (*temp).grade = (*(*temp).next).grade;\r\n                    (*temp).id = (*(*temp).next).id;\r\n                    strcpy((*temp).name, (*(*temp).next).name);\r\n\r\n                    (*(*temp).next).grade = tempGrade;\r\n                    (*(*temp).next).id = tempID;\r\n                    strcpy((*(*temp).next).name, tempName);\r\n\r\n                    swapped = 1;\r\n                }\r\n                temp = (*temp).next;\r\n            }\r\n            last = temp;\r\n        } while (swapped);\r\n} \r\n \r\n// Main function to drive the program \r\nint main() { \r\n \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents();                 \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n} \r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-Meet requirement."
  },
  {
    "student_id": "20700664",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#define MAX 10 // maximum size of the matrix\n\nvoid input(int matrix[MAX][MAX], int row, int col, char name) { // enter the element of the matrix\n    printf(\"Enter the elements for Matrix %c:\\n\", name);\n    for (int i = 0; i < row; i++) { // outer loop use to input rows\n        for (int j = 0; j < col; j++) { // inner loop use to input columns\n            printf(\"Element [%d][%d]: \", i+1, j+1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid add(int A[MAX][MAX], int B[MAX][MAX], int sum[MAX][MAX], int row, int col) { // add matrices\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            sum[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid subtract(int A[MAX][MAX], int B[MAX][MAX], int sum[MAX][MAX], int row, int col) { //  subtract matrices\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            sum[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid transpose(int matrix[MAX][MAX], int T[MAX][MAX], int row, int col) { // transpose matrix\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            T[j][i] = matrix[i][j];\n        }\n    }\n}\n\nvoid print(int matrix[MAX][MAX], int row, int col) { // display the matrix\n    for (int i = 0; i < row; i++) { // outer loop use to input rows\n        for (int j = 0; j < col; j++) { // inner loop use to input columns\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid menu(){\n    printf(\"\\nMatrix Operations Menu:\\n\");\n    printf(\"1. Add Matrices\\n\");\n    printf(\"2. Subtract Matrices\\n\");\n    printf(\"3. Transpose Matrix A\\n\");\n    printf(\"4. Transpose Matrix B\\n\");\n    printf(\"5. Exit\\n\");\n    printf(\"Enter your choice: \");\n}\n\nint main() {\n    int A[MAX][MAX], B[MAX][MAX], sum[MAX][MAX];// matrices\n    char nameA = 'A';\n    char nameB = 'B';\n    int rowsA, colsA, rowsB, colsB;\n    int choice;// choose the operation\n\n    printf(\"Enter the dimensions for matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    input(A, rowsA, colsA, nameA);\n\n    printf(\"Enter the dimensions for matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    input(B, rowsB, colsB, nameB);\n\n    do {\n        menu();\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) { // if matrices have same dimensions then add\n                    add(A, B, sum, rowsA, colsA);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    print(sum, rowsA, colsA);\n                } else {\n                    printf(\"Invalid opreation. Matrices have different dimensions.\\n\");\n                }\n                break;\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) { // if matrices have same dimensions then subtract\n                    subtract(A, B, sum, rowsA, colsA);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    print(sum, rowsA, colsA);\n                } else {\n                    printf(\"Invalid opreation. Matrices have different dimensions.\\n\");\n                }\n                break;\n            case 3:\n                transpose(A, sum, rowsA, colsA); // tranpose Matrix A\n                printf(\"Transpose of Matrix A:\\n\");\n                print(sum, colsA, rowsA);\n                break;\n            case 4:\n                transpose(B, sum, rowsB, colsB); // transpose Matrix B\n                printf(\"Transpose of Matrix B:\\n\");\n                print(sum, colsB, rowsB);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\"); // exit\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_NAME 100\n#define MAX_ITEMS 100\n#define MAX_CATEGORY 50\n\ntypedef struct { // struct for grocery items\n    char name [MAX_NAME];\n    char category[MAX_CATEGORY];\n    int quantity;\n    float price;\n} groceryItem;\n\ntypedef struct { // struct for availability status\n    int inStock;\n    int outOfStock;\n} availStatus;\n\ntypedef struct { // struct for grocery inventory\n    groceryItem items[MAX_ITEMS];\n    availStatus status[MAX_ITEMS];\n    int count;\n} groceryInventory;\n\nvoid menu() { // Grocery Inventory Management System menu\n    printf(\"\\nGrocery Inventory Management System\\n\");\n    printf(\"1. Add Grocery Item\\n\");\n    printf(\"2. List All Grocery Items\\n\");\n    printf(\"3. Update Quantity\\n\");\n    printf(\"4. Remove Grocery Item\\n\");\n    printf(\"5. Exit\\n\");\n}\n\nvoid add(groceryInventory *inventory) { // add grocery item function\n    if (inventory->count < MAX_ITEMS) { // if inventory is not full, input item's name, category, quantity and price\n        printf(\"Enter Item Name: \");\n        scanf(\"%s\", inventory->items[inventory->count].name);\n        printf(\"Enter Category: \");\n        scanf(\"%s\", inventory->items[inventory->count].category);\n        printf(\"Enter Quantity: \");\n        scanf(\"%d\", &inventory->items[inventory->count].quantity);\n        printf(\"Enter Price: \");\n        scanf(\"%f\", &inventory->items[inventory->count].price);\n\n        inventory->status[inventory->count].inStock = (inventory->items[inventory->count].quantity > 0); // update availability status\n        inventory->status[inventory->count].outOfStock = (inventory->items[inventory->count].quantity == 0);\n\n        inventory->count++;\n        printf(\"Grocery item added successfully!\\n\");\n    } else {\n        printf(\"Inventory is full.\\n\");\n    }\n}\n\nvoid list(groceryInventory *inventory) { // display function\n    if (inventory->count == 0) { // if inventory is not empty, display items\n        printf(\"No grocery items in the inventory.\\n\");\n    } else {\n        for (int i = 0; i < inventory->count; i++) {\n            printf(\"Name: %s\\n\", inventory->items[i].name);\n            printf(\"Category: %s\\n\", inventory->items[i].category);\n            printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\n            printf(\"Price: %.2f\\n\", inventory->items[i].price);\n            printf(\"Status: %s\\n\", inventory->status[i].inStock ? \"In Stock\" : \"Out of Stock\");\n        }\n    }\n}\n\nvoid update(groceryInventory *inventory) { // update function\n    char name [MAX_NAME];\n    int newQuantity;\n    printf(\"Enter name of the grocery item to update quantity: \"); \n    scanf(\"%s\", name);\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            printf(\"Enter new quantity for %s: \", name);// update quantity\n            scanf(\"%d\", &newQuantity);\n            inventory->items[i].quantity = newQuantity;\n            inventory->status[i].inStock = (newQuantity > 0); // update availability status\n            inventory->status[i].outOfStock = (newQuantity == 0);\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Grocery item not found.\\n\");\n}\n\nvoid removeGroceryItem(groceryInventory *inventory) { // remove function\n    char name [MAX_NAME];\n    printf(\"Enter name of the grocery item to remove: \");\n    scanf(\"%s\", name);\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            for (int j = i; j < inventory->count - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n                inventory->status[j] = inventory->status[j + 1];\n            }\n            inventory->count--;\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\n            return;\n        }\n    }\n    printf(\"Grocery item not found.\\n\");\n}\n\nint main() {\n    groceryInventory inventory = {0};\n    int choice;\n\n    do {\n        menu();\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) { // use switch-case\n            case 1:\n                add(&inventory);\n                break;\n            case 2:\n                list(&inventory);\n                break;\n            case 3:\n                update(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5); // when choice == 5 exit\n\n    return 0;\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // dynamic allocate memory for newStudent\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL; // initialize \"next\" to NULL\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head; // link \"next\" to the start of the linked list\n    head = newStudent; // update head pointer\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    Student* current = head; // start at the head of the linked list\n    if(current != NULL){ \n        while (current != NULL) {\n            printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n            current = current->next;\n        }\n    } else {\n        printf(\"Student records not found.\\n\");\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) { // when current ID matches, display the student record\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next; \n        free(current);\n        current = next;\n    }\n    head = NULL; \n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() {\n    if (head == NULL) { // if head == NULL exit\n    return;\n    }\n\n    Student* i, *j;\n    char tempName[100];\n    int tempID;\n    float tempGrade;\n\n    for (i = head; i != NULL; i = i->next) { // outer loop\n        for (j = i->next; j != NULL; j = j->next) { // inner loop\n            if (i->grade > j->grade) { // if grades are not in order, then swap student records\n                strcpy(tempName, i->name);// swap name\n                strcpy(i->name, j->name);\n                strcpy(j->name, tempName);\n\n                tempID = i->id;// swap ID\n                i->id = j->id;\n                j->id = tempID;\n\n                tempGrade = i->grade;// swap grade\n                i->grade = j->grade;\n                j->grade = tempGrade;\n            }\n        }\n    }\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n\n} \n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n        switch (choice) {\n        case 1:\n            printf(\"Enter Name: \");\n            fgets(name, sizeof(name), stdin);\n            strtok(name, \"\\n\");\n            printf(\"Enter ID: \");\n            scanf(\"%d\", &id);\n            printf(\"Enter Grade: \");\n            scanf(\"%f\", &grade);\n            insertStudent(name, id, grade);\n            break;\n        case 2:\n            displayStudents();\n            break;\n        case 3:\n            sortStudents();\n            break;\n        case 4:\n            printf(\"Enter ID to search: \");\n            scanf(\"%d\", &id);\n            Student* found = searchStudentByID(id); \n            if (found) {\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\n                found->name, found->id, found->grade);\n            } else {\n                printf(\"Student not found.\\n\");\n            }\n            break;\n        case 5:\n            deleteList();\n            printf(\"List deleted.\\n\");\n            break;\n        case 6:\n            freeMemory();\n            printf(\"Exiting...\\n\");\n            break;\n        default:\n            printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n return 0;\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is correctly implemented, and it sorts the student records by grade in ascending order. However, Bubble Sort has a time complexity of O(n?), which can be inefficient for larger datasets. Consider more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20618167",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 // Define the maximum matrix size\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]);\r\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]);\r\nvoid subtractMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB; // Dimensions of matrices\r\n    int A[MAX][MAX], B[MAX][MAX];  // Matrices A and B\r\n    int result[MAX][MAX];         // Result matrix for operations\r\n    int choice;\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter rows and columns for Matrix A (max %d): \", MAX);\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter rows and columns for Matrix B (max %d): \", MAX);\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Validate dimensions\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX) {\r\n        printf(\"Error: Dimensions exceed maximum limit of %d.\\n\", MAX);\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for matrices\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, A);\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, B);\r\n\r\n    // Menu for operations\r\n    do {\r\n        printf(\"\\nChoose an operation:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, A, B, result); // Call the function to add matrices\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(rowsA, colsA, result); // Display the result\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, A, B, result); // Call the function to subtract matrices\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    printMatrix(rowsA, colsA, result); // Display the result\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(rowsA, colsA, A, result); // Transpose Matrix A\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result); // Display the transpose\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(rowsB, colsB, B, result); // Transpose Matrix B\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result); // Display the transpose\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input elements of a matrix\r\n// Prompts the user to input values for the matrix\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\n// Loops through the matrix and prints its elements row by row\r\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\n// Adds corresponding elements from two matrices and stores in the result matrix\r\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\n// Subtracts corresponding elements from Matrix B from Matrix A and stores in the result matrix\r\nvoid subtractMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\n// Converts rows into columns and vice versa\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Define constants for maximum sizes\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Define struct for a grocery item\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];        // Name of the grocery item\r\n    char category[MAX_CATEGORY_LEN]; // Category of the grocery item (e.g., Dairy, Vegetables)\r\n    int quantity;                   // Quantity of the item in stock\r\n    float price;                    // Price per unit of the item\r\n} GroceryItem;\r\n\r\n// Define struct for availability status\r\ntypedef struct {\r\n    int inStock; // 1 for true (item is in stock), 0 for false (item is out of stock)\r\n} AvailabilityStatus;\r\n\r\n// Define inventory containing items, their availability, and item count\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];           // Array of grocery items\r\n    AvailabilityStatus availability[MAX_ITEMS]; // Array to track the availability of each item\r\n    int count;                              // Current number of items in the inventory\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory); // Adds a new item to the inventory\r\nvoid listGroceryItems(GroceryInventory *inventory); // Lists all items in the inventory\r\nvoid updateGroceryQuantity(GroceryInventory *inventory); // Updates the quantity of a specific item\r\nvoid removeGroceryItem(GroceryInventory *inventory); // Removes an item from the inventory\r\n\r\n// Main function to provide a menu-driven interface\r\nint main() {\r\n    GroceryInventory inventory = {.count = 0}; // Initialize the inventory with 0 items\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity of a Grocery Item\\n\");\r\n        printf(\"4. Remove a Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Process user input and call the appropriate function\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory); // Add a new item\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory); // Display all items\r\n                break;\r\n            case 3:\r\n                updateGroceryQuantity(&inventory); // Update an item's quantity\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory); // Remove an item\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5); // Loop until the user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        // Check if the inventory is full\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Get a reference to the next available slot for an item\r\n    GroceryItem *item = &inventory->items[inventory->count];\r\n    AvailabilityStatus *status = &inventory->availability[inventory->count];\r\n\r\n    // Prompt the user to enter details for the new item\r\n    printf(\"Enter name: \");\r\n    scanf(\" %[^\\n]\", item->name);\r\n    printf(\"Enter category: \");\r\n    scanf(\" %[^\\n]\", item->category);\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    // Set availability status based on the quantity\r\n    status->inStock = (item->quantity > 0) ? 1 : 0;\r\n\r\n    // Increment the inventory count\r\n    inventory->count++;\r\n\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their availability\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        // Check if the inventory is empty\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Loop through each item and display its details\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        AvailabilityStatus *status = &inventory->availability[i];\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateGroceryQuantity(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        // Check if the inventory is empty\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the item to update: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    // Search for the item in the inventory\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Item found, prompt for the new quantity\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n\r\n            // Update the availability status based on the new quantity\r\n            inventory->availability[i].inStock = (inventory->items[i].quantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    // If the item is not found, notify the user\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        // Check if the inventory is empty\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    // Search for the item to remove\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Item found, shift all subsequent items up by one position\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n\r\n            // Decrement the inventory count\r\n            inventory->count--;\r\n\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    // If the item is not found, notify the user\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for a Student\r\ntypedef struct Student {\r\n    char name[100];          // Name of the student\r\n    int id;                  // ID of the student\r\n    float grade;             // Grade of the student\r\n    struct Student* next;    // Pointer to the next student in the list\r\n} Student;\r\n\r\nStudent* head = NULL; // Head pointer for the linked list\r\n\r\n// Function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid sortStudents();\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\nChoose an operation:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove trailing newline\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade); // Insert new student\r\n                break;\r\n            case 2:\r\n                displayStudents(); // Display all students\r\n                break;\r\n            case 3:\r\n                sortStudents(); // Sort students by grade\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id); // Search for a student by ID\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList(); // Delete the entire list\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to create a new student node\r\n// Allocates memory and initializes the fields\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new node\r\n    if (!newStudent) {\r\n        printf(\"Error: Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    // Assign values to the node's fields\r\n    strcpy(newStudent->name, name); // Copy the name to the struct\r\n    newStudent->id = id;            // Assign the ID\r\n    newStudent->grade = grade;      // Assign the grade\r\n    newStudent->next = NULL;        // Initialize the next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student into the linked list\r\n// Adds the student at the end of the list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade); // Create a new student node\r\n    if (!newStudent) return;\r\n\r\n    if (head == NULL) {\r\n        head = newStudent; // If the list is empty, the new student becomes the head\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next; // Traverse to the end of the list\r\n        }\r\n        temp->next = newStudent; // Link the new student to the end of the list\r\n    }\r\n    printf(\"Student added successfully.\\n\");\r\n}\r\n\r\n// Function to display all students\r\n// Traverses the list and prints each student's details\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No students to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next; // Move to the next node\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\n// Returns a pointer to the found student node or NULL if not found\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp; // If the ID matches, return the current node\r\n        }\r\n        temp = temp->next; // Move to the next node\r\n    }\r\n    return NULL; // Student not found\r\n}\r\n\r\n// Function to delete the entire linked list\r\n// Frees all allocated memory\r\nvoid deleteList() {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        Student* next = temp->next; // Store the next node\r\n        free(temp); // Free the current node's memory\r\n        temp = next; // Move to the next node\r\n    }\r\n    head = NULL; // Reset head to NULL\r\n}\r\n\r\n// Function to sort students by grade\r\n// Implements Bubble Sort for simplicity\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough students to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    do {\r\n        swapped = 0;\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            if (current->grade > current->next->grade) {\r\n                // Swap the grade values\r\n                float tempGrade = current->grade;\r\n                current->grade = current->next->grade;\r\n                current->next->grade = tempGrade;\r\n\r\n                // Swap the ID values\r\n                int tempID = current->id;\r\n                current->id = current->next->id;\r\n                current->next->id = tempID;\r\n\r\n                // Swap the name values\r\n                char tempName[100];\r\n                strcpy(tempName, current->name);\r\n                strcpy(current->name, current->next->name);\r\n                strcpy(current->next->name, tempName);\r\n\r\n                swapped = 1; // Indicate a swap occurred\r\n            }\r\n            current = current->next; // Move to the next node\r\n        }\r\n    } while (swapped);\r\n\r\n    printf(\"Students sorted by grade.\\n\");\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. However, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20613019",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for Matrix A\r\n    while (1) {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        if (scanf(\"%d %d\", &rowsA, &colsA) != 2 || rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE) {\r\n            printf(\"Invalid input. Please enter two integers between 1 and %d.\\n\", MAX_SIZE);\r\n            while (getchar() != '\\n'); // Clear invalid input\r\n        } else {\r\n            break; \r\n        }\r\n    }\r\n\r\n    // Input elements for Matrix A\r\n    inputMatrix(matrixA, rowsA, colsA, 'A');\r\n\r\n    // Input dimensions for Matrix B\r\n    while (1) {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        if (scanf(\"%d %d\", &rowsB, &colsB) != 2 || rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE) {\r\n            printf(\"Invalid input. Please enter two integers between 1 and %d.\\n\", MAX_SIZE);\r\n            while (getchar() != '\\n'); \r\n        } else {\r\n            break; \r\n        }\r\n    }\r\n\r\n    // Input elements for Matrix B\r\n    inputMatrix(matrixB, rowsB, colsB, 'B');\r\n\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid input. Please enter a number between 1 and 5.\\n\");\r\n            while (getchar() != '\\n'); \r\n            continue;\r\n        }\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    addMatrices(matrixA, matrixB, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible, matrices have different dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    subtractMatrices(matrixA, matrixB, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible, matrices have different dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                transposeMatrix(matrixA, rowsA, colsA);\r\n                break;\r\n            case 4:\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                transposeMatrix(matrixB, rowsB, colsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            while (scanf(\"%d\", &matrix[i][j]) != 1) { // Handle invalid input\r\n                printf(\"Invalid input. Please enter an integer for Element [%d][%d]: \", i + 1, j + 1);\r\n                while (getchar() != '\\n'); \r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n    displayMatrix(result, rows, cols);\r\n}\r\n\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n    displayMatrix(result, rows, cols);\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n    displayMatrix(result, cols, rows);\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define NAME_LENGTH 100\r\n#define CATEGORY_LENGTH 50\r\n\r\n// Structure represent grocery item\r\ntypedef struct {\r\n    char name[NAME_LENGTH];\r\n    char category[CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Structure represent inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addItem(GroceryInventory *inventory);\r\nvoid listItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeItem(GroceryInventory *inventory);\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .itemCount = 0 };\r\n    int choice;\r\n\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Display\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Add \r\nvoid addItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->itemCount];\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item->name, NAME_LENGTH, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0; \r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, CATEGORY_LENGTH, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    inventory->itemCount++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// List \r\nvoid listItems(const GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        printf(\"\\nName: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", item->quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Update\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; \r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        if (strcmp(item->name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", item->name);\r\n            scanf(\"%d\", &item->quantity);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Remove\r\nvoid removeItem(GroceryInventory *inventory) {\r\n    char name[NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Sort function to sort records by grade using bubble sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"No records to sort or only one record exists.\\n\");\r\n        return;\r\n    }\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                // Copy data of ptr1 into temporary variables\r\n                strcpy(tempName, ptr1->name);\r\n                tempID = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                // Swap ptr1 data with ptr1->next\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                // Put temporary data into ptr1->next\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempID;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1; \r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1; // Set lptr to the last sorted element\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade.\\n\");\r\n}\r\n\r\n// Function to delete\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"List deleted.\\n\");\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Main function\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation correctly sorts student records by grade. While bubble sort is simple and effective for small datasets, it has a time complexity of O(n?), which can lead to inefficiency with larger datasets. For improved performance, consider using more efficient algorithms such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20712242",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n\r\n//declare or define a size for the matrices that cannot be exceeded\r\n#define MAX_MSIZE 10\r\n\r\n//function prototypes\r\nvoid MatrixInput(int matrix[MAX_MSIZE][MAX_MSIZE], int trows, int tcolumns);\r\nvoid add_matrix(int matrix1[MAX_MSIZE][MAX_MSIZE], int matrix2[MAX_MSIZE][MAX_MSIZE], int matrix_result[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols);\r\nvoid sub_matrix(int matrix1[MAX_MSIZE][MAX_MSIZE], int matrix2[MAX_MSIZE][MAX_MSIZE], int matrix_result[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols);\r\nvoid transposeMatrix(int MatrixInput[MAX_MSIZE][MAX_MSIZE], int transposedMatrix[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols);\r\nvoid display(int matrix[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols);\r\n\r\n\r\n\r\n\r\nint main(){\r\n// firstly ask for userinput for the matrices \r\n\r\n//declare the matrices with the maximum size 10 for column and rows\r\nint matrix1[MAX_MSIZE][MAX_MSIZE];\r\nint matrix2[MAX_MSIZE][MAX_MSIZE];\r\nint matrix_result[MAX_MSIZE][MAX_MSIZE];\r\n//declare the dimensions for the matrices\r\nint row1, column1, row2, column2;\r\n//declare userinput\r\nint userinput;   // when user chooses operation\r\nint dimensions = 0;\r\n\r\n//input dimensions for the first matrix \r\ndo{\r\n    printf(\"Enter dimension for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &row1, &column1);\r\n    if(row1 > 0 && row1 <= MAX_MSIZE && column1 > 0 && column1 <= MAX_MSIZE){\r\n        dimensions = 1; // dimensions are correct \r\n    } else {\r\n        printf(\"Invalid Dimensions! Please enter values between 1 and %d.\\n\", MAX_MSIZE);\r\n\r\n    }\r\n} while (!dimensions);  // do this loop till this condition is met\r\n\r\n\r\n//input for elements for matrix 1\r\nprintf(\"Enter elements for Matrix A:\\n\");\r\n//call the function for inputting the matrix \r\nMatrixInput(matrix1, row1, column1);\r\n\r\n\r\n\r\n//input dimension for matrix B\r\ndimensions=0; //reset the validation flag so that it doesnt continue when error message is sent\r\ndo{\r\n    printf(\"Enter dimension for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &row2, &column2);\r\n    if(row2 == row1 && column2 == column1){ //ensure matrices have matching dimensions\r\n        dimensions= 1;       //valid dimensions    \r\n    } else {\r\n        printf(\"Invalid Dimensions! Matrix B must have same dimensions as Matrix A\\n\");   //Else print error message\r\n     }\r\n} while(!dimensions);  // do this loop till this condition is met where Matrix B matches Matrix A.\r\n\r\n//input elements for matrix B\r\nprintf(\"Enter elements for Matrix B:\\n\");\r\nMatrixInput(matrix2, row2, column2); //call the function \r\n\r\n\r\n//main menu for the operations to perform on the operations \r\ndo{\r\n\r\nprintf(\"Matrix Operations Menu:\\n\");\r\nprintf(\"1. Add Matrices\\n\");\r\nprintf(\"2. Subtract Matrices\\n\");\r\nprintf(\"3. Transpose Matrix A\\n\");\r\nprintf(\"4. Transpose Matrix B\\n\");\r\nprintf(\"5. Exit\\n\");\r\nprintf(\"Enter your choice: \");\r\nscanf(\"%d\", &userinput); //take userinput \r\n\r\n//create switch cases to call the functions for each operation\r\n switch(userinput){\r\n    case 1: //add the matrices\r\n    add_matrix(matrix1, matrix2, matrix_result, row1, column1);\r\n    printf(\"Result of Matrix A + B:\\n\");\r\n    display(matrix_result, row1, column1);\r\n    break;\r\n\r\n    case 2: //subtraction\r\n    sub_matrix(matrix1, matrix2, matrix_result, row1, column1);\r\n    printf(\"Result of Matrix A - B:\\n\");\r\n    display(matrix_result, row1, column1);\r\n    break;\r\n\r\n    case 3: //trasnpose Matrix A\r\n    transposeMatrix(matrix1, matrix_result, row1, column1);\r\n    printf(\"Transpose of Matrix A:\\n\");\r\n    display(matrix_result, column1, row1);\r\n    break;\r\n\r\n    case 4: // transpose matrix B\r\n    transposeMatrix(matrix2, matrix_result, row2, column2);\r\n    printf(\"Transpose of Matrix B:\\n\");\r\n    display(matrix_result, column2, row2);\r\n    break;\r\n\r\n    case 5: //exit\r\n    printf(\"Exited!\\n\");\r\n    break;\r\n\r\n    default: //invalid choices\r\n    printf(\"Invalid choice! Please try again.\\n\");\r\n }\r\n\r\n\r\n}while( userinput !=5);\r\n\r\nreturn 0;\r\n}\r\n\r\n\r\n\r\n//function for inputting the matrix\r\nvoid MatrixInput(int matrix[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols){\r\n    for( int row=0; row< numRows; row++){  //loop through the rows\r\n     for( int col=0; col < numCols; col++){  //loop throught the columns\r\n      printf(\"Element[%d][%d]: \", row+1, col+1);    //display each element \r\n      scanf(\"%d\", &matrix[row][col]);      //input the elements\r\n     }\r\n    }\r\n}\r\n\r\n//function to add the matrices\r\n\r\nvoid add_matrix(int matrix1[MAX_MSIZE][MAX_MSIZE], int matrix2[MAX_MSIZE][MAX_MSIZE], int matrix_result[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols){\r\n    for(int row=0; row< numRows; row++){\r\n        for(int col=0; col < numCols; col++){\r\n            matrix_result[row][col]= matrix1[row][col] + matrix2[row][col];   //add the two matrix\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//function to subtract the matrices\r\n\r\nvoid sub_matrix(int matrix1[MAX_MSIZE][MAX_MSIZE], int matrix2[MAX_MSIZE][MAX_MSIZE], int matrix_result[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols){\r\n    for(int row=0; row< numRows; row++){\r\n        for(int col=0; col < numCols; col++){\r\n            matrix_result[row][col]= matrix1[row][col] - matrix2[row][col];   //subtract the two matrix\r\n        }\r\n    }\r\n}\r\n\r\n//function to transpose matrix \r\nvoid transposeMatrix(int MatrixInput[MAX_MSIZE][MAX_MSIZE], int transposedMatrix[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols){\r\n    for(int row=0; row< numRows; row++){\r\n        for(int col=0; col < numCols; col++){\r\n            transposedMatrix[col][row]= MatrixInput[row][col];  //transpose element \r\n        }\r\n    }\r\n}\r\n\r\n\r\n//function to display the matrix\r\nvoid display(int matrix[MAX_MSIZE][MAX_MSIZE], int numRows, int numCols){\r\n    for(int row=0; row< numRows; row++){\r\n        for(int col=0; col < numCols; col++){\r\n           printf(\"%d \", matrix[row][col]); //print element\r\n        }\r\n        printf(\"\\n\"); //new line after each row. \r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h> \r\n#include <string.h>  \r\n\r\n#define MAX_ITEMS 100  // Define maximum number of items in the inventory\r\n#define MAX_NAME_LENGTH 100  // Define maximum length for the grocery item name\r\n#define MAX_CATEGORY_LENGTH 50  // Define maximum length for the grocery item category\r\n\r\n// Function prototypes \r\nvoid listItems();\r\nvoid addItem();\r\nvoid updateItemQuantity();\r\nvoid removeItem();\r\nvoid showMenu();\r\n\r\n// Structure to define a grocery item\r\ntypedef struct {\r\n    char itemName[MAX_NAME_LENGTH];  \r\n    char itemCategory[MAX_CATEGORY_LENGTH];  \r\n    int itemQuantity;  \r\n    float itemPrice;  \r\n    char itemStatus[20];  // Item status (either \"In Stock\" or \"Out of Stock\")\r\n} DataForGrocery;  \r\n\r\n//array and counter to store grocery items\r\nDataForGrocery groceryList[MAX_ITEMS]; \r\nint groceryCount = 0;    // Tracking the number of items in the list. \r\n\r\n// Function to add a grocery item to the inventory\r\nvoid addItem() {\r\n    if (groceryCount >= MAX_ITEMS) {  // To check if the number of items in the list exceed the max amount or not \r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;  \r\n    }\r\n \r\n // Ask for user inputs\r\n    DataForGrocery newGrocery;  // Declare a new grocery item variable\r\n    printf(\"Enter Item Name: \"); \r\n    scanf(\" %[^\\n]\", newGrocery.itemName);  \r\n\r\n    printf(\"Enter Category: \");  \r\n    scanf(\" %[^\\n]\", newGrocery.itemCategory);  // Read item category \r\n\r\n    printf(\"Enter Quantity: \");  \r\n    scanf(\"%d\", &newGrocery.itemQuantity); \r\n\r\n    printf(\"Enter Price: \");  \r\n    scanf(\"%f\", &newGrocery.itemPrice);  \r\n\r\n    // Set the item status based on the quantity\r\n    if (newGrocery.itemQuantity > 0) {\r\n        strcpy(newGrocery.itemStatus, \"In Stock\");  // If quantity is greater than 0, set status as \"In Stock\"\r\n    } else {\r\n        strcpy(newGrocery.itemStatus, \"Out of Stock\");  // Otherwise it is \"Out of Stock\"\r\n    }\r\n\r\n    groceryList[groceryCount++] = newGrocery;  // Add the new item to the inventory and increment item count\r\n    printf(\"Grocery item added successfully!\\n\"); \r\n}\r\n\r\n// Function to list all grocery items in the inventory\r\nvoid listItems() {\r\n    if (groceryCount == 0) {  // Check if the inventory is empty\r\n        printf(\"Inventory is empty.\\n\");  \r\n        return;  \r\n    }\r\n\r\n    // Loop through the inventory and display details of each item\r\n    for (int i = 0; i < groceryCount; i++) {\r\n        printf(\"Name: %s\\n\", groceryList[i].itemName);  \r\n        printf(\"Category: %s\\n\", groceryList[i].itemCategory); \r\n        printf(\"Quantity: %d\\n\", groceryList[i].itemQuantity);  \r\n        printf(\"Price: %.2f\\n\", groceryList[i].itemPrice);  \r\n        printf(\"Status: %s\\n\", groceryList[i].itemStatus); \r\n        printf(\"---------------------------\\n\");  \r\n    }\r\n}\r\n\r\n// Function to update the quantity of a specific grocery item\r\nvoid updateItemQuantity() {\r\n    if (groceryCount == 0) {  // Check if the inventory is empty\r\n        printf(\"Inventory is empty.\\n\");  \r\n        return;  \r\n    }\r\n\r\n    char searchName[MAX_NAME_LENGTH];  \r\n    printf(\"Enter name of the grocery item to update quantity: \");  // Prompt user to enter item name\r\n    scanf(\" %[^\\n]\", searchName);\r\n\r\n    // Loop through the inventory to find the item\r\n    for (int i = 0; i < groceryCount; i++) {\r\n        if (strcmp(groceryList[i].itemName, searchName) == 0) {  // Compare input name with item names in inventory\r\n            printf(\"Enter new quantity for %s: \", searchName); \r\n            scanf(\"%d\", &groceryList[i].itemQuantity);  \r\n\r\n            // Update the item status based on the new quantity\r\n            if (groceryList[i].itemQuantity > 0) {\r\n                strcpy(groceryList[i].itemStatus, \"In Stock\");  \r\n            } else {\r\n                strcpy(groceryList[i].itemStatus, \"Out of Stock\"); \r\n            }\r\n\r\n            printf(\"Quantity updated successfully!\\n\");  // Display success message\r\n            return;  \r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");  // Display message if item not found\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeItem() {\r\n    if (groceryCount == 0) {  \r\n        printf(\"Inventory is empty.\\n\");  // Display message if inventory is empty\r\n        return; \r\n    }\r\n\r\n    char searchName[MAX_NAME_LENGTH];  // Declare a variable to hold the item name to remove\r\n    printf(\"Enter name of the grocery item to remove: \"); \r\n    scanf(\" %[^\\n]\", searchName); \r\n\r\n    // Loop through the inventory to find the item\r\n    for (int i = 0; i < groceryCount; i++) {\r\n        if (strcmp(groceryList[i].itemName, searchName) == 0) {  \r\n            // Shift all items after the found item one position back to remove it\r\n            for (int j = i; j < groceryCount - 1; j++) {\r\n                groceryList[j] = groceryList[j + 1];  // Shift items\r\n            }\r\n            groceryCount--;  // Decrement item count\r\n            printf(\"Grocery item removed successfully!\\n\"); \r\n            return;  \r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");  // Display message if item not found\r\n}\r\n\r\n// Main menu function\r\nvoid showMenu() {\r\n    int userInput;  \r\n    do {\r\n        // Display the menu options\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &userInput);  \r\n\r\n        // Use switch case to choose between the different operations or functions\r\n        switch (userInput) {\r\n            case 1:\r\n                addItem();  // Call function to add item\r\n                break;\r\n            case 2:\r\n                listItems();  // Call function to list items\r\n                break;\r\n            case 3:\r\n                updateItemQuantity();  // Call function to update quantity\r\n                break;\r\n            case 4:\r\n                removeItem();  // Call function to remove item\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program. Goodbye!\\n\");  \r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");  // Display error message for invalid input\r\n        }\r\n    } while (userInput != 5);  \r\n}\r\n\r\nint main() {\r\n    showMenu();  // Call function to display the menu\r\n    return 0;  \r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>  \r\n#include <stdlib.h> \r\n#include <string.h> \r\n\r\n// Define a structure to represent a student record\r\ntypedef struct Student {\r\n    char name[50];          \r\n    int id;                 \r\n    float grade;            \r\n    struct Student* next;   // Pointer to the next student in the linked list\r\n} Student;\r\n\r\n//pointer to manage the linked list\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student info/data\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // memory for student info\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) { // Check if memory allocation failed\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1); \r\n    }\r\n    // Copy the student's name into the node\r\n    strcpy(newStudent->name, name);\r\n    // Assign the student's ID and grade\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent; // Return the newly created node\r\n}\r\n\r\n// Function to insert a new student into the linked list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    // Link the new node to the beginning of the list\r\n    newStudent->next = head;\r\n    // Update the head pointer to point to the new node\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records in the linked list\r\nvoid displayStudents() {\r\n    if (head == NULL) { // Check if the list is empty\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    // Pointer to traverse the linked list\r\n    Student* temp = head;\r\n    while (temp != NULL) { // Loop through each node in the list\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next; // Move to the next node\r\n    }\r\n}\r\n\r\n// Function to sort student records in ascending order of grades using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) { \r\n        printf(\"Not enough records to sort.\\n\");\r\n        return; \r\n    }\r\n    int swapped;        // declare swap variable\r\n    Student* ptr1;      // Pointer to traverse the list\r\n    Student* lptr = NULL; // Pointer to mark the sorted portion of the list\r\n\r\n    do {\r\n        swapped = 0;    \r\n        ptr1 = head;     // Start from the head of the list\r\n\r\n        while (ptr1->next != lptr) { // Traverse the unsorted portion of the list\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the student details between pairs\r\n                float tempGrade = ptr1->grade;\r\n                int tempID = ptr1->id;\r\n                char tempName[50];\r\n                strcpy(tempName, ptr1->name);\r\n\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempID;\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1; \r\n            }\r\n            ptr1 = ptr1->next; //move to the next pair\r\n        }\r\n        lptr = ptr1; // Update the sorted portion\r\n    } while (swapped); // Repeat until no swaps occur\r\n//using bubble srt\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\"); \r\n}\r\n\r\n// Function to search for a student by their ID\r\nStudent* searchStudentByID(int id) {\r\n    // Pointer to traverse the linked list\r\n    Student* temp = head;\r\n    while (temp != NULL) { // Loop through the list\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next; // Move to the next node\r\n    }\r\n    return NULL; // Return NULL if no match is found\r\n}\r\n\r\n// Function to delete the entire linked list and free memory\r\nvoid deleteList() {\r\n    Student* temp; \r\n    while (head != NULL) { \r\n        temp = head;       // Store the current head\r\n        head = head->next;\r\n        free(temp);        // Free the memory of the current node\r\n    }\r\n    printf(\"All student records deleted.\\n\"); \r\n}\r\n\r\n// Utility function to clear the input buffer\r\nvoid clearBuffer() {\r\n    int c;\r\n    // Consume all characters in the input buffer until a newline reached\r\n    while ((c = getchar()) != '\\n' && c != EOF);\r\n}\r\n\r\n//function to free all memory before program exit\r\nvoid freeMemory() {\r\n    deleteList(); \r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;      \r\n    float grade;         \r\n    char name[50];       \r\n\r\n    do {\r\n        // Display the menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        // Validate user input for choice\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            clearBuffer(); // Clear invalid input from the buffer\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            continue; \r\n        }\r\n\r\n        clearBuffer(); // Clear any trailing input\r\n\r\n        switch (choice) {\r\n            \r\n            case 1:\r\n            // Input student details\r\n            printf(\"Enter Name: \");\r\n            scanf(\"%49s\", name); \r\n            printf(\"Enter ID: \");\r\n            if (scanf(\"%d\", &id) != 1) { // Validate ID input\r\n                clearBuffer();\r\n                printf(\"Invalid ID. Please try again.\\n\");\r\n                break;\r\n            }\r\n            printf(\"Enter Grade: \");\r\n            if (scanf(\"%f\", &grade) != 1) { // Validate grade input\r\n                clearBuffer();\r\n                printf(\"Invalid grade. Please try again.\\n\");\r\n                break;\r\n            }\r\n            insertStudent(name, id, grade);\r\n            break;\r\n            \r\n            case 2:\r\n            displayStudents(); // Display all student records\r\n            break;\r\n            \r\n            case 3:\r\n            sortStudents(); // Sort student records by grade\r\n            break;\r\n            \r\n            case 4: {\r\n            printf(\"Enter ID to search: \");\r\n            if (scanf(\"%d\", &id) != 1) { // Validate ID input\r\n                clearBuffer();\r\n                printf(\"Invalid ID. Please try again.\\n\");\r\n                break;\r\n            }\r\n            Student* student = searchStudentByID(id); // Search for the student by ID\r\n            if (student) {\r\n                \r\n                printf(\"Record Found - Name: %s, ID: %d, Grade: %.2f\\n\", student->name, student->id, student->grade);\r\n            } else {\r\n                printf(\"No record found with ID %d.\\n\", id); \r\n            }\r\n            break;\r\n        }\r\n            \r\n            case 5:\r\n            deleteList(); // Delete all student records\r\n            break;\r\n            \r\n            case 6:\r\n            freeMemory(); // Free all allocated memory\r\n            printf(\"Exiting program. Goodbye!\\n\");\r\n            break;\r\n            \r\n            default:\r\n            printf(\"Invalid choice. Please try again.\\n\"); \r\n        }\r\n    } while (choice != 6); // Repeat until the user chooses to exit\r\n\r\n    return 0; \r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While Bubble Sort is straightforward and functional, its time complexity of O(n?) can be inefficient for larger datasets. For better performance, consider using more efficient algorithms such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20706838",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define max 10 // Maximum size for the matrices which can be inserted\r\n\r\n// Function to input elements into a matrix\r\nvoid inputMatrix(int rows, int cols, int matrix[max][max]) {\r\n    printf(\"Enter elements of the matrix (%d %d):\\n\", rows, cols);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int rows, int cols, int matrix[max][max]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add the two matrices\r\nvoid addMatrices(int rows, int cols, int a[max][max], int b[max][max], int result[max][max]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int rows, int cols, int a[max][max], int b[max][max], int result[max][max]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[max][max], int transposed[max][max]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int a[max][max], b[max][max], result[max][max];\r\n    int transposed[max][max];\r\n    int rowsA, colsA, rowsB, colsB, choice;\r\n\r\n    // For the inputs of the dimensions of the  matrix \r\n    printf(\"Enter dimensions of Matrix A (rows cols): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter dimensions of Matrix B (rows cols): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Check for validity of the  dimensions\r\n    if (rowsA > max || colsA > max || rowsB > max || colsB > max || rowsA != rowsB || colsA != colsB) {\r\n        printf(\"Invalid dimensions.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input the elements of the matrix\r\n    printf(\"Matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, a);\r\n    printf(\"Matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, b);\r\n\r\n    // Menu for the operations to be carried\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Perform addition of matricess\r\n                addMatrices(rowsA, colsA, a, b, result);\r\n                printf(\"Result of Addition:\\n\");\r\n                displayMatrix(rowsA, colsA, result);\r\n                break;\r\n            case 2:\r\n                // Perform subtraction of the matrices\r\n                subtractMatrices(rowsA, colsA, a, b, result);\r\n                printf(\"Result of Subtraction:\\n\");\r\n                displayMatrix(rowsA, colsA, result);\r\n                break;\r\n            case 3:\r\n                // Transpose of Matrix A\r\n                transposeMatrix(rowsA, colsA, a, transposed);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(colsA, rowsA, transposed);\r\n                break;\r\n            case 4:\r\n                // Transpose of Matrix B\r\n                transposeMatrix(rowsB, colsB, b, transposed);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(colsB, rowsB, transposed);\r\n                break;\r\n            case 5:\r\n                // Exit\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define maximumItems 100 // Maximum number of grocery items to be stored\r\n\r\n// Structure for a grocery item\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int inStock; // 1 for in stock, 0 for out of stock\r\n} GroceryItem;\r\n\r\n// Function to add an item to the inventory\r\nvoid addItem(GroceryItem inventory[], int *count) {\r\n    if (*count >= maximumItems) {\r\n        printf(\"Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter name: \");\r\n    scanf(\" %[^\\n]\", inventory[*count].name);\r\n    printf(\"Enter category: \");\r\n    scanf(\" %[^\\n]\", inventory[*count].category);\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &inventory[*count].quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &inventory[*count].price);\r\n\r\n    if (inventory[*count].quantity > 0) {\r\n    inventory[*count].inStock = 1;\r\n} else {\r\n    inventory[*count].inStock = 0;\r\n}\r\n(*count)++;\r\n\r\n\r\n}\r\n\r\n// Function to list all items in the inventory\r\nvoid listItems(GroceryItem inventory[], int count) {\r\n    printf(\"Inventory List:\\n\");\r\n    for (int i = 0; i < count; i++) {\r\n        printf(\"%s (%s) - %d @ %.2f (%s)\\n\",\r\n               inventory[i].name, inventory[i].category, inventory[i].quantity, inventory[i].price,\r\n               inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an item\r\nvoid updateQuantity(GroceryItem inventory[], int count) {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < count; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            inventory[i].inStock = inventory[i].quantity > 0 ? 1 : 0;\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Function to remove an item from the inventory\r\nvoid removeItem(GroceryItem inventory[], int *count) {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < *count; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            // Shift items to remove the selected one\r\n            for (int j = i; j < *count - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            (*count)--;\r\n            printf(\"Item removed.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nint main() {\r\n    GroceryItem inventory[maximumItems];\r\n    int count = 0; // Number of items in the inventory\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(inventory, &count);\r\n                break;\r\n            case 2:\r\n                listItems(inventory, count);\r\n                break;\r\n            case 3:\r\n                updateQuantity(inventory, count);\r\n                break;\r\n            case 4:\r\n                removeItem(inventory, &count);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for student \r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name); // Copy the name\r\n    newStudent->id = id;           // Assign the ID\r\n    newStudent->grade = grade;     // Assign the grades\r\n    newStudent->next = NULL;       // Set the next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent)\r\n        return;\r\n\r\n    newStudent->next = head; // Link the new student to the current head\r\n    head = newStudent;       // Update head to point to the new student\r\n    printf(\"Student record added.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    printf(\"Student Records:\\n\");\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current; // Return the student if ID matches\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // Return NULL if not found\r\n}\r\n\r\n// Function to delete the entire linked list and free the allocated memory\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current!= NULL) {\r\n        next = current->next; // Save the next student\r\n        free(current);       // Free the current student\r\n        current = next;      // Move to the next student\r\n    }\r\n    head = NULL; // Set head to NULL to indicate that the list is empty\r\n    printf(\"All student records deleted.\\n\");\r\n\r\n}\r\n\r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n\r\n// Function to sort the students by grade (Bubble Sort)\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the data of the two nodes\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempId = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempId;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next; // Move to the next pair\r\n        }\r\n        lptr = ptr1; // Reduce the range for sorting\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade.\\n\");\r\n}\r\n//Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Insert a new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                // Display all student records\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                // Sort student records by grade\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                // Search for a student by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                // Delete the entire list\r\n                deleteList();\r\n                printf(\"List deleted.\\n\"); \r\n                break;\r\n            case 6:\r\n                // Exit and free memory\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While bubble sort is easy to implement, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using a more efficient sorting algorithm such as Quick Sort or Merge Sort for better performance."
  },
  {
    "student_id": "20595191",
    "code": "\n/* --- QUESTION1.c --- */\n#include <stdio.h>\n\n#define MAX 10\n\n\nvoid input(int matrix[MAX][MAX], int rows, int cols);\nvoid print(int matrix[MAX][MAX], int rows, int cols);\nvoid add(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid sub(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid transpose(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\n\nint main() {\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n\n    // Validate dimensions\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0) {\n        printf(\"Invalid dimensions! Maximum size is 10x10.\\n\");\n        return 1;\n    }\n\n    // Input elements for Matrix A\n    printf(\"Enter elements for Matrix A:\\n\");\n    input(matrixA, rowsA, colsA);\n\n    // Input dimensions for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n\n    // Validate dimensions\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) {\n        printf(\"Invalid dimensions! Maximum size is 10x10.\\n\");\n        return 1;\n    }\n\n    // Input elements for Matrix B\n    printf(\"Enter elements for Matrix B:\\n\");\n    input(matrixB, rowsB, colsB);\n\n    while (1) {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) { //check if matrixes have the same \n                    add(matrixA, matrixB, result, rowsA, colsA); //call function\n                    printf(\"Result of your choice:\\n\");\n                    print(result, rowsA, colsA);\n                } else {\n                    printf(\" Matrices must have the same dimensions therefor addition not possible.\\n\");\n                }\n                break;\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) { //check if matrixes have the same \n                    sub(matrixA, matrixB, result, rowsA, colsA); //call function\n                    printf(\"Result of your choice:\\n\");\n                    print(result, rowsA, colsA);\n                } else {\n                    printf(\" Matrices must have the same dimensions therfor substraction not possible.\\n\");\n                }\n                break;\n            case 3:\n                transpose(matrixA, result, rowsA, colsA);\n                printf(\"Result of your choice:\\n\");\n                print(result, colsA, rowsA);\n                break;\n            case 4:\n                transpose(matrixB, result, rowsB, colsB);\n                printf(\"Result of your choice:\\n\");\n                print(result, colsB, rowsB);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                return 0;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    }\n\n    return 0;\n}\n\n// Function to input elements of a matrix\nvoid input(int matrix[MAX][MAX], int rows, int cols) { \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to print a matrix\nvoid print(int matrix[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to add two matrices\nvoid add(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid sub(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transpose(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n/* --- QUESTION2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];  // The name of the grocery item \r\n    char category[50];  // The category of the item \r\n    int quantity;  // How many of this item are in stock\r\n    float price;  // The price per unit of the item\r\n    bool inStock;  // Whether the item is in stock (true = yes, false = no)\r\n} GroceryItem;\r\n\r\nGroceryItem inventory[MAX_ITEMS];  // An array to store all grocery items\r\nint itemCount = 0;  \r\n\r\nvoid addItem();  // Function to add a new item to the inventory\r\nvoid listItems();  // Function to display all items in the inventory\r\nvoid updateQuantity();  // Function to update the quantity of an existing item\r\nvoid removeItem();  // Function to remove an item from the inventory\r\n\r\nint main() {\r\n    int choice;  \r\n\r\n    while (1) { \r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  \r\n\r\n        // Perform the action based on the user's choice\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();  // Call the function to add a new item\r\n                break;\r\n            case 2:\r\n                listItems();  // Call the function to list all items\r\n                break;\r\n            case 3:\r\n                updateQuantity();  // Call the function to update item quantity\r\n                break;\r\n            case 4:\r\n                removeItem();  // Call the function to remove an item\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;  // Exit the program\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;  \r\n}\r\n\r\n// Function to add a new grocery item\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {  // Check if there is room in the inventory\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;  // Exit the function if inventory is full\r\n    }\r\n\r\n    GroceryItem newItem;  \r\n    \r\n    // Prompt for the item's name\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0;  \r\n\r\n    // Prompt for the item's category\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0;  \r\n    \r\n    // Prompt for the quantity of the item\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    // Prompt for the price of the item\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Set the availability status based on quantity\r\n    newItem.inStock = newItem.quantity > 0;  // true if quantity > 0, false otherwise\r\n\r\n    // Add the new item to the inventory and increment the count\r\n    inventory[itemCount++] = newItem;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items in the inventory\r\nvoid listItems() {\r\n    if (itemCount == 0) {  // Check if the inventory is empty\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;  // Exit the function\r\n    }\r\n\r\n    // Loop through the inventory and display each item's details\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a specific grocery item\r\nvoid updateQuantity() {\r\n    char itemName[100];  // Variable to store the name of the item to update\r\n\r\n    // Prompt for the item's name\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  \r\n    \r\n    // Search for the item in the inventory\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {  // Check if names match\r\n            // Prompt for the new quantity\r\n            printf(\"Enter new quantity for %s: \", inventory[i].name);\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n\r\n            // Update the availability status\r\n            inventory[i].inStock = inventory[i].quantity > 0;  // true if quantity > 0, false otherwise\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;  // Exit the function\r\n        }\r\n    }\r\n\r\n    // If no match was found\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove an item from the inventory\r\nvoid removeItem() {\r\n    char itemName[100];  \r\n    \r\n    // Prompt for the item's name\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  \r\n\r\n    // Search for the item in the inventory\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {  // Check if names match\r\n            // Shift all subsequent items one position up to fill the gap\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n\r\n            itemCount--;  // Decrement the count of items in the inventory\r\n\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n            return;  // Exit the function\r\n        }\r\n    }\r\n\r\n    // If no match was found\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\n/* --- QUESTION3.C --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];  // The name of the student (up to 100 characters)\r\n    int id;          // The unique ID for the student\r\n    float grade;     // The grade of the student\r\n    struct Student* next;  // Pointer to the next student in the list\r\n} Student;\r\n\r\nStudent* head = NULL;  // This points to the start of the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate memory for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Oops! Memory allocation failed.\\n\");\r\n        exit(1);  // Exit the program if we can't allocate memory\r\n    }\r\n    // Fill in the student's details\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;  \r\n    return newStudent;  \r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    // Add the new student to the front of the list\r\n    newStudent->next = head;\r\n    head = newStudent;  // Update the head to point to the new student\r\n    printf(\"Great! Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {  // Check if the list is empty\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;  // Start from the beginning of the list\r\n    while (current != NULL) {  // Go through each student\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;  // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;  // Start at the beginning\r\n    while (current != NULL) {  // Go through each student\r\n        if (current->id == id) {  // Found a match\r\n            return current;\r\n        }\r\n        current = current->next;  // Move to the next student\r\n    }\r\n    return NULL;  // If no match is found, return NULL\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;  // Start at the beginning\r\n    Student* next;\r\n    while (current != NULL) {  // Go through each student\r\n        next = current->next;  // Save the next student\r\n        free(current);  // Free the memory for the current student\r\n        current = next;  // Move to the next student\r\n    }\r\n    head = NULL;  // The list is now empty\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {  // Check if the list is empty or has just one student\r\n        printf(\"No records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* i;\r\n    Student* j;\r\n    float tempGrade;\r\n    int tempId;\r\n    char tempName[100];\r\n\r\n    // Bubble sort algorithm\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {  // Compare the grades\r\n                // Swap grades\r\n                tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n\r\n                // Swap IDs\r\n                tempId = i->id;\r\n                i->id = j->id;\r\n                j->id = tempId;\r\n\r\n                // Swap names\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n            }\r\n        }\r\n    }\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Function to free memory when exiting\r\nvoid freeMemory() {\r\n    deleteList();  // Reuse deleteList to clean up everything\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Add a new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                // Show all student records\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                // Sort records by grade\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                // Search for a specific student by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                // Delete the entire list of records\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                // Exit the program\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);  // Keep showing the menu until the user exits\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program implements bubble sort to sort student records by grade. While bubble sort is functional, it has a time complexity of O(n?), making it inefficient for larger datasets. Consider using a more efficient sorting algorithm like Quick Sort or Merge Sort for improved performance."
  },
  {
    "student_id": "20706721",
    "code": "\n/* --- Q1.c --- */\n#include<stdio.h>\r\n\r\n\r\n#define MAX_SIZE 10\r\n\r\nint matrixA[MAX_SIZE][MAX_SIZE],matrixB[MAX_SIZE][MAX_SIZE],matrixtemp[MAX_SIZE][MAX_SIZE];\r\nint dmsAx,dmsAy,dmsBx,dmsBy;\r\n\r\nint n=1;\r\n\r\nvoid initalMatrices();\r\nvoid AddMatrices();// 1.AddMatrices\r\nvoid SubtractMatrices();// 2. Subtract Matrices\r\nvoid TransposeMatrixA();// 3. Transpose Matrix A\r\nvoid TransposeMatrixB();// 4. Transpose Matrix B\r\nvoid Exit();// 5. Exit (Loop back to the menu until the user chooses to exit.)\r\nvoid menu();\r\n\r\n\r\nint main(){\r\n\r\n\r\n    int x,y,menuid;\r\n\r\n    //\r\n    initalMatrices();\r\n\r\n\r\n//do loop until user select exit\r\n\r\n    while(n){\r\n\r\n\r\n        //output the menu\r\n        menu();\r\n        scanf(\"%d\",&menuid);\r\n    \r\n\r\n        switch (menuid)\r\n        {\r\n        case 1:\r\n            /* code */\r\n            AddMatrices();\r\n            break;\r\n        case 2:\r\n            SubtractMatrices();\r\n            break;\r\n        case 3:\r\n            TransposeMatrixA();\r\n            break;\r\n        case 4:\r\n            TransposeMatrixB();\r\n            break;\r\n        case 5:\r\n            Exit();\r\n            break;\r\n        \r\n        default:\r\n            menu();\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n\r\n}\r\n\r\nvoid menu(){\r\n    printf(\"Please choose the menu number:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @brief \r\n * The program should allow the user to input\r\n * • the dimensions (number of rows and columns) of two matrices A and B (maximum size: 10x10).\r\n * • the elements of both matrices.\r\n */\r\nvoid initalMatrices(){\r\n\r\n    \r\n\r\n    int flag =1;\r\n    //get Matrix A's x and y \r\n    while(flag){\r\n\r\n        //get row and column for matrix A\r\n        printf(\"Enter dimensions for Matrix A(rows and columns <=10):\");\r\n        scanf(\"%d %d\",&dmsAx,&dmsAy);       \r\n\r\n        printf(\"dmsAx: %d dmsAy: %d:\\n\",dmsAx,dmsAy);\r\n\r\n        if(dmsAx>10||dmsAx<=0 || dmsAy>10||dmsAy<=0){\r\n            printf(\"dimensions must be >=1 and <=10:\");\r\n        }else{\r\n\r\n            printf(\"enter elements for Matrix A:\\n\");\r\n\r\n            //get elements one by one\r\n            int i=0;\r\n            for(;i<dmsAx;i++){\r\n                int j=0;\r\n                for(;j<dmsAy;j++){\r\n                    printf(\"Element [ %d , %d ] :\",i+1,j+1);\r\n                    scanf(\"%d\",&matrixA[i][j]);\r\n                }\r\n                // printf(\"i:  %d  \",i);\r\n            }\r\n\r\n            flag=0;\r\n\r\n        }\r\n\r\n    }\r\n    flag=1;\r\n    //get Matrix B's x and y \r\n    while(flag){\r\n\r\n        //get row and column for matrix B\r\n        printf(\"Enter dimensions for Matrix B(rows and columns <=10):\");\r\n        scanf(\"%d %d\",&dmsBx,&dmsBy);        \r\n        if(dmsBx>10||dmsBx<=0 || dmsBy>10||dmsBy<=0){\r\n            printf(\"dimensions must be >0 and <=10:\");\r\n        }else{\r\n\r\n            printf(\"enter elements for Matrix B:\\n\");\r\n\r\n            //get elements one by one\r\n            int i=0;\r\n            for(;i<dmsBx;i++){\r\n\r\n                int j=0;\r\n                for(;j<dmsBy;j++){\r\n                    printf(\"Element [ %d , %d ] :\",i+1,j+1);\r\n                    scanf(\"%d\",&matrixB[i][j]);\r\n                }\r\n\r\n            }\r\n\r\n            flag=0;\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n// 1.AddMatrices\r\nvoid AddMatrices(){\r\n\r\n    //\"Determine if the number of rows and columns of two matrices are equal.\"\r\n    if( dmsAx!=dmsBx||dmsAy!=dmsBy){\r\n        printf(\"The number of rows and columns of two matrices aren't equal!\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n    int i=0;\r\n    for(;i<dmsAx;i++){\r\n        int j=0;\r\n        for(;j<dmsAy;j++){\r\n            printf(\" %d \",matrixA[i][j]+matrixB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    \r\n\r\n}\r\n// 2. Subtract Matrices\r\nvoid SubtractMatrices(){\r\n    //\"Determine if the number of rows and columns of two matrices are equal.\"\r\n    if( dmsAx!=dmsBx||dmsAy!=dmsBy){\r\n        printf(\"The number of rows and columns of two matrices aren't equal!\");\r\n        return;\r\n    }\r\n    \r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    int i=0;\r\n    for(;i<dmsAx;i++){\r\n        int j=0;\r\n        for(;j<dmsAy;j++){\r\n            printf(\" %d \",matrixA[i][j]-matrixB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n/**\r\n * @brief \r\n * Transpose and swap matrix A\r\n */\r\nvoid TransposeMatrixA(){\r\n\r\n    int i=0,temp;\r\n    printf(\"Transpose of Matrix A:\\n\");\r\n    \r\n     for(i=0;i<dmsAx;i++){\r\n        int j=0;\r\n        for(;j<dmsAy;j++){\r\n            printf(\" %d \",matrixA[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    int transposed[dmsAy][dmsAx];\r\n    //Swap the rows and columns of the matrix and store them in a temporary object \r\n    for (int i = 0; i < dmsAx; i++) {\r\n        for (int j = 0; j < dmsAy; j++) {\r\n            transposed[j][i] = matrixA[i][j];\r\n        }\r\n    }\r\n        \r\n    \r\n    \r\n    //Swap the columns and rows of matrix A\r\n    temp = dmsAy;\r\n    dmsAy=dmsAx;\r\n    dmsAx=temp;\r\n\r\n    //Print the swapped matrix A     \r\n    for(i=0;i<dmsAx;i++){\r\n        int j=0;\r\n        for(;j<dmsAy;j++){\r\n            matrixA[i][j]=transposed[i][j];\r\n            printf(\" %d \",matrixA[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @brief \r\n * Transpose and swap matrix B\r\n */\r\nvoid TransposeMatrixB(){\r\n    int i=0,temp;\r\n    printf(\"Transpose of Matrix B:\\n\");\r\n    \r\n     for(i=0;i<dmsBx;i++){\r\n        int j=0;\r\n        for(;j<dmsBy;j++){\r\n            printf(\" %d \",matrixB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    int transposed[dmsBy][dmsBx];\r\n    //Swap the rows and columns of the matrix and store them in a temporary object \r\n    for (int i = 0; i < dmsBx; i++) {\r\n        for (int j = 0; j < dmsBy; j++) {\r\n            transposed[j][i] = matrixB[i][j];\r\n        }\r\n    }\r\n        \r\n    \r\n    \r\n    //Swap the columns and rows of matrix B\r\n    temp = dmsBy;\r\n    dmsBy=dmsBx;\r\n    dmsBx=temp;\r\n\r\n    //Print the swapped matrix B     \r\n    for(i=0;i<dmsBx;i++){\r\n        int j=0;\r\n        for(;j<dmsBy;j++){\r\n            matrixB[i][j]=transposed[i][j];\r\n            printf(\" %d \",matrixB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\n// void TransposeMatrixB();// 4. Transpose Matrix B\r\n\r\n// 5. Exit (Loop back to the menu until the user chooses to exit.)\r\nvoid Exit(){\r\n    n=0;\r\n    \r\n\r\n}\n/* --- Q2.c --- */\n#include<stdio.h>\r\n#include<string.h>\r\n\r\n\r\n\r\n#define NAME_LEN 100//define the name max length\r\n#define CATG_LEN 50//define the category max length\r\n#define MAX_LIST_SIZE 100//max List number\r\n\r\n\r\nint n = 0;//n current amount of people,t to gitemtrol while loop\r\n//function declaretion\r\nvoid menu();//main menu function\r\nvoid add();//add data function\r\nvoid list();//list data \r\nvoid update();//update data\r\nvoid removeData();//remove date\r\n// void quit();//quit system\r\n\r\n\r\n//define data struct \r\nstruct GroceryItem\r\n{\r\n    char name[NAME_LEN];\r\n    char category[CATG_LEN];\r\n    int  quantity;\r\n    float price;\r\n    int status;\r\n\r\n}gitem[MAX_LIST_SIZE],tmp[MAX_LIST_SIZE];\r\n\r\nint main()\r\n{\r\n    int t=1;\r\n    // load();\r\n    int num;//num is menu options\r\n    while (t)//t is global variable\r\n    {\r\n       \r\n        menu();//output mene\r\n        printf(\"Please enter the menu number:\");\r\n        scanf(\"%d\", &num);\r\n        switch (num)\r\n        {\r\n        case 1: add(); break;\r\n        case 2: list(); break;\r\n        case 3: update(); break;\r\n        case 4: removeData(); break;\r\n        case 5: t=0; break;\r\n        default:printf(\"Inputs the mistake,please input again!\");\r\n        }\r\n        \r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n\r\nvoid menu()\r\n{\r\n    printf(\"\\n\\n\");    \r\n    printf(\"1.Add Grocery Item\\n\");\r\n    printf(\"2.List All Grocey Items\\n\");\r\n    printf(\"3.Update Quanltity\\n\");\r\n    printf(\"4.Remove Grocery Item\\n\");\r\n    printf(\"5.Exit\\n\");\r\n}\r\n\r\n/**\r\n * @brief \r\n * Add data\r\n */\r\n\r\nvoid add()\r\n{\r\n    int i = n, j, flag, m = 0;\r\n    char str[NAME_LEN];\r\n    //Enter Item Name\r\n    printf(\"Enter Item Name :\");\r\n    getchar();\r\n    fgets(str, sizeof(str), stdin);\r\n    strncpy(gitem[i].name,str,strlen(str)-1);\r\n\r\n    // Enter Category\r\n    printf(\"Enter Category :\");\r\n    // getchar();\r\n    fgets(str, sizeof(str), stdin);\r\n    strncpy(gitem[i].category,str,strlen(str)-1);\r\n\r\n    //enter quantity\r\n    printf(\"Enter quantity :\");\r\n    scanf(\"%d\", &gitem[i].quantity);\r\n\r\n    // Enter price \r\n    printf(\"Enter price :\");\r\n    scanf(\"%f\", &gitem[i].price);\r\n    \r\n    //Set the inventory status to true;\r\n    if(gitem[i].quantity<=0){\r\n        gitem[i].status=0;\r\n    }\r\n    else{ \r\n        gitem[i].status=1;\r\n    }\r\n\r\n    n=n+1;\r\n    printf(\"Grocery item added successfully!\");\r\n    \r\n}\r\n\r\n\r\n/**\r\n * @brief \r\n * display all data \r\n */\r\nvoid list(){\r\n\r\n    int i=0;\r\n    // If no data exists, return immediately\r\n    if(n<=0){\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    //Output data one by one\r\n    for(i=0;i<n;i++){\r\n        \r\n        printf(\"-------------item: %d--------------\\n\",i);\r\n        printf(\"Name: %s\\n\", gitem[i].name);\r\n        printf(\"Category: %s\\n\", gitem[i].category);\r\n        printf(\"Quantity: %d\\n\", gitem[i].quantity);\r\n        printf(\"Price: %.2f\\n\", gitem[i].price);\r\n\r\n        //Output the inventory status based on the value of 0 or 1\r\n        if(gitem[i].status)\r\n            printf(\"Status: %s\\n\", \"In Stock\");\r\n        else\r\n            printf(\"Status: %s\\n\", \"Out of Stock\");\r\n        \r\n    }\r\n    printf(\"Amount %d\\n\",n);\r\n\r\n}\r\n\r\nvoid update(){\r\n\r\n    char itemName[NAME_LEN],str[NAME_LEN];\r\n    int newQuantity;\r\n    printf(\"Enter name of the grocery item to update quantity:\");        \r\n    getchar();\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n\r\n    // Remove newline character if present\r\n    size_t len = strlen(itemName);\r\n     if (len > 0 && itemName[len - 1] == '\\n') {\r\n        itemName[len - 1] = '\\0';\r\n    }\r\n    printf(\"Enter new quantity for %s:\",itemName);\r\n    scanf(\"%d\",&newQuantity);\r\n\r\n    int i=0,findflag=0;\r\n    //Match names one by one, and if found, update the quantity\r\n    for(i=0;i<n;i++){\r\n        if(strcmp(gitem[i].name,itemName)==0){\r\n            gitem[i].quantity=newQuantity;\r\n            if(newQuantity==0){\r\n                gitem[i].status=0;\r\n            }\r\n            findflag=1;\r\n            break;\r\n        }\r\n    }\r\n    //If found, output \"update successful\"; otherwise, output \"update failed\"\r\n    if(findflag)\r\n        printf(\"Quantity updated successfully!\");\r\n    else\r\n        printf(\"Couldn't find the name,Quantity updated failed!\");\r\n}\r\n\r\nvoid removeData(){\r\n    int j=0, flag=0;\r\n    char s1[NAME_LEN];\r\n    char sure[2];\r\n   \r\n    printf(\"Enter name of the grocery item to remove:\");\r\n    getchar();\r\n    fgets(s1, sizeof(s1), stdin);\r\n\r\n     // Remove newline character if present\r\n     size_t len = strlen(s1);\r\n     if (len > 0 && s1[len - 1] == '\\n') {\r\n        s1[len - 1] = '\\0';\r\n    }\r\n\r\n    //find the data first\r\n    flag = 0;\r\n    for (int i = 0; i < n; i++)\r\n    {\r\n        if (strcmp(s1, gitem[i].name) == 0)\r\n        {\r\n            ++flag ;\r\n            for (j = i; j < n - 1; j++)\r\n            {\r\n                gitem[j] = gitem[j + 1];//Move all the students behind forward one position\r\n            }\r\n            break;\r\n        }\r\n        // if (flag == 1) break;//find the name for delete ,end loop \r\n    }\r\n\r\n    if (flag>0)\r\n    {\r\n        n=n-1;    \r\n        printf(\"item \\\"%s\\\" removed successfully!!\\n\",s1);\r\n        \r\n    }\r\n\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n\r\n#define NAME_LEN 100//define the name max length\r\n#define ID_LEN 50//define the category max length\r\n#define MAX_LIST_SIZE 100//max List number\r\n\r\n\r\nint N = 0;//n current amount of student,t to gitemtrol while loop\r\n\r\n//define linked list data type\r\ntypedef struct Student {\r\n    char name[NAME_LEN];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student ;\r\n\r\nStudent *head = NULL;\r\n\r\n//function declaretion\r\nvoid insertStudent(const char* name, int id, float grade); // Inserts a new student record into the linked list.\r\nvoid displayStudents(); // Displays all current student records inthe linked list.\r\nStudent* searchStudentByID(int id); // Searches for a student recordby student ID and returns a pointer to the corresponding student node.\r\nvoid deleteList(); // Deletes the entire linked list and frees the allocated memory.\r\nvoid freeMemory(); // A utility function to ensure that all memory is freed when the program exits.\r\nStudent* createStudent(const char* name, int id, float grade); //Creates a new student node and returns a pointer to it.\r\nvoid sortStudents(); // Sort the student records by grade according to a sorting algorithm of your choice\r\nvoid menu();\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int t=1;\r\n    // load();\r\n    int num;//num is menu options\r\n    int id; \r\n    float grade;\r\n    char name[NAME_LEN];\r\n    Student* std ;\r\n\r\n    while (t)//t is global variable\r\n    {\r\n        \r\n       \r\n        menu();//output mene\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &num);\r\n        // getchar(); // To consume the newline character\r\n        switch (num)\r\n        {\r\n        case 1: \r\n            \r\n            //Input name\r\n            printf(\"Enter name:\");\r\n            getchar();\r\n            fgets(name, sizeof(name), stdin);\r\n\r\n            // Remove newline character if present\r\n            size_t len = strlen(name);\r\n            if (len > 0 && name[len - 1] == '\\n') {\r\n                name[len - 1] = '\\0';\r\n            }\r\n\r\n            //Input ID\r\n            printf(\"Enter ID:\");\r\n            scanf(\"%d\",&id);\r\n            \r\n\r\n            //Input Grade\r\n            printf(\"Enter Grade:\");\r\n            scanf(\"%f\",&grade);\r\n\r\n\r\n            insertStudent(name,id,grade); \r\n            break;\r\n        case 2: \r\n            \r\n\r\n            displayStudents(); \r\n        \r\n            break;\r\n        case 3: \r\n        \r\n            sortStudents();\r\n            break;\r\n        case 4: \r\n            \r\n            //Input ID\r\n            printf(\"Enter ID:\");\r\n            scanf(\"%d\",&id);\r\n            std = searchStudentByID(id); \r\n            if(std)\r\n                printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", std->name, std->id, std->grade);\r\n            else\r\n                printf(\"Student not found.\\n\");\r\n            break;\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n        case 6: \r\n            t=0; \r\n            break;\r\n        default:printf(\"Inputs the mistake,please input again!\");\r\n        }\r\n        \r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n\r\nvoid menu()\r\n{\r\n    printf(\"\\n\\n\");    \r\n    printf(\"1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n}\r\n\r\n\r\n/**\r\n * @brief \r\n *  Inserts a new student record into the linked list.\r\n * @param name \r\n * @param id \r\n * @param grade \r\n */\r\nvoid insertStudent(const char* name, int id, float grade)\r\n{\r\n   Student *newNode = createStudent(name,id,grade);\r\n\r\n     \r\n//Add the new node to the end of the queue; if the current queue is empty, set the new node as the head node\r\n    if (head == NULL) {\r\n        head = newNode;\r\n    } else {\r\n        Student *current = head;\r\n        //Find the last node\r\n        while (current->next != NULL) {\r\n             current = current->next;\r\n         }\r\n        current->next = newNode;\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * @brief \r\n *  Displays all current student records inthe linked list.\r\n */\r\nvoid displayStudents(){\r\n    Student *current ;\r\n    current=head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n/**\r\n * @brief \r\n * Searches for a student recordby student ID and returns a pointer to the corresponding student node.\r\n * @param id \r\n * @return Student* \r\n */\r\nStudent* searchStudentByID(int id){\r\n\r\n    //Get the head of the queue\r\n    Student *current = head;\r\n    //Traverse the queue from the head; if found, return the result\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    //Return NULL if not found\r\n    return NULL;\r\n}\r\n\r\n/**\r\n * @brief \r\n * Deletes the entire linked list and frees the allocated memory.\r\n */\r\nvoid deleteList(){\r\n    //Traverse from head to tail and release resources for each node\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n    next = current->next;\r\n    free(current);\r\n    current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n/**\r\n * @brief \r\n * A utility function to ensure that all memory is freed when the program exits.\r\n */\r\nvoid freeMemory(){\r\n    deleteList();\r\n}\r\n/**\r\n * @brief Create a Student object\r\n *  //Creates a new student node and returns a pointer to it.\r\n * @param name \r\n * @param id \r\n * @param grade \r\n * @return Student* \r\n */\r\nStudent* createStudent(const char* name, int id, float grade){\r\n    //Create a new node\r\n    Student *newNode = (Student*)malloc(sizeof(Student));\r\n    if (newNode) {\r\n        strcpy(newNode->name, name);\r\n        newNode->id=id;\r\n        newNode->grade = grade;\r\n        newNode->next = NULL;\r\n    }\r\n\r\n    return newNode;\r\n}\r\n\r\n /**\r\n * @brief \r\n * Sort the student records by grade according to a sorting algorithm of your choice\r\n */\r\nvoid sortStudents() { \r\n    if (head == NULL || head->next == NULL) {\r\n        return; // If the linked list is empty or has only one node, sorting is not needed\r\n    }\r\n\r\n    Student *sorted = NULL; // Used to store the head node of the sorted part\r\n    Student *current = head; // The current node being processed\r\n\r\n    while (current != NULL) {\r\n        Student *next = current->next; // Save the next node to prevent breaking the chain\r\n        Student **pos = &sorted; // Points to the head pointer of the sorted part\r\n\r\n        // Find the insertion position (in descending order of scores)\r\n        while (*pos != NULL && (*pos)->grade > current->grade) {\r\n            pos = &(*pos)->next;\r\n        }\r\n\r\n        // Insert the current node into the sorted linked list\r\n        current->next = *pos;\r\n        *pos = current;\r\n\r\n        // Move to the next node\r\n        current = next;\r\n    }\r\n\r\n    head = sorted; //Update the head pointer to the sorted linked list\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function effectively implements Insertion Sort to arrange student records by grade. This method is suitable for linked lists, as it maintains the order while efficiently sorting."
  },
  {
    "student_id": "20617662",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAXIMUM 10\r\n\r\n//Function to input the elements of a matrix \r\nvoid input_matrix(int matrix[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//Function to display the elements of a matrix\r\nvoid display_matrix(int matrix[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int A[MAXIMUM][MAXIMUM], int B[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    int result[MAXIMUM][MAXIMUM];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n    display_matrix(result, rows, columns);\r\n}\r\n\r\n\r\n// Function to substract matrix B from matrix A \r\nvoid substract_matrices(int A[MAXIMUM][MAXIMUM], int B[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    int result[MAXIMUM][MAXIMUM];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    display_matrix(result, rows, columns);\r\n}\r\n\r\n\r\n// Function to transpose a matrix \r\nvoid transposeMatrix(int matrix[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    int transposed[MAXIMUM][MAXIMUM];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n    printf(\"Transposed Matrix:\\n\");\r\n    display_matrix(transposed, columns, rows);\r\n}\r\n\r\nint main() {\r\n    int A[MAXIMUM][MAXIMUM], B[MAXIMUM][MAXIMUM]; // Matrices A & B\r\n    int rowsA, columnsA, rowsB, columnsB; // Dimensions of matrices \r\n    int choice; //User's menu choice \r\n    \r\n\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &columnsA);\r\n\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    input_matrix(A, rowsA, columnsA);\r\n\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &columnsB);\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    input_matrix(B, rowsB, columnsB);\r\n\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && columnsA == columnsB) {\r\n                    addMatrices(A, B, rowsA, columnsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions do not match for addition!\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && columnsA == columnsB) {\r\n                    substract_matrices(A, B, rowsA, columnsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions do not match for subtraction!\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(A, rowsA, columnsA);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(B, rowsB, columnsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Defining structures for Grocery Item and Availability Status\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} grocery_item;\r\n\r\ntypedef struct {\r\n    bool in_stock;\r\n    bool outOfStock;\r\n} availability_status;\r\n\r\ntypedef struct {\r\n    grocery_item items[MAX_ITEMS];\r\n    availability_status status[MAX_ITEMS];\r\n    int count;\r\n} grocery_inventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(grocery_inventory *inventory);\r\nvoid listGroceryItems(grocery_inventory inventory);\r\nvoid updateQuantity(grocery_inventory *inventory);\r\nvoid removeGroceryItem(grocery_inventory *inventory);\r\n\r\nint main() {\r\n    grocery_inventory inventory = { .count = 0 };\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(grocery_inventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n\r\n    grocery_item *item = &inventory->items[inventory->count];\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n    getchar(); \r\n\r\n    availability_status *status = &inventory->status[inventory->count];\r\n    status->in_stock = item->quantity > 0;\r\n    status->outOfStock = item->quantity == 0;\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems(grocery_inventory inventory) {\r\n    if (inventory.count == 0) {\r\n        printf(\"No grocery items in the inventory\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        grocery_item item = inventory.items[i];\r\n        availability_status status = inventory.status[i];\r\n\r\n        printf(\"\\nItem Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\", status.in_stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(grocery_inventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            getchar();\r\n\r\n            inventory->status[i].in_stock = inventory->items[i].quantity > 0;\r\n            inventory->status[i].outOfStock = inventory->items[i].quantity == 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item not found!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem(grocery_inventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            inventory->count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item not found!\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    printf(\"Student Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All records deleted successfully!\\n\");\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current;\r\n    Student* next;\r\n    int swapped;\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != NULL) {\r\n            next = current->next;\r\n            if (current->grade > next->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, current->name);\r\n                tempID = current->id;\r\n                tempGrade = current->grade;\r\n\r\n                strcpy(current->name, next->name);\r\n                current->id = next->id;\r\n                current->grade = next->grade;\r\n\r\n                strcpy(next->name, tempName);\r\n                next->id = tempID;\r\n                next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Function to search for a student record by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Record\\n\");\r\n        printf(\"3. Sort Record\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-While Bubble Sort is straightforward and works well for small datasets, its time complexity of O(n?) can lead to inefficiencies with larger lists. For better performance, consider implementing more efficient algorithms like Merge Sort or Quick Sort in future versions."
  },
  {
    "student_id": "20705922",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>  // For standard input/output functions\r\n#include <stdlib.h>  // For extra utilities like memeory allocation\r\n\r\n// Define maximum size for matrices\r\n#define MAX_ROWS 10\r\n#define MAX_COLS 10\r\n\r\n// Function to get matrix dimensions from the user\r\nvoid getMatrixDimensions(int *rows, int *cols, char matrixName) {\r\n    do {\r\n        printf(\"Please enter dimensions for Matrix %c (rows and columns): \", matrixName);\r\n        scanf(\"%d %d\", rows, cols);\r\n\r\n        if (*rows <= 0 || *rows > MAX_ROWS || *cols <= 0 || *cols > MAX_COLS) {\r\n            printf(\"Invalid dimensions. Rows and columns must be between 1 and 10.\\n\");\r\n        }\r\n    } while (*rows <= 0 || *rows > MAX_ROWS || *cols <= 0 || *cols > MAX_COLS);\r\n}\r\n\r\n// Function to get matrix elements from the user\r\nvoid getMatrixElements(int matrix[MAX_ROWS][MAX_COLS], int rows, int cols, char matrixName) {\r\n    printf(\"Please enter elements for Matrix %c:\\n\", matrixName);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int matrix[MAX_ROWS][MAX_COLS], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrics\r\nvoid addMatrices(int matrixA[MAX_ROWS][MAX_COLS], int matrixB[MAX_ROWS][MAX_COLS], int result[MAX_ROWS][MAX_COLS], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int matrixA[MAX_ROWS][MAX_COLS], int matrixB[MAX_ROWS][MAX_COLS], int result[MAX_ROWS][MAX_COLS], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_ROWS][MAX_COLS], int transposed[MAX_ROWS][MAX_COLS], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int matrixA[MAX_ROWS][MAX_COLS], matrixB[MAX_ROWS][MAX_COLS], result[MAX_ROWS][MAX_COLS];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n    int exitProgram = 0; // This flag controls the main loop\r\n\r\n    do {\r\n        // Get dimensions and elements for Matrix A\r\n        getMatrixDimensions(&rowsA, &colsA, 'A');\r\n        getMatrixElements(matrixA, rowsA, colsA, 'A');\r\n\r\n        // Get dimensons and elements for Matrix B\r\n        getMatrixDimensions(&rowsB, &colsB, 'B');\r\n        getMatrixElements(matrixB, rowsB, colsB, 'B');\r\n\r\n        do {\r\n            // Display menu for the user\r\n            printf(\"\\nMatrix Operations Menu:\\n\");\r\n            printf(\"1. Add Matrices\\n\");\r\n            printf(\"2. Subtract Matrices\\n\");\r\n            printf(\"3. Transpose Matrix A\\n\");\r\n            printf(\"4. Transpose Matrix B\\n\");\r\n            printf(\"5. Exit\\n\");\r\n            printf(\"Please enter your choice: \");\r\n            scanf(\"%d\", &choice);\r\n\r\n            switch (choice) {\r\n                case 1:\r\n                    // Add the matrices\r\n                    if (rowsA == rowsB && colsA == colsB) {\r\n                        addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                        printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                        printMatrix(result, rowsA, colsA);\r\n                    } else {\r\n                        printf(\"Matrices cannot be added. They must have same dimensions.\\n\");\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    // Subtract the matrices\r\n                    if (rowsA == rowsB && colsA == colsB) {\r\n                        subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                        printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                        printMatrix(result, rowsA, colsA);\r\n                    } else {\r\n                        printf(\"Matrices cannot be subtracted. They must have same dimensions.\\n\");\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    // Transpose Matrix A\r\n                    transposeMatrix(matrixA, result, rowsA, colsA);\r\n                    printf(\"Transpose of Matrix A:\\n\");\r\n                    printMatrix(result, colsA, rowsA);\r\n                    break;\r\n                case 4:\r\n                    // Transpose Matrix B\r\n                    transposeMatrix(matrixB, result, rowsB, colsB);\r\n                    printf(\"Transpose of Matrix B:\\n\");\r\n                    printMatrix(result, colsB, rowsB);\r\n                    break;\r\n                case 5:\r\n                    printf(\"Exiting program...\\n\");\r\n                    exitProgram = 1; // This sets the exit flag for the program\r\n                    break;\r\n                default:\r\n                    printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n            }\r\n        } while (choice != 5); \r\n\r\n    } while (!exitProgram); // Loop only if the exitProgram flag is not set\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>  // For standard input/output functions\r\n#include <string.h>  // For string manipulation functions \r\n#include <stdbool.h>  // For 'true/false' logic using the data type 'bool'\r\n\r\n// Define maximum lengths for strings\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n#define MAX_ITEMS 100\r\n\r\n// Structure to represent the availability status of a grocery item\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Structure to represent a grocery item\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    AvailabilityStatus status;\r\n} GroceryItem;\r\n\r\n// Structure to represent the grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    printf(\"Enter item name: \");\r\n    scanf(\" %[^\\n]\", newItem.name); // '%[^\\n]' reads a line of text which includes spaces\r\n\r\n    printf(\"Enter category: \");\r\n    scanf(\" %[^\\n]\", newItem.category);\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Set availability based on quantity\r\n    newItem.status.inStock = newItem.quantity > 0;\r\n    newItem.status.outOfStock = !newItem.status.inStock;\r\n\r\n    inventory->items[inventory->itemCount] = newItem;\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items and their availability\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\", inventory->items[i].status.inStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    int itemIndex = -1;\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            itemIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (itemIndex == -1) {\r\n        printf(\"Grocery item '%s' not found.\\n\", itemName);\r\n        return;\r\n    }\r\n    \r\n    printf(\"Enter new quantity for %s: \", itemName);\r\n    scanf(\"%d\", &inventory->items[itemIndex].quantity);\r\n\r\n    // Update availability status\r\n    inventory->items[itemIndex].status.inStock = inventory->items[itemIndex].quantity > 0;\r\n    inventory->items[itemIndex].status.outOfStock = !inventory->items[itemIndex].status.inStock;\r\n\r\n    printf(\"Quantity has been updated successfully!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No available grocery items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Please enter the name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    int itemIndex = -1;\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            itemIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (itemIndex == -1) {\r\n        printf(\"Grocery item '%s' was not found.\\n\", itemName);\r\n        return;\r\n    }\r\n\r\n    // Shift items to fill the gap\r\n    for (int i = itemIndex; i < inventory->itemCount - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n    }\r\n\r\n    inventory->itemCount--;\r\n    printf(\"Grocery item '%s' was successfully removed!\\n\", itemName);\r\n}\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.itemCount = 0; // Initialize inventory as empty\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Please enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>  // For standard input/output functions\r\n#include <stdlib.h>  // For extra utilities like memory allocation\r\n#include <string.h>  // For string manipulation functions\r\n\r\n// Structure for 'Student'\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL; // This is the global pointer to the head of the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate memory for the new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation has failed!\\n\");\r\n        exit(1); // Exit if the memory allocation fails\r\n    }\r\n\r\n    //Copy the student's name safely to prevent buffer overflow\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\r\n    newStudent->name[sizeof(newStudent->name) - 1] = '\\0'; // Ensure null-termination here\r\n\r\n    // Set the student's ID and grade\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n\r\n    // New student's next pointer is set to NULL since there's no connection yet\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n\r\n    // Make the new student the head of the list\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    // Start at the head of the list\r\n    Student* current = head;\r\n\r\n    if (current == NULL) {\r\n        printf(\"There are no student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Traverse the list and print each student's information\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    // Start at the head of the list\r\n    Student* current = head;\r\n\r\n    // Traverse the list and search for the student with the matching ID\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current; // Student found, so return a pointer to the student\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    return NULL; // Student not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    // Traverse the list and free the memory for each student node\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n\r\n    head = NULL; // Reset the head to 'NULL' (meaning empty list)\r\n}\r\n\r\n// This is a utility function to ensure that all memory is freed when program exits\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    \r\n    /* \r\n       'Bubble Sort' was chosen because it's simplest to implement for a linked list, \r\n       though not the most efficient for large lists. For larger datasets, 'Merge Sort' \r\n       or 'Quick Sort' are better choices. \r\n    */\r\n\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *lptr = NULL;\r\n\r\n    // Checking for an empty list here\r\n    if (head == NULL) {\r\n        printf(\"There are no records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the data of the two nodes\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                int tempId = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempId;\r\n\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n    \r\n    printf(\"The records were sorted by grade using 'Bubble Sort'.\\n\");\r\n}\r\n\r\n// Main function to drive our program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Please enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // This to consume the newline character left by the scanf\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove trailing newline from fgets\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"The student was not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"The list has been deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The program uses Bubble Sort to sort student records by grade. While this method is simple to implement, it has a time complexity of O(n?), which can become inefficient with larger datasets. For better efficiency, consider using more advanced algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20712132",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions and elements of Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE) {\r\n        printf(\"Matrix A dimensions exceed maximum allowed size.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // Input dimensions and elements of Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsB > MAX_SIZE || colsB > MAX_SIZE) {\r\n        printf(\"Matrix B dimensions exceed maximum allowed size.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    // Menu for matrix operations\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Addition of matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    addMatrices(A, B, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions must match for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // Subtraction of matrices\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    subtractMatrices(A, B, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions must match for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Transpose of Matrix A\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                transposeMatrix(A, rowsA, colsA);\r\n                break;\r\n            case 4:\r\n                // Transpose of Matrix B\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                transposeMatrix(B, rowsB, colsB);\r\n                break;\r\n            case 5:\r\n                // Exit the program\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input elements of a matrix\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print elements of a matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n    printMatrix(result, rows, cols);\r\n}\r\n\r\n// Function to subtract one matrix from another\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n    printMatrix(result, rows, cols);\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < cols; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            result[i][j] = matrix[j][i];\r\n        }\r\n    }\r\n    printMatrix(result, cols, rows);\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Struct to hold grocery item information\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];\r\n    char category[MAX_CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Struct to hold availability status\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Struct to manage the inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addItem(GroceryInventory* inventory);\r\nvoid listItems(GroceryInventory* inventory);\r\nvoid updateQuantity(GroceryInventory* inventory);\r\nvoid removeItem(GroceryInventory* inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = {.count = 0};\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addItem(GroceryInventory* inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem* item = &inventory->items[inventory->count];\r\n    AvailabilityStatus* status = &inventory->status[inventory->count];\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(item->name, MAX_NAME_LEN, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(item->category, MAX_CATEGORY_LEN, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = !status->inStock;\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listItems(GroceryInventory* inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    \r\n    for (int i = 0; i < inventory->count; i++) {\r\n        GroceryItem* item = &inventory->items[i];\r\n        AvailabilityStatus* status = &inventory->status[i];\r\n\r\n        \r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory* inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(name, MAX_NAME_LEN, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n\r\n            inventory->status[i].inStock = inventory->items[i].quantity > 0;\r\n            inventory->status[i].outOfStock = !inventory->status[i].inStock;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeItem(GroceryInventory* inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(name, MAX_NAME_LEN, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            \r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n\r\n            inventory->count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;  \r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;\r\n    \r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Free all memory used by the program\r\nvoid freeMemory() {\r\n    deleteList();\r\n\r\n}\r\n\r\n// Swap function to swap two student nodes\r\nvoid swap(Student* a, Student* b) {\r\n    char tempName[100];\r\n    int tempID;\r\n    float tempGrade;\r\n\r\n    // Swap the data of two students\r\n    strcpy(tempName, a->name);\r\n    tempID = a->id;\r\n    tempGrade = a->grade;\r\n\r\n    strcpy(a->name, b->name);\r\n    a->id = b->id;\r\n    a->grade = b->grade;\r\n\r\n    strcpy(b->name, tempName);\r\n    b->id = tempID;\r\n    b->grade = tempGrade;\r\n}\r\n\r\n// Function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;  // No need to sort if the list has 0 or 1 element\r\n    }\r\n\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *ptr2 = NULL;\r\n\r\n    // Sorting the list by grades using Bubble Sort\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != ptr2) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                swap(ptr1, ptr1->next);\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        ptr2 = ptr1;\r\n    } while (swapped);\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Insert student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");  \r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                // Display all student records\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                // Sort student records by grade\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                // Search for student record by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                // Delete all student records\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                // Exit the program\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20611605",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 //define maximum amount of rows/column is 10\r\n\r\n//function for user to fill in matrix\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//function to input matrix\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//function to add matrix\r\nvoid addMatrices(int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//function to subtract matrix\r\nvoid subtractMatrices(int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//function to transpose matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int transposed[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n\r\n    //initialise variables\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB;\r\n\r\n    //ask user to enter rows and coloumns\r\n    printf(\"Enter rows and columns for Matrix A(max 10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter rows and columns for Matrix B(max 10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    //ensure only allowed dimensions are entered\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX || rowsA < 1 || colsA < 1 || rowsB < 1 || colsB < 1) {\r\n        printf(\"Invalid dimensions!\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //let user fill in the matrix\r\n    printf(\"Input Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n    printf(\"Input Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    int choice;\r\n    //use a do while loop\r\n    do {\r\n        //print options\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //use switch case\r\n        switch (choice) {\r\n            //for addition\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible. Dimensions must match.\\n\");\r\n                }\r\n                break;\r\n            //for subtraction\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Dimensions must match.\\n\");\r\n                }\r\n                break;\r\n            //for transposition A\r\n            case 3:\r\n                {\r\n                    int transposedA[MAX][MAX];\r\n                    transposeMatrix(matrixA, transposedA, rowsA, colsA);\r\n                    printf(\"Transpose of Matrix A:\\n\");\r\n                    printMatrix(transposedA, colsA, rowsA);\r\n                }\r\n                break;\r\n            \r\n            // for transposition B\r\n            case 4:\r\n                {\r\n                    int transposedB[MAX][MAX];\r\n                    transposeMatrix(matrixB, transposedB, rowsB, colsB);\r\n                    printf(\"Transpose of Matrix B:\\n\");\r\n                    printMatrix(transposedB, colsB, rowsB);\r\n                }\r\n                break;\r\n            // for exiting program\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            //print if invalid choice\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include <ctype.h>\r\n\r\n// Define the struct\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} GroceryItem;\r\n\r\n// Inventory structure\r\ntypedef struct {\r\n    GroceryItem items[100];\r\n    int count;\r\n} Inventory;\r\n\r\nInventory inventory = { .count = 0 };\r\n\r\n// function to validate if user entered numbers \r\nint getValidatedInteger(const char* prompt) {\r\n    int value;\r\n    char buffer[50];\r\n    while (1) {\r\n        printf(\"%s\", prompt);\r\n        fgets(buffer, sizeof(buffer), stdin);\r\n        if (sscanf(buffer, \"%d\", &value) == 1) {\r\n            return value;\r\n        } else {\r\n            printf(\"Invalid input. Please enter a valid integer.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// function to check if user entered proper float\r\nfloat getValidatedFloat(const char* prompt) {\r\n    float value;\r\n    char buffer[50];\r\n    while (1) {\r\n        printf(\"%s\", prompt);\r\n        fgets(buffer, sizeof(buffer), stdin);\r\n        if (sscanf(buffer, \"%f\", &value) == 1) {\r\n            return value;\r\n        } else {\r\n            printf(\"Invalid input. Please enter a valid number.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// function to add a grocery item\r\nvoid addGroceryItem() {\r\n    GroceryItem newItem;\r\n    printf(\"Enter name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\"); // Remove newline\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\");\r\n\r\n    newItem.quantity = getValidatedInteger(\"Enter quantity: \");\r\n    newItem.price = getValidatedFloat(\"Enter price: \");\r\n\r\n    newItem.inStock = newItem.quantity > 0;\r\n    inventory.items[inventory.count++] = newItem;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// function to list all grocery items\r\nvoid listGroceryItems() {\r\n    if (inventory.count == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nList:\\n\");\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        GroceryItem item = inventory.items[i];\r\n        printf(\"Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\\n\", item.inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// function to update the quantity of a grocery item\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, name) == 0) {\r\n            inventory.items[i].quantity = getValidatedInteger(\"Enter new quantity: \");\r\n            inventory.items[i].inStock = inventory.items[i].quantity > 0;\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// function to remove a grocery item\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory.count - 1; j++) {\r\n                inventory.items[j] = inventory.items[j + 1];\r\n            }\r\n            inventory.count--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    //do while loop\r\n    do {\r\n        //print menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        choice = getValidatedInteger(\"\");\r\n\r\n        switch (choice) {\r\n            //call for add item function\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            //call for list item function\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            //call for update item function\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            // call for remove item function\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            // exit \r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// struct for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL; // start of the linked list\r\n\r\n// function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n//function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// function to get a validated integer\r\nint getValidatedInteger(const char* prompt) {\r\n    int value;\r\n    char buffer[50];\r\n    while (1) {\r\n        printf(\"%s\", prompt);\r\n        fgets(buffer, sizeof(buffer), stdin);\r\n        if (sscanf(buffer, \"%d\", &value) == 1) {\r\n            return value;\r\n        } else {\r\n            printf(\"Invalid input. Please enter a valid integer.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// function to get a validated float\r\nfloat getValidatedFloat(const char* prompt) {\r\n    float value;\r\n    char buffer[50];\r\n    while (1) {\r\n        printf(\"%s\", prompt);\r\n        fgets(buffer, sizeof(buffer), stdin);\r\n        if (sscanf(buffer, \"%f\", &value) == 1) {\r\n            return value;\r\n        } else {\r\n            printf(\"Invalid input. Please enter a valid number.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records deleted successfully.\\n\");\r\n}\r\n\r\n\r\n//function that uses bubble sort the student records by grade in ascending order\r\n//I used bubble sort because it's easy to implement and it's efficiency will not become a problem because this program uses a small sample size\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (Student* i = head; i != NULL; i = i->next) {\r\n        for (Student* j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap grades\r\n                float tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n\r\n                // Swap IDs\r\n                int tempID = i->id;\r\n                i->id = j->id;\r\n                j->id = tempID;\r\n\r\n                // Swap names\r\n                char tempName[100];\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n            }\r\n        }\r\n    }\r\n    printf(\"Student records sorted by grade in ascending order.\\n\");\r\n}\r\n\r\nint main() {\r\n\r\n    //initialise variables\r\n    int choice;\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n\r\n    //do while loop\r\n    do {\r\n\r\n        //print menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        choice = getValidatedInteger(\"\");\r\n\r\n        //switch case\r\n        switch (choice) {\r\n            //insert student\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline\r\n                id = getValidatedInteger(\"Enter ID: \");\r\n                grade = getValidatedFloat(\"Enter Grade: \");\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            //display student\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            //sort students \r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            // search using id\r\n            case 4:\r\n                id = getValidatedInteger(\"Enter ID to search: \");\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            // delete whole list\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            // exit\r\n            case 6:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            // if user give invalid choice\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "feedback": "q1-Meet requirement\nq2-In the removeGroceryItem function, after removing an item, the code does not reset the last item in the array to prevent potential access to uninitialized memory. This could lead to undefined behavior if the last item's data is accessed after removal.\nq3-    The bubble sort implementation correctly sorts the student records by grade. However, bubble sort has a time complexity of O(n?), which can be inefficient for larger datasets. While it's suitable for small sample sizes, consider using a more efficient algorithm like Quick Sort or Merge Sort for scalability."
  },
  {
    "student_id": "20718938",
    "code": "\n/* --- Q1.c --- */\n#define _CRT_SECURE_NO_WARNINGS 1\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define MAX_SIZE 10\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nint validateDimensions(int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int rows, cols, choice;\r\n\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rows, &cols);\r\n\r\n    if (!validateDimensions(rows, cols)) {\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rows, cols, 'A');\r\n\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rows, &cols);\r\n\r\n    if (!validateDimensions(rows, cols)) {\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rows, cols, 'B');\r\n\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            addMatrices(A, B, result, rows, cols);\r\n            printf(\"Result of Matrix A + Matrix B:\\n\");\r\n            displayMatrix(result, rows, cols);\r\n            break;\r\n\r\n        case 2:\r\n            subtractMatrices(A, B, result, rows, cols);\r\n            printf(\"Result of Matrix A - Matrix B:\\n\");\r\n            displayMatrix(result, rows, cols);\r\n            break;\r\n\r\n        case 3:\r\n            transposeMatrix(A, result, rows, cols);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            displayMatrix(result, cols, rows);\r\n            break;\r\n\r\n        case 4:\r\n            transposeMatrix(B, result, rows, cols);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            displayMatrix(result, cols, rows);\r\n            break;\r\n\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint validateDimensions(int rows, int cols) {\r\n    if (rows <= 0 || cols <= 0 || rows > MAX_SIZE || cols > MAX_SIZE) {\r\n        printf(\"Error: Invalid dimensions! Maximum size is %dx%d\\n\", MAX_SIZE, MAX_SIZE);\r\n        return 0;\r\n    }\r\n    return 1;\r\n}\r\n\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#define _CRT_SECURE_NO_WARNINGS 1\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct {\r\n    int inStock;\r\n    int outOfStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    GroceryItem items[100];\r\n    AvailabilityStatus status[100];\r\n    int count;\r\n} GroceryInventory;\r\n\r\nGroceryInventory inventory;\r\n\r\nvoid clearInputBuffer() {\r\n    int c;\r\n    while ((c = getchar()) != '\\n' && c != EOF);\r\n}\r\n\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\nvoid updateItemStatus(int index);\r\n\r\nint main() {\r\n    inventory.count = 0;\r\n    int choice;\r\n    char input[100];\r\n\r\n    do {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        if (fgets(input, sizeof(input), stdin) != NULL) {\r\n            if (sscanf(input, \"%d\", &choice) != 1) {\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n                continue;\r\n            }\r\n\r\n            switch (choice) {\r\n            case 1: addGroceryItem(); break;\r\n            case 2: listGroceryItems(); break;\r\n            case 3: updateQuantity(); break;\r\n            case 4: removeGroceryItem(); break;\r\n            case 5: break;\r\n            default: printf(\"Invalid choice! Please try again.\\n\");\r\n            }\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem() {\r\n    if (inventory.count >= 100) {\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem* item = &inventory.items[inventory.count];\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    clearInputBuffer();\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n    clearInputBuffer();\r\n\r\n    updateItemStatus(inventory.count);\r\n    inventory.count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems() {\r\n    if (inventory.count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        printf(\"Name: %s\\n\", inventory.items[i].name);\r\n        printf(\"Category: %s\\n\", inventory.items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory.items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory.items[i].price);\r\n        printf(\"Status: %s\\n\", inventory.status[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity for %s: \", itemName);\r\n            if (scanf(\"%d\", &inventory.items[i].quantity) != 1) {\r\n                printf(\"Invalid input for quantity!\\n\");\r\n                clearInputBuffer();\r\n                return;\r\n            }\r\n            clearInputBuffer();\r\n            updateItemStatus(i);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, itemName) == 0) {\r\n            for (int j = i; j < inventory.count - 1; j++) {\r\n                inventory.items[j] = inventory.items[j + 1];\r\n                inventory.status[j] = inventory.status[j + 1];\r\n            }\r\n            inventory.count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\r\nvoid updateItemStatus(int index) {\r\n    if (inventory.items[index].quantity > 0) {\r\n        inventory.status[index].inStock = 1;\r\n        inventory.status[index].outOfStock = 0;\r\n    }\r\n    else {\r\n        inventory.status[index].inStock = 0;\r\n        inventory.status[index].outOfStock = 1;\r\n    }\r\n}\n/* --- Q3.c --- */\n#define _CRT_SECURE_NO_WARNINGS \r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    }\r\n    else {\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n}\r\n\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\",\r\n            current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n    Student* current;\r\n    Student* index;\r\n    float temp_grade;\r\n    int temp_id;\r\n    char temp_name[100];\r\n\r\n    for (current = head; current != NULL; current = current->next) {\r\n        for (index = current->next; index != NULL; index = index->next) {\r\n            if (current->grade > index->grade) {\r\n                temp_grade = current->grade;\r\n                temp_id = current->id;\r\n                strcpy(temp_name, current->name);\r\n\r\n                current->grade = index->grade;\r\n                current->id = index->id;\r\n                strcpy(current->name, index->name);\r\n\r\n                index->grade = temp_grade;\r\n                index->id = temp_id;\r\n                strcpy(index->name, temp_name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\");\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n        case 3:\r\n            sortStudents();\r\n            printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n            displayStudents();\r\n            break;\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student* found = searchStudentByID(id);\r\n            if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                    found->name, found->id, found->grade);\r\n            }\r\n            else {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-The AvailabilityStatus struct is used to track the in-stock and out-of-stock status, but it is redundant. This information can be derived directly from the quantity field in the GroceryItem struct or using Union. Additionally, the removeGroceryItem function does not reset the last item's status after removal, which could lead to displaying outdated information.\nq3-    The sorting function uses a nested loop to compare and swap elements, which is characteristic of bubble sort. This algorithm has a time complexity of O(n?), which can become inefficient for larger datasets. For improved performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort, especially for larger lists."
  },
  {
    "student_id": "20574289",
    "code": "\n/* --- Q1.c --- */\n// Library Pull & Variable Definition\r\n#include <stdio.h>\r\n#define MAXIMUM_SIZE 10 // Maximum size for the matrix, 10x10 matrix being the maximum size.\r\n\r\n// Function prototypes\r\nvoid inputDimensions(int *rows, int *columns);\r\nvoid inputMatrix(int rows, int columns, int matrix[MAXIMUM_SIZE][MAXIMUM_SIZE]);\r\nvoid addMatrices(int rows, int columns, int A[MAXIMUM_SIZE][MAXIMUM_SIZE], int B[MAXIMUM_SIZE][MAXIMUM_SIZE], int result[MAXIMUM_SIZE][MAXIMUM_SIZE]);\r\nvoid subtractMatrices(int rows, int columns, int A[MAXIMUM_SIZE][MAXIMUM_SIZE], int B[MAXIMUM_SIZE][MAXIMUM_SIZE], int result[MAXIMUM_SIZE][MAXIMUM_SIZE]);\r\nvoid transposeMatrix(int rows, int columns, int matrix[MAXIMUM_SIZE][MAXIMUM_SIZE], int result[MAXIMUM_SIZE][MAXIMUM_SIZE]);\r\nvoid displayMatrix(int rows, int columns, int matrix[MAXIMUM_SIZE][MAXIMUM_SIZE]);\r\n\r\n\r\n// Function to input matrix dimensions\r\nvoid inputDimensions(int *rows, int *columns) {\r\n    do {\r\n        printf(\"Enter dimensions in numerical format (rows and columns, e.g. 5 7): \");\r\n        scanf(\"%d %d\", rows, columns);\r\n        // Validate input to ensure dimensions are within allowed range\r\n        if (*rows <= 0 || *rows > MAXIMUM_SIZE || *columns <= 0 || *columns > MAXIMUM_SIZE) {\r\n            printf(\"Invalid dimensions. Please enter values between 1 and %d.\\n\", MAXIMUM_SIZE);\r\n        }\r\n    } while (*rows <= 0 || *rows > MAXIMUM_SIZE || *columns <= 0 || *columns > MAXIMUM_SIZE);\r\n}\r\n\r\n// Function to input matrix elements\r\nvoid inputMatrix(int rows, int columns, int matrix[MAXIMUM_SIZE][MAXIMUM_SIZE]) {\r\n    printf(\"Enter elements for the matrix:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1); // Print line that indicates the location of the element.\r\n            scanf(\"%d\", &matrix[i][j]); // Read and store the element\r\n        }\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int rows, int columns, int A[MAXIMUM_SIZE][MAXIMUM_SIZE], int B[MAXIMUM_SIZE][MAXIMUM_SIZE], int result[MAXIMUM_SIZE][MAXIMUM_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = A[i][j] + B[i][j]; // Add corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int rows, int columns, int A[MAXIMUM_SIZE][MAXIMUM_SIZE], int B[MAXIMUM_SIZE][MAXIMUM_SIZE], int result[MAXIMUM_SIZE][MAXIMUM_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = A[i][j] - B[i][j]; // Subtract corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int rows, int columns, int matrix[MAXIMUM_SIZE][MAXIMUM_SIZE], int result[MAXIMUM_SIZE][MAXIMUM_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[j][i] = matrix[i][j]; // Swap rows and columns\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int rows, int columns, int matrix[MAXIMUM_SIZE][MAXIMUM_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"%d \", matrix[i][j]); // Print each element\r\n        }\r\n        printf(\"\\n\"); // Move to the next line after each row\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rowsA, columnsA, rowsB, columnsB;\r\n    int matrixA[MAXIMUM_SIZE][MAXIMUM_SIZE], matrixB[MAXIMUM_SIZE][MAXIMUM_SIZE], result[MAXIMUM_SIZE][MAXIMUM_SIZE];\r\n    int choice;\r\n\r\n    printf(\"Welcome to the Basic Operational Matrix System! \\nYou'll be asked to enter the dimension of the matrix in addition to the elements inside the matrix.\\nIt is of note that once you have inputted the dimensions and elements, you will not be able to change them. \\n\\n\\n\");\r\n\r\n    // Input for Matrix A\r\n    printf(\"The following inputs are going to be for Matrix A. \\n\");\r\n    inputDimensions(&rowsA, &columnsA); // Get dimensions for matrix A\r\n    inputMatrix(rowsA, columnsA, matrixA); // Get elements for matrix A\r\n\r\n    // Input for Matrix B\r\n    printf(\"The following inputs are going to be for Matrix B. \\n\");\r\n    inputDimensions(&rowsB, &columnsB); // Get dimensions for matrix B\r\n    inputMatrix(rowsB, columnsB, matrixB); // Get elements for matrix B\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA != rowsB || columnsA != columnsB) {\r\n                    printf(\"Error: Matrices must have the same dimensions for addition.\\n\");\r\n                } else {\r\n                    addMatrices(rowsA, columnsA, matrixA, matrixB, result); // Add matrices\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(rowsA, columnsA, result); // Display the result\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA != rowsB || columnsA != columnsB) {\r\n                    printf(\"Error: Matrices must have the same dimensions for subtraction.\\n\");\r\n                } else {\r\n                    subtractMatrices(rowsA, columnsA, matrixA, matrixB, result); // Subtract matrices\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(rowsA, columnsA, result); // Display the result\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(rowsA, columnsA, matrixA, result); // Transpose matrix A\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(columnsA, rowsA, result); // Display the result (note the swapped dimensions)\r\n                break;\r\n            case 4:\r\n                transposeMatrix(rowsB, columnsB, matrixB, result); // Transpose matrix B\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(columnsB, rowsB, result); // Display the result (note the swapped dimensions)\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice!\\n\");\r\n        }\r\n    } while (choice != 5); // Continue until the user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n\r\n//----------------------------------------------------------------\r\n\r\n// Library Header Pull & Variable Definitions/Constants\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>    // Used for the boolean/Availability Status.\r\n\r\n#define MAXIMUM_ITEMS_ALLOWED 100\r\n#define MAXIMUM_NAME_LEN 100\r\n#define MAXIMUM_CATEGORY_LEN 50\r\n\r\n//----------------------------------------------------------------\r\n\r\n// Structure for Grocery Item\r\ntypedef struct {\r\n    char name[MAXIMUM_NAME_LEN];\r\n    char category[MAXIMUM_CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n} GROCItem;\r\n\r\n// Structure for Availability Status\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Structure for Grocery Inventory\r\ntypedef struct {\r\n    GROCItem items[MAXIMUM_ITEMS_ALLOWED];\r\n    AvailabilityStatus availability[MAXIMUM_ITEMS_ALLOWED];\r\n    int count;\r\n} GROCInv;\r\n\r\n//----------------------------------------------------------------\r\n\r\n// Function prototypes\r\nvoid addGROCItem(GROCInv *inventory);               // Function for adding a Grocery Item with its Category, Price & Quantity\r\nvoid listGROCItems(GROCInv *inventory);             // Lists all the Grocery Items\r\nvoid updateGROCItemQuantity(GROCInv *inventory);    // Updates a specified Grocery Item's quantity.\r\nvoid removeGROCItem(GROCInv *inventory);            // Function for removing a specified Grocery Item.\r\n\r\n//----------------------------------------------------------------\r\n\r\nint main() {\r\n    GROCInv inventory = {{}, {}, 0};            // Grocery Struct, Availability, Items in Inv, starting from zero.\r\n    int choice;\r\n    printf(\"Welcome to the Grocery Inventory Management System! \\nThis Software serves to manage your grocery inventory by allowing you to add, modify, remove and view all your inventory. \\nFor more information or assistance, reach out to IT @ efyms24 <3 \\n\\n\");\r\n    do {\r\n        // Menu\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGROCItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGROCItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateGROCItemQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGROCItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:                            // Data Validation & Error Handling with Return Handler\r\n                printf(\"Invalid choice!\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGROCItem(GROCInv *inventory) {\r\n    if (inventory->count >= MAXIMUM_ITEMS_ALLOWED) {\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n\r\n    getchar(); // Consume leftover newline\r\n    printf(\"Enter Item Name: \");\r\n    fgets(inventory->items[inventory->count].name, MAXIMUM_NAME_LEN, stdin);\r\n    inventory->items[inventory->count].name[strcspn(inventory->items[inventory->count].name, \"\\n\")] = 0; // Remove newline character\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(inventory->items[inventory->count].category, MAXIMUM_CATEGORY_LEN, stdin);\r\n    inventory->items[inventory->count].category[strcspn(inventory->items[inventory->count].category, \"\\n\")] = 0; // Remove newline character\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &inventory->items[inventory->count].quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &inventory->items[inventory->count].price);\r\n\r\n    // Set availability based on quantity\r\n    if (inventory->items[inventory->count].quantity > 0) {\r\n        inventory->availability[inventory->count].inStock = true;\r\n        inventory->availability[inventory->count].outOfStock = false;\r\n    } else {\r\n        inventory->availability[inventory->count].inStock = false;\r\n        inventory->availability[inventory->count].outOfStock = true;\r\n    }\r\n\r\n    inventory->count++;                                       // Incremental line\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGROCItems(GROCInv *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");     // Data Validation & Error Handling with Return Handler\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Items List:\\n\");\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\\n\", inventory->availability[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateGROCItemQuantity(GROCInv *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items to update.\\n\");            // Data Validation & Error Handling with Return Handler\r\n        return;\r\n    }\r\n\r\n    char itemName[MAXIMUM_NAME_LEN];\r\n    int newQuantity;\r\n\r\n    getchar(); // Consume leftover newline\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(itemName, MAXIMUM_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    int index = -1;\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1) {\r\n        printf(\"Item not found!\\n\");                        // Data Validation & Error Handling with Return Handler\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter the new quantity: \");\r\n    scanf(\"%d\", &newQuantity);\r\n\r\n    inventory->items[index].quantity = newQuantity;                         // Pointer Segment\r\n    inventory->availability[index].inStock = (newQuantity > 0);             // Usage of Arrow operator to access values of Quantity & Availability.\r\n    inventory->availability[index].outOfStock = (newQuantity <= 0);\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGROCItem(GROCInv *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items to remove.\\n\");            // Data Validation & Error Handling with Return Handler\r\n        return;\r\n    }\r\n\r\n    char itemName[MAXIMUM_NAME_LEN];\r\n\r\n    getchar(); // Consume leftover newline\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, MAXIMUM_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    int index = -1;\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1) {\r\n        printf(\"Item not found!\\n\");                        // Data Validation & Error Handling with Return Handler\r\n        return;\r\n    }\r\n\r\n    for (int i = index; i < inventory->count - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];                  // Pointer Segment\r\n        inventory->availability[i] = inventory->availability[i + 1];    // Usage of Arrow operator to access values of Quantity & Availability.\r\n    }\r\n\r\n    inventory->count--;\r\n\r\n    printf(\"Grocery item removed successfully!\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n// --------------------------------------\r\n\r\n// Library Header Pull\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// --------------------------------------\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int StudentID;\r\n    float grade;\r\n    struct Student* next;   // Pointer to the next Student in the linked list of students\r\n} Student;\r\n\r\n// -------------------------------------\r\n\r\n// Global VAR for the head/top of the list of students\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int StudentID, float grade) {\r\n    // Write your code (1 mark)\r\n    // Allocation of MEM for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1); // Exit the program if memory allocation fails\r\n    }\r\n    // Initialization of the fields for the new student\r\n    strcpy(newStudent->name, name);\r\n    newStudent->StudentID = StudentID;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int StudentID, float grade) {\r\n    // Write your code (1 mark)\r\n    Student* newStudent = createStudent(name, StudentID, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;                  // If the lis is empty, set the head/top to the new/next student\r\n    } else {\r\n        Student* current = head;            // Add the new student at the end of the linked list\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    // Write your code (1 mark)\r\n    if (head == NULL) {\r\n        printf(\"List is empty.\\n\");     // Data Validation & Error Handling with Return Handler\r\n        return;\r\n    }\r\n\r\n    // While loop used to go through the LL and print each students list while the node its on is not empty.\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->StudentID, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    // Using a While loop to go through the LL and free every node it goes through\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;            // Setting the Head/Top to NULL to state that the list is empty now.\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    // Write your code (1 mark)\r\n    // Choosing Bubble Sort as I already understand how to implement it from the Group Project\r\n\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *lptr = NULL;\r\n\r\n    // In case that the list is empty, return immediately as no sorting is needed.\r\n    if (head == NULL)\r\n        return;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n                // While loop to go through the LL and compare the adjacent student's grades.\r\n        while (ptr1->next != lptr) {\r\n\r\n                // If the current students grade is higher than the next student's grade, swap them together/pointers used.\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n\r\n                // Swap data of the nodes without swapping the nodes themselves\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                int tempId = ptr1->StudentID;\r\n                ptr1->StudentID = ptr1->next->StudentID;\r\n                ptr1->next->StudentID = tempId;\r\n\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;    // Last swap/node swapped is set at the end of the list.\r\n    } while (swapped);  // If any swaps occur, continue swapping until they stop.\r\n}\r\n\r\n// Advanced partial search feature for Student ID\r\nvoid searchPartialID() {\r\n    char searchTerm[20]; // Assuming ID is stored as a string for partial search\r\n    int found = 0; // Flag to check if any match is found\r\n\r\n    printf(\"Enter the partial or full ID to search: \");\r\n    scanf(\" %[^\\n]\", searchTerm);\r\n\r\n    // While loop used to go through the LL and look for matching IDs\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        char idString[20];\r\n        sprintf(idString, \"%d\", current->StudentID); // Convert ID to string for comparison\r\n\r\n        // strstr mnemonic used to search for parts of the ID\r\n        if (strstr(idString, searchTerm) != NULL) {\r\n            printf(\"Match found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                   current->name, current->StudentID, current->grade);\r\n            found = 1;\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"No students found with the given partial ID.\\n\");\r\n    }\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, StudentID;\r\n    char name[100];\r\n    float grade;\r\n    printf(\"Welcome to the Student Recordkeeping & Information Processing Program [Inspired from RAISA] \\nFor assistance in any inquiries or bug reporting, kindly refer to your closest handler or contact efyms24.\\nEnjoy!\\n- efyms24\\n\\n\");\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (Bubble Sort in Ascending Order for Grades)\\n\");\r\n        printf(\"4. Partial Search by ID\\n\"); // Implemented Partial Search function inspired and adapted from the Group Project [Contact Management System]\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"\\nEnter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove the trailing newline from fgets()\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &StudentID);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, StudentID, grade);\r\n                break;\r\n            case 2:\r\n                printf(\"\\n\");\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                printf(\"\\n\");\r\n                sortStudents();\r\n                printf(\"Records sorted by grade in ascending order using Bubble Sort.\\n\");\r\n                break;\r\n            case 4: // Now calls searchPartialID()\r\n                printf(\"\\n\");\r\n                searchPartialID();\r\n                break;\r\n            case 5:\r\n                printf(\"\\n\");\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                printf(\"\\n\");\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"\\n\");\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is well-implemented and sorts the student records by grade in ascending order. While Bubble Sort is simple and effective for small datasets, it has a time complexity of O(n?), which might not be efficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better scalability.\n4. Final Mark"
  },
  {
    "student_id": "20713310",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10\r\n\r\n// Function prototypes\r\nvoid displayMenu();\r\nvoid performOperation(int choice, int A[MAX][MAX], int B[MAX][MAX], int rowsA, int colsA, int rowsB, int colsB);\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int A[MAX][MAX], B[MAX][MAX];\r\n    int choice;\r\n\r\n    // Input dimensions for matrices\r\n    do {\r\n        printf(\"Enter the number of rows and columns for Matrix A (max %d): \", MAX);\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n    } while (rowsA <= 0 || rowsA > MAX || colsA <= 0 || colsA > MAX);\r\n\r\n    do {\r\n        printf(\"Enter the number of rows and columns for Matrix B (max %d): \", MAX);\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n    } while (rowsB <= 0 || rowsB > MAX || colsB <= 0 || colsB > MAX);\r\n\r\n    // Input matrices\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    // Menu-driven operations\r\n    do {\r\n        displayMenu();\r\n        scanf(\"%d\", &choice);\r\n        performOperation(choice, A, B, rowsA, colsA, rowsB, colsB);\r\n    } while (choice != 0);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid displayMenu() {\r\n    printf(\"\\nMenu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"0. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n}\r\n\r\nvoid performOperation(int choice, int A[MAX][MAX], int B[MAX][MAX], int rowsA, int colsA, int rowsB, int colsB) {\r\n    int result[MAX][MAX];\r\n\r\n    switch (choice) {\r\n        case 1:\r\n            if (rowsA == rowsB && colsA == colsB) {\r\n                addMatrices(A, B, result, rowsA, colsA);\r\n                printf(\"Result of Addition:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            } else {\r\n                printf(\"Matrix dimensions do not match for addition!\\n\");\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            if (rowsA == rowsB && colsA == colsB) {\r\n                subtractMatrices(A, B, result, rowsA, colsA);\r\n                printf(\"Result of Subtraction:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            } else {\r\n                printf(\"Matrix dimensions do not match for subtraction!\\n\");\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            transposeMatrix(A, result, rowsA, colsA);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(result, colsA, rowsA);\r\n            break;\r\n\r\n        case 4:\r\n            transposeMatrix(B, result, rowsB, colsB);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(result, colsB, rowsB);\r\n            break;\r\n\r\n        case 0:\r\n            printf(\"Exiting program.\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n    }\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Structure Definitions\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int isAvailable; // 1 for available, 0 for not available\r\n} Item;\r\n\r\n// Global Variables\r\nItem items[MAX_ITEMS];\r\nint totalItems = 0;\r\n\r\n// Function Declarations\r\nvoid addNewItem();\r\nvoid showItems();\r\nvoid modifyQuantity();\r\nvoid deleteItem();\r\nvoid menu();\r\n\r\nint main() {\r\n    int option;\r\n\r\n    do {\r\n        menu();\r\n        scanf(\"%d\", &option);\r\n        getchar(); // Flush newline\r\n\r\n        switch (option) {\r\n            case 1:\r\n                addNewItem();\r\n                break;\r\n            case 2:\r\n                showItems();\r\n                break;\r\n            case 3:\r\n                modifyQuantity();\r\n                break;\r\n            case 4:\r\n                deleteItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid option. Try again.\\n\");\r\n        }\r\n    } while (option != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid menu() {\r\n    printf(\"\\nInventory System:\\n\");\r\n    printf(\"1. Add New Item\\n\");\r\n    printf(\"2. Display All Items\\n\");\r\n    printf(\"3. Update Item Quantity\\n\");\r\n    printf(\"4. Remove an Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    printf(\"Choose an option: \");\r\n}\r\n\r\nvoid addNewItem() {\r\n    if (totalItems >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    Item newItem;\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\");\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\");\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    newItem.isAvailable = newItem.quantity > 0 ? 1 : 0;\r\n\r\n    items[totalItems] = newItem;\r\n    totalItems++;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\nvoid showItems() {\r\n    if (totalItems == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nCurrent Inventory:\\n\");\r\n    printf(\"%-20s %-15s %-10s %-10s %-10s\\n\", \"Name\", \"Category\", \"Quantity\", \"Price\", \"Availability\");\r\n    printf(\"-------------------------------------------------------------\\n\");\r\n\r\n    for (int i = 0; i < totalItems; i++) {\r\n        printf(\"%-20s %-15s %-10d %-10.2f %-10s\\n\",\r\n               items[i].name,\r\n               items[i].category,\r\n               items[i].quantity,\r\n               items[i].price,\r\n               items[i].isAvailable ? \"Available\" : \"Unavailable\");\r\n    }\r\n}\r\n\r\nvoid modifyQuantity() {\r\n    char searchName[100];\r\n    int newQuantity;\r\n\r\n    if (totalItems == 0) {\r\n        printf(\"No items to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(searchName, sizeof(searchName), stdin);\r\n    strtok(searchName, \"\\n\");\r\n\r\n    for (int i = 0; i < totalItems; i++) {\r\n        if (strcmp(items[i].name, searchName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            items[i].quantity = newQuantity;\r\n            items[i].isAvailable = newQuantity > 0;\r\n\r\n            printf(\"Item updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nvoid deleteItem() {\r\n    char searchName[100];\r\n\r\n    if (totalItems == 0) {\r\n        printf(\"No items to delete.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(searchName, sizeof(searchName), stdin);\r\n    strtok(searchName, \"\\n\");\r\n\r\n    for (int i = 0; i < totalItems; i++) {\r\n        if (strcmp(items[i].name, searchName) == 0) {\r\n            for (int j = i; j < totalItems - 1; j++) {\r\n                items[j] = items[j + 1];\r\n            }\r\n            totalItems--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define the student structure\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Head pointer for the linked list\r\nStudent* head = NULL;\r\n\r\n// Helper function to create a new student node\r\nStudent* createStudentNode(const char* name, int id, float grade) {\r\n    Student* newNode = (Student*)malloc(sizeof(Student));\r\n    if (newNode == NULL) {\r\n        printf(\"Error allocating memory!\\n\");\r\n        return NULL;\r\n    }\r\n    strncpy(newNode->name, name, sizeof(newNode->name) - 1);\r\n    newNode->id = id;\r\n    newNode->grade = grade;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\r\n\r\n// Inserts a new student record at the beginning of the list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudentNode(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Displays all student records in the linked list\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %-20s ID: %-6d Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Searches for a student by their ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Deletes all records in the linked list and frees memory\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* temp;\r\n\r\n    while (current != NULL) {\r\n        temp = current->next;\r\n        free(current);\r\n        current = temp;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to recursively merge two sorted sublists\r\nStudent* mergeLists(Student* left, Student* right) {\r\n    if (left == NULL) return right;\r\n    if (right == NULL) return left;\r\n\r\n    // If left grade is smaller, it should come first\r\n    if (left->grade <= right->grade) {\r\n        left->next = mergeLists(left->next, right);\r\n        return left;\r\n    } else {\r\n        right->next = mergeLists(left, right->next);\r\n        return right;\r\n    }\r\n}\r\n\r\n// Function to split the linked list into two halves\r\nvoid splitList(Student* source, Student** left, Student** right) {\r\n    Student* slow = source;\r\n    Student* fast = source->next;\r\n\r\n    // Move the fast pointer two steps for every slow pointer step\r\n    while (fast != NULL) {\r\n        fast = fast->next;\r\n        if (fast != NULL) {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n    }\r\n\r\n    *left = source;\r\n    *right = slow->next;\r\n    slow->next = NULL;\r\n}\r\n\r\n// Merge sort for sorting the linked list\r\nvoid mergeSort(Student** list) {\r\n    if (*list == NULL || (*list)->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    Student* left;\r\n    Student* right;\r\n\r\n    // Split the list into two halves\r\n    splitList(*list, &left, &right);\r\n\r\n    // Recursively sort the two halves\r\n    mergeSort(&left);\r\n    mergeSort(&right);\r\n\r\n    // Merge the sorted halves\r\n    *list = mergeLists(left, right);\r\n}\r\n\r\n// Sorts the student records by grade in ascending order\r\nvoid sortStudents() {\r\n    mergeSort(&head);\r\n}\r\n\r\n// Main function to handle user input and interaction\r\nint main() {\r\n    int choice;\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n\r\n    while (1) {\r\n        printf(\"\\nStudent Record Management System\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Student Records by Grade\\n\");\r\n        printf(\"4. Search for a Student by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter student's full name: \");\r\n                scanf(\" %[^\\n]\", name);  // Allow for spaces in name input\r\n                printf(\"Enter student ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter student grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                printf(\"Student record added.\\n\");\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records have been sorted by grade in ascending order.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter the ID of the student to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* student = searchStudentByID(id);\r\n                if (student != NULL) {\r\n                    printf(\"Student found: Name: %s, ID: %d, Grade: %.2f\\n\", student->name, student->id, student->grade);\r\n                } else {\r\n                    printf(\"No student found with ID %d.\\n\", id);\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"All student records have been deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting program. Goodbye!\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The mergeSort function implements Merge Sort, which is efficient for linked lists with a time complexity of O(n log n). This is a good choice for sorting student records by grade, especially for larger datasets."
  },
  {
    "student_id": "20596870",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function to input matrix element\r\nvoid inputMatrix (int matrix[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j< cols; j ++) {\r\n            printf (\"Enter element [%d][%d]: \", i + 1, j + 1); // Prompt user for each element\r\n            scanf (\"%d\", &matrix[i][j]); // Read the input element\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display matrix element\r\nvoid displayMatrix( int matrix[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]); // Print each element\r\n        }\r\n        printf (\"\\n\"); // New line after each row\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices (int matrixA[][MAX_SIZE], int matrixB[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j =0; j < cols; j ++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j]; // add corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices (int matrixA[][MAX_SIZE], int matrixB[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j =0; j < cols; j ++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j]; // subtract corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose matrix\r\nvoid transposeMatrix (int matrix[][MAX_SIZE], int transposed[][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j =0; j < cols; j ++) {\r\n            transposed[j][i] = matrix[i][j]; // Swap rows & columns\r\n        }\r\n    }\r\n}\r\n\r\n// Main menu\r\nvoid displayMenu () {\r\n    printf (\"Matrix Operations Menu: \\n\");\r\n    printf (\"1. Add Matrices\\n\");\r\n    printf (\"2. Subtract Matrices\\n\");\r\n    printf (\"3. Transpose Matrix A\\n\");\r\n    printf (\"4. Transpose Matrix B\\n\");\r\n    printf (\"5. Exit\\n\");\r\n}\r\n\r\nint main () {\r\n    // Declare matrices & variables\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE], result [MAX_SIZE][MAX_SIZE], transposedA[MAX_SIZE][MAX_SIZE], transposedB[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB, choice;\r\n\r\n    choice =0; // Initialize choice to a non-zero value to enter the loop\r\n\r\n    // Input matrix A&B\r\n    printf (\"Enter dimensions of matrix A (rows and columns): \");\r\n    scanf (\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter the elements of matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n    printf (\"Enter dimensions of matrix B (rows and columns): \");\r\n    scanf (\"%d %d\", &rowsB, &colsB);\r\n    printf(\"Enter the elements of matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    while (choice != 5) {\r\n        displayMenu (); \r\n        printf(\"Enter your choice: \");\r\n        scanf (\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Check dimensions are compatible or not\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf (\"Result of adding matrices A and B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf (\"Matrices cannot be added. Different dimension\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // Check dimensions are compatible or not\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf (\"Result of subtracting matrices A and B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf (\"Matrices cannot be subtracted. Different dimension\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(matrixA, transposedA, rowsA, colsA);\r\n                printf(\"Tranpose of matrix A:\\n\");\r\n                displayMatrix(transposedA, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(matrixB, transposedB, rowsB, colsB);\r\n                printf(\"Transpose of matrix B:\\n\");\r\n                displayMatrix(transposedB, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                printf (\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf (\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Sturcture for grocery item\r\nstruct GroceryItem {\r\n    char name[100]; //Name of the grocery item\r\n    char category[50]; // Category of the grocery item\r\n    int quantity; // Quantity of the item in stock\r\n    float price; // Price of the grocery item\r\n};\r\n\r\n// Structure for availability status\r\nstruct AvailabilityStatus {\r\n    int inStock; // Boolean: 1 if the item is in stock, 0 otherwise\r\n    int outofStock; // Boolean: 1 if the item is out of stock, 0 otherwise\r\n};\r\n\r\n// Functions\r\nvoid addItem (struct GroceryItem inventory[], struct AvailabilityStatus availability[], int *itemCount) {\r\n    if (*itemCount < MAX_ITEMS) {\r\n        printf (\"Enter details for the new item: \\n\");\r\n        printf (\"Name: \"); //Input item name\r\n        scanf (\" %99[^\\n]\", inventory[*itemCount].name);\r\n        \r\n        printf (\"Category: \"); // Input item category\r\n        scanf (\" %49[^\\n]\", inventory[*itemCount].category);\r\n        \r\n        printf (\"Quantity: \"); // Input item quantity\r\n        if (scanf (\"%d\", &inventory[*itemCount].quantity) != 1 || inventory[*itemCount].quantity < 0) {\r\n            printf (\"Invalid quantity. Please enter a non-negative number.\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            return;\r\n        }\r\n        \r\n        printf (\"Price: \"); // Input item price\r\n        if (scanf (\"%f\", &inventory[*itemCount].price) != 1 || inventory[*itemCount].price < 0) {\r\n            printf (\"Invalid price. Please enter a non-negative number.\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            return;\r\n        }\r\n\r\n        // Set availability status\r\n        availability[*itemCount].inStock = (inventory[*itemCount].quantity > 0);\r\n        availability[*itemCount].outofStock = (inventory[*itemCount].quantity == 0);\r\n\r\n        (*itemCount)++; // Increment the item count\r\n        printf (\"Item added successfully!\\n\");\r\n    } else {\r\n        printf (\"Inventory is full.\\n\");\r\n    }\r\n}\r\n\r\nvoid listItems (struct GroceryItem inventory[], struct AvailabilityStatus availability[], int itemCount) {\r\n    if (itemCount == 0) {\r\n        printf (\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n    \r\n    printf (\"List of Grocery Items:\\n\");\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf (\"\\nName: %s\\n\", inventory[i].name);\r\n        printf (\"Category: %s\\n\", inventory[i].category);\r\n        printf (\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf (\"Price: %.2f\\n\", inventory[i].price);\r\n        printf (\"Status: %s\\n\", availability[i].inStock ? \"In stock\"  : \"Out of stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity (struct GroceryItem inventory[], struct AvailabilityStatus availability[], int itemCount) {\r\n    if (itemCount == 0) {\r\n        printf (\"No item in inventory to update.\\n\");\r\n        return;\r\n    }\r\n    \r\n    char name [100];\r\n    printf (\"Enter the name of the item to update: \");\r\n    scanf (\" %99[^\\n]\", name);\r\n\r\n    // Search for the item by name\r\n    int found = -1;\r\n    for (int i = 0; i < itemCount; i ++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            found = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (found == -1) {\r\n        printf (\"Item '%s' not found in inventory.\\n\", name);\r\n        return;\r\n    }\r\n\r\n    // Update quantity with validation\r\n    printf(\"Enter new quantity: \");\r\n    if (scanf(\"%d\", &inventory[found].quantity) != 1 || inventory[found].quantity < 0){\r\n        printf (\"Invalid quantity. Please enter a non-negative number.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n        return;\r\n    }\r\n\r\n    // Update availability status based on new quantity\r\n    availability[found].inStock = (inventory[found].quantity > 0);\r\n    availability[found].outofStock = (inventory[found].quantity == 0);\r\n\r\n    printf (\"Quantity updated successfully!\\n\");\r\n}\r\n\r\nvoid removeItem (struct GroceryItem inventory[], struct AvailabilityStatus availability[], int *itemCount){\r\n    if (*itemCount == 0) {\r\n        printf (\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n    \r\n    char name [100];\r\n    printf (\"Enter the name of the item to remove: \");\r\n    scanf (\" %99[^\\n]\", name);\r\n\r\n    // Search for the item by name\r\n    int found = -1;\r\n    for (int i = 0; i < *itemCount; i ++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            found = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (found == -1) {\r\n        printf (\"Item '%s' not found in inventory.\\n\", name);\r\n        return;\r\n    }\r\n    \r\n    //Shift items to fill the gap\r\n    for(int i = found; i < *itemCount -1; i++) {\r\n        inventory[i] = inventory[i+1];\r\n        availability[i] = availability[i+1];\r\n    }\r\n    (*itemCount)--; // Decrement the item count\r\n\r\n    printf (\"Grocery item '%s'removed successfully!\\n\", name);\r\n}\r\n\r\nint main () {\r\n    struct GroceryItem inventory[MAX_ITEMS]; // Array of grocery items\r\n    struct AvailabilityStatus availability[MAX_ITEMS]; // Array of availability statuses\r\n    int itemCount = 0; // Total number of items in inventory\r\n    int choice;\r\n\r\n    while (1) {\r\n        printf (\"\\n Grocery Inventory Management\\n\");\r\n        printf (\"1. Add Grocery Item\\n\");\r\n        printf (\"2. List All Grocery Items\\n\");\r\n        printf (\"3. Update Quantity of a Grocery Item\\n\");\r\n        printf (\"4. Remove a Grocery Item\\n\");\r\n        printf (\"5. Exit\\n\");\r\n        printf (\"Enter your choice: \");\r\n        \r\n        // Read user input with validation\r\n        if (scanf (\"%d\", &choice)!= 1) {\r\n            printf (\"Invalid input. Please enter a number.\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            continue;\r\n        }\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(inventory, availability, &itemCount);\r\n                break;\r\n\r\n            case 2:\r\n                listItems(inventory, availability, itemCount);\r\n                break;\r\n\r\n            case 3:\r\n                updateQuantity(inventory, availability, itemCount);\r\n                break;\r\n\r\n            case 4:\r\n                removeItem(inventory, availability, &itemCount);\r\n                break;\r\n\r\n            case 5:\r\n                printf (\"Exiting program...\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf (\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name [100]; // Name of student\r\n    int id; // ID of student\r\n    float grade; // grade of student\r\n    struct Student* next; // Pointer to the next student in the list\r\n} Student;\r\n\r\n// Pointer to the head of the linked list\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent (const char* name, int id, float grade) {\r\n    // Dynamically allocate memory for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent) { // Check if memory allocation is successful\r\n        strcpy (newStudent->name, name); // Copy name to structure\r\n        newStudent ->id = id; // Set id\r\n        newStudent ->grade = grade; // Set grade\r\n        newStudent ->next = NULL; // Initialize the next pointer to NULL\r\n    }\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent (const char* name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!head) { // Set new student as the head if list is empty\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        // Traverse to the end of list\r\n        while (temp->next) {\r\n            temp = temp->next;\r\n        }\r\n        // Add new student at the end\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* temp = head;\r\n    if (!temp) { // Display message if list is empty\r\n        printf (\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    printf (\"Student records: \\n\");\r\n    // Traverse list and print each students details\r\n    while (temp) {\r\n        printf (\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentById (int id) {\r\n    // Traverse list and search student via ID\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) return temp; // Return student node if found\r\n        temp = temp->next;\r\n    }\r\n    return NULL; // Return NULL if not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    // Traverse list and free each node\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free (current); // Free memory allocated for the current node\r\n        current = next;\r\n    }\r\n    head = NULL; // Reset head pointer to NULL\r\n}\r\n\r\n// Function to free memory before exiting program\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on Bubble Sort\r\nvoid sortStudents() {\r\n    if (!head || !head ->next) { // If list is empty or has only 1 node, no need to sort\r\n        printf (\"No records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped; // Flag to track if any swapping occurred\r\n    Student *ptr1, *lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        // Compare nodes and swap data if needed\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                float tempGrade = ptr1->grade;\r\n                int tempID = ptr1->id;\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempID;\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf (\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main () {\r\n\r\n    int choice, id;\r\n    char name [100];\r\n    float grade;\r\n\r\n    do {\r\n        printf (\"\\n1. Insert Student Record\\n\");\r\n        printf (\"2. Display Student records\\n\");\r\n        printf (\"3. Sort Records\\n\");\r\n        printf (\"4. Search Records\\n\");\r\n        printf (\"5. Delete List\\n\");\r\n        printf (\"6. Exit\\n\");\r\n        printf (\"Enter your choice: \");\r\n        scanf (\"%d\", &choice);\r\n        getchar(); // to consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf (\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok (name, \"\\n\");\r\n                printf (\"Enter ID: \");\r\n                scanf (\"%d\", &id);\r\n                printf (\"Enter Grade: \");\r\n                scanf (\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf (\"Enter ID to search: \");\r\n                scanf (\"%d\", &id);\r\n                Student* found = searchStudentById(id);\r\n                if (found) {\r\n                    printf (\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf (\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf (\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory ();\r\n                printf (\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf (\"Invalid choice ! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While this method is straightforward and sufficient for small datasets, it has a time complexity of O(n?), which can lead to inefficiencies with larger datasets. For better performance, consider using a more efficient sorting algorithm like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20701396",
    "code": "\n/* --- Question1.c --- */\n#include <stdio.h>\r\n#define MAXSIZE 10\r\n//code runs on cmd\r\n\r\n\r\n//function for matrix input\r\nvoid matinput(int row, int column, int matrix[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traverses through row and column\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1); //asks userto input elements\r\n            scanf(\"%d\", &matrix[i][j]); //saves the input into a matrix\r\n        }\r\n    }\r\n}\r\n\r\n//function to add matrix A and B\r\nvoid matrixadd(int row, int column, int MatrixA[row][column], int MatrixB[row][column], int result[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            result[i][j] = MatrixA[i][j] + MatrixB[i][j]; //finding the result of addition and putting it into the corresponding row and column for the result matrix\r\n        }\r\n    }\r\n}\r\n\r\n//function to subract 2 matrices\r\nvoid matrixsub(int row, int column, int MatrixA[row][column], int MatrixB[row][column], int result[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            result[i][j] = MatrixA[i][j] - MatrixB[i][j]; //finding the result of subtraction and putting it into the corresponding row and column for the result matrix\r\n        }\r\n    }\r\n}\r\n//function to transpose a matrix\r\nvoid transposeMatrix(int row, int column, int matrix[row][column], int result[column][row]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            result[j][i] = matrix[i][j]; //changing i to j and j to i\r\n        }\r\n    }\r\n}\r\n//function to display the matrix\r\nvoid display(int row, int column, int matrix[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            printf(\"%d\\t\", matrix[i][j]); // printing element\r\n        }\r\n        printf(\"\\n\"); //to go to next line after a column is done\r\n    }\r\n}\r\n\r\nint main(){\r\n    //variable declarations\r\n    int rowA, columnA, rowB, columnB;\r\n    int choice = 0;\r\n\r\n    //while loop to ensure proper dimensions are inputted\r\n    while(1){\r\n    printf(\"Enter the number of rows in Matrix A: \");\r\n    scanf(\"%d\", &rowA);\r\n    printf(\"Enter the number of columns in Matrix A: \");\r\n    scanf(\"%d\", &columnA);\r\n\r\n    if (rowA > MAXSIZE || columnA > MAXSIZE) { //validate that the dimensions are 10x10\r\n        printf(\"Error, max size for matrices is %dx%d!\\n\", MAXSIZE, MAXSIZE);\r\n    }else{\r\n        break;\r\n    }\r\n    }\r\n    int MatrixA[rowA][columnA]; //initialising matrix\r\n\r\n    //while loop to ensure proper dimensions are inputted\r\n    while(1){\r\n    printf(\"Enter the number of rows in Matrix B: \");\r\n    scanf(\"%d\", &rowB);\r\n    printf(\"Enter the number of columns in Matrix B: \");\r\n    scanf(\"%d\", &columnB);\r\n\r\n    if (rowB > MAXSIZE || columnB > MAXSIZE) {//validate the dimensions\r\n        printf(\"Error, max size for matrices is is %dx%d!\\n\", MAXSIZE, MAXSIZE);\r\n    }else{\r\n        break;\r\n    }\r\n    }\r\n    int MatrixB[rowB][columnB]; //initialising matrix\r\n\r\n    printf(\"Enter the values for Matrix A\\n\"); //getting the values of the matrices\r\n    matinput(rowA, columnA, MatrixA); //calling functions\r\n\r\n    printf(\"Enter the values for Matrix B\\n\");\r\n    matinput(rowB, columnB, MatrixB);\r\n\r\n    int loop = 1;\r\n    while(loop){ //loop to permit consecutive operations\r\n        printf(\"\\tMATRIX OPERATION MENU\\n\");\r\n        printf(\"1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix A\\n4. Transpose Matrix B\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \"); //For user to choose operation\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice){\r\n            case 1:\r\n            if(rowA != rowB || columnA != columnB){\r\n                printf(\"Matrices must have same size to be added\\n\"); //checking if matrix dimensions are equal\r\n                break;\r\n            }else{\r\n                int resultMatrix[rowA][columnA]; //calculating the addition of matrix A and B\r\n                matrixadd(rowA, columnA, MatrixA, MatrixB, resultMatrix);\r\n                display(rowA, columnA, resultMatrix); //output\r\n            break;\r\n            }\r\n\r\n            case 2:\r\n            if(rowA != rowB || columnA != columnB){\r\n                printf(\"Matrices must have same size to be subtracted\\n\"); //checking if matrices have same dimensions\r\n                break;\r\n            }else{\r\n                int resultMatrix[rowA][columnA]; //calculating the difference between matrix A and B\r\n                matrixsub(rowA, columnA, MatrixA, MatrixB, resultMatrix);\r\n                display(rowA, columnA, resultMatrix); //output\r\n                break;\r\n            }\r\n\r\n            case 3: {\r\n            int resultMatrix[columnA][rowA]; //transposing matrix A\r\n            transposeMatrix(rowA, columnA, MatrixA, resultMatrix);\r\n            printf(\"Transpose of Matrix A: \\n\");\r\n            display(columnA, rowA, resultMatrix);\r\n            break;\r\n            }\r\n\r\n            case 4: {\r\n            int resultMatrix[columnB][rowB]; //transposing matrix B\r\n            transposeMatrix(rowB, columnB, MatrixB, resultMatrix);\r\n            printf(\"Transpose of Matrix B: \\n\");\r\n            display(columnB, rowB, resultMatrix);\r\n            break;\r\n            }\r\n\r\n            case 5: //exit\r\n            printf(\"Exiting...\");\r\n            loop = 0;\r\n            break;\r\n\r\n            default: //in case user enters unsupported values\r\n            printf(\"Please enter a valid input.\");\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\n/* --- Question2.c --- */\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n//code runs on cmd\r\n\r\ntypedef struct { // Structure for grocery products\r\n    char name[100];\r\n    char category[100];\r\n    int quantity;\r\n    float price;\r\n    char available[100];\r\n} grocitem;\r\n\r\nvoid add() { // Function to add items to the inventory\r\n    grocitem *item = malloc(sizeof(grocitem)); // memory allocation for new iterm\r\n    FILE *filepointer = fopen(\"Inventory.csv\", \"a+\"); // Open the file in mode \"append\"\r\n\r\n    // ask user for input\r\n    printf(\"Enter the name of the product: \");\r\n    scanf(\" %[^\\n]s\", item->name);\r\n    printf(\"Enter the category of the item: \");\r\n    scanf(\" %[^\\n]s\", item->category);\r\n\r\n    while (1) { // infinite loop handles errors\r\n        printf(\"Enter the quantity of the item: \");\r\n        scanf(\" %d\", &item->quantity);\r\n\r\n        if (item->quantity < 0) {\r\n            printf(\"The quantity of an item cannot be negative!\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    printf(\"Enter the price of the item: RM \");\r\n    scanf(\" %f\", &item->price);\r\n\r\n    \r\n    if (item->quantity > 0) {\r\n        strcpy(item->available, \"Item is In Stock\");\r\n    } else if (item->quantity == 0) {\r\n        strcpy(item->available, \"Item is Out of Stock\");\r\n    } //Check if item is in stock by comparing to the quantity available\r\n\r\n    // Write item details to the file\r\n    fprintf(filepointer, \"%s, %s, %d, %.2f, %s\\n\", item->name, item->category, item->quantity, item->price, item->available);\r\n    fclose(filepointer); // close file \"filepointer\"\r\n    free(item); // free memory\r\n}\r\n\r\n// Function to display the saved inventory information\r\nvoid display() {\r\n    FILE *filepointer = fopen(\"Inventory.csv\", \"r\"); // Open the inventory file in read mode\r\n    char buffer[1024]; // intialising buffer\r\n    int i = 1; // counter\r\n    printf(\"Name, Category, Quantity, Price(RM), Available\\n\");\r\n\r\n    while (fgets(buffer, sizeof(buffer), filepointer) != NULL) { // Read each buffer of the inventory\r\n        printf(\"%d. %s\\n\", i, buffer); // Display each item\r\n        i++;\r\n    }\r\n\r\n    fclose(filepointer); // Close the file\r\n}\r\n\r\n// Function to update the quantity of an item\r\nvoid update() {\r\n    FILE *filepointer = fopen(\"Inventory.csv\", \"r\"); // Open Inventory.csv in read mode\r\n    FILE *temporaryfile = fopen(\"temporaryfile\", \"w\"); // Create a temporary file for updates\r\n    char search[100], buffer[1024];\r\n    char name[100], category[100], available[100];\r\n    int quantity;\r\n    float price;\r\n    int found = 0; // Flag to track if the item is found\r\n\r\n    if (filepointer == NULL || temporaryfile == NULL) { // Error handling for file opening\r\n        printf(\"Error: Could not open file.\\n\");\r\n        if (filepointer != NULL) fclose(filepointer);\r\n        if (temporaryfile != NULL) fclose(temporaryfile);\r\n        return;\r\n    }\r\n\r\n    getchar(); // Clear the input buffer\r\n    printf(\"Which product would you like to update: \"); // Prompt for product to update\r\n    fgets(search, sizeof(search), stdin);\r\n    search[strcspn(search, \"\\n\")] = 0; // Remove trailing newbuffer\r\n\r\n    while (fgets(buffer, sizeof(buffer), filepointer) != NULL) {\r\n        // Parse the current buffer\r\n        int parsed = sscanf(buffer, \"%99[^,],%99[^,],%d,%f,%99[^\\n]\", name, category, &quantity, &price, available);\r\n        if (parsed != 5) {\r\n            printf(\"Error traversing buffer: %s\", buffer);\r\n            continue; // Skip malformed buffers\r\n        }\r\n\r\n        if (strcmp(search, name) == 0) { // Check for a match by name\r\n            found = 1; // Mark as found\r\n            printf(\"Enter the new quantity: \");\r\n            while (scanf(\"%d\", &quantity) != 1 || quantity < 0) {\r\n                printf(\"Invalid input. Enter a non-negative quantity: \");\r\n                while (getchar() != '\\n'); // Clear invalid input\r\n            }\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n\r\n            // Update available status\r\n            if (quantity > 0) {\r\n                strcpy(available, \"In Stock\");\r\n            } else {\r\n                strcpy(available, \"Out of Stock\");\r\n            }\r\n        }\r\n\r\n        // Write to the temporary file\r\n        fprintf(temporaryfile, \"%s,%s,%d,%.2f,%s\\n\", name, category, quantity, price, available);\r\n    }\r\n\r\n    // Close files and replace the original file with the updated one\r\n    fclose(filepointer);\r\n    fclose(temporaryfile);\r\n\r\n    if (found) {\r\n        // Replace the file with the new updated one\r\n        remove(\"Inventory.csv\");\r\n        rename(\"temporaryfile\", \"Inventory.csv\");\r\n        printf(\"Quantity updated.\\n\");\r\n    } else {\r\n        remove(\"temporaryfile\"); // Remove temp file if no items were found\r\n        printf(\"Product not found.\\n\");\r\n    }\r\n}\r\n\r\n// Function to delete an item\r\nvoid delete() {\r\n    FILE *filepointer = fopen(\"Inventory.csv\", \"r\"); // Open Inventory.csv in read mode\r\n    FILE *temporaryfile = fopen(\"temporaryfile\", \"w\"); // Create a temporary file for the updated list\r\n    char search[100], buffer[1024];\r\n    char name[100], category[100], available[100];\r\n    int quantity;\r\n    float price;\r\n    int found = 0; // Flag to track if the item is found\r\n\r\n    if (filepointer == NULL || temporaryfile == NULL) {\r\n        printf(\"Error opening file.\\n\");\r\n        return;\r\n    }\r\n\r\n    getchar(); // Clear leftover newbuffer from previous input\r\n    printf(\"Type product to delete: \"); // Prompt for product to delete\r\n    fgets(search, sizeof(search), stdin);\r\n    search[strcspn(search, \"\\n\")] = 0; // Remove newbuffer\r\n\r\n    while (fgets(buffer, sizeof(buffer), filepointer) != NULL) { // Search for the product in the file\r\n        sscanf(buffer, \"%99[^,],%99[^,],%d,%f,%s\", name, category, &quantity, &price, available);\r\n\r\n        if (strcmp(search, name) == 0) { // Check for a match by name\r\n            found = 1; // Mark as found\r\n            printf(\"Product '%s' deleted successfully.\\n\", name);\r\n            continue; // Skip writing this buffer to the temporary file\r\n        }\r\n\r\n        // Write other buffers to the temporary file\r\n        fprintf(temporaryfile, \"%s,%s,%d,%.2f,%s\\n\", name, category, quantity, price, available);\r\n    }\r\n\r\n    fclose(filepointer); // Close files\r\n    fclose(temporaryfile);\r\n\r\n    if (found) { // Replace the original file with the updated one\r\n        remove(\"Inventory.csv\");\r\n        rename(\"temporaryfile\", \"Inventory.csv\");\r\n    } else {\r\n        printf(\"Product was not found\\n\");\r\n        remove(\"temporaryfile\"); // Remove temp file if no products were found\r\n    }\r\n}\r\n\r\nint main() {\r\n    int choice = 0;\r\n    int loop = 1;\r\n\r\n    while (loop) {\r\n        // Display menu options\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n2. List all grocery items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); // Get user choice\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                add(); // Function to add a grocery item\r\n                break;\r\n\r\n            case 2:\r\n                display(); // Function to display all grocery items\r\n                break;\r\n\r\n            case 3:\r\n                update(); // Function to update groc quantities\r\n                break;\r\n\r\n            case 4:\r\n                delete(); // Function to remove grocery item\r\n                    break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\"); // Exit message\r\n                loop = 0; // Exit the loop\r\n                break;\r\n\r\n            default:\r\n                printf(\"Error, Enter a valid input\\n\"); // Error message for invalid input\r\n        }\r\n    }\r\n}\n/* --- Question3.c --- */\n#include <stdio.h> \r\n#include <string.h> \r\n#include <stdlib.h> \r\n//code runs on cmd\r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student; \r\n \r\nStudent* head = NULL; \r\n \r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    Student* newnode = (Student*)malloc(sizeof(Student)); //allocate memory withmalloc\r\n\r\n    //copying data into the list\r\n    strcpy(newnode->name, name); \r\n    newnode->id = id;\r\n    newnode->grade = grade;\r\n    newnode->next = NULL;\r\n    return newnode;\r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    int i = 1;\r\n    Student* temporaryvar = head; //begin at the head of the linked list\r\n\r\n    if(temporaryvar == NULL){\r\n        printf(\"No students are in the list\\n\"); //if list is empty\r\n        return;\r\n    }\r\n\r\n    while(temporaryvar != NULL){\r\n        printf(\"%d. Name: %s, ID: %d, Grade: %.2f\\n\", i++, temporaryvar->name, temporaryvar->id, temporaryvar->grade); //printing members of the list\r\n        temporaryvar = temporaryvar->next; // go to the next node\r\n    }\r\n} \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n    Student* temporaryvar = head;\r\n    while(temporaryvar != NULL){ \r\n        if(temporaryvar->id == id){ //validate that the search element is the value of the temporary variable\r\n        return temporaryvar; \r\n        }else{\r\n            temporaryvar = temporaryvar->next;\r\n        }\r\n    }\r\n    return NULL;\r\n} \r\n \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; //goto the next element of the list\r\n        free(current); //delete element of the list\r\n        current = next; //make the current element become the next element\r\n    } \r\n    head = NULL; \r\n}\r\n \r\n \r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\n// Function to split the linked list into two halves\r\nStudent* splitList(Student* head) {\r\n    Student* Right = head->next;\r\n    Student* Left = head;\r\n    \r\n\r\n    while (Right != NULL && Right->next != NULL) {\r\n        Left = Left->next;\r\n        Right = Right->next->next;\r\n    }\r\n\r\n    Student* secondHalf = Left->next;\r\n    Left->next = NULL; // Split the list\r\n    return secondHalf;\r\n}\r\n\r\n// Function to merge two sorted lists\r\nStudent* merge(Student* list1, Student* list2) {\r\n    if (list1 == NULL) return list2;\r\n    if (list2 == NULL) return list1;\r\n\r\n    Student* merged = NULL;\r\n\r\n    if (list1->grade <= list2->grade) {\r\n        merged = list1;\r\n        merged->next = merge(list1->next, list2);\r\n    } else {\r\n        merged = list2;\r\n        merged->next = merge(list1, list2->next);\r\n    }\r\n\r\n    return merged;\r\n}\r\n\r\n// Recursive Merge Sort function\r\nStudent* mergeSort(Student* head) {\r\n    if (head == NULL || head->next == NULL) {\r\n        return head; // Base case: 0 or 1 node\r\n    }\r\n\r\n    Student* secondHalf = splitList(head); // Split the list into two halves\r\n    Student* sortedFirstHalf = mergeSort(head); // Sort the first half\r\n    Student* sortedSecondHalf = mergeSort(secondHalf); // Sort the second half\r\n\r\n    return merge(sortedFirstHalf, sortedSecondHalf); // Merge sorted halves\r\n}\r\n\r\n// Sort function for your skeleton\r\nvoid sortStudents() {\r\n    head = mergeSort(head);\r\n    printf(\"Sorted Students Recors\\n\");\r\n}\r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* newnode = createStudent(name, id, grade); // creating a new node\r\n    if (head == NULL) {\r\n        head = newnode; //inserts to the head if head is empty\r\n        return;\r\n    }\r\n    Student* temporaryvar = head;\r\n    while (temporaryvar->next != NULL) { // traverses through the list to find the last node\r\n        temporaryvar = temporaryvar->next;\r\n    }\r\n    temporaryvar->next = newnode; //enters student at end of the list\r\n\r\n} \r\n\r\n \r\n// Main function to drive the program \r\nint main() { \r\n \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (Ascending Order)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents();                 \r\n                break; \r\n            case 4: \r\n                printf(\"Search for ID \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                    found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The mergeSort function implements Merge Sort, which is efficient for linked lists with a time complexity of O(n log n). This is a good choice for sorting student records by grade, especially for larger datasets."
  },
  {
    "student_id": "20577892",
    "code": "\n/* --- Question 2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n#define NOITEMS 50  // Maximum number of items that can be added to the inventory\r\n\r\n// Define the structure for grocery items\r\nstruct grocery_items {\r\n    char name[100];       \r\n\r\n    \r\n    char category[50];    \r\n    int quantity;        \r\n    float price;          \r\n    bool availability;    // Availability status (in stock or out of stock)\r\n};\r\n\r\nint main() {\r\n    int choice; \r\n    struct grocery_items grocery[NOITEMS];  // Array to store grocery items\r\n    int index_counter = 0;  // Counter to track how many items are added\r\n    char search[50];  // Variable to store the name of the item to search or update\r\n    int search_index = 0;  // Index to track the item position for updates\r\n    char remove[50];  // Variable to store the name of the item to remove\r\n\r\n    while (1) {\r\n        // Display the menu\r\n        printf(\"Grocery Inventory Management System\\n\"\r\n               \"1. Add grocery item\\n\"\r\n               \"2. List all grocery items with their availability\\n\"\r\n               \"3. Update the quantity of a grocery item\\n\"\r\n               \"4. Remove a grocery item from the inventory\\n\"\r\n               \"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); \r\n\r\n       \r\n        switch (choice) {\r\n        case 1:\r\n            // Add a new grocery item to the inventory\r\n            printf(\"Enter item Name: \");\r\n            scanf(\" %[^\\n]\", grocery[index_counter].name);  // Input the item's name\r\n\r\n            printf(\"Enter Category: \");\r\n            scanf(\" %[^\\n]\", grocery[index_counter].category);  // Input the item's category\r\n\r\n            printf(\"Enter Quantity: \");\r\n            scanf(\" %d\", &grocery[index_counter].quantity);  // Input the quantity of the item\r\n\r\n            printf(\"Enter Price: \");\r\n            scanf(\"%f\", &grocery[index_counter].price);  // Input the price of the item\r\n\r\n            // Set availability based on the quantity\r\n            grocery[index_counter].availability = (grocery[index_counter].quantity > 0) ? true : false;\r\n\r\n            // If quantity is less than or equal to 0, the item is out of stock\r\n            if (grocery[index_counter].quantity <= 0) {\r\n                grocery[index_counter].availability = false;\r\n            }\r\n\r\n            puts(\"Grocery item added successfully!\");\r\n            index_counter++;  // Increment the item count\r\n            break;\r\n\r\n        case 2:\r\n            // List all the grocery items with their availability status\r\n            if (index_counter == 0) {\r\n                printf(\"No items in the inventory.\\n\");  // If no items are added\r\n            } else {\r\n                // Loop through all items and display their details\r\n                for (int l = 0; l < index_counter; l++) {\r\n                    printf(\"\\nItem %d:\\n\", l + 1);\r\n                    printf(\"Name: %s\\n\", grocery[l].name);\r\n                    printf(\"Category: %s\\n\", grocery[l].category);\r\n                    printf(\"Quantity: %d\\n\", grocery[l].quantity);\r\n                    printf(\"Price: %.2f\\n\", grocery[l].price);\r\n                    printf(\"Availability: %s\\n\", grocery[l].availability ? \"In-stock\" : \"Out-stock\");\r\n                }\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            // Update the quantity of an existing grocery item\r\n            printf(\"Enter name of the grocery item to update quantity: \");\r\n            scanf(\" %[^\\n]\", search);  // Input the item name to search for\r\n\r\n            // Search for the item in the inventory\r\n            for (size_t s = 0; s < index_counter; s++) {\r\n                if (strcmp(search, grocery[s].name) == 0) {\r\n                    search_index = s;  // Item found, store its index\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If the item was found, update its quantity\r\n            if (search_index >= 0) {\r\n                printf(\"Enter new quantity for %s: \", search);  // Prompt for the new quantity\r\n                scanf(\"%d\", &grocery[search_index].quantity);  // Update the quantity\r\n                puts(\"Quantity updated successfully!\");\r\n\r\n                // Update availability based on the new quantity\r\n                if (grocery[search_index].quantity <= 0) {\r\n                    grocery[search_index].availability = false;  // Mark item as out of stock if quantity is 0 or less\r\n                }\r\n            } else {\r\n                printf(\"Item not found.\\n\");  // If item is not found, notify the user\r\n            }\r\n            break;\r\n\r\n        case 4:\r\n            // Remove a grocery item from the inventory\r\n            printf(\"Enter name of the grocery item to remove: \");\r\n            scanf(\" %[^\\n]\", remove);  // Input the item name to remove\r\n\r\n            int remove_index = -1;  // Variable to store the index of the item to remove\r\n\r\n            // Search for the item to remove\r\n            for (int r = 0; r < index_counter; r++) {\r\n                if (strcmp(remove, grocery[r].name) == 0) {\r\n                    remove_index = r;  // Item found, store its index\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If the item is found, remove it by shifting the remaining items to the left\r\n            if (remove_index == -1) {\r\n                printf(\"Item not found.\\n\");  // if Item not found, show an error\r\n            } else {\r\n                // Shift the items to the left to fill the gap\r\n                for (int i = remove_index; i < index_counter - 1; i++) {\r\n                    grocery[i] = grocery[i + 1];\r\n                }\r\n                index_counter--;  // Decrease the item count\r\n                printf(\"Grocery item '%s' removed successfully!\\n\", remove);\r\n            }\r\n            break;\r\n\r\n        case 5:\r\n            // Exit the program\r\n            printf(\"Exiting...\\n\");\r\n            return 0;\r\n\r\n        default:\r\n            // For invalid menu choice\r\n            printf(\"Error: Invalid choice!\\n\");\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\n/* --- Question one.c --- */\n#include <stdio.h>\r\n\r\n// Function to add two matrices (A and B), storing the result in the sum matrix\r\nvoid addMatrices(int A_rows, int A_columns, int a[A_rows][A_columns], int b[A_rows][A_columns], int sum[A_rows][A_columns]) {\r\n    // Iterate through each element and add the corresponding elements from A and B\r\n    for (int i = 0; i < A_rows; ++i)\r\n        for (int j = 0; j < A_columns; ++j) {\r\n            sum[i][j] = a[i][j] + b[i][j];  \r\n        }\r\n}\r\n\r\n// Function to subtract matrix B from matrix A, storing the result in the subtraction matrix\r\nvoid subtractMatrices(int A_rows, int A_columns, int a[A_rows][A_columns], int b[A_rows][A_columns], int subtraction[A_rows][A_columns]) {\r\n    // Iterate through each element and subtract the corresponding elements of B from A\r\n    for (int i = 0; i < A_rows; ++i)\r\n        for (int j = 0; j < A_columns; ++j) {\r\n            subtraction[i][j] = a[i][j] - b[i][j];  \r\n        }\r\n}\r\n\r\n// Function to calculate the transpose of matrix A, storing the result in the transpose_result matrix\r\nvoid transposeMatrix(int A_rows, int A_columns, int a[A_rows][A_columns], int transpose_result[A_columns][A_rows]) {\r\n    // Iterate through each element and swap rows with columns for transposition\r\n    for (int i = 0; i < A_rows; ++i)\r\n        for (int j = 0; j < A_columns; ++j) {\r\n            transpose_result[j][i] = a[i][j];  // Swap A[i][j] to transpose_result[j][i]\r\n        }\r\n}\r\n\r\n// Function to display any matrix of given rows and columns\r\nvoid displayMatrix(int rows, int columns, int matrix[rows][columns]) {\r\n    // Print each element of the matrix row by row\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < columns; ++j) {\r\n            printf(\"%d \", matrix[i][j]);  \r\n        }\r\n        printf(\"\\n\");  // Print a new line after each row\r\n    }\r\n}\r\n\r\nint main() {\r\n    int A_rows, A_columns;  // Declare variables for the dimensions of Matrix A\r\n    int a[100][100], b[100][100], sum[100][100], subtraction[100][100], i, j;\r\n    int B_rows, B_columns;  // Declare variables for the dimensions of Matrix B\r\n    int choice;  \r\n    int transpose_result[100][100];  \r\n\r\n    // Start of the program: user inputs for Matrix A\r\n    start:\r\n    printf(\"Enter rows and columns for Matrix A (between 1 and 10): \");\r\n    scanf(\"%d %d\", &A_rows, &A_columns);  // User inputs rows and columns for Matrix A\r\n\r\n    // Input values for Matrix A\r\n    for (i = 0; i < A_rows; ++i)\r\n        for (j = 0; j < A_columns; ++j) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);  \r\n            scanf(\"%d\", &a[i][j]);  \r\n        }\r\n\r\n    // user inputs for Matrix B\r\n    printf(\"Enter rows and columns for Matrix B (between 1 and 10): \");\r\n    scanf(\"%d %d\", &B_rows, &B_columns);  // User inputs rows and columns for Matrix B\r\n\r\n    // Input values for Matrix B\r\n    for (i = 0; i < B_rows; ++i)\r\n        for (j = 0; j < B_columns; ++j) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);  // Prompt user for each element\r\n            scanf(\"%d\", &b[i][j]);  \r\n        }\r\n\r\n\r\n    while (1) {\r\n        printf(\"\\nMatrix Operations Menu:\\n\"\r\n               \"1. Add Matrices\\n\"\r\n               \"2. Subtract Matrices\\n\"\r\n               \"3. Transpose Matrix A\\n\"\r\n               \"4. Transpose Matrix B\\n\"\r\n               \"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);  // User selects an operation\r\n\r\n        // Handle the menu\r\n        switch (choice) {\r\n        case 1:\r\n            // Adding two matrices (A + B)\r\n            if (A_rows == B_rows && A_columns == B_columns) {  // Check if matrices have the same dimensions\r\n                addMatrices(A_rows, A_columns, a, b, sum);  // Call the addMatrices function\r\n                printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n                displayMatrix(A_rows, A_columns, sum);  // Display the result of addition\r\n            } else {\r\n                printf(\"Error: Can't perform operation! Matrices dimensions are not equal.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            // Subtracting two matrices (A - B)\r\n            if (A_rows == B_rows && A_columns == B_columns) {  // Check if matrices have the same dimensions\r\n                subtractMatrices(A_rows, A_columns, a, b, subtraction);  // Call the subtractMatrices function\r\n                printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n                displayMatrix(A_rows, A_columns, subtraction);  // Display the result of subtraction\r\n            } else {\r\n                printf(\"Error: Can't perform operation! Matrices dimensions are not equal.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            // Transposing Matrix A\r\n            transposeMatrix(A_rows, A_columns, a, transpose_result);  // Call the transposeMatrix function for Matrix A\r\n            printf(\"\\nTranspose of Matrix A:\\n\");\r\n            displayMatrix(A_columns, A_rows, transpose_result);  // Display the transpose of Matrix A\r\n            break;\r\n\r\n        case 4:\r\n            // Transposing Matrix B\r\n            transposeMatrix(B_rows, B_columns, b, transpose_result);  // Call the transposeMatrix function for Matrix B\r\n            printf(\"\\nTranspose of Matrix B:\\n\");\r\n            displayMatrix(B_columns, B_rows, transpose_result);  // Display the transpose of Matrix B\r\n            break;\r\n\r\n        case 5:\r\n            // Exit the program\r\n            printf(\"Exiting...\\n\");\r\n            return 0;\r\n\r\n        default:\r\n            // For invalid choices\r\n            printf(\"Error: Invalid choice!\\n\");\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- Question three.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    \r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;  // Not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Utility function to free memory when program exits\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort student records by grade using Bubble Sort because its simple\r\nvoid sortStudents() {\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* ptr2 = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n        while (ptr1->next != ptr2) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the data\r\n                float tempGrade = ptr1->grade;\r\n                int tempID = ptr1->id;\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n\r\n\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempID;\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        ptr2 = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                        found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2- The variable search_index is initialized to 0 but is not set to a valid index if the item is not found. This can lead to incorrect behavior when checking if the item was found. Instead, it should be initialized to -1 or -1 should be used as a flag to indicate that the item was not found.\nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20611251",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE) {\r\n        printf(\"Error: Matrix size exceeds the maximum allowed size (%dx%d).\\n\", MAX_SIZE, MAX_SIZE);\r\n        return 1;\r\n    }\r\n\r\n    printf(\"\\nEnter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA, 'A');\r\n\r\n    //Matrix B\r\n    printf(\"\\nEnter dimensions for Matrix B (rows columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsB > MAX_SIZE || colsB > MAX_SIZE) {\r\n        printf(\"Error: Matrix size exceeds the maximum allowed size (%dx%d).\\n\", MAX_SIZE, MAX_SIZE);\r\n        return 1;\r\n    }\r\n\r\n    printf(\"\\nEnter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB, 'B');\r\n\r\n    //Operations\r\n    while (1) {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"\\nResult of Addition:\\n\");\r\n                    addMatrices(A, B, rowsA, colsA);\r\n                } else {\r\n                    printf(\"\\nError: Dimensions of A and B do not match for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    printf(\"\\nResult of Subtraction:\\n\");\r\n                    subtractMatrices(A, B, rowsA, colsA);\r\n                } else {\r\n                    printf(\"\\nError: Dimensions of A and B do not match for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                transposeMatrix(A, rowsA, colsA);\r\n                break;\r\n            case 4:\r\n                printf(\"\\nTranspose of Matrix B:\\n\");\r\n                transposeMatrix(B, rowsB, colsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"\\nInvalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element %c[%d][%d]: \", name, i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n\r\n    printMatrix(result, rows, cols);\r\n}\r\n\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n\r\n    printMatrix(result, rows, cols);\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int transpose[MAX_SIZE][MAX_SIZE];\r\n\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transpose[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n\r\n    printMatrix(transpose, cols, rows);\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} StockStatus;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    StockStatus stockStatus[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\nvoid addItem(GroceryInventory *inventory);\r\nvoid listItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .count = 0 };\r\n    int choice;\r\n\r\n    while (1) {\r\n        printf(\"\\nGrocery Inventory Management System:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); //remove newline\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->count];\r\n    StockStatus *status = &inventory->stockStatus[inventory->count];\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = !status->inStock;\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listItems(const GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        const StockStatus *status = &inventory->stockStatus[i];\r\n\r\n        printf(\"\\nName: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter the item name to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            GroceryItem *item = &inventory->items[i];\r\n            StockStatus *status = &inventory->stockStatus[i];\r\n\r\n            printf(\"Enter new quantity for %s: \", item->name);\r\n            scanf(\"%d\", &item->quantity);\r\n\r\n            status->inStock = item->quantity > 0;\r\n            status->outOfStock = !status->inStock;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item with name '%s' not found.\\n\", name);\r\n}\r\n\r\nvoid removeItem(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter the item name to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->stockStatus[j] = inventory->stockStatus[j + 1];\r\n            }\r\n\r\n            inventory->count--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item with name '%s' not found.\\n\", name);\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added.\\n\");\r\n}\r\n\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    printf(\"-----------------------------------\\n\");\r\n    while (current) {\r\n        printf(\"Name: %s ID: %d Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records deleted.\\n\");\r\n}\r\n\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student *ptr1, *lptr = NULL;\r\n\r\n    while (1) {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempID = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempID;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n\r\n        if (!swapped) break;\r\n    }\r\n\r\n    printf(\"Records sorted using Bubble Sort.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    while (1) {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20673433",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n// Function to add two matrices\nvoid addMatrices(int m1[10][10], int m2[10][10], int result[10][10], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = m1[i][j] + m2[i][j];\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int m1[10][10], int m2[10][10], int result[10][10], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = m1[i][j] - m2[i][j];\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix(int matrix[10][10], int transposed[10][10], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\n// Function to display a matrix\nvoid displayMatrix(int matrix[10][10], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int m1[10][10], m2[10][10], result[10][10], transposed[10][10];\n    int rows, cols, choice;\n\n    printf(\"Enter the number of rows of the matrices: \");\n    scanf(\"%d\", &rows);\n    printf(\"Enter the number of columns of the matrices: \");\n    scanf(\"%d\", &cols);\n\n    printf(\"Enter the elements of the first matrix:\\n\");\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &m1[i][j]);\n        }\n    }\n\n    printf(\"Enter the elements of the second matrix:\\n\");\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &m2[i][j]);\n        }\n    }\n\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose First Matrix\\n\");\n        printf(\"4. Transpose Second Matrix\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                addMatrices(m1, m2, result, rows, cols);\n                printf(\"Result of Addition:\\n\");\n                displayMatrix(result, rows, cols);\n                break;\n            case 2:\n                subtractMatrices(m1, m2, result, rows, cols);\n                printf(\"Result of Subtraction:\\n\");\n                displayMatrix(result, rows, cols);\n                break;\n            case 3:\n                transposeMatrix(m1, transposed, rows, cols);\n                printf(\"Transpose of First Matrix:\\n\");\n                displayMatrix(transposed, cols, rows);\n                break;\n            case 4:\n                transposeMatrix(m2, transposed, rows, cols);\n                printf(\"Transpose of Second Matrix:\\n\");\n                displayMatrix(transposed, cols, rows);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define NAME_LEN 25\n\nstruct Part {\n    int number;\n    char name[NAME_LEN + 1];\n    int quantity;\n    float price;\n    struct Part *next;\n};\n\n// Function prototypes\nvoid add_part(struct Part **stock);\nstruct Part *find_part(struct Part *stock, int number);\nvoid search_part(struct Part *stock);\nvoid update_quantity(struct Part *stock);\nvoid display_inventory(struct Part *stock);\nvoid delete_part(struct Part **stock);\nvoid clear_stock(struct Part *stock);\nvoid clear_input_buffer();\n\nint main() {\n    struct Part *stock = NULL;\n\n    int choice;\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Grocery items \\n\");\n        printf(\"2. Search for an items\\n\");\n        printf(\"3. Update quantity\\n\");\n        printf(\"4. Display items\\n\");\n        printf(\"5. Delete an item\\n\");\n        printf(\"6. Quit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        clear_input_buffer();\n\n        switch (choice) {\n            case 1:\n                add_part(&stock);\n                break;\n            case 2:\n                search_part(stock);\n                break;\n            case 3:\n                update_quantity(stock);\n                break;\n            case 4:\n                display_inventory(stock);\n                break;\n            case 5:\n                delete_part(&stock);\n                break;\n            case 6:\n                printf(\"Exiting program...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    // Free memory allocated for stock\n    clear_stock(stock);\n\n    return 0;\n}\n\nvoid add_part(struct Part **stock) {\n    struct Part *new_part = (struct Part *)malloc(sizeof(struct Part));\n    if (new_part == NULL) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n\n    printf(\"Enter Grocery Number: \");\n    if (scanf(\"%d\", &new_part->number) != 1) {\n        printf(\"Invalid input for grocery number. Please try again.\\n\");\n        free(new_part);\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    // Check if part number already exists\n    if (find_part(*stock, new_part->number) != NULL) {\n        printf(\"Grocery Number already exists. Try again.\\n\");\n        free(new_part);\n        return;\n    }\n\n    printf(\"Enter grocery name: \");\n    if (scanf(\"%s\", new_part->name) != 1) {\n        printf(\"Invalid input for grocery name. Please try again.\\n\");\n        free(new_part);\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    printf(\"Enter initial quantity: \");\n    if (scanf(\"%d\", &new_part->quantity) != 1) {\n        printf(\"Invalid input for quantity. Please try again.\\n\");\n        free(new_part);\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    printf(\"Enter the price: \");\n    if (scanf(\"%f\", &new_part->price) != 1) {\n        printf(\"Invalid input for price. Please try again.\\n\");\n        free(new_part);\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    // Insert the new part into the linked list while maintaining sorted order\n    struct Part *current = *stock;\n    struct Part *previous = NULL;\n    while (current != NULL && current->number < new_part->number) {\n        previous = current;\n        current = current->next;\n    }\n\n    if (previous == NULL) {\n        new_part->next = *stock;\n        *stock = new_part;\n    } else {\n        previous->next = new_part;\n        new_part->next = current;\n    }\n\n    printf(\"Items added successfully.\\n\");\n}\n\nstruct Part *find_part(struct Part *stock, int number) {\n    struct Part *current = stock;\n    while (current != NULL && current->number != number) {\n        current = current->next;\n    }\n    return current;\n}\n\nvoid search_part(struct Part *stock) {\n    int number;\n    printf(\"Enter grocery number to search: \");\n    if (scanf(\"%d\", &number) != 1) {\n        printf(\"Invalid input for grocery number. Please try again.\\n\");\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    struct Part *part = find_part(stock, number);\n    if (part == NULL) {\n        printf(\"Grocery not found.\\n\");\n    } else {\n        printf(\"Grocery Name: %s\\n\", part->name);\n        printf(\"Quantity: %d\\n\", part->quantity);\n        printf(\"Price: %.2f\\n\", part->price);\n    }\n}\n\nvoid update_quantity(struct Part *stock) {\n    int number;\n    printf(\"Enter grocery number to update quantity: \");\n    if (scanf(\"%d\", &number) != 1) {\n        printf(\"Invalid input for grocery number. Please try again.\\n\");\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    struct Part *part = find_part(stock, number);\n    if (part == NULL) {\n        printf(\"Grocery not found.\\n\");\n        return;\n    }\n\n    int quantity;\n    printf(\"Enter new quantity: \");\n    if (scanf(\"%d\", &quantity) != 1) {\n        printf(\"Invalid input for quantity. Please try again.\\n\");\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    part->quantity = quantity;\n    printf(\"Quantity updated successfully.\\n\");\n}\n\nvoid display_inventory(struct Part *stock) {\n    printf(\"\\nInventory:\\n\");\n    printf(\"Grocery Number\\tGrocery Name\\tQuantity\\tPrice\\n\");\n    printf(\"-------------------------------------------------------\\n\");\n\n    struct Part *current = stock;\n    while (current != NULL) {\n        printf(\"%d\\t\\t%s\\t\\t%d\\t\\t%.2f\\n\", current->number, current->name, current->quantity, current->price);\n        current = current->next;\n    }\n}\n\nvoid delete_part(struct Part **stock) {\n    int number;\n    printf(\"Enter grocery number to delete: \");\n    if (scanf(\"%d\", &number) != 1) {\n        printf(\"Invalid input for grocery number. Please try again.\\n\");\n        clear_input_buffer();\n        return;\n    }\n    clear_input_buffer();\n\n    struct Part *current = *stock;\n    struct Part *previous = NULL;\n\n    while (current != NULL && current->number != number) {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL) {\n        printf(\"Grocery not found.\\n\");\n        return;\n    }\n\n    if (previous == NULL) {\n        *stock = current->next;\n    } else {\n        previous->next = current->next;\n    }\n\n    free(current);\n    printf(\"Grocery deleted successfully.\\n\");\n}\n\nvoid clear_stock(struct Part *stock) {\n    struct Part *temp;\n    while (stock != NULL) {\n        temp = stock;\n        stock = stock->next;\n        free(temp);\n    }\n}\n\nvoid clear_input_buffer() {\n    int c;\n    while ((c = getchar()) != '\\n' && c != EOF);\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    if (head == NULL) {\n        head = newStudent;\n    } else {\n        Student* current = head;\n        while (current->next != NULL) {\n            current = current->next;\n        }\n        current->next = newStudent;\n    }\n    printf(\"Student added successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"The list is empty.\\n\");\n        return;\n    }\n    Student* current = head;\n    printf(\"\\nStudents in the list:\\n\");\n    printf(\"ID\\tName\\t\\tGrade\\n\");\n    printf(\"----------------------------------\\n\");\n    while (current != NULL) {\n        printf(\"%d\\t%s\\t\\t%.2f\\n\", current->id, current->name, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to sort the student records by grade in ascending order\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        printf(\"No need to sort, the list is empty or has only one student.\\n\");\n        return;\n    }\n\n    Student* i;\n    Student* j;\n    for (i = head; i->next != NULL; i = i->next) {\n        for (j = i->next; j != NULL; j = j->next) {\n            if (i->grade > j->grade) {\n                // Swap the data\n                char tempName[100];\n                int tempId;\n                float tempGrade;\n\n                strcpy(tempName, i->name);\n                tempId = i->id;\n                tempGrade = i->grade;\n\n                strcpy(i->name, j->name);\n                i->id = j->id;\n                i->grade = j->grade;\n\n                strcpy(j->name, tempName);\n                j->id = tempId;\n                j->grade = tempGrade;\n            }\n        }\n    }\n    printf(\"Students sorted by grade successfully!\\n\");\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    while (current != NULL) {\n        Student* temp = current;\n        current = current->next;\n        free(temp);\n    }\n    head = NULL;\n    printf(\"List deleted successfully.\\n\");\n}\n\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\"); // Remove newline character\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"\\nFound: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                break;\n            case 6:\n                deleteList();\n                printf(\"Exiting program...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is used to sort student records by grade. While it works correctly for this purpose, Bubble Sort has a time complexity of O(n?), which can lead to inefficiencies with larger datasets. For better performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20724197",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// Declare prototype function\r\nvoid showMenu();\r\nint inputMatrixA(float matrix[50][50], int *row, int *column);\r\nint inputMatrixB(float matrix[50][50], int *row, int *column);\r\nvoid addMatrices(float matrixA[50][50], int *row, int *column, float matrixB[50][50], float sum[50][50]);\r\nvoid substractMatrices(float matrixA[50][50], int *row, int *column, float matrixB[50][50], float sub[50][50]);\r\nvoid transposeMatrixA(float matrix[50][50], int *row, int *column, float transpose[50][50]);\r\nvoid transposeMatrixB(float matrix[50][50], int *row, int *column, float transpose[50][50]);\r\n\r\nint main()\r\n{\r\n  // decalre global variables\r\n    int rowA, columnA, rowB, columnB;\r\n    float a[50][50], b[50][50], result[50][50], transposeA[50][50], transposeB[50][50];\r\n\r\n    while(1){\r\n        int validateA=inputMatrixA(a, &rowA, &columnA);\r\n        if(validateA!=1){\r\n            break;\r\n        }\r\n    }\r\n\r\n    while(1){\r\n        int validateB=inputMatrixB(b, &rowB, &columnB);\r\n        if(validateB!=1 && rowA == rowB && columnA == columnB){\r\n            break;\r\n        } \r\n         else {\r\n            printf(\"Error: Matrices must have the same dimensions for addition and subtraction.\\n\");\r\n        }\r\n    }\r\n\r\n  while(1){\r\n    showMenu();\r\n\r\n    int decision;\r\n\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &decision);\r\n    getchar();\r\n\r\n    // all main function going here\r\n    switch (decision)\r\n    {\r\n    case 1: \r\n      addMatrices(a, &rowA, &columnA, b, result);\r\n      break;\r\n    case 2:\r\n      substractMatrices(a, &rowA, &columnA, b, result);\r\n      break;\r\n    case 3: \r\n      transposeMatrixA(a, &rowA, &columnA, transposeA);\r\n      break;\r\n    case 4: \r\n      transposeMatrixB(b, &rowB, &columnB, transposeB);\r\n      break;\r\n    case 5: \r\n      printf(\"Exiting...\\n\");\r\n      exit(0);\r\n    default:\r\n      printf(\"Invalid choice. \\n\");\r\n      printf(\"Please enter a number between 1 to 5...\\n\");\r\n      break;\r\n    }\r\n  }\r\n    return 0;\r\n}\r\n\r\n// Landing page\r\nvoid showMenu()\r\n{\r\n  printf(\"\\nMatrix Operations Menu:\\n\");\r\n  printf(\"1. Add Matrices\\n\");\r\n  printf(\"2. Substract Matrices\\n\");\r\n  printf(\"3. Transpose Matrix A\\n\");\r\n  printf(\"4. Transpose Matrix B\\n\");\r\n  printf(\"5. Exit\\n\");\r\n}\r\n\r\nint inputMatrixA(float matrix[50][50], int *row, int *column){\r\n\r\n    printf(\"\\nEnter dimensions for Matrix A (rows and columns): \");\r\n    scanf (\"%d %d\", row, column);\r\n\r\n    // validate the inputs\r\n    if(*row<=0 || *column<=0){\r\n        printf(\"Invalid inputs for dimensions !\\n\");\r\n        return 1;\r\n    }\r\n\r\n  // taking input using nested for loop\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < *row; ++i)\r\n     for (int j = 0; j < *column; ++j)\r\n    {\r\n      printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n      scanf(\"%f\", &matrix[i][j]);\r\n    }\r\n    return 0;\r\n}\r\n\r\nint inputMatrixB(float matrix[50][50], int *row, int *column){\r\n\r\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\r\n    scanf (\"%d %d\", row, column);\r\n\r\n    // validate the inputs\r\n    if(*row<=0 || *column<=0){\r\n        printf(\"Invalid inputs for dimensions !\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // taking input using nested for loop\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < *row; ++i)\r\n     for (int j = 0; j < *column; ++j)\r\n    {\r\n      printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n      scanf(\"%f\", &matrix[i][j]);\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid addMatrices(float matrixA[50][50], int *row, int *column, float matrixB[50][50], float sum[50][50]){\r\n    for (int i = 0; i < *row; ++i)\r\n    for (int j = 0; j < *column; ++j)\r\n    {\r\n      sum[i][j] = matrixA[i][j] + matrixB[i][j];\r\n    }\r\n\r\n  // Displaying the sum\r\n    printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n\r\n   for (int i = 0; i < *row; ++i){\r\n    for (int j = 0; j < *column; ++j)\r\n    {\r\n      printf(\"%.1f\\t\", sum[i][j]);\r\n    }\r\n     printf(\"\\n\");\r\n   }\r\n}\r\n\r\nvoid substractMatrices(float matrixA[50][50], int *row, int *column, float matrixB[50][50], float sub[50][50]){\r\n    for (int i = 0; i < *row; ++i)\r\n     for (int j = 0; j < *column; ++j)\r\n    {\r\n      sub[i][j] = matrixA[i][j] - matrixB[i][j];\r\n    }\r\n\r\n  // Displaying the substract\r\n    printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n\r\n   for (int i = 0; i < *row; ++i){\r\n    for (int j = 0; j < *column; ++j)\r\n    {\r\n      printf(\"%.1f\\t\", sub[i][j]);\r\n    }\r\n     printf(\"\\n\");\r\n   }\r\n}\r\n\r\nvoid transposeMatrixA(float matrix[50][50], int *row, int *column, float transpose[50][50]){\r\n    \r\n    // computing the transpose for matrix A\r\n  for (int i = 0; i < *row; ++i)\r\n  for (int j = 0; j < *column; ++j) {\r\n    transpose[j][i] = matrix[i][j];\r\n  }\r\n\r\n  // printing the transpose\r\n  printf(\"\\nTranspose of the matrix A:\\n\");\r\n  for (int i = 0; i < *column; ++i){\r\n  for (int j = 0; j < *row; ++j) {\r\n    printf(\"%.1f\\t \", transpose[i][j]);\r\n  }\r\n     printf(\"\\n\");\r\n  }\r\n}\r\n\r\nvoid transposeMatrixB(float matrix[50][50], int *row, int *column, float transpose[50][50]){\r\n    \r\n    // computing the transpose for matrix B\r\n  for (int i = 0; i < *row; ++i)\r\n  for (int j = 0; j < *column; ++j) {\r\n    transpose[j][i] = matrix[i][j];\r\n  }\r\n\r\n  // printing the transpose\r\n  printf(\"\\nTranspose of the matrix B:\\n\");\r\n  for (int i = 0; i < *column; ++i){\r\n  for (int j = 0; j < *row; ++j) {\r\n    printf(\"%.1f\\t \", transpose[i][j]);\r\n  }\r\n     printf(\"\\n\");\r\n  }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_LENGTH_NAME 100\r\n#define MAX_LENGTH_CATEGORY 50\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[MAX_LENGTH_NAME];\r\n    char category[MAX_LENGTH_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n} Item;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} Status;\r\n\r\nItem itemList[MAX_ITEMS];\r\nStatus statusList[MAX_ITEMS]; \r\nint itemCount = 0; // to track the number of items in list\r\n\r\n// Declare prototypes function\r\nvoid addItem();\r\nvoid listItem();\r\nvoid updateStatus(int count);\r\nvoid updateQuantity();\r\nvoid removeItem();\r\nvoid showMenu();\r\n\r\n// main Function\r\nint main() {\r\n    int decision;\r\n\r\n  while (1)\r\n  {\r\n    showMenu();\r\n\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &decision);\r\n    getchar();\r\n\r\n    switch (decision)\r\n    {\r\n    case 1: // Add\r\n      addItem();\r\n     \r\n      break;\r\n    case 2: // Display\r\n      listItem();\r\n      break;\r\n    case 3: // Edit\r\n      updateQuantity();\r\n      break;\r\n    case 4: // Delete\r\n      removeItem();\r\n      break;\r\n    case 5: \r\n      printf(\"Exiting...\");\r\n      exit(0);\r\n    default:\r\n      printf(\"Invalid choice. \\n\");\r\n      break;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid showMenu(){\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n// Add an Item to the Inventory\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Maximum number of items had stored in inventory !\\n\");\r\n        return;\r\n    }\r\n\r\n    // prompt user inputs\r\n    printf(\"Enter Item Name: \");\r\n    fgets(itemList[itemCount].name, sizeof(itemList[itemCount].name), stdin);\r\n    itemList[itemCount].name[strcspn(itemList[itemCount].name, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(itemList[itemCount].category, sizeof(itemList[itemCount].category), stdin);\r\n    itemList[itemCount].category[strcspn(itemList[itemCount].category, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &itemList[itemCount].quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &itemList[itemCount].price);\r\n    getchar(); \r\n\r\n    updateStatus(itemCount);\r\n\r\n    itemCount++; // increment item count\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// update status based on quantity\r\nvoid updateStatus(int count){\r\n    if (itemList[count].quantity > 0) {\r\n        statusList[count].inStock = true;\r\n        statusList[count].outOfStock = false;\r\n    } else {\r\n        statusList[count].inStock = false;\r\n        statusList[count].outOfStock = true;\r\n    }\r\n}\r\n\r\n// Diaplay all items in the inventory\r\nvoid listItem() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery item found.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n\r\n        printf(\"Name: %s\\n\", itemList[i].name);\r\n        printf(\"Category: %s\\n\", itemList[i].category);\r\n        printf(\"Quantity: %d\\n\", itemList[i].quantity);\r\n        printf(\"Price: %.2f\\n\", itemList[i].price);\r\n\r\n        if(statusList[i].inStock){\r\n            printf(\"Status: In Stock\\n\");\r\n        }else\r\n        {    printf(\"Status: Out of Stock\\n\");\r\n            }  \r\n\r\n     printf(\"\\n\"); \r\n    }\r\n}\r\n\r\n// Update the quantity of item\r\nvoid updateQuantity(){\r\n\r\n    char updateName[MAX_LENGTH_NAME];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(updateName, sizeof(updateName), stdin);\r\n    updateName[strcspn(updateName, \"\\n\")] = '\\0'; // remove newline\r\n    \r\n    int indices=-1; // to track if item is found\r\n    for(int i=0; i<itemCount; i++){\r\n\r\n        if(strcmp(itemList[i].name, updateName)==0){\r\n            indices=i;\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (indices == -1) {\r\n        printf(\"No grocery item found with the name '%s'.\\n\", updateName);\r\n        return;\r\n    }\r\n\r\n    int newQuantity;\r\n    printf(\"Enter new quantity for %s: \", updateName);\r\n    scanf(\"%d\", &newQuantity);\r\n    getchar();\r\n\r\n    itemList[indices].quantity=newQuantity;\r\n    updateStatus(indices);\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n   \r\n}\r\n\r\n// remove item\r\nvoid removeItem(){\r\n\r\n    char deletedItem[MAX_LENGTH_NAME];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(deletedItem, sizeof(deletedItem), stdin);\r\n    deletedItem[strcspn(deletedItem, \"\\n\")] = '\\0'; \r\n\r\n    int indices=-1;\r\n    for(int i=0; i<itemCount; i++){\r\n       \r\n        if(strcmp(itemList[i].name, deletedItem)==0){\r\n            indices=i;\r\n            break;\r\n        }\r\n    }\r\n\r\n     if (indices == -1) {\r\n        printf(\"No grocery item found with the name '%s'.\\n\", deletedItem);\r\n        return;\r\n     }\r\n\r\n     for (int i = indices; i < itemCount - 1; i++) {\r\n            itemList[i] = itemList[i + 1];\r\n        }\r\n\r\n    printf(\"Grocery item '%s' removed successfully!\\n\", deletedItem);\r\n\r\n        // decrease the array size\r\n        itemCount--;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n char name[100];\r\n int id;\r\n float grade;\r\n struct Student* next;\r\n} Student;\r\nStudent* head = NULL;\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n// Write your code (1 mark)\r\n}\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n// Write your code (1 mark)\r\n}\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n // Write your code (1 mark)\r\n}\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n // Write your code (1 mark)\r\n}\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n Student* current = head;\r\n Student* next;\r\n while (current != NULL) {\r\n next = current->next;\r\n free(current);\r\n current = next;\r\n }\r\n head = NULL;\r\n}\r\nvoid freeMemory() {\r\n deleteList();\r\n}\r\n// Sort function to sort the student records by grade based on an\r\nalgorithm of your choice\r\nvoid sortStudents() {\r\n// Write your code (1 mark)\r\n}\r\n// Main function to drive the program\r\nint main() {\r\n int choice, id;\r\n char name[100];\r\n float grade;\r\n do {\r\n printf(\"\\n1. Insert Student Record\\n\");\r\n printf(\"2. Display Student Records\\n\");\r\n printf(\"3. Sort Records (choose sorting method)\\n\");\r\n printf(\"4. Search Record by ID\\n\");\r\n printf(\"5. Delete List\\n\");\r\n printf(\"6. Exit\\n\");\r\n printf(\"Enter your choice: \");\r\n scanf(\"%d\", &choice);\r\n getchar(); // To consume the newline character\r\n switch (choice) {\r\n case 1:\r\n printf(\"Enter Name: \");\r\n fgets(name, sizeof(name), stdin);\r\n strtok(name, \"\\n\");\r\n printf(\"Enter ID: \");\r\n scanf(\"%d\", &id);\r\n printf(\"Enter Grade: \");\r\n scanf(\"%f\", &grade);\r\n insertStudent(name, id, grade);\r\n break;\r\n case 2:\r\n displayStudents();\r\n break;\r\n case 3:\r\n sortStudents();\r\n break;\r\n case 4:\r\n printf(\"Enter ID to search: \");\r\n scanf(\"%d\", &id);\r\n Student* found = searchStudentByID(id); \r\n if (found) {\r\n printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\nfound->name, found->id, found->grade);\r\n } else {\r\n printf(\"Student not found.\\n\");\r\n }\r\n break;\r\n case 5:\r\n deleteList();\r\n printf(\"List deleted.\\n\");\r\n break;\r\n case 6:\r\n freeMemory();\r\n printf(\"Exiting...\\n\");\r\n break;\r\n default:\r\n printf(\"Invalid choice! Please try again.\\n\");\r\n }\r\n } while (choice != 6);\r\n return 0;\r\n}\r\n\r\n\r\n",
    "feedback": "q1-The condition in the second while loop for inputting Matrix B incorrectly combines validation of matrix dimensions with the input validation. As a result, it may exit the loop prematurely without ensuring that both matrices have been validated for dimensions. To improve, ensure that the validation for Matrix B's dimensions is correctly separated from the input validation. This will prevent the loop from exiting prematurely and ensure that the user is prompted for valid matrix dimensions appropriately. \nq2-    Ensure the status of items is updated correctly after modifying quantities, especially when items go out of stock.  Consider adding more validation for user input, especially for quantity and price, to prevent invalid values (like negative numbers).\nq3-all key functions are not implemented"
  },
  {
    "student_id": "20721435",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// Function prototypes\r\nvoid matrixInput(int *rowsA, int *columnsA, int *rowsB, int *columnsB, int matrixA[10][10], int matrixB[10][10]);\r\nvoid menu(int *rowsA, int *columnsA, int *rowsB, int *columnsB, int matrixA[10][10], int matrixB[10][10]);\r\nvoid selection(int choice, int *rowsA, int *columnsA, int *rowsB, int *columnsB, int matrixA[10][10], int matrixB[10][10]);\r\nvoid addMatrices(int rowsA, int columnsA, int rowsB, int columnsB, int matrixA[10][10], int matrixB[10][10]);\r\nvoid subtractMatrices(int rowsA, int columnsA, int rowsB, int columnsB, int matrixA[10][10], int matrixB[10][10]);\r\nvoid transposeMatrixA(int rows, int columns, int matrix[10][10]);\r\nvoid transposeMatrixB(int rows, int columns, int matrix[10][10]);\r\nvoid exitProgram();\r\n\r\n// Main function\r\nint main() {\r\n    // Variables to store dimensions of matrices\r\n    int rowsA, columnsA, rowsB, columnsB;\r\n    // Arrays to store matrices\r\n    int matrixA[10][10], matrixB[10][10];\r\n    \r\n    matrixInput(&rowsA, &columnsA, &rowsB, &columnsB, matrixA, matrixB);\r\n    while (1) {\r\n        menu(&rowsA, &columnsA, &rowsB, &columnsB, matrixA, matrixB);\r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n// Function to input matrices\r\nvoid matrixInput(int *rowsA, int *columnsA, int *rowsB, int *columnsB, int matrixA[10][10], int matrixB[10][10]) {\r\n    while (1) {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        // Read and validate input\r\n        if (scanf(\"%d %d\", rowsA, columnsA) != 2) {\r\n            printf(\"Invalid input. Please enter two integers.\\n\");\r\n            while (getchar() != '\\n');\r\n            continue;\r\n        }\r\n        // If dimensions are valid\r\n        if (*rowsA > 0 && *rowsA <= 10 && *columnsA > 0 && *columnsA <= 10) {\r\n            printf(\"Enter elements for Matrix A:\\n\");\r\n            for (int i = 0; i < *rowsA; i++) {\r\n                for (int j = 0; j < *columnsA; j++) {\r\n                    printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n                    // Read and validate input\r\n                    if (scanf(\"%d\", &matrixA[i][j]) != 1) {\r\n                        printf(\"Invalid input. Please enter an integer.\\n\");\r\n                        while (getchar() != '\\n');\r\n                        j--;\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        // If dimensions are invalid\r\n        } else {\r\n            printf(\"Invalid dimensions for Matrix A. Rows and columns must be > 0 and <= 10.\\n\");\r\n            continue;\r\n        }\r\n    }\r\n\r\n    while (1) {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        // Read and validate input\r\n        if (scanf(\"%d %d\", rowsB, columnsB) != 2) {\r\n            printf(\"Invalid input. Please enter two integers.\\n\");\r\n            while (getchar() != '\\n');\r\n            continue;\r\n        }\r\n        // If dimensions are valid\r\n        if (*rowsB > 0 && *rowsB <= 10 && *columnsB > 0 && *columnsB <= 10) {\r\n            printf(\"Enter elements for Matrix B:\\n\");\r\n            for (int i = 0; i < *rowsB; i++) {\r\n                for (int j = 0; j < *columnsB; j++) {\r\n                    printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n                    // Read and validate input\r\n                    if (scanf(\"%d\", &matrixB[i][j]) != 1) {\r\n                        printf(\"Invalid input. Please enter an integer.\\n\");\r\n                        while (getchar() != '\\n');\r\n                        j--;\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        // If dimensions are invalid\r\n        } else {\r\n            printf(\"Invalid dimensions for Matrix A. Rows and columns must be > 0 and <= 10.\\n\");\r\n            continue;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display menu\r\nvoid menu(int *rowsA, int *columnsA, int *rowsB, int *columnsB, int matrixA[10][10], int matrixB[10][10]) {\r\n    printf(\"Matrix Operations Menu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    printf(\"Enter your choice: \\n\");\r\n    int choice;\r\n    // Read and validate input\r\n    if (scanf(\"%d\", &choice) != 1) {\r\n        printf(\"Invalid input. Please enter an integer.\\n\");\r\n        while (getchar() != '\\n');\r\n        return;\r\n    }\r\n    selection(choice, rowsA, columnsA, rowsB, columnsB, matrixA, matrixB);\r\n}\r\n\r\n// Function to select operation\r\nvoid selection(int choice, int *rowsA, int *columnsA, int *rowsB, int *columnsB, int matrixA[10][10], int matrixB[10][10]) {\r\n    switch (choice) {\r\n        case 1:\r\n            addMatrices(*rowsA, *columnsA, *rowsB, *columnsB, matrixA, matrixB);\r\n            break;\r\n        case 2:\r\n            subtractMatrices(*rowsA, *columnsA, *rowsB, *columnsB, matrixA, matrixB);\r\n            break;\r\n        case 3:\r\n            transposeMatrixA(*rowsA, *columnsA, matrixA);\r\n            break;\r\n        case 4:\r\n            transposeMatrixB(*rowsB, *columnsB, matrixB);\r\n            break;\r\n        case 5:\r\n            exitProgram();\r\n            exit(0);\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n            break;\r\n    }\r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int rowsA, int columnsA, int rowsB, int columnsB, int matrixA[10][10], int matrixB[10][10]) {\r\n    // Check if both matrices have the same dimensions\r\n    if (rowsA != rowsB || columnsA != columnsB) {\r\n        printf(\"Cannot add matrices. Dimensions of Matrix A and Matrix B are not the same.\\n\");\r\n    } else {\r\n        int result[10][10];\r\n        for (int i = 0; i < rowsA; i++) {\r\n            for (int j = 0; j < columnsA; j++) {\r\n                result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n            }\r\n        }\r\n        printf(\"Result of Matrix A + Matrix B:\\n\");\r\n        for (int i = 0; i < rowsA; i++) {\r\n            for (int j = 0; j < columnsA; j++) {\r\n                printf(\"%d \", result[i][j]);\r\n            }\r\n            printf(\"\\n\");\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtractMatrices(int rowsA, int columnsA, int rowsB, int columnsB, int matrixA[10][10], int matrixB[10][10]) {\r\n    // Check if both matrices have the same dimensions\r\n    if (rowsA != rowsB || columnsA != columnsB) {\r\n        printf(\"Cannot subtract matrices. Dimensions of Matrix A and Matrix B are not the same.\\n\");\r\n    } else {\r\n        int result[10][10];\r\n        for (int i = 0; i < rowsA; i++) {\r\n            for (int j = 0; j < columnsA; j++) {\r\n                result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n            }\r\n        }\r\n        printf(\"Result of Matrix A - Matrix B:\\n\");\r\n        for (int i = 0; i < rowsA; i++) {\r\n            for (int j = 0; j < columnsA; j++) {\r\n                printf(\"%d \", result[i][j]);\r\n            }\r\n            printf(\"\\n\");\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to transpose Matrix A\r\nvoid transposeMatrixA(int rows, int columns, int matrixA[10][10]) {\r\n    int result[10][10];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[j][i] = matrixA[i][j];\r\n        }\r\n    }\r\n    printf(\"Transposed of Matrix A:\\n\");\r\n    for (int i = 0; i < columns; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n// Function to transpose Matrix B\r\nvoid transposeMatrixB(int rows, int columns, int matrixB[10][10]) {\r\n    int result[10][10];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[j][i] = matrixB[i][j];\r\n        }\r\n    }\r\n    printf(\"Transposed of Matrix B:\\n\");\r\n    for (int i = 0; i < columns; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n// Function to exit the program\r\nvoid exitProgram() {\r\n    printf(\"Exiting...\\n\");\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n// Union for availability status\r\nunion AvailabilityStatus {\r\n    bool inStock;\r\n    bool outOfStock;\r\n};\r\n\r\n// Structure for Grocery Item\r\nstruct GroceryItem {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    union AvailabilityStatus availability;\r\n};\r\n\r\n// Structure for Grocery Inventory\r\nstruct GroceryInventory {\r\n    struct GroceryItem items[100];\r\n    int itemCount;\r\n};\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(struct GroceryInventory *inventory);\r\nvoid listAll(struct GroceryInventory *inventory);\r\nvoid updateQuantity(struct GroceryInventory *inventory);\r\nvoid removeGroceryItem(struct GroceryInventory *inventory);\r\n\r\n// Main function\r\nint main() {\r\n    struct GroceryInventory inventory = {{0}, 0};\r\n    int choice = 0;\r\n    while (1) {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        // Validate input\r\n        while (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid input. Please enter an integer.\\n\");\r\n            while (getchar() != '\\n');\r\n            printf(\"Enter your choice: \");\r\n        }\r\n\r\n        switch(choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listAll(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                exit(0);\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item to the inventory\r\nvoid addGroceryItem(struct GroceryInventory *inventory) {\r\n    // Check if inventory is full\r\n    if (inventory->itemCount == 100) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\\n\");\r\n        return;\r\n    }\r\n\r\n    struct GroceryItem *item = &inventory->items[inventory->itemCount];\r\n    printf(\"Enter Item name: \");\r\n    getchar();\r\n    fgets(item->name, 100, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0; // Remove newline character\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, 50, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0; // Remove newline character\r\n\r\n    printf(\"Enter Quantity: \");\r\n    while (scanf(\"%d\", &item->quantity) != 1) {\r\n        printf(\"Invalid input. Please enter an integer.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n        printf(\"Enter Quantity: \");\r\n    }\r\n    \r\n    printf(\"Enter Price: \");\r\n    while (scanf(\"%f\", &item->price) != 1) {\r\n        printf(\"Invalid input. Please enter a valid price.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n    }\r\n\r\n    // Set availability status\r\n    if (item->quantity > 0) {\r\n        item->availability.inStock = true;\r\n    } else {\r\n        item->availability.outOfStock = true;\r\n    }\r\n\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\\n\");\r\n}\r\n\r\n// Function to list all grocery items in the inventory\r\nvoid listAll (struct GroceryInventory *inventory) {\r\n    // Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\", \r\n            inventory->items[i].quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to update quantity of a grocery item\r\nvoid updateQuantity(struct GroceryInventory *inventory) {\r\n    // Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    int c;\r\n\r\n    // Loop to update quantity\r\n    while (1) {\r\n        printf(\"Enter name of the grocery item to update quantity: \");\r\n        getchar();\r\n        // Read and validate input\r\n        if (fgets(name, 100, stdin) == NULL) {\r\n            printf(\"Error reading input.\\n\");\r\n            return;\r\n        }\r\n        name[strcspn(name, \"\\n\")] = 0;  // Remove newline\r\n\r\n        // Search for the item in the inventory\r\n        bool found = false;\r\n        for (int i = 0; i < inventory->itemCount; i++) {\r\n            if (strcmp(inventory->items[i].name, name) == 0) {\r\n                found = true; // Set to true if item is found\r\n                printf(\"Enter new quantity for %s: \", inventory->items[i].name);\r\n\r\n                // Read and validate input\r\n                while (scanf(\"%d\", &inventory->items[i].quantity) != 1) {\r\n                    printf(\"Invalid input. Please enter an integer.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    printf(\"Enter new quantity for %s: \", inventory->items[i].name);\r\n                }\r\n                \r\n                while (getchar() != '\\n');  // Clear input buffer\r\n                \r\n                // Update availability status based on quantity\r\n                if (inventory->items[i].quantity > 0) {\r\n                    inventory->items[i].availability.inStock = true;\r\n                    inventory->items[i].availability.outOfStock = false;\r\n                } else {\r\n                    inventory->items[i].availability.inStock = false;\r\n                    inventory->items[i].availability.outOfStock = true;\r\n                }\r\n                printf(\"Quantity updated successfully!\\n\\n\");\r\n\r\n                return;  // Exit function after successful update\r\n            }\r\n        }\r\n        \r\n        // If item is not found\r\n        if (!found) {\r\n            printf(\"Item not found!\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid removeGroceryItem(struct GroceryInventory *inventory) {\r\n    // Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    int c;\r\n    // Clear any leftover newline from previous input\r\n    getchar();\r\n\r\n    // Loop to remove item\r\n    while (1) {\r\n        printf(\"Enter name of the grocery item to remove: \");\r\n        // Read and validate input\r\n        if (fgets(name, 100, stdin) == NULL) {\r\n            printf(\"Error reading input.\\n\");\r\n            return;\r\n        }\r\n        name[strcspn(name, \"\\n\")] = 0;  // Remove newline\r\n\r\n        // Search for the item in the inventory\r\n        bool found = false;\r\n        for (int i = 0; i < inventory->itemCount; i++) {\r\n            if (strcmp(inventory->items[i].name, name) == 0) {\r\n                found = true; // Set to true if item is found\r\n                // Shift items to the left to remove the item\r\n                for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                    inventory->items[j] = inventory->items[j + 1];\r\n                }\r\n                inventory->itemCount--;\r\n                printf(\"Grocery item '%s' removed successfully!\\n\\n\", name);\r\n                return;  // Exit function after successful removal\r\n            }\r\n        }\r\n        \r\n        // If item is not found\r\n        if (!found) {\r\n            printf(\"Item not found!\\n\");\r\n        }\r\n    }\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student;\r\n\r\nStudent *head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char *name, int id, float grade) {\r\n    // Allocate memory for the new student node\r\n    Student *newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Copy the data into the new node\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\r\n    newStudent->name[strcspn(newStudent->name, \"\\n\")] = 0; // Remove newline character\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char *name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head; // Link the new student to the current head\r\n    head = newStudent; // Set new student as head\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n\r\n    // If the list is empty\r\n    if (current == NULL) {\r\n        printf(\"No records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Student Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n\r\n    // Traverse the list to find the student with the given ID\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current; // Return the student if found\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    return NULL; // Return NULL if student not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student *current = head;\r\n    Student *next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n\r\n    // If the list is empty\r\n    if (head == NULL) {\r\n        printf(\"No records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    // If there is only one record\r\n    if (head->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student *currentStudent;\r\n    Student *lastSorted = NULL;\r\n\r\n    // Bubble sort algorithm\r\n    // Reason for using Bubble Sort:\r\n    // - Easy to implement and understand\r\n    // - Suitable for small datasets\r\n    // - Requires only swapping of data\r\n    do {\r\n        swapped = 0;\r\n        currentStudent = head;\r\n\r\n        while (currentStudent->next != lastSorted) {\r\n            if (currentStudent->grade > currentStudent->next->grade) {\r\n                // Swap data\r\n                float tempGrade = currentStudent->grade;\r\n                int tempId = currentStudent->id;\r\n                char tempName[100];\r\n                strcpy(tempName, currentStudent->name);\r\n                \r\n                currentStudent->grade = currentStudent->next->grade;\r\n                currentStudent->id = currentStudent->next->id;\r\n                strcpy(currentStudent->name, currentStudent->next->name);\r\n                \r\n                currentStudent->next->grade = tempGrade;\r\n                currentStudent->next->id = tempId;\r\n                strcpy(currentStudent->next->name, tempName);\r\n                \r\n                swapped = 1;\r\n            }\r\n            currentStudent = currentStudent->next;\r\n        }\r\n        lastSorted = currentStudent;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation effectively sorts student records by grade. While bubble sort is easy to understand and implement, its time complexity of O(n?) can lead to inefficiency with larger datasets. For improved performance, consider using more efficient sorting algorithms, such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20718864",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define SIZE 10  // Maximum matrix size\r\n\r\n// Declare matrices and variables\r\nint A[SIZE][SIZE], B[SIZE][SIZE];\r\nint rowsA, rowsB, columnA, columnB;\r\nint result[SIZE][SIZE];\r\nint choice = 0;  // Initialize choice to 0\r\n\r\n// Function to input matrix elements\r\nvoid inputMatrix(int rows, int column, int matrix[SIZE][SIZE]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < column; j++) \r\n        {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int rows, int column, int matrix[SIZE][SIZE]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < column; j++) \r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int rows, int column, int matrix[SIZE][SIZE]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < column; j++) \r\n        {\r\n            result[i][j] = A[i][j] + B[i][j];  // Corrected matrix addition logic\r\n        }\r\n    }\r\n    printMatrix(rows, column, result);\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtractMatrices(int rows, int column, int matrix[SIZE][SIZE]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < column; j++) \r\n        {\r\n            result[i][j] = A[i][j] - B[i][j];  // Corrected matrix subtraction logic\r\n        }\r\n    }\r\n    printMatrix(rows, column, result);\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int rows, int column, int matrix[SIZE][SIZE]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < column; j++) \r\n        {\r\n            result[j][i] = matrix[i][j];  // Swap rows and columns\r\n        }\r\n    }\r\n    printMatrix(column, rows, result);  // Print the transposed matrix (rows and columns swapped)\r\n}\r\n\r\nint main() \r\n{\r\n    // Input the dimensions of matrices A and B\r\n    printf(\"Enter rows and columns for Matrix A (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &columnA);\r\n    printf(\"Enter rows and columns for Matrix B (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &columnB);\r\n\r\n    // Check for valid matrix dimensions before inputting matrix elements\r\n    if (rowsA > SIZE || columnA > SIZE || rowsB > SIZE || columnB > SIZE || rowsA <= 0 || columnA <= 0 || rowsB <= 0 || columnB <= 0) \r\n    {\r\n        printf(\"Invalid dimensions. Exiting.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for both matrices\r\n    printf(\"\\nEnter elements for Matrix A:\\n\");\r\n    inputMatrix(rowsA, columnA, A);\r\n    printf(\"\\nEnter elements for Matrix B:\\n\");\r\n    inputMatrix(rowsB, columnB, B);\r\n\r\n    // Menu-driven program to perform matrix operations\r\n    printf(\"\\nMenu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n\r\n    // Menu-driven program to perform matrix operations\r\n    while (choice != 5) \r\n    {\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n        {\r\n            case 1:\r\n                if (rowsA == rowsB && columnA == columnB) \r\n                {\r\n                    printf(\"Result of Addition:\\n\");\r\n                    addMatrices(rowsA, columnA, A);\r\n                } else \r\n                {\r\n                    printf(\"Error: Matrices must have the same dimensions for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && columnA == columnB) \r\n                {\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    subtractMatrices(rowsA, columnA, A);\r\n                } else \r\n                {\r\n                    printf(\"Error: Matrices must have the same dimensions for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                transposeMatrix(rowsA, columnA, A);\r\n                break;\r\n            case 4:\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                transposeMatrix(rowsB, columnB, B);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Create struct for grocery items\r\nstruct GroceryItem {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Global Variables\r\nstruct GroceryItem items[100]; \r\nint itemCount = 0;             \r\n\r\n// Add a grocery item\r\nvoid addItem() \r\n{\r\n    // Checks if the amount is below maximum\r\n    if (itemCount >= 100) {\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter name: \");\r\n    scanf(\"%s\", items[itemCount].name);  \r\n\r\n    printf(\"Enter category: \");\r\n    scanf(\"%s\", items[itemCount].category);\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &items[itemCount].quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &items[itemCount].price);\r\n\r\n    itemCount++;\r\n    printf(\"Item added.\\n\");\r\n}\r\n\r\n\r\nvoid listItems() \r\n{\r\n    // Checks if the inventory is empty or not\r\n    if (itemCount == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Loop through each item in the inventory\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        // Print details of each item \r\n        printf(\"Item %d: %s, %s, Quantity: %d, Price: %.2f, Status: %s\\n\", \r\n            i + 1, items[i].name, items[i].category, items[i].quantity, \r\n            items[i].price, items[i].quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid removeItem() \r\n{\r\n    // Checks if the inventory is empty or not\r\n    if (itemCount == 0) \r\n    {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Get the name of the item to remove\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\"%s\", name);  \r\n\r\n    // Loop through the inventory to find the item by nbame\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        if (strcmp(items[i].name, name) == 0) \r\n        {\r\n            // Shift all items after the found item one position to the left\r\n            for (int j = i; j < itemCount - 1; j++) \r\n            {\r\n                items[j] = items[j + 1];\r\n            }\r\n            itemCount--;  \r\n            printf(\"Item '%s' removed successfully.\\n\", name);\r\n            return;  \r\n        }\r\n    }\r\n\r\n    // check if item exist\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n\r\n\r\nvoid updateItem() \r\n{\r\n    // Checks if the inventory is empty or not\r\n    if (itemCount == 0) \r\n    {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Find the mentioned item\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    scanf(\"%s\", name);\r\n\r\n    // Loop to find the item that wanted to be updated\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        if (strcmp(items[i].name, name) == 0) \r\n        {\r\n            // Update quantity and price\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &items[i].quantity);\r\n\r\n            printf(\"Enter new price: \");\r\n            scanf(\"%f\", &items[i].price);\r\n\r\n            printf(\"Item '%s' updated.\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Checks if item exist or not\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    printf(\"\\nGrocery Inventory Menu:\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n\r\n    int choice;\r\n    // Use while loop to keep looping until user exit the program\r\n    while (1) {\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateItem();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                // Exit the program\r\n                printf(\"Exiting program...\\n\");\r\n                return 0; \r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n\r\n// Structure for Student \r\ntypedef struct Student \r\n{ \r\n    char name[100]; \r\n    int id; \r\n    float grade;    \r\n    struct Student* next; \r\n} Student; \r\n\r\nStudent* head = NULL; \r\n\r\n\r\n// Create new student by allocating the memory  \r\nStudent* createStudent(const char* name, int id, float grade) \r\n{ \r\n    // Allocate memory for the student\r\n    Student* newStudent = malloc(sizeof(Student));\r\n\r\n    // Checks if memory allocation is succesfull or not. If not, return NULL\r\n    if (newStudent == NULL) \r\n    {\r\n        printf(\"Memory allocation fails\");\r\n        return NULL;\r\n    }\r\n\r\n    // Set student details\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    strcpy(newStudent->name, name);\r\n\r\n    return newStudent; \r\n}\r\n\r\n\r\nvoid insertStudent(const char* name, int id, float grade) \r\n{\r\n    // Allocating memory for the new student\r\n    Student* newStudent = createStudent(name, id, grade);\r\n\r\n    // Check if memory allocation is succesfull or not, if not then return\r\n    if (newStudent == NULL) \r\n    {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return;\r\n    }\r\n\r\n    newStudent->next = head;  \r\n    head = newStudent;        \r\n\r\n    printf(\"Student added.\\n\");\r\n}\r\n\r\n\r\nvoid displayStudents() \r\n{\r\n    // Check if the list is empty or not\r\n    if (head == NULL) \r\n    {\r\n        printf(\"No students found.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Traverse through the list and find the student's information (with pointer)\r\n    Student* current = head;\r\n    // Will keep printing as long as there are still some students\r\n    while (current != NULL) \r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;  \r\n    }\r\n}\r\n\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id)\r\n{\r\n    // sets the 'current' to the 'head', which mean the first student on the lsit\r\n    Student* current = head;\r\n    // While loop continues as long there are still some students left in this list\r\n    while (current != NULL)\r\n    {\r\n        if (current->id == id)\r\n        {\r\n            return current; \r\n        }\r\n        current = current->next;  \r\n    }\r\n\r\n    // If the student is not found, return NULL\r\n    return NULL;\r\n    printf(\"Student not found\");\r\n}\r\n\r\n\r\n// Function to delete the entire list \r\nvoid deleteList() \r\n{ \r\n    Student* current = head; \r\n    Student* next; \r\n    while (current != NULL) \r\n    { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n    head = NULL; \r\n} \r\n\r\nvoid freeMemory() \r\n{ \r\n deleteList(); \r\n} \r\n\r\n\r\n// Function to sort student records by grade using Bubble Sort\r\nvoid sortStudents() \r\n{\r\n    // Make sure that there is student\r\n    if (head == NULL) \r\n    {\r\n        printf(\"No students to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Decalre the variable\r\n    Student* current;\r\n    Student* next;\r\n    int swapped;\r\n\r\n    // Use bubble sort to swap until there is no more to swap (based on grades in ascending order)\r\n    /// Reason why I use bubble sort is because it is simple and easy to use compared to other sort method \r\n    do \r\n    {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        // Use while loop to go through each student\r\n        while (current != NULL && current->next != NULL)\r\n        {\r\n            next = current->next;\r\n\r\n            // Compare grades of two adjacent students\r\n            if (current->grade > next->grade) \r\n            {\r\n                // Swap grades if the current grade is higher than the next's grade\r\n                float tempGrade = current->grade;\r\n                current->grade = next->grade;\r\n                next->grade = tempGrade;\r\n\r\n                swapped = 1;  \r\n            }\r\n            current = current->next;\r\n        }\r\n    } while (swapped);  \r\n\r\n    printf(\"Students sorted by grade.\\n\");\r\n}\r\n\r\n\r\n// Main function to drive the program \r\nint main() \r\n{ \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n\r\n    do \r\n    { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n    \r\n        switch (choice) \r\n        { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n\r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n\r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n\r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents(); \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n                if (found) \r\n                { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                    found->name, found->id, found->grade); \r\n                } \r\n                else \r\n                { \r\n                    printf(\"Student not found.\\n\");\r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting the system...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } \r\n    while (choice != 6); \r\n}",
    "feedback": "q1-Meet requirement\nq2-The code does not handle the case where an item with the same name exists multiple times. Removing one instance may lead to confusion about which item was removed if duplicates are present.\nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20505065",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX 10\r\n\r\n// Function declarations\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]);\r\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]);\r\nvoid subtractMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\r\n    int choice;\r\n\r\n    printf(\"Enter the number of rows and columns for Matrix A (max %d): \", MAX);\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    printf(\"Enter the number of rows and columns for Matrix B (max %d): \", MAX);\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX || rowsA < 1 || colsA < 1 || rowsB < 1 || colsB < 1) {\r\n        printf(\"Invalid matrix dimensions. Exiting.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, A);\r\n\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, B);\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"\\nResult of Addition:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"\\nResult of Subtraction:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(rowsA, colsA, A, result);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(rowsB, colsB, B, result);\r\n                printf(\"\\nTranspose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#define MAX_ITEMS 100\r\n\r\n// Structs\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    int inStock;\r\n} AvailabilityStatus;\r\n\r\n// Global Variables\r\nGroceryItem inventory[MAX_ITEMS];\r\nAvailabilityStatus availability[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n// Function Prototypes\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid displayMenu() {\r\n    printf(\"\\nMenu:\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\nvoid addGroceryItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\");\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\");\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    inventory[itemCount] = newItem;\r\n    availability[itemCount].inStock = (newItem.quantity > 0);\r\n\r\n    itemCount++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n%-20s %-15s %-10s %-10s %-10s\\n\", \"Name\", \"Category\", \"Quantity\", \"Price\", \"Status\");\r\n    printf(\"--------------------------------------------------------------------------------\\n\");\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"%-20s %-15s %-10d %-10.2f %-10s\\n\",\r\n               inventory[i].name,\r\n               inventory[i].category,\r\n               inventory[i].quantity,\r\n               inventory[i].price,\r\n               availability[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char itemName[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            inventory[i].quantity = newQuantity;\r\n            availability[i].inStock = (newQuantity > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    char itemName[100];\r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n                availability[j] = availability[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid sortStudents();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted.\\n\");\r\n}\r\n\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    printf(\"\\n%-20s %-10s %-10s\\n\", \"Name\", \"ID\", \"Grade\");\r\n    printf(\"------------------------------------\\n\");\r\n    while (current) {\r\n        printf(\"%-20s %-10d %-10.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return;\r\n    }\r\n    for (Student* i = head; i->next; i = i->next) {\r\n        for (Student* j = i->next; j; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap records\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempID;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation uses Bubble Sort to sort student records by grade. While it is simple and functional, it has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20593212",
    "code": "\n/* --- 20593212.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\nint main()\r\n{\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for matrix A\r\n    printf(\"Enter the number of rows and columns for matrix A (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Input elements for matrix A\r\n    printf(\"Enter the elements for matrix A:\\n\");\r\n    for (int i = 0; i < rowsA; i++)\r\n    {\r\n        for (int j = 0; j < colsA; j++)\r\n        {\r\n            printf(\"Enter element A[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input dimensions for matrix B\r\n    printf(\"Enter the number of rows and columns for matrix B (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Input elements for matrix B\r\n    printf(\"Enter the elements for matrix B:\\n\");\r\n    for (int i = 0; i < rowsB; i++)\r\n    {\r\n        for (int j = 0; j < colsB; j++)\r\n        {\r\n            printf(\"Enter element B[%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n    }\r\n\r\n    do\r\n    {\r\n        // Display menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            // Matrix addition requires A and B to have the same dimensions\r\n            if (rowsA == rowsB && colsA == colsB)\r\n            {\r\n                for (int i = 0; i < rowsA; i++)\r\n                {\r\n                    for (int j = 0; j < colsA; j++)\r\n                    {\r\n                        result[i][j] = A[i][j] + B[i][j];\r\n                    }\r\n                }\r\n                printf(\"Result of A + B:\\n\");\r\n                for (int i = 0; i < rowsA; i++)\r\n                {\r\n                    for (int j = 0; j < colsA; j++)\r\n                    {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrices A and B must have the same dimensions to add.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            // Matrix subtraction requires A and B to have the same dimensions\r\n            if (rowsA == rowsB && colsA == colsB)\r\n            {\r\n                for (int i = 0; i < rowsA; i++)\r\n                {\r\n                    for (int j = 0; j < colsA; j++)\r\n                    {\r\n                        result[i][j] = A[i][j] - B[i][j];\r\n                    }\r\n                }\r\n                printf(\"Result of A - B:\\n\");\r\n                for (int i = 0; i < rowsA; i++)\r\n                {\r\n                    for (int j = 0; j < colsA; j++)\r\n                    {\r\n                        printf(\"%d \", result[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrices A and B must have the same dimensions to subtract.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            // Transpose of Matrix A\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            for (int i = 0; i < colsA; i++)\r\n            {\r\n                for (int j = 0; j < rowsA; j++)\r\n                {\r\n                    printf(\"%d \", A[j][i]);\r\n                }\r\n                printf(\"\\n\");\r\n            }\r\n            break;\r\n\r\n        case 4:\r\n            // Transpose of Matrix B\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            for (int i = 0; i < colsB; i++)\r\n            {\r\n                for (int j = 0; j < rowsB; j++)\r\n                {\r\n                    printf(\"%d \", B[j][i]);\r\n                }\r\n                printf(\"\\n\");\r\n            }\r\n            break;\r\n\r\n        case 5:\r\n            printf(\"Exiting the program.\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice, please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-No submission\nq3-No submission"
  },
  {
    "student_id": "20715036",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function to input matrix dimensions\r\nvoid inputMatrixDimensions(int* rows, int* cols) {\r\n    do {\r\n        printf(\"Enter number of rows (1-10): \");\r\n        scanf(\"%d\", rows);\r\n        printf(\"Enter number of columns (1-10): \");\r\n        scanf(\"%d\", cols);\r\n\r\n        if (*rows < 1 || *rows > MAX_SIZE || *cols < 1 || *cols > MAX_SIZE) {\r\n            printf(\"Invalid dimensions. Please enter dimensions between 1 and 10.\\n\");\r\n        }\r\n    } while (*rows < 1 || *rows > MAX_SIZE || *cols < 1 || *cols > MAX_SIZE);\r\n}\r\n\r\n// Function to input matrix elements\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    printf(\"Enter matrix elements:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d\\t\", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                 int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                      int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], \r\n                     int* rows, int* cols) {\r\n    // Swap rows and columns\r\n    int temp = *rows;\r\n    *rows = *cols;\r\n    *cols = temp;\r\n\r\n    for (int i = 0; i < *rows; i++) {\r\n        for (int j = 0; j < *cols; j++) {\r\n            result[i][j] = matrix[j][i];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB, choice;\r\n\r\n    printf(\"Enter dimensions for Matrix A:\\n\");\r\n    inputMatrixDimensions(&rowsA, &colsA);\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    printf(\"Enter dimensions for Matrix B:\\n\");\r\n    inputMatrixDimensions(&rowsB, &colsB);\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions are not compatible for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions are not compatible for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(A, result, &rowsA, &colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(B, result, &rowsB, &colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, rowsB, colsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Availability status structure\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Grocery item structure\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    AvailabilityStatus status;\r\n} GroceryItem;\r\n\r\n// Grocery inventory structure\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\nGroceryInventory inventory = {0};\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem() {\r\n    if (inventory.count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\");  \r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\");  \r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Set availability status\r\n    newItem.status.inStock = (newItem.quantity > 0);\r\n    newItem.status.outOfStock = (newItem.quantity == 0);\r\n\r\n    // Add item to inventory\r\n    inventory.items[inventory.count++] = newItem;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems() {\r\n    if (inventory.count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Grocery Inventory:\\n\");\r\n    printf(\"%-20s %-15s %-10s %-10s %-15s\\n\", \"Name\", \"Category\", \"Quantity\", \"Price\", \"Availability\");\r\n    \r\n    for (int i = 0; i < inventory.count; i++) {\r\n        printf(\"%-20s %-15s %-10d %-10.2f \", \r\n               inventory.items[i].name, \r\n               inventory.items[i].category, \r\n               inventory.items[i].quantity, \r\n               inventory.items[i].price);\r\n\r\n        if (inventory.items[i].status.inStock) {\r\n            printf(\"In Stock\\n\");\r\n        } else {\r\n            printf(\"Out of Stock\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update item quantity\r\nvoid updateQuantity() {\r\n    char itemName[MAX_NAME_LENGTH];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter item name to update quantity: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");  \r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, itemName) == 0) {\r\n            printf(\"Current quantity: %d\\n\", inventory.items[i].quantity);\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            inventory.items[i].quantity = newQuantity;\r\n            inventory.items[i].status.inStock = (newQuantity > 0);\r\n            inventory.items[i].status.outOfStock = (newQuantity == 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem() {\r\n    char itemName[MAX_NAME_LENGTH];\r\n\r\n    printf(\"Enter item name to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");  \r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        if (strcmp(inventory.items[i].name, itemName) == 0) {\r\n            // Shift remaining items to fill the gap\r\n            for (int j = i; j < inventory.count - 1; j++) {\r\n                inventory.items[j] = inventory.items[j + 1];\r\n            }\r\n            inventory.count--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate memory for new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    \r\n    // Check if memory allocation was successful\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    \r\n    // Copy name, set id and grade\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    \r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    \r\n    // If memory allocation failed\r\n    if (newStudent == NULL) return;\r\n    \r\n    // If list is empty or new student should be at the beginning\r\n    if (head == NULL || head->id > newStudent->id) {\r\n        newStudent->next = head;\r\n        head = newStudent;\r\n        printf(\"Student record inserted successfully!\\n\");\r\n        return;\r\n    }\r\n    \r\n    // Find the correct position to insert\r\n    Student* current = head;\r\n    while (current->next != NULL && current->next->id < newStudent->id) {\r\n        current = current->next;\r\n    }\r\n    \r\n    // Insert the new student\r\n    newStudent->next = current->next;\r\n    current->next = newStudent;\r\n    \r\n    printf(\"Student record inserted successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    \r\n    printf(\"Student Records:\\n\");\r\n    printf(\"%-30s %-10s %-10s\\n\", \"Name\", \"ID\", \"Grade\");\r\n        \r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"%-30s %-10d %-10.2f\\n\", \r\n               current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    \r\n    head = NULL;\r\n    printf(\"Entire student list has been deleted.\\n\");\r\n}\r\n\r\n// Function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort students by grade\r\nvoid sortStudents() {\r\n    // If list is empty or has only one element, no need to sort\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n    \r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n    \r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n        \r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                Student temp;\r\n                strcpy(temp.name, ptr1->name);\r\n                temp.id = ptr1->id;\r\n                temp.grade = ptr1->grade;\r\n                \r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n                \r\n                strcpy(ptr1->next->name, temp.name);\r\n                ptr1->next->id = temp.id;\r\n                ptr1->next->grade = temp.grade;\r\n                \r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n    \r\n    printf(\"Student records sorted by grade in ascending order.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    \r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (by grade)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    \r\n    return 0;\r\n}",
    "feedback": "q1-In the transposeMatrix function, the logic to swap the rows and columns is incorrect when accessing the elements. The loop should iterate based on the original dimensions of the matrix, not the swapped dimensions. Therefore, using the original rows and cols when filling the result matrix is necessary.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly, but it has a time complexity of O(n?), which is inefficient for larger datasets. For improved performance, consider using more efficient algorithms such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20599677",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n//function to add matrices\r\nvoid add_Matrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE]) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//function to subtract matrices\r\nvoid subtract_Matrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE]) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//function to transpose a matrix\r\nvoid transpose_Matrices(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char matrixName) {\r\n    printf(\"Transpose of Matrix %c:\\n\", matrixName);\r\n    for (int i = 0; i < cols; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            printf(\"%d \", matrix[j][i]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rows_A, cols_A, rows_B, cols_B;\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n\r\n    //prompt user to input dimensions for matrix a\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rows_A, &cols_A);\r\n\r\n    //prompt user to input elements of matrix a\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rows_A; i++) {\r\n        for (int j = 0; j < cols_A; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    //prompt user to input dimensions for matrix b\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rows_B, &cols_B);\r\n\r\n    //prompt user to input elements of matrix b\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < rows_B; i++) {\r\n        for (int j = 0; j < cols_B; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n    }\r\n\r\n    while (1) {\r\n        int choice;\r\n\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        //prompt user to input a choice\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rows_A == rows_B && cols_A == cols_B) {\r\n                    add_Matrices(rows_A, cols_A, A, B);\r\n                } else {\r\n                    printf(\"Error: Please make sure the matrices dimensions are the same.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rows_A == rows_B && cols_A == cols_B) {\r\n                    subtract_Matrices(rows_A, cols_A, A, B);\r\n                } else {\r\n                    printf(\"Error: Please make sure the matrices dimensions are the same.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transpose_Matrices(rows_A, cols_A, A, 'A');\r\n                break;\r\n\r\n            case 4:\r\n                transpose_Matrices(rows_B, cols_B, B, 'B');\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Error: Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_SIZE 100\r\n\r\n//structure to store grocery items' info\r\ntypedef struct{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    bool in_stock;\r\n    bool out_stock;\r\n}info_grocery;\r\ninfo_grocery inventory[MAX_SIZE]; //array to store inventory\r\nint count = 0;\r\n\r\n//function to add grocery item\r\nvoid add_grocery(){\r\n    if(count >= MAX_SIZE){\r\n        printf(\"Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    info_grocery *item = &inventory[count]; //pointer to next slot available\r\n\r\n    printf(\"Enter Item Name: \");\r\n    getchar();\r\n    fgets(item -> name, sizeof(item -> name), stdin);\r\n    item -> name[strcspn(item -> name, \"\\n\")] = '\\0'; //remove trailing newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item -> category, sizeof(item -> category), stdin); \r\n    item -> category[strcspn(item -> category, \"\\n\")] = '\\0'; //remove trailing newline\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n    //set stock availability based on quantity\r\n    item -> in_stock = item -> quantity > 0;\r\n    item -> out_stock = item -> quantity == 0;\r\n    count++; //increment inventory count\r\n    printf(\"Grocery item added successfully!\\n\");\r\n\r\n}\r\n\r\n//function to show list of grocery items\r\nvoid list_grocery(){\r\n    if(count == 0){\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for(int i = 0; i < count; i++){\r\n        info_grocery *item = &inventory[i];\r\n        printf(\"%d. Name: %s\\n\", i + 1, item -> name);\r\n        printf(\"   Category: %s\\n\", item -> category);\r\n        printf(\"   Quantity: %d\\n\", item -> quantity);\r\n        printf(\"   Price: %.2f\\n\", item -> price);\r\n        printf(\"   Availability: %s\\n\", item -> in_stock ? \"In Stock\":\"Out of Stock\");\r\n    }\r\n\r\n}\r\n\r\n//function to update quantity\r\nvoid update_grocery(){\r\n    if (count == 0) {\r\n        printf(\"No items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char item_name[100];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    getchar(); //consume newline left in input buffer\r\n    fgets(item_name, sizeof(item_name), stdin);\r\n    item_name[strcspn(item_name, \"\\n\")] = '\\0'; //remove trailing newline\r\n\r\n    int index = -1;\r\n    //search item by name\r\n    for(int i = 0; i < count; i++){\r\n        if(strcmp(inventory[i].name, item_name) == 0){\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if(index == -1){\r\n        printf(\"Item not found.\\n\");\r\n        return;\r\n    }\r\n\r\n    info_grocery *item = &inventory[index]; //pointer to found item\r\n\r\n    printf(\"Enter new quantity for %s: \", item -> name);\r\n    scanf(\"%d\", &item -> quantity); //update quantity\r\n\r\n    //update stock availability based on new quantity\r\n    item -> in_stock = item -> quantity > 0;\r\n    item -> out_stock = item -> quantity == 0;\r\n    printf(\"Quantity updated successfully!\\n\");\r\n\r\n}\r\n\r\n\r\n//function to remove grocery item\r\nvoid remove_grocery(){\r\n    if(count == 0){\r\n        printf(\"No grocery items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char item_name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    getchar(); //consume newline left in buffer\r\n    fgets(item_name, sizeof(item_name), stdin);\r\n    item_name[strcspn(item_name, \"\\n\")] = '\\0'; //remove trailing newline\r\n\r\n    int index = -1;\r\n    //search item by name\r\n    for(int i = 0; i < count; i++){\r\n        if(strcmp(inventory[i].name, item_name) == 0){\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1){\r\n        printf(\"Item not found.\\n\");\r\n        return;\r\n    }\r\n\r\n    //shift items to fill gap\r\n    for(int i = index; i < count - 1; i++){\r\n        inventory[i] = inventory[i + 1];\r\n    }\r\n\r\n    count--; //decrement inventory count\r\n    printf(\"Grocery item '%s' removed successfully!\\n\", item_name);\r\n}\r\n\r\nint main(){\r\n\r\n    while(1){\r\n        int choice;\r\n\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        //prompt user to enter a choice\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice){\r\n            case 1:\r\n                add_grocery();\r\n                break;\r\n\r\n            case 2:\r\n                list_grocery();\r\n                break;\r\n\r\n            case 3:\r\n                update_grocery();\r\n                break;\r\n\r\n            case 4:\r\n                remove_grocery();\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Error: Please enter a number between 1 and 5.\\n\");\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* create_student = (Student*)malloc(sizeof(Student)); //allocate memory for new student node\r\n    if(create_student == NULL){\r\n        printf(\"Error: Failed to create a new student node.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(create_student->name, name); //copy student's name into node\r\n    create_student->id = id; //set student id\r\n    create_student->grade = grade; //set student's grade\r\n    create_student->next = NULL; //initialize next pointer to NULL\r\n    return create_student; \r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* add_student = createStudent(name, id, grade);\r\n    add_student->next = head; //\r\n    head = add_student;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* list_students = head;\r\n    while(list_students != NULL){ \r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", list_students->name, list_students->id, list_students->grade);\r\n        list_students = list_students->next; //move to next node\r\n    }\r\n\r\n    //empty list\r\n    if(head == NULL){\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* search_students = head;\r\n    while(search_students != NULL){\r\n        if(search_students->id == id){\r\n            return search_students;\r\n        }\r\n        search_students = search_students->next; //move to next node\r\n    }\r\n    return NULL;\r\n\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next; \r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current); \r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory(){\r\n    deleteList();\r\n}\r\n\r\n//Sort function to sort the student records by grade based on bubble sort\r\nvoid sortStudents(){\r\n    int swapped;\r\n    Student *ptr, *sort_students = NULL;\r\n\r\n    do{\r\n        swapped = 0;\r\n        ptr = head;\r\n\r\n        while(ptr->next != sort_students){\r\n            //compare grades\r\n            if(ptr->grade > ptr->next->grade){\r\n                //sort grade\r\n                float sort_grade = ptr->grade;\r\n                ptr->grade = ptr->next->grade;\r\n                ptr->next->grade = sort_grade;\r\n\r\n                //sort name\r\n                char sort_name[100];\r\n                strcpy(sort_name, ptr->name);\r\n                strcpy(ptr->name, ptr->next->name);\r\n                strcpy(ptr->next->name, sort_name);\r\n\r\n                //sort ID\r\n                int sort_id = ptr->id;\r\n                ptr->id = ptr->next->id;\r\n                ptr->next->id = sort_id;\r\n\r\n                swapped = 1; //swap occurred\r\n            }\r\n            ptr = ptr->next; //move to next node\r\n        }\r\n        sort_students = ptr; //update list\r\n    }while(swapped);\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n\r\n}\r\n\r\nint main(){\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do{\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch(choice){\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if(found){\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                }else{\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    \r\n    }while(choice != 6);\r\n\r\n    return 0;\r\n\r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is suitable for small datasets due to its simplicity, but it has a time complexity of O(n?). For larger datasets, consider implementing more efficient sorting algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20611327",
    "code": "\n/* --- Q1.c --- */\n/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\n#include <stdio.h>\n\n#define MAX_SIZE 10\n\n// Function prototypes\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\nvoid displayMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\nvoid subtractMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE]);\n\nint main() {\n    int rowsA, colsA, rowsB, colsB;\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\n    int result[MAX_SIZE][MAX_SIZE];\n    int choice;\n\n    // Input dimensions and elements for Matrix A\n    printf(\"Enter dimensions of Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    if (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE) {\n        printf(\"Invalid dimensions for Matrix A.\\n\");\n        return 1;\n    }\n    printf(\"Enter elements of Matrix A:\\n\");\n    inputMatrix(rowsA, colsA, A);\n\n    // Input dimensions and elements for Matrix B\n    printf(\"Enter dimensions of Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    if (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE) {\n        printf(\"Invalid dimensions for Matrix B.\\n\");\n        return 1;\n    }\n    printf(\"Enter elements of Matrix B:\\n\");\n    inputMatrix(rowsB, colsB, B);\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(rowsA, colsA, A, B, result);\n                    printf(\"Result of Addition:\\n\");\n                    displayMatrix(rowsA, colsA, result);\n                } else {\n                    printf(\"Matrices cannot be added due to incompatible dimensions.\\n\");\n                }\n                break;\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(rowsA, colsA, A, B, result);\n                    printf(\"Result of Subtraction:\\n\");\n                    displayMatrix(rowsA, colsA, result);\n                } else {\n                    printf(\"Matrices cannot be subtracted due to incompatible dimensions.\\n\");\n                }\n                break;\n            case 3:\n                transposeMatrix(rowsA, colsA, A, result);\n                printf(\"Transpose of Matrix A:\\n\");\n                displayMatrix(colsA, rowsA, result);\n                break;\n            case 4:\n                transposeMatrix(rowsB, colsB, B, result);\n                printf(\"Transpose of Matrix B:\\n\");\n                displayMatrix(colsB, rowsB, result);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid displayMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\n/* --- Q2.c --- */\n/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LEN 100\n#define MAX_CATEGORY_LEN 50\n\n// Structures for Grocery Item and Availability Status\ntypedef struct {\n    char name[MAX_NAME_LEN];\n    char category[MAX_CATEGORY_LEN];\n    int quantity;\n    float price;\n    bool inStock; // Availability status\n} GroceryItem;\n\n// Global variables\nGroceryItem inventory[MAX_ITEMS];\nint itemCount = 0;\n\n// Function prototypes\nvoid addGroceryItem();\nvoid listGroceryItems();\nvoid updateQuantity();\nvoid removeGroceryItem();\nvoid displayMenu();\n\nint main() {\n    int choice;\n\n    do {\n        displayMenu();\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Consume newline left in the buffer\n\n        switch (choice) {\n            case 1:\n                addGroceryItem();\n                break;\n            case 2:\n                listGroceryItems();\n                break;\n            case 3:\n                updateQuantity();\n                break;\n            case 4:\n                removeGroceryItem();\n                break;\n            case 5:\n                printf(\"Exiting the program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to display menu\nvoid displayMenu() {\n    printf(\"\\nGrocery Inventory Management System\\n\");\n    printf(\"1. Add Grocery Item\\n\");\n    printf(\"2. List All Grocery Items\\n\");\n    printf(\"3. Update Quantity\\n\");\n    printf(\"4. Remove Grocery Item\\n\");\n    printf(\"5. Exit\\n\");\n}\n\n// Function to add a grocery item\nvoid addGroceryItem() {\n    if (itemCount >= MAX_ITEMS) {\n        printf(\"Inventory is full! Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n    printf(\"Enter item name: \");\n    fgets(newItem.name, MAX_NAME_LEN, stdin);\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0; // Remove newline character\n\n    printf(\"Enter category: \");\n    fgets(newItem.category, MAX_CATEGORY_LEN, stdin);\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0; // Remove newline character\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &newItem.price);\n    getchar(); // Consume newline left in the buffer\n\n    newItem.inStock = newItem.quantity > 0;\n\n    inventory[itemCount++] = newItem;\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items with their availability\nvoid listGroceryItems() {\n    if (itemCount == 0) {\n        printf(\"No items in the inventory.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < itemCount; i++) {\n        printf(\"Name: %s\\n\", inventory[i].name);\n        printf(\"Category: %s\\n\", inventory[i].category);\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\n        printf(\"Price: %.2f\\n\", inventory[i].price);\n        printf(\"Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity() {\n    char itemName[MAX_NAME_LEN];\n    int newQuantity;\n\n    if (itemCount == 0) {\n        printf(\"No items in the inventory to update.\\n\");\n        return;\n    }\n\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets(itemName, MAX_NAME_LEN, stdin);\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline character\n\n    for (int i = 0; i < itemCount; i++) {\n        if (strcmp(inventory[i].name, itemName) == 0) {\n            printf(\"Enter new quantity for \\\"%s\\\": \", inventory[i].name);\n            scanf(\"%d\", &newQuantity);\n            getchar(); // Consume newline left in the buffer\n\n            inventory[i].quantity = newQuantity;\n            inventory[i].inStock = newQuantity > 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem() {\n    char itemName[MAX_NAME_LEN];\n\n    if (itemCount == 0) {\n        printf(\"No items in the inventory to remove.\\n\");\n        return;\n    }\n\n    printf(\"Enter the name of the item to remove: \");\n    fgets(itemName, MAX_NAME_LEN, stdin);\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline character\n\n    for (int i = 0; i < itemCount; i++) {\n        if (strcmp(inventory[i].name, itemName) == 0) {\n            // Shift items to remove the found item\n            for (int j = i; j < itemCount - 1; j++) {\n                inventory[j] = inventory[j + 1];\n            }\n            itemCount--;\n            printf(\"Item removed successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\");\n}\n/* --- Q3.c --- */\n/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\n// Global variable for the head of the linked list\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (!head) {\n        printf(\"No records to display.\\n\");\n        return;\n    }\n    Student* temp = head;\n    while (temp) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp) {\n        if (temp->id == id) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\n// Sort function to sort the student records by grade using Bubble Sort\nvoid sortStudents() {\n    if (!head || !head->next) {\n        return; // No need to sort if the list has 0 or 1 element\n    }\n    int swapped;\n    Student *ptr1, *ptr2 = NULL;\n\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != ptr2) {\n            if (ptr1->grade > ptr1->next->grade) {\n                // Swap data\n                float tempGrade = ptr1->grade;\n                ptr1->grade = ptr1->next->grade;\n                ptr1->next->grade = tempGrade;\n\n                int tempID = ptr1->id;\n                ptr1->id = ptr1->next->id;\n                ptr1->next->id = tempID;\n\n                char tempName[100];\n                strcpy(tempName, ptr1->name);\n                strcpy(ptr1->name, ptr1->next->name);\n                strcpy(ptr1->next->name, tempName);\n\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        ptr2 = ptr1;\n    } while (swapped);\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Function to free all memory (calls deleteList)\nvoid freeMemory() {\n    deleteList();\n}\n\n// Main function\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                name[strcspn(name, \"\\n\")] = 0; // Remove newline character\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly to sort student records by grade in ascending order. While Bubble Sort is straightforward for small datasets, it has a time complexity of O(n?), which can be inefficient for larger datasets. For larger lists, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20614437",
    "code": "",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3- The implementation correctly uses Merge Sort, which is efficient with a time complexity of O(n log n). This makes it suitable for sorting larger datasets in linked lists, as it does not require random access and maintains stability."
  },
  {
    "student_id": "20706147",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 10\n\n//Define the prototypes of five functions that are used for matrix operations\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]);\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]);\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]);\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]);\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]);\n\nint main() {\n    //Declare several variables to be used in the matrix operations\n    int rowsA, colsA, rowsB, colsB;\n    int matrixA[MAX][MAX], matrixB[MAX][MAX];\n    int result[MAX][MAX];\n    int choice;\n\n    // Input dimensions for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n\n    //Ensure input matrix dimensions are valid for accurate matrix calculations\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0 ) {\n        printf(\"Invalid matrix dimensions. Maximum allowed is %dx%d.\\n\", MAX, MAX);\n        return 1;\n    }\n\n    // Input Matrix A\n    printf(\"Enter elements for Matrix A:\\n\");\n    inputMatrix(rowsA, colsA, matrixA);\n    \n    // Input dimensions for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) {\n        printf(\"Invalid matrix dimensions. Maximum allowed is %dx%d.\\n\", MAX, MAX);\n        return 1;\n    }\n\n    // Input Matrix B\n    printf(\"Enter elements of Matrix B:\\n\");\n    inputMatrix(rowsB, colsB, matrixB);\n\n    do {\n        //Print the menu options\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        //Enter the choice\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        //Process the choice\n        switch (choice) {\n            case 1://Add Matrices \n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\n                    printf(\"Resultant Matrix after Addition:\\n\");\n                    printMatrix(rowsA, colsA, result);\n                } else {\n                    printf(\"Matrix dimensions do not match for addition.\\n\");\n                }\n                break;\n            case 2://Subtract Matrices\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\n                    printf(\"Resultant Matrix after Subtraction:\\n\");\n                    printMatrix(rowsA, colsA, result);\n                } else {\n                    printf(\"Matrix dimensions do not match for subtraction.\\n\");\n                }\n                break;\n            case 3://Transpose Matrix A\n                transposeMatrix(rowsA, colsA, matrixA, result);\n                printf(\"Transpose of Matrix A:\\n\");\n                printMatrix(colsA, rowsA, result);\n                break;\n            case 4://Transpose Matrix B \n                transposeMatrix(rowsB, colsB, matrixB, result);\n                printf(\"Transpose of Matrix B:\\n\");\n                printMatrix(colsB, rowsB, result);\n                break;\n            case 5://Exit the program\n                printf(\"Exiting ...\\n\");\n                break;\n            default://Handle invalid choices\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n//This function is used to input a matrix\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n//This function is used to print a matrix\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n//This function is used to compute the addition of two matrices\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = a[i][j] + b[i][j];\n        }\n    }\n}\n\n//This function is used to compute the subtraction of two matrices\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = a[i][j] - b[i][j];\n        }\n    }\n}\n\n//This function is used to compute the transpose of a matrix\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#define MAX_ITEMS 100\r\n\r\n//A structure named GroceryItem is defined to represent a commodity. \r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    _Bool isAvailable; // true for in stock, false for out of stock\r\n} GroceryItem;\r\n\r\n// Define Grocery Inventory\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n//Define the prototypes of four functions\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice;\r\n    // Main program loop（do-while）\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        \r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        //Process user's choice\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();//Add a new grocery item\r\n                break;\r\n            case 2:\r\n                listGroceryItems();//List all grocery items\r\n                break;\r\n            case 3:\r\n                updateQuantity();//Update the quantity of an existing item\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();//Remove an item from the inventory\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n//Function to add a new grocery item to the inventory\r\nvoid addGroceryItem() {\r\n    //Check if inventory is full\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n\r\n    printf(\"Enter Item name: \");\r\n    fgets(item.name, sizeof(item.name), stdin);\r\n    strtok(item.name, \"\\n\"); // Remove newline character\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, sizeof(item.category), stdin);\r\n    strtok(item.category, \"\\n\");\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n    item.isAvailable = (item.quantity > 0); // Set availability based on quantity\r\n\r\n    inventory[itemCount++] = item;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n//Function to list all grocery items in the inventory\r\nvoid listGroceryItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n    // Print the table header\r\n    printf(\"Name: %s\\n\", inventory[0].name);\r\n    printf(\"Category: %s\\n\", inventory[0].category);\r\n    printf(\"Quantity: %d\\n\", inventory[0].quantity);\r\n    printf(\"Price: %.2f\\n\", inventory[0].price);\r\n    printf(\"Status: %s\\n\", inventory[0].isAvailable ? \"In Stock\" : \"Out of Stock\");\r\n}\r\n\r\n//Function to update the quantity of an existing grocery item\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    int found = 0;\r\n\r\n    printf(\"Enter name of the geocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n\r\n    //Find products matching the entered name\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            found = 1;\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            inventory[i].isAvailable = (inventory[i].quantity > 0); // Update availability\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found in the inventory.\\n\");\r\n    }\r\n}\r\n\r\n//Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    int found = 0;\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n    \r\n    //Find products matching the entered name\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            found = 1;\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found in the inventory.\\n\");\r\n    }\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    //Allocate memory for a new Student structure\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    //Check if memory allocation was successful\n    if (newStudent == NULL) {\n        perror(\"Memory allocation failed\");\n        exit(EXIT_FAILURE); \n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    //Initialize the 'next' pointer of the new student to NULL\n    newStudent->next = NULL;\n    //Return a pointer to the newly created student node\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    //Check if the linked list is empty\n    if (head == NULL) {\n        head = newStudent;\n    } else {\n        Student* temp = head;\n        //Traverse the list until 'temp' reaches the last node\n        while (temp->next != NULL) {\n            temp = temp->next;\n        }\n        //After the loop, 'temp' points to the last node\n        temp->next = newStudent;\n    }\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n    Student* temp = head;\n    //print the student information of the node that the pointer is currently referencing within the loop\n    while (temp != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    //This pointer will be used to traverse the list to find the specified student ID\n    Student* temp = head;\n    //Use while loop to check if the 'id' of the current node pointed to by 'temp' matches the target 'id'\n    while (temp != NULL) {\n        if (temp->id == id) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() {\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n    // In cases where the data size is small，bubbling sort is simple to implement and easy to understand.\n    if (head == NULL || head->next == NULL) {\n        return; \n    }\n\n    int swapped;\n    Student* ptr1; \n    Student* lptr = NULL; //Pointer to mark the beginning of the sorted portion\n\n    do {\n        swapped = 0; //Reset the swapped flag before each pass\n        ptr1 = head;\n\n        //Compare adjacent elements\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                //Swap data (name, ID, and grade)\n                char tempName[100];\n                int tempId;\n                float tempGrade;\n\n                strcpy(tempName, ptr1->name);\n                tempId = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempId;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1; //A swap occurred, set the swapped flag\n            }\n            ptr1 = ptr1->next; //Move to the next node\n        }\n        lptr = ptr1; //Update the beginning of the sorted portion\n    } while (swapped);\n}\n\n// Main function to drive the program \nint main() { \n \n    int choice, id; \n    char name[100]; \n    float grade; \n \n    do { \n        printf(\"\\n1. Insert Student Record\\n\"); \n        printf(\"2. Display Student Records\\n\"); \n        printf(\"3. Sort Records\\n\"); \n        printf(\"4. Search Record by ID\\n\"); \n        printf(\"5. Delete List\\n\"); \n        printf(\"6. Exit\\n\"); \n        printf(\"Enter your choice: \"); \n        scanf(\"%d\", &choice); \n        getchar(); // To consume the newline character \n \n        switch (choice) { \n            case 1: \n                printf(\"Enter Name: \"); \n                fgets(name, sizeof(name), stdin); \n                strtok(name, \"\\n\"); \n                printf(\"Enter ID: \"); \n                scanf(\"%d\", &id); \n                printf(\"Enter Grade: \"); \n                scanf(\"%f\", &grade); \n                insertStudent(name, id, grade); \n                break; \n            case 2: \n                displayStudents(); \n                break; \n            case 3: \n     sortStudents();                 \n                break; \n            case 4: \n                printf(\"Enter ID to search: \"); \n                scanf(\"%d\", &id); \n                Student* found = searchStudentByID(id); \n                if (found) { \n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \nfound->name, found->id, found->grade); \n                } else { \n                    printf(\"Student not found.\\n\"); \n                } \n                break; \n            case 5: \n                deleteList(); \n                printf(\"List deleted.\\n\"); \n                break; \n            case 6: \n                freeMemory(); \n                printf(\"Exiting...\\n\"); \n                break; \n            default: \n                printf(\"Invalid choice! Please try again.\\n\"); \n        } \n    } while (choice != 6); \n \n    return 0; \n} ",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation correctly sorts student records by grade. While bubble sort is simple and easy to understand, it has a time complexity of O(n?), which can be inefficient for larger datasets. For improved performance, consider using more efficient algorithms such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20700473",
    "code": "\n/* --- Q1.c --- */\n/**\n * @file Q1.c\n * @brief This C program performs basic operations on two matrices.\n *\n * The program allow the user to input the dimensions of two matrices\n * A and B (maximum size: 10x10).\n * Provide a menu for the user to choose an operation:\n * 1. Add Matrices\n * 2. Subtract Matrices\n * 3. Transpose Matrix A\n * 4. Transpose Matrix B\n * 5. Exit (Loop back to the menu until the user chooses to exit.)\n *\n * @author Yichen Si\n * @date 2024-12-11\n * @note code is formated by vscode\n */\n\n#include <stdio.h>\n\n#define MAX_SIZE (10)\n#define MAX_VALUE (10000)\n#define MIN_VALUE (-10000)\n\n// check if the matrix dimensions are valid\nstatic int check_validity(int row, int col)\n{\n    if (row > MAX_SIZE || col > MAX_SIZE || row <= 0 || col <= 0)\n    {\n        return 0;\n    }\n    return 1;\n}\n\n// get matrix elements from user input\nstatic void input_elements(int matrix[MAX_SIZE][MAX_SIZE], int row, int col)\n{\n    for (int i = 0; i < row; i++)\n    {\n        for (int j = 0; j < col; j++)\n        {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            while (1)\n            {\n                if (scanf(\"%d\", &matrix[i][j]) != 1)\n                {\n                    printf(\"Error: invalid input element. Enter again: \");\n                    while (getchar() != '\\n')\n                        ; // clear the buffer to avoid messing up the next input\n                    continue;\n                }\n                while (getchar() != '\\n')\n                    ; // clear the buffer to avoid messing up the next input\n                if (matrix[i][j] > MAX_VALUE || matrix[i][j] < MIN_VALUE)\n                {\n                    printf(\n                        \"Error: value must within [-10000,10000]. Enter \"\n                        \"again: \");\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n    }\n}\n\n// add two matrices\nstatic void add_matrix(int matrixA[MAX_SIZE][MAX_SIZE],\n                       int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE],\n                       int row, int col)\n{\n    for (int i = 0; i < row; i++)\n    {\n        for (int j = 0; j < col; j++)\n        {\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\n        }\n    }\n}\n\n// subtract two matrices\nstatic void subtract_matrix(int matrixA[MAX_SIZE][MAX_SIZE],\n                            int matrixB[MAX_SIZE][MAX_SIZE],\n                            int result[MAX_SIZE][MAX_SIZE], int col, int row)\n{\n    for (int i = 0; i < row; i++)\n    {\n        for (int j = 0; j < col; j++)\n        {\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\n        }\n    }\n}\n\n// transpose a matrix\nstatic void tanspose_matrix(int matrix[MAX_SIZE][MAX_SIZE],\n                            int result[MAX_SIZE][MAX_SIZE], int row, int col)\n{\n    for (int i = 0; i < row; i++)\n    {\n        for (int j = 0; j < col; j++)\n        {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n// display a matrix\nstatic void display_result(int matrix[MAX_SIZE][MAX_SIZE], int row, int col)\n{\n    for (int i = 0; i < row; i++)\n    {\n        for (int j = 0; j < col; j++)\n        {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(void)\n{\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE],\n        result[MAX_SIZE][MAX_SIZE];\n    int rowA = 0, colA = 0;\n    int rowB = 0, colB = 0;\n    int choice = -1;\n\n    printf(\"Enter dimensions for Matrix A(rows and columns): \");\n    scanf(\"%d %d\", &rowA, &colA);\n\n    if (!check_validity(rowA, colA))\n    {\n        printf(\n            \"Error: invalid matrix dimensions. The row and col must > 0 and <= \"\n            \"10\\n\");\n        return -1;\n    }\n\n    printf(\"Enter elements for matrix A:\\n\");\n    input_elements(matrixA, rowA, colA);\n\n    printf(\"Enter dimensions for Matrix B(rows and columns): \");\n    scanf(\"%d %d\", &rowB, &colB);\n\n    if (!check_validity(rowB, colB))\n    {\n        printf(\"Error: invalid matrix dimensions\\n\");\n        return -1;\n    }\n\n    printf(\"Enter elements for matrix B:\\n\");\n    input_elements(matrixB, rowB, colB);\n\n    // menu of matrix operations\n    while (1)\n    {\n        printf(\"Matrix Operations Menu: \\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrics\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        while (getchar() != '\\n')\n            ;\n        switch (choice)\n        {\n        case 1:\n            if (rowA == rowB && colA == colB)\n            {\n                add_matrix(matrixA, matrixB, result, rowA, colA);\n                printf(\"Result of Matrix A + Matrix B:\\n\");\n                display_result(result, rowA, colA);\n            }\n            else\n            {\n                printf(\"Error: the dimensions don't match for addition\\n\");\n            }\n            break;\n        case 2:\n            if (rowA == rowB && colA == colB)\n            {\n                subtract_matrix(matrixA, matrixB, result, colA, rowA);\n                printf(\"Result of Matrix A - Matrix B:\\n\");\n                display_result(result, rowA, colA);\n            }\n            else\n            {\n                printf(\n                    \"Error: the dimensions don't match for subtraction\\n\");\n            }\n            break;\n        case 3:\n            tanspose_matrix(matrixA, result, rowA, colA);\n            printf(\"Transpose of Matrix A:\\n\");\n            display_result(result, colA, rowA);\n            break;\n        case 4:\n            tanspose_matrix(matrixB, result, rowB, colB);\n            printf(\"Transpose of Matrix B:\\n\");\n            display_result(result, colB, rowB);\n            break;\n        case 5:\n            printf(\"Exiting...\\n\");\n            return 0;\n        default:\n            printf(\"Error: invalid choice.\\n\");\n            break;\n        }\n    }\n}\n\n/* --- Q2.c --- */\n/**\n * @file Q2.c\n * @brief This C program manage grocery item information and item availability.\n *\n * The program menu runs in a loop, allowing users to select different actions until\n * they choose to exit.\n *\n * @author Yichen Si\n * @date 2024-12-11\n * @note code is formated by vscode\n */\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#define MAX_NAME_LEN (100)\n#define MAX_CATEGORY_LEN (50)\n#define MAX_ITEM_LEN (100)\n\ntypedef struct\n{\n    char name[MAX_NAME_LEN];\n    char category[MAX_CATEGORY_LEN];\n    int quantity;\n    float price;\n    bool status;    // availability of the item (true if in stock)\n    bool used_slot; // flag to check if the slot is used, total MAX_ITEM_LEN slots\n} grocery_item;\n\ntypedef struct\n{\n    grocery_item item[MAX_ITEM_LEN];\n    int item_count;\n} grocery_inventory;\n\ngrocery_inventory inventory = {0}; // initialize inventory\n\nstatic void add_grocery_item(void)\n{\n    grocery_item newitem;\n\n    // clear the input buffer\n    while (getchar() != '\\n')\n        ;\n\n    printf(\"Enter Item Name: \");\n    fgets(newitem.name, MAX_NAME_LEN, stdin);\n    strtok(newitem.name, \"\\n\");\n\n    printf(\"Enter Category: \");\n    fgets(newitem.category, MAX_CATEGORY_LEN, stdin);\n    strtok(newitem.category, \"\\n\");\n\n    // read the item quantity and validate input\n    while (1)\n    {\n        printf(\"Enter Quantity: \");\n        if (scanf(\"%d\", &newitem.quantity) != 1)\n        {\n            printf(\"Error: quantitiy must be numbers. Please enter again.\\n\");\n            while (getchar() != '\\n') // clear buffer to avoid messing up next input\n                ;\n            continue;\n        }\n        break;\n    }\n\n    while (getchar() != '\\n')\n        ;\n\n    while (1)\n    {\n        printf(\"Enter Pirce: \");\n        if (scanf(\"%f\", &newitem.price) != 1)\n        {\n            printf(\"Error: price must be numbers. Please enter again.\\n\");\n            while (getchar() != '\\n')\n                ;\n            continue;\n        }\n        break;\n    }\n\n    while (getchar() != '\\n')\n        ;\n\n    if (newitem.quantity > 0)\n    {\n        newitem.status = true;\n    }\n    else\n    {\n        newitem.status = false;\n    }\n\n    // find an empty slot and add the new item\n    for (int i = 0; i < MAX_ITEM_LEN; i++)\n    {\n        if (inventory.item[i].used_slot == false)\n        {\n            inventory.item[i] = newitem;\n            inventory.item[i].used_slot = true;\n            inventory.item_count++;\n            printf(\"Grocery item added successfully!\");\n            return;\n        }\n    }\n    printf(\"Error: the maximum number of inventory is %d.\\n\", MAX_ITEM_LEN);\n}\n\nstatic void list_grocery_item(void)\n{\n    int item = 0;\n    for (int i = 0; i < MAX_ITEM_LEN; i++)\n    {\n        if (inventory.item[i].used_slot == true)\n        {\n            item = 1;\n            printf(\"Name: %s\\n\", inventory.item[i].name);\n            printf(\"Category: %s\\n\", inventory.item[i].category);\n            printf(\"Quantity: %d\\n\", inventory.item[i].quantity);\n            printf(\"Price: %.2f\\n\", inventory.item[i].price);\n            printf(\"Status: %s\\n\", inventory.item[i].status ? \"In Stock\" : \"Out of Stock\");\n        }\n    }\n    if (item == 0)\n    {\n        printf(\"No grocery items in the inventory.\\n\");\n    }\n}\n\nstatic void update_grocery_item(void)\n{\n    char name[MAX_NAME_LEN];\n\n    while (getchar() != '\\n')\n        ;\n\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets(name, MAX_NAME_LEN, stdin);\n    strtok(name, \"\\n\");\n\n    for (int i = 0; i < MAX_ITEM_LEN; i++)\n    {\n        if ((inventory.item[i].used_slot == true) && strcmp(inventory.item[i].name, name) == 0)\n        {\n            printf(\"Enter new quantity for %s: \", name);\n            scanf(\"%d\", &inventory.item[i].quantity);\n            while (getchar() != '\\n')\n                ;\n\n            if (inventory.item[i].quantity > 0)\n            {\n                inventory.item[i].status = true;\n            }\n            else\n            {\n                inventory.item[i].status = false;\n            }\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Error: there is no such item.\\n\");\n}\n\nstatic void remove_grocery_item(void)\n{\n    char name[MAX_NAME_LEN];\n    int item = 0;\n\n    while (getchar() != '\\n')\n        ;\n\n    printf(\"Enter name of the grocery item to remove: \");\n    fgets(name, MAX_NAME_LEN, stdin);\n    strtok(name, \"\\n\");\n\n    for (int i = 0; i < MAX_ITEM_LEN; i++)\n    {\n        if ((inventory.item[i].used_slot == true) && strcmp(inventory.item[i].name, name) == 0)\n        {\n            item = 1;\n            inventory.item[i].used_slot = false;\n            printf(\"Grocery item '%s' removed successfully!\\n\", inventory.item[i].name);\n            inventory.item_count--;\n            break;\n        }\n    }\n    if (item == 0)\n    {\n        printf(\"Error: there is no such item\\n\");\n    }\n}\n\nint main(void)\n{\n    int choice;\n\n    while (1)\n    {\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n\n        if (scanf(\"%d\", &choice) != 1)\n        {\n            printf(\"Error: input must be number.\\n\");\n            while (getchar() != '\\n')\n                ;\n            continue;\n        }\n\n        switch (choice)\n        {\n        case 1:\n            add_grocery_item();\n            break;\n        case 2:\n            list_grocery_item();\n            break;\n        case 3:\n            update_grocery_item();\n            break;\n        case 4:\n            remove_grocery_item();\n            break;\n        case 5:\n            return 0;\n        default:\n            printf(\"Error: invalid choice. Please try again.\\n\");\n        }\n    }\n}\n\n/* --- Q3.c --- */\n/**\n * @file Q3.c\n * @brief This C program implements a linked list to store a collection of student records.\n *\n * Each record should include the student’s name, ID, and grade. The program should allow\n * the user to perform the following operations:\n *  a) Insert Student Record: Allow the user to insert new student records into the linked\n *     list.\n *  b) Display Student Records: Display all current student records in the list.\n *  c) Sort Records: Implement a sorting algorithm to sort the student records by grade in\n *     ascending order. You may choose to implement a sorting algorithm (e.g., Merge Sort,\n *     Quick Sort, Bubble Sort, Selection Sort, Insertion Sort etc.). Put in the comment on\n *     your reason for the choice of the sorting algorithm.\n *  d) Search Record by ID: Allow the user to search for a student record by student ID.\n *  e) Delete List: Provide an option to delete the entire linked list and free allocated\n *     memory.\n *\n * @author Yichen Si\n * @date 2024-12-11\n * @note code is formated by vscode\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LEN (100)\n\ntypedef struct record\n{\n    char name[MAX_NAME_LEN];\n    int id;\n    float grade;\n    struct record *next;\n} record;\n\nrecord *head = NULL;\n\nstatic record *create_student(const char *name, int id, float grade)\n{\n    record *newrecord = (record *)malloc(sizeof(record));\n    if (newrecord == NULL)\n    {\n        printf(\"Error: memory allocation failed\");\n        return NULL;\n    }\n\n    // name length is valided at input, so it safe to strpcy\n    strcpy(newrecord->name, name);\n    newrecord->id = id;\n    newrecord->grade = grade;\n    newrecord->next = NULL;\n\n    return newrecord;\n}\n\nstatic void insert_student_record(const char *name, int id, float grade)\n{\n    record *newrecord = create_student(name, id, grade);\n\n    if (newrecord == NULL)\n    {\n        printf(\"Error: memory allocation failed.\\n\");\n        return;\n    }\n\n    // head always point to the new added record.\n    newrecord->next = head;\n    head = newrecord;\n}\n\nstatic void display_student_records(void)\n{\n    record *current_record = head;\n\n    if (head == NULL)\n    {\n        printf(\"Error: no records to display.\\n\");\n        return;\n    }\n\n    // travel list till end to display each record\n    while (current_record != NULL)\n    {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current_record->name,\n               current_record->id, current_record->grade);\n        current_record = current_record->next;\n    }\n}\n\nstatic void sort_records(void)\n{\n    record *i;\n    record *j;\n    record temp;\n\n    if (head == NULL)\n    {\n        printf(\"Error: no records to sort.\\n\");\n        return;\n    }\n    // Bubble sort\n    for (i = head; i != NULL; i = i->next)\n    {\n        for (j = i->next; j != NULL; j = j->next)\n        {\n            if (i->grade > j->grade)\n            {\n                temp.grade = i->grade;\n                i->grade = j->grade;\n                j->grade = temp.grade;\n\n                temp.id = i->id;\n                i->id = j->id;\n                j->id = temp.id;\n\n                strcpy(temp.name, i->name);\n                strcpy(i->name, j->name);\n                strcpy(j->name, temp.name);\n            }\n        }\n    }\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\nstatic record *search_student(int id)\n{\n    record *current_record = head;\n\n    while (current_record != NULL)\n    {\n        if (current_record->id == id)\n        {\n            return current_record;\n        }\n        current_record = current_record->next;\n    }\n    return NULL;\n}\n\nstatic void deleteList(void)\n{\n    record *current = head;\n    record *next;\n    while (current != NULL)\n    {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\nstatic void freeMemory(void) { deleteList(); }\n\nint main(void)\n{\n    int choice;\n    char name[MAX_NAME_LEN];\n    int id;\n    float grade;\n\n    do\n    {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();\n\n        switch (choice)\n        {\n        case 1:\n            printf(\"Enter Name: \");\n            fgets(name, MAX_NAME_LEN, stdin);\n            long int len = strlen(name);\n            if (len == MAX_NAME_LEN - 1)\n            {\n                while (getchar() != '\\n')\n                    ;\n            }\n            if (name[0] == '\\n')\n            {\n                printf(\"Error: invalid Name.\\n\");\n                break;\n            }\n            strtok(name, \"\\n\");\n\n            printf(\"Enter ID: \");\n\n            if (scanf(\"%d\", &id) != 1)\n            {\n                printf(\"Error: invalid ID.\\n\");\n                while (getchar() != '\\n')\n                    ;\n                break;\n            }\n\n            printf(\"Enter Grade: \");\n            if (scanf(\"%f\", &grade) != 1)\n            {\n                printf(\"Error: invalid Grade.\\n\");\n                while (getchar() != '\\n')\n                    ;\n                break;\n            }\n\n            insert_student_record(name, id, grade);\n            break;\n        case 2:\n            display_student_records();\n            break;\n        case 3:\n            sort_records();\n            break;\n        case 4:\n            printf(\"Enter ID to search: \");\n            scanf(\"%d\", &id);\n            while (getchar() != '\\n')\n                ;\n            record *found = search_student(id);\n            if (found)\n            {\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\n                       found->name, found->id, found->grade);\n            }\n            else\n            {\n                printf(\"Student not found.\\n\");\n            }\n            break;\n        case 5:\n            deleteList();\n            printf(\"List deleted.\\n\");\n            break;\n        case 6:\n            freeMemory();\n            printf(\"Exiting...\\n\");\n            break;\n        default:\n            printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3- Bubble Sort is straightforward and easy to implement but has a time complexity of O(n?). While it works for small datasets, it may not be efficient for larger ones. Consider implementing a more efficient sorting algorithm like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20595637",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes for matrix operations\r\nvoid getInputMatrix(int rowCount, int colCount, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid showMatrix(int rowCount, int colCount, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid addTwoMatrices(int rowCount, int colCount, int firstMatrix[MAX_SIZE][MAX_SIZE], int secondMatrix[MAX_SIZE][MAX_SIZE], int sumMatrix[MAX_SIZE][MAX_SIZE]);\r\nvoid subtractTwoMatrices(int rowCount, int colCount, int firstMatrix[MAX_SIZE][MAX_SIZE], int secondMatrix[MAX_SIZE][MAX_SIZE], int diffMatrix[MAX_SIZE][MAX_SIZE]);\r\nvoid transposeOfMatrix(int rowCount, int colCount, int matrix[MAX_SIZE][MAX_SIZE], int transposedMatrix[MAX_SIZE][MAX_SIZE]);\r\n\r\n// Function for obtaining user-provided matrix values\r\nvoid getInputMatrix(int rowCount, int colCount, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rowCount; i++) {\r\n        for (int j = 0; j < colCount; j++) {\r\n            printf(\"Please enter the value for position [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//  Function to print the matrix elements to the console for display\r\n\r\nvoid showMatrix(int rowCount, int colCount, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rowCount; i++) {\r\n        for (int j = 0; j < colCount; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to output the matrix content to the screen\r\nvoid addTwoMatrices(int rowCount, int colCount, int firstMatrix[MAX_SIZE][MAX_SIZE], int secondMatrix[MAX_SIZE][MAX_SIZE], int sumMatrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rowCount; i++) {\r\n        for (int j = 0; j < colCount; j++) {\r\n            sumMatrix[i][j] = firstMatrix[i][j] + secondMatrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to compute the result of subtracting one matrix from another\r\nvoid subtractTwoMatrices(int rowCount, int colCount, int firstMatrix[MAX_SIZE][MAX_SIZE], int secondMatrix[MAX_SIZE][MAX_SIZE], int diffMatrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rowCount; i++) {\r\n        for (int j = 0; j < colCount; j++) {\r\n            diffMatrix[i][j] = firstMatrix[i][j] - secondMatrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to find the transpose of a given matrix\r\nvoid transposeOfMatrix(int rowCount, int colCount, int matrix[MAX_SIZE][MAX_SIZE], int transposedMatrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rowCount; i++) {\r\n        for (int j = 0; j < colCount; j++) {\r\n            transposedMatrix[j][i] = matrix[i][j];  // Switch rows and columns\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rowsFirstMatrix, colsFirstMatrix, rowsSecondMatrix, colsSecondMatrix;\r\n    int firstMatrix[MAX_SIZE][MAX_SIZE], secondMatrix[MAX_SIZE][MAX_SIZE]; // Matrices for storing values\r\n    int resultMatrix[MAX_SIZE][MAX_SIZE]; // Matrix to store the result of operations\r\n    int userChoice;\r\n\r\n    // Asking the user to enter the dimensions for the first matrix\r\n    printf(\"Enter the dimensions for Matrix 1 (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsFirstMatrix, &colsFirstMatrix);\r\n    if (rowsFirstMatrix <= 0 || rowsFirstMatrix > MAX_SIZE || colsFirstMatrix <= 0 || colsFirstMatrix > MAX_SIZE) {\r\n        printf(\"The dimensions you entered for Matrix 1 are invalid.\\n\");\r\n        return 1;\r\n    }\r\n    printf(\"Enter values for Matrix 1:\\n\");\r\n    getInputMatrix(rowsFirstMatrix, colsFirstMatrix, firstMatrix);\r\n\r\n    // Requesting input for the second matrix dimensions\r\n    printf(\"Enter the dimensions for Matrix 2 (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsSecondMatrix, &colsSecondMatrix);\r\n    if (rowsSecondMatrix <= 0 || rowsSecondMatrix > MAX_SIZE || colsSecondMatrix <= 0 || colsSecondMatrix > MAX_SIZE) {\r\n        printf(\"The dimensions you entered for Matrix 2 are invalid.\\n\");\r\n        return 1;\r\n    }\r\n    printf(\"Enter values for Matrix 2:\\n\");\r\n    getInputMatrix(rowsSecondMatrix, colsSecondMatrix, secondMatrix);\r\n\r\n    // Providing the user with a menu of matrix operations\r\n    do {\r\n        printf(\"\\nSelect a matrix operation:\\n\");\r\n        printf(\"1. Add the matrices\\n\");\r\n        printf(\"2. Subtract the matrices\\n\");\r\n        printf(\"3. Transpose Matrix 1\\n\");\r\n        printf(\"4. Transpose Matrix 2\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Your choice: \");\r\n        scanf(\"%d\", &userChoice);\r\n\r\n        switch (userChoice) {\r\n            case 1:\r\n                // If the matrices have the same dimensions, perform addition\r\n                if (rowsFirstMatrix == rowsSecondMatrix && colsFirstMatrix == colsSecondMatrix) {\r\n                    addTwoMatrices(rowsFirstMatrix, colsFirstMatrix, firstMatrix, secondMatrix, resultMatrix);\r\n                    printf(\"Sum of Matrix 1 and Matrix 2:\\n\");\r\n                    showMatrix(rowsFirstMatrix, colsFirstMatrix, resultMatrix);\r\n                } else {\r\n                    printf(\"Addition not possible: Matrices have different sizes.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // If the matrices have the same dimensions, perform subtraction\r\n                if (rowsFirstMatrix == rowsSecondMatrix && colsFirstMatrix == colsSecondMatrix) {\r\n                    subtractTwoMatrices(rowsFirstMatrix, colsFirstMatrix, firstMatrix, secondMatrix, resultMatrix);\r\n                    printf(\"Difference between Matrix 1 and Matrix 2:\\n\");\r\n                    showMatrix(rowsFirstMatrix, colsFirstMatrix, resultMatrix);\r\n                } else {\r\n                    printf(\"Subtraction not possible: Matrices have different sizes.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Compute and show the transpose of the first matrix\r\n                transposeOfMatrix(rowsFirstMatrix, colsFirstMatrix, firstMatrix, resultMatrix);\r\n                printf(\"Transpose of Matrix 1:\\n\");\r\n                showMatrix(colsFirstMatrix, rowsFirstMatrix, resultMatrix);\r\n                break;\r\n            case 4:\r\n                // Compute and show the transpose of the second matrix\r\n                transposeOfMatrix(rowsSecondMatrix, colsSecondMatrix, secondMatrix, resultMatrix);\r\n                printf(\"Transpose of Matrix 2:\\n\");\r\n                showMatrix(colsSecondMatrix, rowsSecondMatrix, resultMatrix);\r\n                break;\r\n            case 5:\r\n                // Exit the program\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid option, please choose again.\\n\");\r\n        }\r\n    } while (userChoice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Constants defining limits for the inventory system\r\n#define MAX_ITEMS 100          // Maximum number of items that can be stored in the inventory\r\n#define MAX_NAME_LEN 100       // Maximum length allowed for item names\r\n#define MAX_CATEGORY_LEN 50    // Maximum length allowed for category names\r\n\r\n// Function prototypes for managing the inventory\r\nvoid addItem();               // Adds a new item to the inventory\r\nvoid displayItems();          // Displays all items in the inventory\r\nvoid updateItemQuantity();    // Updates the quantity of a specific item\r\nvoid deleteItem();            // Removes an item from the inventory\r\nvoid displayMenu();           // Displays the menu options for the user\r\n\r\n// Structure to represent a single item in the inventory\r\ntypedef struct {\r\n    char itemName[MAX_NAME_LEN];         // Name of the grocery item\r\n    char itemCategory[MAX_CATEGORY_LEN]; // Category of the grocery item (e.g., Fruits, Vegetables)\r\n    int itemQuantity;                    // Quantity of the item in stock\r\n    float itemPrice;                     // Price per unit of the item\r\n    int isAvailable;                     // Availability status: 1 (available), 0 (not available)\r\n} InventoryItem;\r\n\r\n// Global variables\r\nInventoryItem inventoryList[MAX_ITEMS]; // Array to hold all inventory items\r\nint totalItems = 0;                     // Current count of items in the inventory\r\n\r\n// Function to display the main menu of the inventory manager\r\nvoid displayMenu() {\r\n    printf(\"\\n========== Smart Inventory Manager ==========\\n\");\r\n    printf(\"1. Add New Grocery Item\\n\");\r\n    printf(\"2. View All Grocery Items\\n\");\r\n    printf(\"3. Update Item Quantity\\n\");\r\n    printf(\"4. Remove a Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    printf(\"=============================================\\n\");\r\n}\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addItem() {\r\n    if (totalItems >= MAX_ITEMS) {\r\n        // Check if the inventory is full\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    InventoryItem newItem; // Temporary variable to store the new item details\r\n    printf(\"\\n--- Add a New Grocery Item ---\\n\");\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.itemName, MAX_NAME_LEN, stdin);\r\n    newItem.itemName[strcspn(newItem.itemName, \"\\n\")] = 0; // Remove the newline character\r\n\r\n    printf(\"Enter Item Category: \");\r\n    fgets(newItem.itemCategory, MAX_CATEGORY_LEN, stdin);\r\n    newItem.itemCategory[strcspn(newItem.itemCategory, \"\\n\")] = 0; // Remove the newline character\r\n\r\n    printf(\"Enter Item Quantity: \");\r\n    scanf(\"%d\", &newItem.itemQuantity);\r\n\r\n    printf(\"Enter Item Price: \");\r\n    scanf(\"%f\", &newItem.itemPrice);\r\n    getchar(); // Clear the input buffer\r\n\r\n    // Determine availability based on the quantity\r\n    newItem.isAvailable = (newItem.itemQuantity > 0) ? 1 : 0;\r\n\r\n    // Add the item to the inventory and update the total count\r\n    inventoryList[totalItems++] = newItem;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to display all items currently in the inventory\r\nvoid displayItems() {\r\n    if (totalItems == 0) {\r\n        // If no items are present in the inventory\r\n        printf(\"\\nNo grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n--- Current Grocery Items ---\\n\");\r\n    for (int i = 0; i < totalItems; i++) {\r\n        // Display details of each item\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", inventoryList[i].itemName);\r\n        printf(\"  Category: %s\\n\", inventoryList[i].itemCategory);\r\n        printf(\"  Quantity: %d\\n\", inventoryList[i].itemQuantity);\r\n        printf(\"  Price: $%.2f\\n\", inventoryList[i].itemPrice);\r\n        printf(\"  Status: %s\\n\", inventoryList[i].isAvailable ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an existing grocery item\r\nvoid updateItemQuantity() {\r\n    if (totalItems == 0) {\r\n        // Check if there are items in the inventory\r\n        printf(\"\\nNo grocery items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char targetItem[MAX_NAME_LEN]; // Temporary variable to store the name of the item to update\r\n    printf(\"\\n--- Update Grocery Item Quantity ---\\n\");\r\n    printf(\"Enter the Name of the Item to Update: \");\r\n    fgets(targetItem, MAX_NAME_LEN, stdin);\r\n    targetItem[strcspn(targetItem, \"\\n\")] = 0; // Remove the newline character\r\n\r\n    // Search for the item in the inventory\r\n    for (int i = 0; i < totalItems; i++) {\r\n        if (strcmp(inventoryList[i].itemName, targetItem) == 0) {\r\n            int updatedQuantity;\r\n            printf(\"Enter the New Quantity: \");\r\n            scanf(\"%d\", &updatedQuantity);\r\n            getchar(); // Clear the input buffer\r\n\r\n            // Update the quantity and availability status of the item\r\n            inventoryList[i].itemQuantity = updatedQuantity;\r\n            inventoryList[i].isAvailable = (updatedQuantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Grocery item quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid deleteItem() {\r\n    if (totalItems == 0) {\r\n        // Check if there are items in the inventory\r\n        printf(\"\\nNo grocery items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char targetItem[MAX_NAME_LEN]; // Temporary variable to store the name of the item to delete\r\n    printf(\"\\n--- Remove a Grocery Item ---\\n\");\r\n    printf(\"Enter the Name of the Item to Remove: \");\r\n    fgets(targetItem, MAX_NAME_LEN, stdin);\r\n    targetItem[strcspn(targetItem, \"\\n\")] = 0; // Remove the newline character\r\n\r\n    // Search for the item and delete it if found\r\n    for (int i = 0; i < totalItems; i++) {\r\n        if (strcmp(inventoryList[i].itemName, targetItem) == 0) {\r\n            // Shift remaining items to fill the gap left by the deleted item\r\n            for (int j = i; j < totalItems - 1; j++) {\r\n                inventoryList[j] = inventoryList[j + 1];\r\n            }\r\n            totalItems--; // Reduce the total item count\r\n            printf(\"Grocery item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\r\n\r\n// Main function to run the inventory manager program\r\nint main() {\r\n    int menuChoice;\r\n\r\n    do {\r\n        displayMenu(); // Show the menu options to the user\r\n        printf(\"Enter your choice (1-5): \");\r\n        scanf(\"%d\", &menuChoice);\r\n        getchar(); // Clear the input buffer\r\n\r\n        // Perform the action based on the user's choice\r\n        switch (menuChoice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                displayItems();\r\n                break;\r\n            case 3:\r\n                updateItemQuantity();\r\n                break;\r\n            case 4:\r\n                deleteItem();\r\n                break;\r\n            case 5:\r\n                printf(\"\\nExiting the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (menuChoice != 5); // Exit when the user chooses option 5\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define the Student structure to hold student details\r\ntypedef struct Student {\r\n    char name[50];           // Student's name\r\n    int id;                  // Student's ID\r\n    float grade;             // Student's grade\r\n    struct Student* next;    // Pointer to the next student in the list\r\n} Student;\r\n\r\nStudent* head = NULL;        // Head pointer for the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\r\n    strcpy(newStudent->name, name);   // Copy the name into the new student node\r\n    newStudent->id = id;              // Assign the ID\r\n    newStudent->grade = grade;        // Assign the grade\r\n    newStudent->next = NULL;          // Initialize the next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Insert a new student record into the linked list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade); // Create a new student node\r\n    newStudent->next = head;     // Point the new node to the current head of the list\r\n    head = newStudent;           // Update the head pointer to the new node\r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// Display all student records in the list\r\nvoid displayStudents() {\r\n    if (head == NULL) {          // Check if the list is empty\r\n        printf(\"No records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;        // Temporary pointer to traverse the list\r\n    while (temp != NULL) {       // Iterate until the end of the list\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;       // Move to the next node\r\n    }\r\n}\r\n\r\n// Sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) { // Check if sorting is unnecessary\r\n        printf(\"No sorting needed.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Bubble Sort: Compare and swap data between adjacent nodes\r\n    Student* i;\r\n    Student* j;\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = head; j->next != NULL; j = j->next) {\r\n            if (j->grade > j->next->grade) {  // Swap if the current grade is greater than the next\r\n                // Temporary variables to hold the data\r\n                char tempName[50];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                // Swap names\r\n                strcpy(tempName, j->name);\r\n                strcpy(j->name, j->next->name);\r\n                strcpy(j->next->name, tempName);\r\n\r\n                // Swap IDs\r\n                tempID = j->id;\r\n                j->id = j->next->id;\r\n                j->next->id = tempID;\r\n\r\n                // Swap grades\r\n                tempGrade = j->grade;\r\n                j->grade = j->next->grade;\r\n                j->next->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Search for a student record by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;        // Temporary pointer to traverse the list\r\n    while (temp != NULL) {       // Iterate through the list\r\n        if (temp->id == id) {    // Check if the current node matches the given ID\r\n            return temp;         // Return the matching node\r\n        }\r\n        temp = temp->next;       // Move to the next node\r\n    }\r\n    return NULL;                 // Return NULL if no match is found\r\n}\r\n\r\n// Delete the entire linked list\r\nvoid deleteList() {\r\n    Student* temp;\r\n    while (head != NULL) {       // Iterate through the list\r\n        temp = head;             // Store the current head node\r\n        head = head->next;       // Move the head pointer to the next node\r\n        free(temp);              // Free memory for the current node\r\n    }\r\n    printf(\"All records deleted successfully.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[50];\r\n    float grade;\r\n\r\n    do {\r\n        // Display the menu\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Insert a new student record\r\n                printf(\"Enter Name: \");\r\n                scanf(\" %[^\\n]s\", name); // Read the name\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);        // Read the ID\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);     // Read the grade\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                // Display all student records\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                // Sort student records by grade\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                // Search for a student record by ID\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                Student* result = searchStudentByID(id);\r\n                if (result != NULL) {\r\n                    printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", result->name, result->id, result->grade);\r\n                } else {\r\n                    printf(\"Record not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                // Delete all student records\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                // Exit the program\r\n                deleteList(); // Ensure memory is freed before exiting\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation correctly uses Bubble Sort for sorting student records by grade. However, Bubble Sort has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20714140",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX 10\r\n\r\nvoid AddorSub(int *a, int *b, int xa, int ya, int xb, int yb, int addorsub) {\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n\r\n    int big_x = (xa > xb) ? xa : xb;  // Larger number of rows\r\n    int big_y = (ya > yb) ? ya : yb;  // Larger number of columns\r\n\r\n    for (int i = 0; i < big_x; i++) {\r\n        for (int j = 0; j < big_y; j++) {\r\n            // Access elements from Matrix A and B, if out of scope, gives a 0\r\n\r\n            int A = (i < xa && j < ya) ? *(a + i * ya + j) : 0;\r\n            int B = (i < xb && j < yb) ? *(b + i * yb + j) : 0;\r\n            if (addorsub == 1){\r\n            printf(\"%d \", A + B);\r\n            } else {printf(\"%d \", A - B);}\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid Transpose(int *matrix, int x, int y) {\r\n    printf(\"Result of Transposing Matrix A:\\n\");\r\n\r\n    // Transposing and printing\r\n    for (int i = 0; i < y; i++) {\r\n        for (int j = 0; j < x; j++) {\r\n            printf(\"%d \", *(matrix + j * y + i));  // Print elements in transposed form\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int x1, y1, x2, y2;\r\n\r\n    // Dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d\", &x1);\r\n    scanf(\"%d\", &y1);\r\n    while (x1 > MAX || y1 > MAX) {\r\n        printf(\"10 is the Maximum size for either grid. Please re-enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d\", &x1);\r\n        scanf(\"%d\", &y1);\r\n    }\r\n\r\n    // Dynamically allocate memory for Matrix A\r\n    int *MatA = (int *)malloc(x1 * y1 * sizeof(int));\r\n\r\n    printf(\"Enter elements for Matrix A: \\n\");\r\n    for (int i = 0; i < x1; i++) {\r\n        for (int j = 0; j < y1; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", (MatA + i * y1 + j));  // Pointer arithmetic to assign elements\r\n        }   // stores the matrix as an array like A = {1,2,3,4,5,6,7,8,9} where 1 is A[0][0] and 4 is [1][0]\r\n    }\r\n\r\n    // Dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d\", &x2);\r\n    scanf(\"%d\", &y2);\r\n    while (x2 > MAX || y2 > MAX) {\r\n        printf(\"10 is the Maximum size for either grid. Please re-enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d\", &x2);\r\n        scanf(\"%d\", &y2);\r\n    }\r\n\r\n    // Dynamically allocate memory for Matrix B\r\n    int *MatB = (int *)malloc(x2 * y2 * sizeof(int));\r\n\r\n    printf(\"Enter elements for Matrix B: \\n\");\r\n    for (int i = 0; i < x2; i++) {\r\n        for (int j = 0; j < y2; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", (MatB + i * y2 + j));  // Pointer arithmetic to assign elements\r\n        }\r\n    }\r\n\r\n    int choice = 0;\r\n    while (choice != 5) { // Selection Menu\r\n        printf(\"Matrix Operations Menu:\\n1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix A\\n4. Transpose Matrix B\\n5. Exit\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        if (choice == 1) {\r\n            AddorSub(MatA, MatB, x1, y1, x2, y2,1);  // Addition\r\n        }\r\n        else if (choice == 2) {\r\n            AddorSub(MatA, MatB, x1, y1, x2, y2,2);  // Subtraction\r\n        }\r\n        else if (choice == 3) {\r\n            Transpose(MatA, x1, y1);  // Transpose Matrix A\r\n        }\r\n        else if (choice == 4) {\r\n            Transpose(MatB, x2, y2);  // Transpose Matrix B\r\n        } else if (choice != 5){\r\n            printf(\"There is no such option. Please enter again.\\n\");\r\n        }\r\n    }\r\n\r\n    printf(\"Exiting...\\n\");\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nstruct Item {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\nvoid AddGroItem(struct Item gro_item[], int *item_count) {\r\n\r\n    if (*item_count >= 100) {\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n    \r\n    struct Item new_item;\r\n    printf(\"Enter Item Name: \");\r\n    getchar();\r\n    fgets(new_item.name, sizeof(new_item.name), stdin);\r\n    new_item.name[strcspn(new_item.name, \"\\n\")] = 0;  // Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(new_item.category, sizeof(new_item.category), stdin);\r\n    new_item.category[strcspn(new_item.category, \"\\n\")] = 0;  // Remove newline\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &new_item.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &new_item.price);\r\n\r\n    gro_item[*item_count] = new_item;\r\n    (*item_count)++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid ListItem(struct Item gro_item[], int item_count) {\r\n    if (item_count == 0) {\r\n        printf(\"No grocery items in inventory.\\n\");\r\n        return;\r\n    }\r\n    \r\n    for (int i = 0; i < item_count; i++) {\r\n        printf(\"Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\n\", gro_item[i].name, gro_item[i].category, gro_item[i].quantity, gro_item[i].price);\r\n        if (gro_item[i].quantity != 0){\r\n            printf(\"Status: In Stock\\n\");\r\n        } else {printf(\"Status: Out of Stock\\n\");}\r\n    }\r\n}\r\n\r\nvoid UpdateQuantity(struct Item gro_item[], int item_count) {\r\n    char item_name[100];\r\n    int new_quantity;\r\n    \r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar();\r\n    fgets(item_name, sizeof(item_name), stdin);\r\n    item_name[strcspn(item_name, \"\\n\")] = 0;  // Remove newline\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(gro_item[i].name, item_name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", gro_item[i].name);\r\n            scanf(\"%d\", &new_quantity);\r\n            gro_item[i].quantity = new_quantity;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\r\n//\r\nvoid RemoveItem(struct Item gro_item[], int *item_count) {\r\n    char item_name[100];\r\n    \r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    getchar();\r\n    fgets(item_name, sizeof(item_name), stdin);\r\n    item_name[strcspn(item_name, \"\\n\")] = 0;  // Remove newline\r\n\r\n    for (int i = 0; i < *item_count; i++) {\r\n        if (strcmp(gro_item[i].name, item_name) == 0) {\r\n            for (int j = i; j < *item_count - 1; j++) { \r\n                gro_item[j] = gro_item[j + 1]; // Shift items left after removal\r\n            }\r\n            (*item_count)--;  // Decrease item count\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", item_name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\r\nint main(){\r\n    struct Item gro_item[100]; //Array to hold 100 items\r\n    int item_count = 0; //number of item in the inventory\r\n    \r\n    int choice = 0;\r\n    while (choice != 5) { //Selection Menu\r\n        printf(\"Grocery Inventory Management System\\n1. Add Grocery Item\\n2. List All Grocery Items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        if (choice == 1) {\r\n            AddGroItem(gro_item, &item_count);  //Add Grocery Item\r\n        }\r\n        else if (choice == 2) {\r\n            ListItem(gro_item, item_count);  // List all grocery items with their availability\r\n        }\r\n        else if (choice == 3) {\r\n            UpdateQuantity(gro_item, item_count);  // Update the quantity of a grocery item\r\n        }\r\n        else if (choice == 4) {\r\n            RemoveItem(gro_item, &item_count);  // Remove a grocery item from the inventory\r\n        } else if (choice != 5) {\r\n            printf(\"There is no such option. Please enter again.\\n\");\r\n        }\r\n    }\r\n    printf(\"Exiting...\\n\");\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student; \r\n \r\nStudent* head = NULL; \r\n \r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    Student* NewStudent = (Student*)malloc(sizeof(Student));\r\n\r\n    strncpy(NewStudent->name,name,sizeof(NewStudent->name)-1);\r\n    NewStudent->name[sizeof(NewStudent->name) - 1] = '\\0'; // Remove Null\r\n    NewStudent->id = id;\r\n    NewStudent->grade = grade;\r\n    NewStudent->next = NULL;\r\n// Write your code (1 mark) \r\n \r\n} \r\n \r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* NewStudent = createStudent(name,id,grade);\r\n\r\n    NewStudent->next = head; // Initialise a new head\r\n    head = NewStudent;\r\n// Write your code (1 mark) \r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    if (head == NULL){\r\n        printf(\"No student record available\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* display = head;\r\n    while (display != NULL){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", display->name, display->id, display->grade);\r\n        display = display->next;\r\n    }\r\n   // Write your code (1 mark) \r\n} \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n    Student* now = head;\r\n    while (now != NULL) {\r\n        if (now->id == id) {\r\n            return now;\r\n        }\r\n        now = now->next;\r\n    }\r\n    return NULL;\r\n   // Write your code (1 mark) \r\n} \r\n \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n    head = NULL; \r\n}\r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n// Sort function to sort the student records by grade based on an algorithm of your choice \r\nvoid sortStudents() { \r\n    if (head == NULL || head->next == NULL){\r\n        printf(\"List has no need to be sorted\\n\");\r\n        return;\r\n    }\r\n    \r\n    Student* i;\r\n    Student* j;\r\n    char tempName[100];\r\n    int tempID;\r\n    float tempGrade;\r\n    int swapped;\r\n\r\n    for (i = head; i != NULL; i = i->next){\r\n        swapped = 0;\r\n        for (j = i->next; j != NULL; j = j->next){  //swap names,id and grades\r\n            if (i->grade > j->grade) {\r\n                strncpy(tempName, i->name, sizeof(tempName));\r\n                tempName[sizeof(tempName) - 1] = '\\0';\r\n                strncpy(i->name, j->name, sizeof(i->name));\r\n                i->name[sizeof(i->name) - 1] = '\\0';\r\n                strncpy(j->name, tempName, sizeof(j->name));\r\n                j->name[sizeof(j->name) - 1] = '\\0';\r\n        \r\n                tempID = i->id;\r\n                i->id = j->id;\r\n                j->id = tempID;\r\n\r\n                tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n        }\r\n        if (swapped == 0) {\r\n            break;\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n// Write your code (1 mark) \r\n} \r\n \r\n// Main function to drive the program \r\nint main() { \r\n \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents();                 \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id);\r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n} ",
    "feedback": "q1-In the AddorSub function, the output for subtraction is incorrect. The subtraction should be A - B, but the function does not properly handle cases where one matrix might be larger than the other. The implementation currently outputs 0 for missing elements without clear indication.\nq2-The UpdateQuantity function does not update the item's status based on the new quantity. Even though the code changes the quantity, it does not reflect whether the item is \"In Stock\" or \"Out of Stock\" after the update.\nq3-    The bubble sort implementation correctly sorts the student records by grade. While it is a straightforward algorithm, bubble sort has a time complexity of O(n?), making it inefficient for larger datasets. Consider using a more efficient sorting algorithm, like Merge Sort or Quick Sort, especially for larger lists of students."
  },
  {
    "student_id": "20723870",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int *rows, int *cols);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                 int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                      int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], \r\n                     int transposed[MAX_SIZE][MAX_SIZE], int *rows, int *cols);\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], C[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    printf(\"Matrix A Input:\\n\");\r\n    inputMatrix(A, &rowsA, &colsA);\r\n\r\n    printf(\"Matrix B Input:\\n\");\r\n    inputMatrix(B, &rowsB, &colsB);\r\n\r\n    while(choice != 5) {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //switch cases to choose functions\r\n        switch(choice) {\r\n            case 1:\r\n                if (rowsA != rowsB || colsA != colsB) { //checking if same dimension\r\n                    printf(\"Error: Matrices must have the same dimensions for addition.\\n\");\r\n                } else {\r\n                    addMatrices(A, B, C, rowsA, colsA);\r\n                    printf(\"Result of Matrix Addition:\\n\");\r\n                    printMatrix(C, rowsA, colsA);\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA != rowsB || colsA != colsB) { //checking if same dimension\r\n                    printf(\"Error: Matrices must have the same dimensions for subtraction.\\n\");\r\n                } else {\r\n                    subtractMatrices(A, B, C, rowsA, colsA);\r\n                    printf(\"Result of Matrix Subtraction:\\n\");\r\n                    printMatrix(C, rowsA, colsA);\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(A, C, &rowsA, &colsA);\r\n                printf(\"Transposed Matrix A:\\n\");\r\n                printMatrix(C, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(B, C, &rowsB, &colsB);\r\n                printf(\"Transposed Matrix B:\\n\");\r\n                printMatrix(C, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                break; //exit code\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } \r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input matrix dimensions and elements\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int *rows, int *cols) { //byref for rows and cols to check num of rows and cols\r\n    while (*rows < 1 || *rows > MAX_SIZE) { //ensure row doesnt go above limit (input validation)\r\n        printf(\"Enter number of rows (1-10): \");\r\n        scanf(\"%d\", rows);\r\n    };\r\n\r\n    while (*cols < 1 || *cols > MAX_SIZE){ //(input validation)\r\n        printf(\"Enter number of columns (1-10): \");\r\n        scanf(\"%d\", cols);\r\n    };\r\n\r\n    printf(\"Enter matrix elements:\\n\");\r\n    for (int i = 0; i < *rows; i++) { //input elements by iterating through matrice rows and columns\r\n        for (int j = 0; j < *cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { //iterate through matrice and print\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                 int C[MAX_SIZE][MAX_SIZE], int rows, int cols) { // C is result matrix\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] + B[i][j]; //elem in A + elem in B = elem in C\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                      int C[MAX_SIZE][MAX_SIZE], int rows, int cols) { // C is result matrix\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] - B[i][j]; //elem in B - elem in A = elem in C\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], \r\n                     int transposed[MAX_SIZE][MAX_SIZE], int *rows, int *cols) {//\r\n    // Swap rows and columns for transpose\r\n    int temp = *rows;\r\n    *rows = *cols;\r\n    *cols = temp;\r\n\r\n    for (int i = 0; i < *rows; i++) {\r\n        for (int j = 0; j < *cols; j++) {\r\n            transposed[i][j] = matrix[j][i];//swapping rows and columns (i and j)\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus availability[MAX_ITEMS];\r\n    int totalItems;\r\n} Inventory;\r\n\r\nInventory inventory = {0};\r\n\r\n// Function Prototypes\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    while (choice != 5) {\r\n        printf(\"Grocery Inventory Management\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        \r\n        scanf(\"%d\", &choice);\r\n      \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    };\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem() {\r\n    if (inventory.totalItems >= MAX_ITEMS) {//check if item more than 100\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n    //using fgets for string inputs as per reccomendation from AI and forums\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    getchar();\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar();\r\n\r\n    inventory.items[inventory.totalItems] = newItem;\r\n    \r\n    inventory.availability[inventory.totalItems].inStock = (newItem.quantity > 0);//if item greater than 0 set to true\r\n    inventory.availability[inventory.totalItems].outOfStock = (newItem.quantity == 0);//if item 0 set to true\r\n\r\n    inventory.totalItems++;//incerement totalitems\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems() {\r\n    if (inventory.totalItems == 0) { //check if empty\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Inventory\\n\");\r\n    printf(\"%-20s %-15s %-10s %-10s %-15s\\n\\n\", \r\n           \"Name\", \"Category\", \"Quantity\", \"Price\", \"Availability\");\r\n \r\n\r\n    for (int i = 0; i < inventory.totalItems; i++) {\r\n        GroceryItem item = inventory.items[i];\r\n        char* status = inventory.availability[i].inStock ? \"In Stock\" : \"Out of Stock\"; //switch case to print avaibality of stock\r\n        \r\n        printf(\"%-20s %-15s %-10d $%-9.2f %-15s\\n\", \r\n               item.name, item.category, item.quantity, item.price, status);\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char itemName[MAX_NAME_LENGTH]; //temp var to store item to be updated\r\n    \r\n    printf(\"Enter Item Name to Update Quantity: \");\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0; //remove \\n\r\n\r\n    for (int i = 0; i < inventory.totalItems; i++) {\r\n        if (strcmp(inventory.items[i].name, itemName) == 0) {\r\n            int newQuantity;\r\n            printf(\"Current Quantity: %d\\n\", inventory.items[i].quantity);\r\n            printf(\"Enter New Quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n            \r\n\r\n            inventory.items[i].quantity = newQuantity; //update item quantity with newQuantity\r\n            \r\n            inventory.availability[i].inStock = (newQuantity > 0);\r\n            inventory.availability[i].outOfStock = (newQuantity == 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    char itemName[MAX_NAME_LENGTH]; //to store item to be removed\r\n    \r\n    printf(\"Enter Item Name to Remove: \");\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory.totalItems; i++) {\r\n        if (strcmp(inventory.items[i].name, itemName) == 0) {\r\n            for (int j = i; j < inventory.totalItems - 1; j++) {\r\n                inventory.items[j] = inventory.items[j+1];\r\n                inventory.availability[j] = inventory.availability[j+1];//move item to left to fill gap\r\n            }\r\n            \r\n            inventory.totalItems--;//decrement totalitem\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));     // Allocate memory for a new student node using malloc\r\n    \r\n    // memory error handling\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    \r\n    \r\n    strcpy(newStudent->name, name); // Copy name, set ID and grade\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;//initiliase null pointer to null\r\n    \r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n   \r\n    Student* newStudent = createStudent(name, id, grade); //calling createStudent\r\n    \r\n    if (newStudent == NULL) return;//malloc handling\r\n    \r\n    \r\n    if (head == NULL) { //if list empty\r\n        head = newStudent; //make node head\r\n        printf(\"Student record inserted successfully.\\n\");\r\n        return;\r\n    }\r\n    \r\n    \r\n    Student* current = head;//make as last node\r\n    while (current->next != NULL) {\r\n        current = current->next;\r\n    }\r\n    current->next = newStudent;\r\n    \r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    \r\n    if (head == NULL) { //check if list empty\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    \r\n    Student* current = head; //point at the head of the list \r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current != NULL) { //loop through each node until it point to null (end)\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; //update current pointer to next \r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    // Traverse the list to find matching ID\r\n    Student* current = head;\r\n    while (current != NULL) { //loop through pointer\r\n        if (current->id == id) {\r\n            return current; //return node if match\r\n        }\r\n        current = current->next;\r\n    }\r\n    \r\n    \r\n    return NULL;//return null if no match\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    while (current != NULL) { //loop through list to free\r\n        next = current->next; \r\n        free(current); //free current node\r\n        current = next;\r\n    }\r\n    \r\n    head = NULL;\r\n}\r\n\r\n// Function to free memory when exiting\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade\r\nvoid sortStudents() {\r\n    // If list is empty or has only one element, no sorting needed\r\n    if (head == NULL || head->next == NULL) {//check list empty or has only one node\r\n        printf(\"Not enough node to be sorted\\n\");\r\n        return;\r\n    }\r\n    \r\n    int swapped;\r\n    Student* current;\r\n    Student* last = NULL;\r\n    \r\n    do { //loop until swapped != 0\r\n        swapped = 0;\r\n        current = head;\r\n        \r\n        while (current->next != last) {\r\n            if (current->grade > current->next->grade) {//swapping if current node bigger than node after\r\n                //bubble sort implementation logic\r\n                Student temp;\r\n                strcpy(temp.name, current->name);\r\n                temp.id = current->id;\r\n                temp.grade = current->grade;\r\n                \r\n                strcpy(current->name, current->next->name);\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade;\r\n                \r\n                strcpy(current->next->name, temp.name);\r\n                current->next->id = temp.id;\r\n                current->next->grade = temp.grade;\r\n                \r\n                swapped = 1;\r\n            }\r\n            current = current->next;//set current to next node\r\n        }\r\n        last = current;\r\n    }while(swapped) ;\r\n    \r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    \r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    \r\n    return 0;\r\n}",
    "feedback": "q1- In the inputMatrix function, the initial values of *rows and *cols are uninitialized. This could lead to an infinite loop if the values are not set properly before input validation checks.\nq2-The variable choice in main() is not initialized before use, which could lead to unpredictable behavior. It should be initialized to a default value, such as 0 or 5.\nq3-The program uses Bubble Sort to sort student records by grade. While this algorithm is straightforward and easy to understand, it has a time complexity of O(n?), making it inefficient for larger datasets. For improved performance, consider implementing more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20682988",
    "code": "\n/* --- Q1.c/Q1.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#define MAX_SIZE 10\n\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n\tint A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\n\tint rowsA,colsA, rowsB, colsB;\n\tint choice;\n\n\tprintf(\"Enter dimensions for Matrix A (rows and columns): \");\n\tscanf(\"%d %d\", &rowsA, &colsA);\n//matrix dimensions validation for A\n\twhile (rowsA>MAX_SIZE||colsA>MAX_SIZE||rowsA<=0||colsA<=0) {\n\t\tprintf(\"Invalid dimensions. Exiting!\\n\");\n\t\tscanf(\"%d %d\",&rowsA,&colsA);\n\t}\n\tprintf(\"Enter elements for Matrix A:\\n\");\n\tinputMatrix(A,rowsA,colsA);\n\n\tprintf(\"Enter dimensions for Matrix B (rows and columns): \");\n\tscanf(\"%d %d\", &rowsB, &colsB);\n//matrix dimensions validation for B\n\twhile(rowsB>MAX_SIZE||colsB>MAX_SIZE||rowsB<=0||colsB<=0)  {\n\t\tprintf(\"Invalid dimensions. Exiting!\\n\");\n\t\tscanf(\"%d %d\",&rowsB,&colsB);\n\t}\n\tprintf(\"Enter elements for Matrix B:\\n\");\n\tinputMatrix(B,rowsB,colsB);\n\n\tdo {\n\t\tprintf(\"\\nMatrix Operations Menu:\\n\");\n\t\tprintf(\"1. Add Matrices\\n\");\n\t\tprintf(\"2. Subtract Matrices\\n\");\n\t\tprintf(\"3. Transpose Matrix A\\n\");\n\t\tprintf(\"4. Transpose Matrix B\\n\");\n\t\tprintf(\"5. Exit\\n\");\n\t\tprintf(\"Enter your choice:\");\n\t\tscanf(\"%d\",&choice);\n\n\t\tswitch(choice) {\n\t\tcase 1://add\n\t\t\tif(rowsA==rowsB&&colsA==colsB) {\n\t\t\t\taddMatrices(A,B,result,rowsA,rowsB);\n\t\t\t\tprintf(\"Result of Matrix A + Matrix B:\\n\");\n\t\t\t\tdisplayMatrix(result,rowsA,colsA);\n\t\t\t} else {\n\t\t\t\tprintf(\"Error!Matrices must have the same dimensions for addition.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 2://subtract\n\t\t\tif(rowsA==rowsB&&colsA==colsB) {\n\t\t\t\tsubtractMatrices(A,B,result,rowsA,rowsB);\n\t\t\t\tprintf(\"Result of Matrix A - Matrix B:\\n\");\n\t\t\t\tdisplayMatrix(result,rowsA,colsA);\n\t\t\t} else {\n\t\t\t\tprintf(\"Error!Matrices must have the same dimensions for suntraction.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3://transpose for A\n\t\t\ttransposeMatrix(A,result,rowsA,colsA);\n\t\t\tprintf(\"Transpose of Matrix A:\\n\");\n\t\t\tdisplayMatrix(result,colsA,rowsA);\n\t\t\tbreak;\n\n\t\tcase 4://transpose for B\n\t\t\ttransposeMatrix(B,result,rowsB,colsB);\n\t\t\tprintf(\"Transpose of Matrix B:\\n\");\n\t\t\tdisplayMatrix(result,colsB,rowsB);\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tprintf(\"Exiting…\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintf(\"Invalid choice!Please try again.\\n\");\n\t\t}\n\t} while (choice!=5);\n\treturn 0;\n}\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n\tfor (int i=0; i<rows; i++) {\n\t\tfor(int j=0; j<cols; j++) {\n\t\t\tprintf(\"Element [%d][%d]:\",i+1,j+1);\n\t\t\tscanf(\"%d\",&matrix[i][j]);\n\t\t}\n\t}\n}\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n\tfor (int i=0; i<rows; i++) {\n\t\tfor(int j=0; j<cols; j++) {\n\t\t\tprintf(\"%d\",matrix[i][j]);\n\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n\tfor (int i=0; i<rows; i++) {\n\t\tfor(int j=0; j<cols; j++) {\n\t\t\tresult[i][j]=A[i][j]+B[i][j];\n\t\t}\n\t}\n}\n\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n\tfor (int i=0; i<rows; i++) {\n\t\tfor(int j=0; j<cols; j++) {\n\t\t\tresult[i][j]=A[i][j]-B[i][j];\n\t\t}\n\t}\n}\n\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n\tfor (int i=0; i<rows; i++) {\n\t\tfor(int j=0; j<cols; j++) {\n\t\t\ttransposed[j][i]=matrix[i][j];\n\t\t}\n\t}\n}\n\n/* --- Q1.c/__MACOSX/._Q1.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0001\u0000\u0000\u0000\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0001\f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0001\f\u0000\u0000\u0000\u0010\u0000\u0000\u001acom.apple.lastuseddate#PS\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u001c\u0000\u0000\u0000H\u0000\u0000\u000fcom.apple.macl\u0000\u0000\u0000\u0000\u0000\u0001d\u0000\u0000\u0000p\u0000\u0000%com.apple.metadata:kMDItemWhereFroms\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0018\u0000\u0000\u0015com.apple.quarantine\u0000\rO\\g\u0000\u0000\u0000\u0000\u001d\u000e\u0000\u0000\u0000\u0000\u0006\u0000vfJ\u0016Dٯ\u0006\u0000`\"nL\u001c%ɸB\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000bplist00\u0001\u0002_\u0010\"https://www.onlinegdb.com/download_\u0010\u001ahttps://www.onlinegdb.com/\b\u000b0\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000Mq/0081;67585f71;Chrome;\u0000\n/* --- Q2.c/Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#define MAX_NAME_LENGTH 100\n#define MAX_CATEGORY_LENGTH 50\n#define MAX_ITEMS 100\n//struct definitions\nstruct GroceryItem {\n\tchar name[MAX_NAME_LENGTH];\n\tchar category[MAX_CATEGORY_LENGTH];\n\tint quantity;\n\tfloat price;\n};\n\nstruct AvailabilityStatus {\n\tbool inStock;\n\tbool outOfStock;\n};\n\nstruct GroceryItem groceryInventory[MAX_ITEMS];\nstruct AvailabilityStatus availability[MAX_ITEMS];\nint itemCount = 0;\n//addGroceryItem function\nvoid addGroceryItem() {\n\tif(itemCount>=MAX_ITEMS) {\n\t\tprintf(\"Inventory is full.Cannot add items.\\n\");\n\t\treturn;//check if the inventory is full!\n\t}\n\n\tstruct GroceryItem newItem;\n\tprintf(\"Enter Item Name: \");\n\tfgets(newItem.name, MAX_NAME_LENGTH, stdin);\n\tstrtok(newItem.name, \"\\n\") ; //remove newline\n\n\tprintf(\"Enter Category: \");\n\tfgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\n\tstrtok(newItem.category,\"\\n\") ;\n\n\tprintf(\"Enter Quantity: \");\n\tscanf(\"%d\", &newItem.quantity);\n\tprintf(\"Enter Price: \");\n\tscanf(\"%f\", &newItem.price);\n\tgetchar();\n\n\tgroceryInventory[itemCount] = newItem;\n\tavailability[itemCount].inStock = newItem.quantity > 0;\n\tavailability[itemCount].outOfStock = newItem.quantity == 0;\n\n\titemCount++;\n\tprintf(\"Grocery item added successfully!\\n\");\n}\n//listGroceryItems function\nvoid listGroceryItems() {\n\tif (itemCount == 0) {\n\t\tprintf(\"No grocery items in the inventory.\\n\");//check if there are some items in the inventory!\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < itemCount; i++) {\n\t\tprintf(\"Name: %s\\n\", groceryInventory[i].name);\n\t\tprintf(\"Category: %s\\n\", groceryInventory[i].category);\n\t\tprintf(\"Quantity: %d\\n\", groceryInventory[i].quantity);\n\t\tprintf(\"Price: %.2f\\n\", groceryInventory[i].price);\n\t\tprintf(\"Status: %s\\n\", availability[i].inStock ? \"In Stock\" : \"Out of Stock\");\n\t\tprintf(\"-------------------------------\\n\");\n\t}\n}\n//updateQuantity function\nvoid updateQuantity() {\n\tif (itemCount == 0) {\n\t\tprintf(\"No grocery items in the inventory.\\n\");\n\t\treturn;\n\t}\n\n\tchar itemName[MAX_NAME_LENGTH];\n\tprintf(\"Enter name of the grocery item to update quantity: \");\n\tfgets(itemName, MAX_NAME_LENGTH, stdin);\n\tstrtok(itemName,\"\\n\");\n\n\tint itemIndex = -1;\n\tfor (int i = 0; i < itemCount; i++) {\n\t\tif (strcmp(groceryInventory[i].name, itemName) == 0) {\n\t\t\titemIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (itemIndex == -1) {\n\t\tprintf(\"Item '%s' not found in the inventory.\\n\", itemName);//check if the items exists\n\t\treturn;\n\t}\n\tint newQuantity;\n\tprintf(\"Enter new quantity for %s: \", itemName);\n\tscanf(\"%d\", &newQuantity);\n\tgetchar();\n\n\tgroceryInventory[itemIndex].quantity = newQuantity;\n\tavailability[itemIndex].inStock = newQuantity > 0;//if the quantity is more than one ,that means it's instock\n\tavailability[itemIndex].outOfStock = newQuantity == 0;//if the quantity is one ,that means it's out of stock\n\n\tprintf(\"Quantity updated successfully!\\n\");\n}\n//removeGroceryItem function\nvoid removeGroceryItem() {\n\tif (itemCount == 0) {\n\t\tprintf(\"No grocery items in the inventory.\\n\");\n\t\treturn;\n\t}\n\n\tchar itemName[MAX_NAME_LENGTH];\n\tprintf(\"Enter name of the grocery item to remove: \");\n\tfgets(itemName, MAX_NAME_LENGTH, stdin);\n\tstrtok(itemName,\"\\n\");\n\n\tint itemIndex = -1;\n\tfor (int i = 0; i < itemCount; i++) {\n\t\tif (strcmp(groceryInventory[i].name, itemName) == 0) {//compare name with groceryInventory\n\t\t\titemIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (itemIndex == -1) {\n\t\tprintf(\"Item '%s' not found in the inventory.\\n\", itemName);\n\t\treturn;\n\t}\n\n\tfor (int i = itemIndex; i < itemCount - 1; i++) {\n\t\tgroceryInventory[i] = groceryInventory[i + 1];\n\t\tavailability[i] = availability[i + 1];\n\t}\n\n\titemCount--;\n\tprintf(\"Grocery item '%s' removed successfully!\\n\", itemName);\n}\n\n//main program loop\nint main() {\n\tint choice;\n\n\tdo {\n\t\tprintf(\"\\nGrocery Inventory Management System\\n\");\n\t\tprintf(\"1. Add Grocery Item\\n\");\n\t\tprintf(\"2. List All Grocery Items\\n\");\n\t\tprintf(\"3. Update Quantity\\n\");\n\t\tprintf(\"4. Remove Grocery Item\\n\");\n\t\tprintf(\"5. Exit\\n\");\n\t\tprintf(\"Enter your choice: \");\n\t\tscanf(\"%d\", &choice);\n\t\tgetchar();\n\n\t\tswitch(choice) {\n\t\tcase 1:\n\t\t\taddGroceryItem();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlistGroceryItems();\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tupdateQuantity();\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tremoveGroceryItem();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"Exiting!\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Invalid choice!Please try again.\\n\");\n\t\t}\n\t} while(choice!=5);\n\treturn 0;\n}\n\n\n\n\n/* --- Q2.c/__MACOSX/._Q2.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0001\u0000\u0000\u0000\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0001\f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0001\f\u0000\u0000\u0000\u0010\u0000\u0000\u001acom.apple.lastuseddate#PS\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u001c\u0000\u0000\u0000H\u0000\u0000\u000fcom.apple.macl\u0000\u0000\u0000\u0000\u0000\u0001d\u0000\u0000\u0000~\u0000\u0000%com.apple.metadata:kMDItemWhereFroms\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0018\u0000\u0000\u0015com.apple.quarantine\u0000U\\g\u0000\u0000\u0000\u0000?K\u001b\u0000\u0000\u0000\u0000\u0006\u0000vfJ\u0016Dٯ\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000bplist00\u0001\u0002_\u0010\"https://www.onlinegdb.com/download_\u0010(https://www.onlinegdb.com/edit/QmejUAbqX\b\u000b0\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000[q/0081;675c5582;Chrome;\u0000\n/* --- Q3.c/Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n\tchar name[100];\n\tint id;\n\tfloat grade;    \n\tstruct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n\tStudent* newStudent=(Student*)malloc(sizeof(Student));\n\tif(newStudent==NULL) {\n\t\tprintf(\"Memory allocation failed!!\\n\");//check the memory allocation\n\t\treturn NULL;\n\t}\n\tstrcpy(newStudent->name,name);\n\tnewStudent->id=id;\n\tnewStudent->grade=grade;//copy name,id,grade\n\tnewStudent->next=NULL;\n\treturn newStudent;\n}\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n\tStudent* newStudent=createStudent(name,id,grade);\n\tif(newStudent==NULL)\n\t\treturn;\n\tnewStudent->next=head;\n\thead=newStudent;\n}\n\n// Function to display all student records\nvoid displayStudents() {\n\tif(head==NULL) {\n\t\tprintf(\"No records to display!\\n\");\n\t\treturn;//check if the list is empty\n\t}\n\n\tStudent* current=head;\n\twhile(current!=NULL) {//this loop will end if current is NULL\n\t\tprintf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n\t\t       current=current->next;//move to next\n\t}\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n\tStudent* current=head;\n\twhile(current!=NULL) {\n\t\tif(current->id==id){\n\t\t    return current;\n\t\t}\n\t\tcurrent=current->next;\n\t}\n\treturn NULL;\n}\n// Function to delete the entire list\nvoid deleteList() {\n\tStudent* current = head;\n\tStudent* next;\n\twhile (current != NULL) {\n\t\tnext = current->next;\n\t\tfree(current);//free the current \n\t\tcurrent = next;\n\t}\n\thead = NULL;\n}\nvoid freeMemory() {\n\tdeleteList();//deleteList()to free the memory\n}\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() {\n    if(head==NULL||head->next==NULL){//check if the list is empty or only has one\n        printf(\"No records to sort!\\n\");\n        return;\n    }\n    \n}\n\n// Main function to drive the program\nint main() {\n\tint choice, id;\n\tchar name[100];\n\tfloat grade;\n\tdo {\n\t\tprintf(\"\\n1. Insert Student Record\\n\");\n\t\tprintf(\"2. Display Student Records\\n\");\n\t\tprintf(\"3. Sort Records (choose sorting method)\\n\");\n\t\tprintf(\"4. Search Record by ID\\n\");\n\t\tprintf(\"5. Delete List\\n\");\n\t\tprintf(\"6. Exit\\n\");\n\t\tprintf(\"Enter your choice: \");\n\t\tscanf(\"%d\", &choice);\n\t\tgetchar(); // To consume the newline character\n\n\t\tswitch (choice) {\n\t\tcase 1:\n\t\t\tprintf(\"Enter Name: \");\n\t\t\tfgets(name, sizeof(name), stdin);\n\t\t\tstrtok(name, \"\\n\");\n\n\t\t\tprintf(\"Enter ID: \");\n\t\t\tscanf(\"%d\", &id);\n\n\t\t\tprintf(\"Enter Grade: \");\n\t\t\tscanf(\"%f\", &grade);\n\n\t\t\tinsertStudent(name, id, grade);\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tdisplayStudents();\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tsortStudents();\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tprintf(\"Enter ID to search: \");\n\t\t\tscanf(\"%d\", &id);\n\t\t\tStudent* found = searchStudentByID(id);\n\n\t\t\tif (found) {\n\t\t\t\tprintf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\n\t\t\t\t       found->name, found->id, found->grade);\n\t\t\t} else {\n\t\t\t\tprintf(\"Student not found.\\n\");\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 5:\n\t\t\tdeleteList();\n\t\t\tprintf(\"List deleted.\\n\");\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tfreeMemory();\n\t\t\tprintf(\"Exiting...\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"Invalid choice! Please try again.\\n\");\n\t\t}\n\n\t} while (choice != 6);\n\treturn 0;\n}\n/* --- Q3.c/__MACOSX/._Q3.c --- */\n\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0001\u0000\u0000\u0000\u0002\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0001\f\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0004\u0000\u0000\u0001\f\u0000\u0000\u0000\u0010\u0000\u0000\u001acom.apple.lastuseddate#PS\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u001c\u0000\u0000\u0000H\u0000\u0000\u000fcom.apple.macl\u0000\u0000\u0000\u0000\u0000\u0001d\u0000\u0000\u0000\u0000\u0000%com.apple.metadata:kMDItemWhereFroms\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0018\u0000\u0000\u0015com.apple.quarantine\u0000\u0016U\\g\u0000\u0000\u0000\u0000>\u000b\u0000\u0000\u0000\u0000\u0006\u0000vfJ\u0016Dٯ\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000bplist00\u0001\u0002_\u0010\"https://www.onlinegdb.com/download_\u0010)https://www.onlinegdb.com/edit/Su3sLCKRwn\b\u000b0\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\\q/0081;675c54df;Chrome;\u0000",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function is currently empty. You need to implement a sorting algorithm (e.g., Bubble Sort, Merge Sort) to sort the student records by grade."
  },
  {
    "student_id": "20712310",
    "code": "\n/* --- Q1.c --- */\n\n#include <stdio.h>\n\n#define MAX_SIZE 10\n\n// Function declarations\nvoid inputMatrix(int matrix[][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[][MAX_SIZE], int transposed[][MAX_SIZE], int rows, int cols);\nvoid printMatrix(int matrix[][MAX_SIZE], int rows, int cols);\n\n// Define A,B,result,rows and colomns\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\n    int rows, cols;\n\n    while (1) {\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\n        scanf(\"%d %d\", &rows, &cols);\n        inputMatrix(A, rows, cols);\n\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\n        scanf(\"%d %d\", &rows, &cols);\n        inputMatrix(B, rows, cols);\n\n//user selection variable\n        int choice;\n        do {\n            printf(\"\\nMatrix Operations Menu:\\n\");\n            printf(\"1. Add Matrices\\n\");\n            printf(\"2. Subtract Matrices\\n\");\n            printf(\"3. Transpose Matrix A\\n\");\n            printf(\"4. Transpose Matrix B\\n\");\n            printf(\"5. Exit\\n\");\n            printf(\"Enter your choice: \");\n            scanf(\"%d\", &choice);\n\n//operation of different variables\n\n            switch (choice) {\n                case 1:\n                    addMatrices(A, B, result, rows, cols);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    printMatrix(result, rows, cols);\n                    break;\n                case 2:\n                    subtractMatrices(A, B, result, rows, cols);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    printMatrix(result, rows, cols);\n                    break;\n                case 3:\n                    transposeMatrix(A, result, rows, cols);\n                    printf(\"Transpose of Matrix A:\\n\");\n                    printMatrix(result, cols, rows);\n                    break;\n                case 4:\n                    transposeMatrix(B, result, rows, cols);\n                    printf(\"Transpose of Matrix B:\\n\");\n                    printMatrix(result, cols, rows);\n                    break;\n                case 5:\n                    printf(\"Exiting...\\n\");\n                    return 0;\n                default:\n                    printf(\"Invalid choice. Please try again.\\n\");\n            }\n        } while (choice != 5);\n    }\n    return 0;\n}\n\n\n// Function definitions\nvoid inputMatrix(int matrix[][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid addMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int A[][MAX_SIZE], int B[][MAX_SIZE], int result[][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int matrix[][MAX_SIZE], int transposed[][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\nvoid printMatrix(int matrix[][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n/* --- Q2.c --- */\n\n#include <stdio.h>\n#include <string.h>\n\n// define the  largest number of grocery\n#define MAX_ITEMS 100\n\n// define the single item\ntypedef struct {\n    char name[101];\n    char category[51];\n    int quantity;\n    float price;\n    int inStock; // 1 for In Stock, 0 for Out of Stock\n} GroceryItem;\n\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    int itemCount;\n} GroceryInventory;\n\n// five functions\n\nvoid addGroceryItem(GroceryInventory *inventory);\nvoid listAllGroceryItems(GroceryInventory *inventory);\nvoid updateQuantity(GroceryInventory *inventory);\nvoid removeGroceryItem(GroceryInventory *inventory);\nvoid printGroceryItem(const GroceryItem *item);\n\nint main() {\n\n// initializ inventory as 0\n    GroceryInventory inventory = { .itemCount = 0 };\n    int choice;\n\n//loop\n\n    while (1) {\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Consume newline\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory);\n                break;\n            case 2:\n                listAllGroceryItems(&inventory);\n                break;\n            case 3:\n                updateQuantity(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                return 0;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    }\n    return 0;\n}\n\n//declare concrete function\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->itemCount >= MAX_ITEMS) {\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n    GroceryItem newItem;\n    printf(\"Enter Item Name: \");\n    fgets(newItem.name, sizeof(newItem.name), stdin);\n    strtok(newItem.name, \"\\n\");\n    printf(\"Enter Category: \");\n    fgets(newItem.category, sizeof(newItem.category), stdin);\n    strtok(newItem.category, \"\\n\");\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n    getchar(); // Consume newline\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &newItem.price);\n    getchar(); // Consume newline\n    newItem.inStock = newItem.quantity > 0;\n    inventory->items[inventory->itemCount++] = newItem;\n    printf(\"Grocery item added successfully!\\n\");\n}\n\nvoid listAllGroceryItems(GroceryInventory *inventory) {\n    for (int i = 0; i < inventory->itemCount; i++) {\n        printGroceryItem(&inventory->items[i]);\n    }\n    if (inventory->itemCount == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n    }\n}\n\nvoid updateQuantity(GroceryInventory *inventory) {\n    char name[101];\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets(name, sizeof(name), stdin);\n    strtok(name, \"\\n\");\n    for (int i = 0; i < inventory->itemCount; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            printf(\"Enter new quantity for %s: \", name);\n            scanf(\"%d\", &inventory->items[i].quantity);\n            getchar(); // Consume newline\n            inventory->items[i].inStock = inventory->items[i].quantity > 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Grocery item not found.\\n\");\n}\n\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    char name[101];\n    printf(\"Enter name of the grocery item to remove: \");\n    fgets(name, sizeof(name), stdin);\n    strtok(name, \"\\n\");\n    for (int i = 0; i < inventory->itemCount; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            for (int j = i; j < inventory->itemCount - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n            }\n            inventory->itemCount--;\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\n            return;\n        }\n    }\n    printf(\"Grocery item not found.\\n\");\n}\n\nvoid printGroceryItem(const GroceryItem *item) {\n    printf(\"Name: %s\\n\", item->name);\n    printf(\"Category: %s\\n\", item->category);\n    printf(\"Quantity: %d\\n\", item->quantity);\n    printf(\"Price: %.2f\\n\", item->price);\n    printf(\"Status: %s\\n\", item->inStock ? \"In Stock\" : \"Out of Stock\");\n}\n/* --- Q3.c --- */\n/******************************************************************************\n\nWelcome to GDB Online.\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\nC#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\nCode, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function declarations\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid freeMemory();\nvoid sortStudents();\nStudent* createStudent(const char* name, int id, float grade);\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (newStudent == NULL) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted successfully.\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    Student* current = head;\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\n// Function to free memory\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade using Bubble Sort\nvoid sortStudents() {\n    int swapped;\n    Student *ptr1, *lptr;\n\n    do {\n        swapped = 0;\n        ptr1 = head;\n        lptr = NULL;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                char tempName[100];\n                int tempId;\n                float tempGrade;\n                strcpy(tempName, ptr1->name);\n                tempId = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempId;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n            if (ptr1 == head) lptr = ptr1;\n        }\n    } while (swapped);\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}",
    "feedback": "q1-The dimensions for matrix B are reused for input and operations. When calling the transpose function for matrix B, the dimensions should reflect its actual rows and cols, which were set initially for matrix A.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. However, it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20618865",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#define MAX_SIZE 10\n\nvoid add_matrices(int row, int col, int A[][col], int B[][col]) {\n    int result[row][col]; //declare another matrix of the same size for storing addition result \n    //use nested for loop to access each element in matrix A and matrix B\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n\n    //nested for loop to display each element of the added matrix\n    printf(\"Result of Matrix A + Matrix B:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d  \", result[i][j]);\n        }\n        printf(\"\\n\"); //print newline after each row\n    }\n    printf(\"\\n\"); //print newline after the whole matrix is displayed\n}\n\nvoid subtract_matrices(int row, int col, int A[][col], int B[][col]) {\n    int result[row][col]; //declare another matrix of the same size for storing subtraction result\n    //use nested for loop to access each element in matrix A and matrix B\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n\n    //nested for loop to display each element of the subtracted matrix\n    printf(\"Result of Matrix A - Matrix B:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d  \", result[i][j]);\n        }\n        printf(\"\\n\"); //print newline after each row\n    }\n    printf(\"\\n\"); //print newline after the whole matrix is displayed\n}\n\nvoid transpose_matrix(int row, int col, char name, int matrix[][col]) {\n    int transpose[col][row]; //declare another matrix of the same size for storing transposed matrix\n\n    // Computing the transpose\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            transpose[j][i] = matrix[i][j];\n        }\n    }\n\n    // Print the transpose\n    printf(\"Transpose of Matrix %c:\\n\", name);\n    for (int i = 0; i < col; i++) { // Loop over columns\n        for (int j = 0; j < row; j++) {\n            printf(\"%d  \", transpose[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int menu_choice;\n\n    // Input for Matrix A\n    int rowA, colA;\n    do {\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\n        scanf(\"%d %d\", &rowA, &colA);\n        getchar(); //consume newline character\n\n        //check whether row and col inputted are valid\n        if (rowA <= 0 || rowA > MAX_SIZE || colA <= 0 || colA > MAX_SIZE) {\n            printf(\"Invalid dimension. Maximum size: 10x10. Minimum size: 1x1\\n\");\n        }\n    } while (rowA <= 0 || rowA > MAX_SIZE || colA <= 0 || colA > MAX_SIZE); //if invalid, keep asking user to input until it is valid\n\n    int matrixA[rowA][colA]; //declare matrixA of the size inputted by user\n    printf(\"Enter elements for Matrix A:\\n\");\n    //scan each element of Matrix A one by one using nested for loop\n    for (int i = 0; i < rowA; i++) {\n        for (int j = 0; j < colA; j++) {\n            printf(\"Element[%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrixA[i][j]);\n        }\n    }\n\n    // Input for Matrix B\n    int rowB, colB;\n    do {\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\n        scanf(\"%d %d\", &rowB, &colB);\n        getchar(); //consume newline character\n\n        //check whether row and col inputted are valid\n        if (rowB <= 0 || rowB > MAX_SIZE || colB <= 0 || colB > MAX_SIZE) {\n            printf(\"Invalid dimension. Maximum size: 10x10. Minimum size: 1x1\\n\");\n        }\n    } while (rowB <= 0 || rowB > MAX_SIZE || colB <= 0 || colB > MAX_SIZE); //if invalid, keep asking user to input until it is valid\n\n    int matrixB[rowB][colB]; //declare matrixB of the size inputted by user\n    printf(\"Enter elements for Matrix B:\\n\");\n    //scan each element of Matrix B one by one using nested for loop\n    for (int i = 0; i < rowB; i++) {\n        for (int j = 0; j < colB; j++) {\n            printf(\"Element[%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrixB[i][j]);\n        }\n    }\n\n    do {\n        //display menu for at least once\n        printf(\"********* Matrix Operation Menu *********\\n\");\n        printf(\"\\t1. Add Matrices\\n\");\n        printf(\"\\t2. Subtract Matrices\\n\");\n        printf(\"\\t3. Transpose Matrix A\\n\");\n        printf(\"\\t4. Transpose Matrix B\\n\");\n        printf(\"\\t5. Exit\\n\");\n\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &menu_choice);\n        getchar(); //consume newline character\n\n        switch (menu_choice) {\n            case 1:\n                //check dimensions of matrices before addition\n                if (rowA == rowB && colA == colB) {\n                    add_matrices(rowA, colA, matrixA, matrixB);\n                } else {\n                    printf(\"Matrix A and Matrix B are not of the same dimension.\\nAddition cannot be performed.\\n\\n\");\n                }\n                break;\n\n            case 2:\n                //check dimensions of matrices before subtraction\n                if (rowA == rowB && colA == colB) {\n                    subtract_matrices(rowA, colA, matrixA, matrixB);\n                } else {\n                    printf(\"Matrix A and Matrix B are not of the same dimension.\\nSubtraction cannot be performed.\\n\\n\");\n                }\n                break;\n\n            case 3:\n                transpose_matrix(rowA, colA, 'A', matrixA);\n                break;\n\n            case 4:\n                transpose_matrix(rowB, colB, 'B', matrixB);\n                break;\n\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice. Try again.\\n\");\n                break;\n        }\n    } while (menu_choice != 5); //loop back to display menu while user doesn't choose to exit\n\n    return 0;\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_NAME_LEN 100 // Maximum length for item names\n#define MAX_CATEGORY_LEN 50 // Maximum length for category names\n#define MAX_SIZE 100 // Maximum number of items in inventory\n\n// Structure to represent a grocery item\ntypedef struct {\n    char name[MAX_NAME_LEN];\n    char category [MAX_CATEGORY_LEN];\n    int quantity;\n    float price;\n}grocery_item;\n\n//Union to represent the stock status of an item\ntypedef union{\n    bool in_stock;\n    bool out_of_stock;\n}status;\n\n// Structure to represent the grocery inventory\ntypedef struct {\n    grocery_item items[MAX_SIZE]; // Array of grocery items\n    status availability_status[MAX_SIZE]; // Array of availability statuses\n    int counter; // Number of items currently in inventory\n}grocery_inventory;\n\n// Function to read and validate a quantity input from the user\nint read_valid_quantity(void){\n    int quantity;\n    do {\n        scanf(\"%d\", &quantity);\n        getchar(); // Consume newline character\n        \n        if (quantity<0){\n            printf(\"Invalid quantity. Quantity must be >= 0.\\nTry again: \");\n        }\n    }while(quantity<0); //keep asking user to input if the quantity is invalid\n\n    return quantity;\n}\n\nvoid add_item(grocery_inventory *inventory){\n    // Check if the inventory is full\n    if (inventory->counter == MAX_SIZE){\n        printf(\"Inventory fulled. Items cannot be added.\\n\\n\");\n        return;\n    }\n    grocery_item new_grocery; // Temporary variable to hold the new item\n    status new_status; // Temporary variable to hold the new item's status\n\n    // Read item details from the user\n    printf(\"Enter Item Name: \");\n    fgets(new_grocery.name, MAX_NAME_LEN, stdin);\n    new_grocery.name[strcspn(new_grocery.name, \"\\n\")]='\\0'; //remove newline character\n\n    printf(\"Enter category: \");\n    fgets(new_grocery.category, MAX_CATEGORY_LEN, stdin);\n    new_grocery.category[strcspn(new_grocery.category, \"\\n\")]='\\0';\n\n    printf(\"Enter Quantity: \");\n    new_grocery.quantity = read_valid_quantity();\n    \n    printf(\"Enter Price: \");\n    scanf(\"%f\", &new_grocery.price);\n    getchar(); //consume newline character\n\n    // assign the new_grocery struct to the items array at the index \"counter\" of grocery inventory\n    inventory->items[inventory->counter] = new_grocery;\n\n    // Update the availability status based on the quantity\n    if(new_grocery.quantity > 0){\n        new_status.out_of_stock = false;\n    }\n    else{\n        new_status.in_stock = false;\n    }\n\n    inventory->availability_status[inventory->counter] = new_status;\n    inventory->counter ++; //increment the inventory counter\n    printf(\"Grocery item added successfully!\\n\\n\");\n}\n\nvoid list_items(grocery_inventory *inventory){\n    //check whether the inventory is empty\n    if(inventory->counter == 0){\n        printf(\"Inventory is empty. No item to list.\\n\\n\");\n        return;\n    }\n    printf(\"\\n\");\n    printf(\"-----------------------------\\n\");\n    //print the details of each item\n    for (int i=0; i<inventory->counter; i++){\n        printf(\"Item %d\\n\", i+1);\n        printf(\"\\tName: %s\\n\", (inventory->items[i]).name);\n        printf(\"\\tCategory: %s\\n\", (inventory->items[i]).category);\n        printf(\"\\tQuantity: %d\\n\", (inventory->items[i]).quantity);\n        printf(\"\\tPrice: %.2f\\n\", (inventory->items[i]).price);\n        //if quantity of the item is not 0, the status is in stock\n        if((inventory->items[i]).quantity > 0){\n            printf(\"\\tStatus: In Stock\\n\");\n        }\n        //else, the item is out of stock\n        else{\n            printf(\"\\tStatus: Out of Stock\\n\");\n        }\n        printf(\"-----------------------------\\n\");\n    }\n    printf(\"\\n\");\n}\n\nvoid update_quantity (grocery_inventory *inventory){\n    //check whether the inventory is empty\n    if(inventory->counter == 0){\n        printf(\"Inventory is empty. No items to be updated.\\n\\n\");\n        return;\n    }\n\n    char name_to_update[MAX_NAME_LEN];\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets (name_to_update, MAX_NAME_LEN, stdin);\n    name_to_update[strcspn(name_to_update, \"\\n\")] = '\\0'; //remove newline character\n\n    int found = 0; //found flag\n    //search for the item in the inventory\n    for (int i=0; i<inventory->counter; i++){\n        if(strcmp((inventory->items[i]).name, name_to_update)==0){\n\n            //item_to_update == inventory -> items[i]\n            //item_to_update.name == (inventory->items[i]).name\n            //status_to_update == inventory -> availability_status[i]\n            grocery_item *item_to_update = &inventory->items[i]; //use pointer to struct to directly change the quantity\n            status *status_to_update = &inventory->availability_status[i]; //use pointer to struct to directly change the status\n\n            found = 1; //set the flag to indicate item is found\n            printf(\"Current quantity of %s: %d\\n\", item_to_update->name, item_to_update->quantity);\n            printf(\"Enter new quantity for %s: \", item_to_update->name);\n\n            //update the quantity of the searched item\n            item_to_update->quantity = read_valid_quantity();\n\n            //update the availability status of the searched item\n            if (item_to_update->quantity > 0){\n                status_to_update->out_of_stock=false;\n            }\n            else{\n                status_to_update->in_stock=false;\n            }\n            printf(\"\\nQuantity of %s updated to %d.\\n\\n\", item_to_update->name, item_to_update->quantity);\n            return;\n        }\n    }\n    //if flag is not set, item is not found\n    if (!found){\n        printf(\"%s is not found in inventory list\\n\\n\", name_to_update); //display not found message\n        return;\n    }\n}\n\nvoid remove_item(grocery_inventory *inventory){\n    //check whether the inventory is empty\n    if(inventory->counter == 0){\n        printf(\"Inventory list is empty. No items to be deleted.\\n\\n\");\n        return;\n    }\n\n    char name_to_remove[MAX_NAME_LEN];\n    printf(\"Enter name of the grocery item to remove: \");\n    fgets (name_to_remove, MAX_NAME_LEN, stdin);\n    name_to_remove[strcspn(name_to_remove, \"\\n\")] = '\\0'; //remove newline character\n\n    int found = 0; //found flag\n    int id_to_delete = 0;\n\n    //search for the item to remove in inventory\n    for (int i=0; i<inventory->counter; i++){\n        if(strcmp((inventory->items[i]).name, name_to_remove)==0){\n            id_to_delete = i;\n            found =1; //found and set the flag to 1\n        }\n    }\n    //if the flag is not set, item to remove is not found\n    if (!found){\n        printf(\"%s is not found in inventory list\\n\\n\", name_to_remove);\n        return;\n    }\n    //shift the items after the item to be removed to fill the gap left by the removed item\n    for (int i = id_to_delete; i<inventory->counter-1; i++){\n        inventory->items[i] = inventory->items[i+1];\n        inventory->availability_status[i] = inventory->availability_status[i+1];  \n    }\n    inventory->counter--; //decrement the inventory counter\n    printf(\"Item %s is removed successfully.\\n\\n\", name_to_remove);\n}\n\nint main(){\n    int menu_choice;\n    grocery_inventory inventory;\n    inventory.counter=0; // initialize the counter of items to 0\n\n    do{\n        //display menu for at least once\n        printf(\"***** Grocery Inventory Management System *****\\n\");\n        printf(\"\\t1. Add Grocery Items\\n\");\n        printf(\"\\t2. List all Grocery Items\\n\");\n        printf(\"\\t3. Update Quantity\\n\");\n        printf(\"\\t4. Remove Grocery Item\\n\");\n        printf(\"\\t5. Exit\\n\");\n\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &menu_choice);\n        getchar(); //consume newline character\n\n        switch (menu_choice){\n            case 1:\n            add_item(&inventory);\n            break;\n\n            case 2:\n            list_items(&inventory);\n            break;\n\n            case 3:\n            update_quantity(&inventory);\n            break;\n\n            case 4:\n            remove_item(&inventory);\n            break;\n\n            case 5:\n            printf(\"Thank you for using Grocery Inventory Management System.\\nTerminating program...\\n\");\n            break;\n\n            default:\n            printf(\"Invalid choice.\\n\\n\");\n            break;\n        }\n    }while(menu_choice != 5); //keep looping back to display menu if user doesn't choose to exit\n\n    return 0;\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//Structure for Student\ntypedef struct Student{\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;   // Pointer to the next node in the list\n}Student;\n\n\nStudent* globalHead = NULL; //refer to pointer to the start of linked list\n\n//Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade){\n    Student* newNode = (Student*)malloc(sizeof(Student)); //allocate memory for newNode\n    if (!newNode){\n        perror(\"Memory Allocation failed.\\n\"); //display error message and exit is memory allocation fail\n        exit(1);\n    }\n    // Initialize the new node with given data\n    strcpy(newNode->name, name);    //place name in node\n    newNode->id = id;               //place id in node\n    newNode->grade = grade;         //place grade in node\n    newNode->next = NULL;           //set next pointer to NULL, node does not link to another node\n    return newNode;                 \n}\n\n//Function to insert a new student record\n//The function takes a double pointer (Student **head) \n//because the head pointer itself is being updated. \n//By passing a pointer to the head, the function can directly modify the head pointer \n//in the calling function.\nvoid insertStudent (Student** head, const char* name, int id, float grade){\n    Student* newNode = createStudent(name, id, grade);  //assign the new node created to newNode\n    newNode->next = *head;                              //link newNode to the current head\n    *head = newNode;                                    // Update head to point to the new node\n}\n\n//Function to display all student records\nvoid displayStudents(Student* node){\n    if(node == NULL){ //check whether the list is empty\n        printf(\"Record is empty. No record to display.\\n\");\n        return;\n    }\n    while(node!=NULL){\n        //display the first node in the list and move to the next node until the node is NULL\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", node->name, node->id, node->grade);\n        node = node->next;\n    }\n}\n\n//Function to search for a student by ID\nStudent* searchStudentByID (int id){\n    Student *search = globalHead;\n    //loop from the beginning of the list to compare the target id with the id in each node\n    while(search!=NULL){    // Traverse the list\n        if(search->id == id){\n            return search;  //if found, return the node\n        }\n        search=search->next;//else, assign the next node to the current node\n    }\n    return NULL; //if not found, return NULL\n}\n\n//Function to delete the entire list\nvoid deleteList(Student** head){\n    Student* current = *head;   //begin at the head of the list\n    Student* next;              //declare temporary pointer to store the next node\n\n    while(current!=NULL){\n        next=current->next;     //store the next node\n        free(current);          //free current node\n        current=next;           //move to the next node\n    }\n    *head = NULL;               //assign NULL to head pointer to show that the list is now empty\n    \n}\n\n//Function to split the linked list into two halves\nStudent* split(Student *head){\n    Student* fast = head;   // Fast pointer moves two steps at a time\n    Student* slow = head;   // Slow pointer moves two steps at a time\n\n    // Move fast pointer two steps and slow pointer one step until fast reaches the end\n    while (fast != NULL && fast->next != NULL) {\n        fast = fast->next->next;\n        if (fast != NULL) {\n            slow = slow->next;\n        }\n    }\n    // Split the list into two halves\n    Student* temp = slow->next; //temp = second half which starts after the slow pointer\n    slow->next = NULL; // first half link to NULL, terminate the first half, split the first half and second half\n    return temp; //return the second half to mergeSort\n}\n\n// Function to merge two sorted linked lists\nStudent* merge(Student* first, Student* second) {\n  \n    // If either list is empty, return the other list\n    if (first == NULL) return second;\n    if (second == NULL) return first;\n\n    // Pick the smaller grade between first and second nodes\n    if (first->grade < second->grade) {\n        first->next = merge(first->next, second); //merge remaining list\n        return first;\n    }\n    else {\n        // else if second node is greater than first node\n        second->next = merge(first, second->next); //merge remaining list\n        return second;\n    }\n}\n\n// Function to perform merge sort on a linked list\nStudent* mergeSort(Student* head) {\n  \n    // Base case: if the list is empty or has only one node, \n    // it's already sorted\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n\n    // Split the list into two halves\n    Student* second = split(head);\n\n    // Recursively sort each half\n    head = mergeSort(head); //First half\n    second = mergeSort(second); //Second half\n\n    // Merge the two sorted halves\n    return merge(head, second);\n}\n\n//Free memory by deleting the entire list\nvoid freeMemory(Student **head){\n    deleteList(head);\n}\n\n//Main function to drive the program\nint main(){\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do{\n        //display menu for at least one time\n        printf(\"\\n***** Student Records Management System *****\\n\");\n        printf(\"\\t1. Insert Student Record\\n\");\n        printf(\"\\t2. Display Student Records\\n\");\n        printf(\"\\t3. Sort Records\\n\");\n        printf(\"\\t4. Search Record by ID\\n\");\n        printf(\"\\t5. Delete List\\n\");\n        printf(\"\\t6. Exit\\n\");\n\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); //to consume newline character;\n\n        switch(choice){\n            case 1:\n                printf(\"Enter Name: \"); //scan for student name\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                \n                int repeat = 0; //repeat flag\n                int invalid = 0;//invalid flag\n                do{\n                    repeat=0; //reset the flag\n                    invalid=0;//reset the flag\n                    Student* current = globalHead; \n\n                    printf(\"Enter ID: \");   //scan for student ID\n                    scanf(\"%d\", &id);\n                    \n                    if(id<0){               //check whether ID is valid \n                        invalid=1;          //if no, set the invalid flag\n                        printf(\"ID cannot be negative. Try again.\\n\"); //print error message\n                    }\n\n                    while(current!=NULL){           //compare whether the inputted ID already existed in the list\n                        if(current->id == id){\n                            repeat = 1;             //if yes, set the repeat flag\n                            printf(\"ID %d is in record. ID cannot be repeated. Try again.\\n\", id);\n                            break;\n                        }\n                        current=current->next;      //else, move to the next node to continue comparing until the node is NULL\n                    }\n                }while(repeat==1 || invalid==1);    //if either the ID is repeated or invalid, ask user to input again\n\n                printf(\"Enter Grade: \");           \n                scanf(\"%f\", &grade);                //scan for student grade\n\n                insertStudent(&globalHead, name, id, grade);    //when all details are inputted correctly, insert the student record into the list\n                printf(\"Record inserted successfully.\\n\\n\");    //display success message\n                break;\n\n            case 2:\n                displayStudents(globalHead);\n                break;\n\n            case 3:\n                if (globalHead == NULL){            //check whether the list is empty\n                    printf(\"Record is empty. No records to sort.\\n\");\n                    break;\n                }\n                globalHead = mergeSort(globalHead); //if no, sort the list according to grade\n                printf(\"Records sorted successfully in ascending order of grades.\\n\\n\");\n                printf(\"Sorted records: \\n\");\n                displayStudents(globalHead);        //display the sorted records to user\n                break;\n\n            case 4:\n                if (globalHead == NULL){            //check whether the list is empty\n                    printf(\"Record is empty. No records to search.\\n\");\n                    break;\n                }\n                printf(\"Enter ID to search: \"); \n                scanf(\"%d\", &id);                   //scan for ID to search\n                Student* found = searchStudentByID(id); //assign the node found to 'found'\n                if (found){\n                    printf(\"Student with ID %d is found in record.\\n\", id);\n                    //display the student records searched by user\n                    printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                }\n                else{\n                    //if no node is found, NULL will be returned by the function\n                    //if found == NULL, display not found message\n                    printf(\"Student with ID %d is not found in record.\\n\", id);\n                }\n                break;\n\n            case 5:\n                deleteList(&globalHead);\n                printf(\"List is entirely deleted.\\n\");\n                break;\n\n            case 6:\n                freeMemory(&globalHead);\n                printf(\"Thank you for using Student Records Management System.\\nTerminating program...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice. Please try again.\\n\\n\");\n                break;\n\n        }\n    }while(choice != 6); //while choice is not exit, loop back to print the menu for user to input\n\n    return 0;\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Merge Sort algorithm is implemented correctly to sort student records by grade in ascending order. This algorithm is efficient with a time complexity of O(n log n), making it suitable for larger datasets compared to simpler algorithms like Bubble Sort."
  },
  {
    "student_id": "20592884",
    "code": "\n/* --- Oguzhan Tekin 20592884 Lab Assessment 3 Source Files/Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10  // Maximum matrix size\r\n\r\n// Function declarations\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for matrix A\r\n    do {\r\n        printf(\"Enter number of rows and columns for Matrix A (max 10x10): \");\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n        if (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsA <= 0 || colsA <= 0) {\r\n            printf(\"Invalid dimensions, try again.\\n\");\r\n        }\r\n    } while (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsA <= 0 || colsA <= 0);\r\n\r\n    // Input dimensions for matrix B\r\n    do {\r\n        printf(\"Enter number of rows and columns for Matrix B (max 10x10): \");\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n        if (rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsB <= 0 || colsB <= 0) {\r\n            printf(\"Invalid dimensions, try again.\\n\");\r\n        }\r\n    } while (rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsB <= 0 || colsB <= 0);\r\n\r\n    // Check if matrices A and B have the same dimensions for addition and subtraction\r\n    if (rowsA != rowsB || colsA != colsB) {\r\n        printf(\"Matrix dimensions must match for addition or subtraction.\\n\");\r\n        return 1;  // Exit if dimensions don't match\r\n    }\r\n\r\n    // Input elements for both matrices\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    // Display menu for matrix operations\r\n    do {\r\n        printf(\"\\nChoose an operation:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Add matrices\r\n                addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n                break;\r\n            case 2:\r\n                // Subtract matrices\r\n                subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n                break;\r\n            case 3:\r\n                // Transpose matrix A\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA); // Transposed dimensions\r\n                break;\r\n            case 4:\r\n                // Transpose matrix B\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB); // Transposed dimensions\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice, please try again.\\n\");\r\n        }\r\n\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input matrix elements\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element at [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Oguzhan Tekin 20592884 Lab Assessment 3 Source Files/Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100   // Maximum number of items in the inventory\r\n#define MAX_NAME_LEN 100  // Maximum length for the item name\r\n#define MAX_CATEGORY_LEN 50  // Maximum length for the category\r\n\r\n// Struct to represent a grocery item\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];  // Name of the grocery item\r\n    char category[MAX_CATEGORY_LEN];  // Category of the grocery item\r\n    int quantity;  // Quantity of the grocery item\r\n    float price;  // Price of the grocery item\r\n} GroceryItem;\r\n\r\n// Enum to represent availability status\r\ntypedef enum {\r\n    IN_STOCK,\r\n    OUT_OF_STOCK\r\n} AvailabilityStatus;\r\n\r\n// Struct to represent the grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];  // Array of grocery items\r\n    AvailabilityStatus status[MAX_ITEMS];  // Availability status array\r\n    int totalItems;  // Total number of items in the inventory\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addItem(GroceryInventory* inventory);\r\nvoid listItems(const GroceryInventory* inventory);\r\nvoid updateQuantity(GroceryInventory* inventory);\r\nvoid removeItem(GroceryInventory* inventory);\r\nvoid displayMenu();\r\nvoid clearInputBuffer();\r\nint findItemIndexByName(const GroceryInventory* inventory, const char* name);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .totalItems = 0 };  // Initialize inventory with no items\r\n\r\n    int choice;\r\n    \r\n    // Run the menu in a loop until the user decides to exit\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        clearInputBuffer();  // Clear any extra input left in the buffer\r\n        \r\n        switch(choice) {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice, please try again.\\n\");\r\n        }\r\n    } while(choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to display the menu options\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Menu:\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items With Their Availability\\n\");\r\n    printf(\"3. Update the Quantity of a Grocery Item\\n\");\r\n    printf(\"4. Remove a Grocery Item From Inventory\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Function to clear any extra input left in the buffer (useful after scanf)\r\nvoid clearInputBuffer() {\r\n    while(getchar() != '\\n');\r\n}\r\n\r\n// Function to find the index of an item by its name in the inventory\r\nint findItemIndexByName(const GroceryInventory* inventory, const char* name) {\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            return i;  // Return index if the item is found\r\n        }\r\n    }\r\n    return -1;  // Return -1 if the item is not found\r\n}\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addItem(GroceryInventory* inventory) {\r\n    if (inventory->totalItems >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Get item details from the user\r\n    GroceryItem newItem;\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem.name, MAX_NAME_LEN, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0;  // Remove trailing newline\r\n\r\n    // Check if the item already exists\r\n    if (findItemIndexByName(inventory, newItem.name) != -1) {\r\n        printf(\"Item with the name '%s' already exists in the inventory.\\n\", newItem.name);\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LEN, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0;  // Remove trailing newline\r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    clearInputBuffer();  // Clear the buffer\r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    clearInputBuffer();  // Clear the buffer\r\n\r\n    // Add the new item to the inventory\r\n    inventory->items[inventory->totalItems] = newItem;\r\n\r\n    // Set the availability status based on the quantity\r\n    inventory->status[inventory->totalItems] = newItem.quantity > 0 ? IN_STOCK : OUT_OF_STOCK;\r\n\r\n    inventory->totalItems++;  // Increase the total number of items in the inventory\r\n    printf(\"Grocery Item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items in the inventory\r\nvoid listItems(const GroceryInventory* inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Items in Inventory:\\n\");\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        GroceryItem item = inventory->items[i];\r\n        AvailabilityStatus status = inventory->status[i];\r\n\r\n        printf(\"\\nItem %d:\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Availability: %s\\n\", status == IN_STOCK ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory* inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LEN];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, MAX_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  // Remove trailing newline\r\n\r\n    int itemIndex = findItemIndexByName(inventory, itemName);\r\n    if (itemIndex == -1) {\r\n        printf(\"Item '%s' not found in the inventory.\\n\", itemName);\r\n        return;\r\n    }\r\n\r\n    // Get the new quantity from the user\r\n    int newQuantity;\r\n    printf(\"Enter new quantity for '%s': \", inventory->items[itemIndex].name);\r\n    scanf(\"%d\", &newQuantity);\r\n    clearInputBuffer();  // Clear the buffer\r\n\r\n    // Update the item's quantity and availability status\r\n    inventory->items[itemIndex].quantity = newQuantity;\r\n    inventory->status[itemIndex] = newQuantity > 0 ? IN_STOCK : OUT_OF_STOCK;\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeItem(GroceryInventory* inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LEN];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(itemName, MAX_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  // Remove trailing newline\r\n\r\n    int itemIndex = findItemIndexByName(inventory, itemName);\r\n    if (itemIndex == -1) {\r\n        printf(\"Item '%s' not found in the inventory.\\n\", itemName);\r\n        return;\r\n    }\r\n\r\n    // Shift the items to remove the selected item\r\n    for (int i = itemIndex; i < inventory->totalItems - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->status[i] = inventory->status[i + 1];\r\n    }\r\n\r\n    inventory->totalItems--;  // Decrease the total number of items\r\n    printf(\"Grocery Item '%s' removed successfully!\\n\", itemName);\r\n}\r\n\n/* --- Oguzhan Tekin 20592884 Lab Assessment 3 Source Files/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];  // Student's name\r\n    int id;          // Student's ID\r\n    float grade;     // Student's grade\r\n    struct Student* next;  // Pointer to the next student node\r\n} Student;\r\n\r\nStudent* head = NULL;  // Head of the linked list (initially empty)\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));  // Allocate memory for new student\r\n    if (newStudent == NULL) {  // Check for memory allocation failure\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    \r\n    // Copy data into the new student node\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;  // Initially, the next pointer is NULL\r\n    \r\n    return newStudent;  // Return the pointer to the new student node\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);  // Create a new student node\r\n\r\n    if (head == NULL) {  // If the list is empty, set the new student as the head\r\n        head = newStudent;\r\n    } else {\r\n        Student* current = head;\r\n        // Traverse to the end of the list to insert the new student\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;  // Add the new student at the end\r\n    }\r\n\r\n    printf(\"Student record inserted.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {  // Check if the list is empty\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    // Traverse through the linked list and print each student record\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;  // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    \r\n    // Traverse through the list to find the student by ID\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;  // Return the student node if ID matches\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    return NULL;  // Return NULL if student with the given ID is not found\r\n}\r\n\r\n// Function to delete the entire linked list and free memory\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    // Traverse and free all student nodes\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);  // Free memory for current student node\r\n        current = next;\r\n    }\r\n    \r\n    head = NULL;  // Reset head to NULL as the list is now empty\r\n}\r\n\r\n// Function to free all memory when the program exits\r\nvoid freeMemory() {\r\n    deleteList();  // Delete the list and free memory\r\n}\r\n\r\n// Comparison function to be used with qsort\r\nint compareStudents(const void* a, const void* b) {\r\n    // Cast the input pointers to Student pointers\r\n    Student* studentA = *(Student**)a;\r\n    Student* studentB = *(Student**)b;\r\n\r\n    // Compare the grades of the two students\r\n    if (studentA->grade < studentB->grade) return -1;\r\n    if (studentA->grade > studentB->grade) return 1;\r\n    return 0;  // Return 0 if grades are equal\r\n}\r\n\r\n// Function to sort the student records by grade using qsort\r\n//QSORT has average performance and it is quite generalized function which why I chose it\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough students to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    // First, we need to store the students in an array for sorting\r\n    int count = 0;\r\n    Student* current = head;\r\n\r\n    // Count the total number of students\r\n    while (current != NULL) {\r\n        count++;\r\n        current = current->next;\r\n    }\r\n\r\n    // Create an array to store student pointers\r\n    Student** studentArray = (Student**)malloc(count * sizeof(Student*));\r\n    if (studentArray == NULL) {\r\n        printf(\"Memory allocation for sorting failed!\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    // Fill the array with student pointers\r\n    current = head;\r\n    for (int i = 0; i < count; i++) {\r\n        studentArray[i] = current;\r\n        current = current->next;\r\n    }\r\n\r\n    // Use qsort to sort the array of student pointers by grade\r\n    qsort(studentArray, count, sizeof(Student*), compareStudents);\r\n\r\n    // Re-link the sorted student nodes back into the linked list\r\n    for (int i = 0; i < count - 1; i++) {\r\n        studentArray[i]->next = studentArray[i + 1];\r\n    }\r\n    studentArray[count - 1]->next = NULL;  // The last student points to NULL\r\n\r\n    // Set the head of the list to the first student in the sorted array\r\n    head = studentArray[0];\r\n\r\n    // Free the array of student pointers (we no longer need it)\r\n    free(studentArray);\r\n\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display the menu for the user\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Insert a new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");  // Remove the trailing newline\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                // Display all student records\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                // Sort student records by grade\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                // Search for a student by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                // Delete the entire linked list\r\n                deleteList();\r\n                printf(\"Student list deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                // Exit the program and free memory\r\n                freeMemory();\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The use of qsort is appropriate for sorting student records by grade. It offers average performance with a time complexity of O(n log n), making it more efficient than Bubble Sort for larger datasets. This choice is well justified."
  },
  {
    "student_id": "20609660",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main()\r\n{\r\n    int rowsA, colsA, rowsB, colsB, choice = 0;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE] = {0};\r\n\r\n    // Input dimensions for matrices\r\n    do\r\n    {\r\n        printf(\"Enter the dimensions for Matrix A (rows and columns): \");\r\n        scanf(\" %d %d\", &rowsA, &colsA);\r\n        if (rowsA < 1 || rowsA > MAX_SIZE || colsA < 1 || colsA > MAX_SIZE)\r\n        {\r\n            printf(\"Invalid dimensions. Please enter dimensions between 1 and 10.\\n\");\r\n        }\r\n    } while (rowsA < 1 || rowsA > MAX_SIZE || colsA < 1 || colsA > MAX_SIZE);\r\n\r\n    // Input elements of matrix A\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA, 'A');\r\n\r\n    do\r\n    {\r\n        printf(\"Enter the dimensions for Matrix B (rows and columns): \");\r\n        scanf(\" %d %d\", &rowsB, &colsB);\r\n        if (rowsB < 1 || rowsB > MAX_SIZE || colsB < 1 || colsB > MAX_SIZE)\r\n        {\r\n            printf(\"Invalid dimensions. Please enter dimensions between 1 and 10.\\n\");\r\n        }\r\n    } while (rowsB < 1 || rowsB > MAX_SIZE || colsB < 1 || colsB > MAX_SIZE);\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n\r\n    // Input elements of matrix B\r\n    inputMatrix(matrixB, rowsB, colsB, 'B');\r\n\r\n    // Menu-driven loop\r\n    do\r\n    {\r\n        printf(\"\\nMatrix Operations Menu:\\n\\\r\n1. Add Matrices\\n\\\r\n2. Subtract Matrices\\n\\\r\n3. Transpose Matrix A\\n\\\r\n4. Transpose Matrix B\\n\\\r\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\" %d\", &choice);\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            // Validate if matrices can be added\r\n            if (rowsA == rowsB && colsA == colsB)\r\n            {\r\n                addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrix addition not possible. Dimensions do not match.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            // Validate if matrices can be subtracted\r\n            if (rowsA == rowsB && colsA == colsB)\r\n            {\r\n                subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrix subtraction not possible. Dimensions do not match.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            transposeMatrix(matrixA, result, rowsA, colsA);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(result, colsA, rowsA);\r\n            break;\r\n\r\n        case 4:\r\n            transposeMatrix(matrixB, result, rowsB, colsB);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(result, colsB, rowsB);\r\n            break;\r\n\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice. Please select a valid option.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input elements of a matrix from user\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name)\r\n{\r\n    // Loop through each element of the matrix, starting from row 1 and column 1 to row 1 and column 2, and so on\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            printf(\"Element %c[%d][%d]: \", name, i + 1, j + 1);\r\n            scanf(\" %d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols)\r\n{\r\n    // Loop through each element of the matrix and print it\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Structure definitions\r\ntypedef struct\r\n{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct\r\n{\r\n    bool inStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct\r\n{\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus availability[MAX_ITEMS];\r\n    int totalItems;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid displayMenu();\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main()\r\n{\r\n    // Initialize the inventory and choice\r\n    GroceryInventory inventory = {0};\r\n    int choice = 0;\r\n\r\n    // Loop the menu until user chooses to exit (choice 5)\r\n    do\r\n    {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\" %d\", &choice);\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            addGroceryItem(&inventory);\r\n            break;\r\n        case 2:\r\n            listGroceryItems(&inventory);\r\n            break;\r\n        case 3:\r\n            updateQuantity(&inventory);\r\n            break;\r\n        case 4:\r\n            removeGroceryItem(&inventory);\r\n            break;\r\n        case 5:\r\n            printf(\"Exiting program.\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to display the menu, a prompt for the user to choose an option\r\nvoid displayMenu()\r\n{\r\n    printf(\"\\nGrocery Inventory Management System:\\n\\\r\n1. Add Grocery Item\\n\\\r\n2. List All Grocery Items\\n\\\r\n3. Update Quantity\\n\\\r\n4. Remove Grocery Item\\n\\\r\n5. Exit\\n\");\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory)\r\n{\r\n    // Initialize variables to store the name, quantity, and price of the item\r\n    char name[100] = {0};\r\n    int quantity = 0;\r\n    float price = 0;\r\n\r\n    // Check if the inventory is full\r\n    if (inventory->totalItems >= MAX_ITEMS)\r\n    {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Let item point to the new item to be added\r\n    GroceryItem *item = &inventory->items[inventory->totalItems];\r\n    // Let status point to the availability status of the new item\r\n    AvailabilityStatus *status = &inventory->availability[inventory->totalItems];\r\n\r\n    printf(\"Enter name of the item: \");\r\n    getchar();             // Clear newline character from buffer\r\n    scanf(\"%[^\\n]\", name); // Read the name of the item\r\n\r\n    // Check if the item name already exists in the inventory by looping through the items in the inventory\r\n    for (int i = 0; i < inventory->totalItems; i++)\r\n    {\r\n        if (strcmp(inventory->items[i].name, name) == 0)\r\n        {\r\n            printf(\"Item already exists in inventory.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Store the name of the items into the items array\r\n    strcpy(item->name, name);\r\n\r\n    printf(\"Enter category of the item: \");\r\n    getchar(); // Clear newline character from buffer\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0; // Remove newline character\r\n\r\n    printf(\"Enter quantity of the item: \");\r\n    scanf(\" %d\", &quantity);\r\n\r\n    // Check if the quantity is a positive value\r\n    if (quantity < 0)\r\n    {\r\n        printf(\"Invalid quantity. Please enter a positive value.\\n\");\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        // Update the quantity of the item if it is valid\r\n        item->quantity = quantity;\r\n    }\r\n\r\n    printf(\"Enter price of the item: \");\r\n    getchar(); // Clear newline character from buffer\r\n    scanf(\" %f\", &price);\r\n    getchar(); // Clear newline character from buffer\r\n\r\n    // Check if the price is a positive value\r\n    if (price < 0)\r\n    {\r\n        printf(\"Invalid price. Please enter a positive value.\\n\");\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        item->price = price; // Update the price of the item if it is valid\r\n    }\r\n\r\n    // Update the availability status of the item based on the quantity (Maybe 0, hence need to have a logic to check if it is in stock)\r\n    status->inStock = (item->quantity > 0);\r\n\r\n    // Increment the totalItems count\r\n    inventory->totalItems++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their availability\r\nvoid listGroceryItems(GroceryInventory *inventory)\r\n{\r\n    // Check if there are is items in the inventory\r\n    if (inventory->totalItems == 0)\r\n    {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Loop through the items in the inventory and print their details\r\n    for (int i = 0; i < inventory->totalItems; i++)\r\n    {\r\n        GroceryItem *item = &inventory->items[i];\r\n        AvailabilityStatus *status = &inventory->availability[i];\r\n        printf(\"\\nName: %s\\n\\\r\nCategory: %s\\n\\\r\nQuantity: %d\\n\\\r\nPrice: %.2f\\n\\\r\nStatus: %s\\n\",\r\n               item->name, item->category, item->quantity, item->price, status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n        // For the status, if inStock is true, print \"In Stock\", else print \"Out of Stock\"\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory)\r\n{\r\n    // An array name to store the item name\r\n    char name[100] = {0};\r\n    // An integer to store the new quantity\r\n    int newQuantity = 0;\r\n\r\n    // If no items in the inventory, user not allowed to update quantity\r\n    if (inventory->totalItems == 0)\r\n    {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter the name of the item to update quantity: \");\r\n    getchar(); // Clear newline character from buffer\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; // Remove newline character\r\n\r\n    // Loop through the inventory to find the item to update\r\n    for (int i = 0; i < inventory->totalItems; i++)\r\n    {\r\n        // String comparison to check if the item name is in the inventory\r\n        if (strcmp(inventory->items[i].name, name) == 0)\r\n        {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\" %d\", &newQuantity);\r\n\r\n            // Check if the new quantity is a positive value\r\n            if (newQuantity < 0)\r\n            {\r\n                printf(\"Invalid quantity. Please enter a positive value.\\n\");\r\n                return;\r\n            }\r\n\r\n            // Update the quantity of the item if it is valid\r\n            inventory->items[i].quantity = newQuantity;\r\n            // Update the availability status of the item based on the new quantity\r\n            inventory->availability[i].inStock = newQuantity > 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(GroceryInventory *inventory)\r\n{\r\n    // An array name to store the item name\r\n    char name[100] = {0};\r\n\r\n    // User not allow to remove item if no items in the inventory\r\n    if (inventory->totalItems == 0)\r\n    {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar(); // Clear newline character from buffer\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; // Remove newline character\r\n\r\n    // Loop through the inventory to find the item to remove\r\n    for (int i = 0; i < inventory->totalItems; i++)\r\n    {\r\n        // String comparison to check if the item name is in the inventory\r\n        if (strcmp(inventory->items[i].name, name) == 0)\r\n        {\r\n            // Shift all items that is left from the loop to the left to remove the item\r\n            for (int j = i; j < inventory->totalItems - 1; j++)\r\n            {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n\r\n            // Decrement the totalItems count\r\n            inventory->totalItems--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student\r\n{\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student;\r\n\r\nStudent *head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent *createStudent(const char *name, int id, float grade)\r\n{\r\n    // Allocate memory for the new student\r\n    Student *newStudent = (Student *)malloc(sizeof(Student));\r\n    if (newStudent == NULL)\r\n    {\r\n        printf(\"Memory allocation failed!\\n\"); // Print error message if memory allocation fails\r\n        exit(1);\r\n    }\r\n\r\n    // Initialise a pointer that will point to the head of the list\r\n    Student *current = head;\r\n\r\n    // Loop from the head to the end of the list to check if the student already exists\r\n    while (current != NULL)\r\n    {\r\n        if (strcmp(current->name, name) == 0)\r\n        {\r\n            printf(\"\\\"%s\\\" already exist in the system\\n\", name);\r\n            return NULL;\r\n        }\r\n        else if (current->id == id)\r\n        {\r\n            printf(\"ID %d already exist in the system\\n\", id);\r\n            return NULL;\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    // Copy student name and assign ID and grade to the new student node\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char *name, int id, float grade)\r\n{\r\n    // Check if the grade is within the valid range\r\n    if (grade < 0 || grade > 100)\r\n    {\r\n        printf(\"Invalid grade. Grade should be between 0 and 100.\\n\");\r\n        return;\r\n    }\r\n    // Create a new student record\r\n    Student *newStudent = createStudent(name, id, grade);\r\n    // createStudent function will return NULL if the student already exists\r\n    if (newStudent == NULL)\r\n    {\r\n        return;\r\n    }\r\n    // Set the next pointer of the new student to the head of the list\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents()\r\n{\r\n    // Check if the list is empty\r\n    if (head == NULL)\r\n    {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    // Initialise a pointer that will point to the head of the list\r\n    Student *current = head;\r\n\r\n    // Loop from the head to the end of the list to print each student record\r\n    // Loop will continue until the current pointer reaches the end of the list\r\n    while (current != NULL)\r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Let that pointer to shift to the next node\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent *searchStudentByID(int id)\r\n{\r\n    // Initialise a pointer that will point to the head of the list\r\n    Student *current = head;\r\n\r\n    // Loop from the head to the end of the list to search for the student record\r\n    // Linear search\r\n    while (current != NULL)\r\n    {\r\n        if (current->id == id)\r\n        {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList()\r\n{\r\n    Student *current = head;\r\n    Student *next;\r\n    while (current != NULL)\r\n    {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Sort function to sort the student records by grade\r\n// Sort by bubble sort algorithm\r\nvoid sortStudents()\r\n{\r\n    if (head == NULL || head->next == NULL)\r\n    {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *lptr = NULL;\r\n\r\n    do\r\n    {\r\n        // Set swapped to 0, a variable to check if the list is sorted\r\n        // Will come back as 0 if no swaps are made in the list\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        // loop through the list\r\n        while (ptr1->next != lptr)\r\n        {\r\n            if (ptr1->grade > ptr1->next->grade)\r\n            {\r\n                // Swap the data between both the nodes\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                // Copy the data of the first node to temporary variables\r\n                strcpy(tempName, ptr1->name);\r\n                tempId = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                // Copy the data of the second node to the first node\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                // Copy the data of the first node which is stored in the temporary variables to the second node\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempId;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                // Set swapped to 1 to indicate that a swap has been made\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next; // Set ptr1 to the next node in the list\r\n        }\r\n        lptr = ptr1; // Set lptr to the last node where the swap was made because based on bubble sort the last element is guranteed to be the largest\r\n        // Reducing the number of loop for next iteration by 1\r\n    } while (swapped);\r\n\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main()\r\n{\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do\r\n    {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\"); // Remove trailing newline\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student *found = searchStudentByID(id);\r\n            if (found)\r\n            {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                       found->name, found->id, found->grade);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n\r\n        case 6:\r\n            deleteList();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The program uses Bubble Sort to sort student records by grade. While functional, this algorithm has a time complexity of O(n?), which may not scale well for larger datasets. For improved performance, consider more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20701283",
    "code": "\n/* --- 20701283-ZHAO YUKE (2).c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Define the general merchandise structure\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];\r\n    char category[MAX_CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n    bool inStock; // inventory status:true indicated stockfalse out of stock\r\n} GroceryItem;\r\n\r\n// Define the grocery inventory structure.\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int totalItems; // The number of items currently in stock\r\n} GroceryInventory;\r\n\r\n// Add product function\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->totalItems >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *newItem = &inventory->items[inventory->totalItems];\r\n    printf(\"Enter item name: \");\r\n    scanf(\" %[^\\n]\", newItem->name);\r\n    printf(\"Enter item category: \");\r\n    scanf(\" %[^\\n]\", newItem->category);\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &newItem->quantity);\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &newItem->price);\r\n\r\n    newItem->inStock = (newItem->quantity > 0);\r\n    inventory->totalItems++;\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Lists all commodity functions\r\nvoid listGroceryItems(const GroceryInventory *inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nInventory Items:\\n\");\r\n    int i;\r\n\tfor ( i = 0; i < inventory->totalItems; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", item->name);\r\n        printf(\"  Category: %s\\n\", item->category);\r\n        printf(\"  Quantity: %d\\n\", item->quantity);\r\n        printf(\"  Price: %.2f\\n\", item->price);\r\n        printf(\"  Availability: %s\\n\", item->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Update the quantity function\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the item to update: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    int i;\r\n\tfor ( i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            inventory->items[i].inStock = (inventory->items[i].quantity > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Delete commodity function\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    int i;\r\n\tfor ( i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            int j;\r\n\t\t\tfor ( j = i; j < inventory->totalItems - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->totalItems--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// main function\r\nint main() {\r\n    GroceryInventory inventory = {.totalItems = 0};\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Menu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Item Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n\n/* --- 20701283-ZHAO YUKE (3).c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define student structure\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// List head pointer\r\nStudent* head = NULL;\r\n\r\n// Creat a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// Display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Search student records by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Delete the entire linked list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* nextNode;\r\n    while (current != NULL) {\r\n        nextNode = current->next;\r\n        free(current);\r\n        current = nextNode;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\n\r\n// release memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort student records by achievement using bubble sort.\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"No sorting needed.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // swap data\r\n                float tempGrade = ptr1->grade;\r\n                int tempID = ptr1->id;\r\n                char tempName[100];\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempID;\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n// main function\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Absorb excess newlines\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n\n/* --- 20701283-ZHAOYUKE (1).c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// input matrix element\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    printf(\"Enter the elements of the %dx%d matrix:\\n\", rows, cols);\r\n    int i;\r\n\tfor ( i = 0; i < rows; i++) {\r\n        int j;\r\n\t\tfor ( j = 0; j < cols; j++) {\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// printing matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    printf(\"Matrix:\\n\");\r\n    int i;\r\n\tfor ( i = 0; i < rows; i++) {\r\n        int j;\r\n\t\tfor ( j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// matrix addition\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int i;\r\n\tfor ( i = 0; i < rows; i++) {\r\n        int j;\r\n\t\tfor ( j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// matrix subtraction\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int i;\r\n\tfor ( i = 0; i < rows; i++) {\r\n        int j;\r\n\t\tfor ( j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// matrix transpose\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int i;\r\n\tfor ( i = 0; i < rows; i++) {\r\n        int j;\r\n\t\tfor ( j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n\r\n    // Enter the dimensions of matrices A and B\r\n    printf(\"Enter the dimensions of Matrix A (rows cols): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter the dimensions of Matrix B (rows cols): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Verify that matrix dimensions are valid\r\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsA <= 0 || colsA <= 0 || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid matrix dimensions.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Matrix A:\\n\");\r\n    inputMatrix(a, rowsA, colsA);\r\n    printf(\"Matrix B:\\n\");\r\n    inputMatrix(b, rowsB, colsB);\r\n\r\n    int choice;\r\n    do {\r\n        // display menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:  // matrix addition\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(a, b, result, rowsA, colsA);\r\n                    printf(\"Result of addition:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions do not match for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:  // matrix subtraction\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(a, b, result, rowsA, colsA);\r\n                    printf(\"Result of subtraction:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrix dimensions do not match for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:  // transpose matrix A\r\n                transposeMatrix(a, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:  // transpose matrix B\r\n                transposeMatrix(b, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:  // exit\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n\r\n            default:  \r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. However, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for improved performance."
  },
  {
    "student_id": "20601165",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_SIZE 10   // maximum size 10 x 10\r\n#define MIN_SIZE 1    // cannot be less than 0\r\n\r\nint main () {\r\n    int matrixRowA, matrixColumnA;   // declared to hold inputted rows and columns for matrix A\r\n    do {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");   // prompt\r\n        scanf(\"%d %d\", &matrixRowA, &matrixColumnA);   // getting user input\r\n\r\n        // Give an error if size is not between 1 and 10\r\n        if (matrixRowA > MAX_SIZE || matrixColumnA > MAX_SIZE || matrixRowA < MIN_SIZE || matrixColumnA < MIN_SIZE) {\r\n            printf(\"Please input a value for the rows and columns between 1 and 10.\\n\");\r\n        }\r\n\r\n    } while (matrixRowA > MAX_SIZE || matrixColumnA > MAX_SIZE || matrixRowA < MIN_SIZE || matrixColumnA < MIN_SIZE);\r\n\r\n    int matrixA[matrixRowA][matrixColumnA];   // matrixA's values will be inputted by user\r\n\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < matrixRowA; i++) {\r\n        for (int j = 0; j < matrixColumnA; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    int matrixRowB, matrixColumnB;   // declared to hold inputted rows and columns for matrix B\r\n    do {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");   // prompt\r\n        scanf(\"%d %d\", &matrixRowB, &matrixColumnB);   // getting user input\r\n\r\n        // Give an error if size is not between 1 and 10\r\n        if (matrixRowB > MAX_SIZE || matrixColumnB > MAX_SIZE || matrixRowB < MIN_SIZE || matrixColumnB < MIN_SIZE) {\r\n            printf(\"Please input a value for the rows and columns between 1 and 10.\\n\");\r\n        }\r\n\r\n    } while (matrixRowB > MAX_SIZE || matrixColumnB > MAX_SIZE || matrixRowB < MIN_SIZE || matrixColumnB < MIN_SIZE);\r\n\r\n    int matrixB[matrixRowB][matrixColumnB];   // matrixB's values will be inputted by user\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < matrixRowB; i++) {\r\n        for (int j = 0; j < matrixColumnB; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n    // Menu interface\r\n    while (1) {\r\n        int choice;\r\n        int transposeA[matrixColumnA][matrixRowA];   // declared transpose A with flipped rows and columns\r\n        int transposeB[matrixColumnB][matrixRowB];   // declared transpose B with flipped rows and columns\r\n\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter you choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                // Addition assuming matrixA and matrixB has similar rows and columns\r\n                for (int i = 0; i < matrixRowA; i++) {\r\n                    for (int j = 0; j < matrixColumnA; j++) {\r\n                        int sum = matrixA[i][j] + matrixB[i][j];\r\n                        printf(\"%d \", sum);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n\r\n                printf(\"\\n\");\r\n                break;\r\n            case 2:\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                // Subtraction assuming matrixA and matrixB has similar rows and columns\r\n                for (int i = 0; i < matrixRowA; i++) {\r\n                    for (int j = 0; j < matrixColumnA; j++) {\r\n                        int dif = matrixA[i][j] - matrixB[i][j];\r\n                        printf(\"%d \", dif);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n\r\n                printf(\"\\n\");\r\n                break;\r\n            case 3:\r\n                // Swapping rows and columns\r\n                for (int i = 0; i < matrixRowA; i++) {\r\n                    for (int j = 0; j < matrixColumnA; j++) {\r\n                        transposeA[j][i] = matrixA[i][j];\r\n                    }\r\n                }\r\n\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n\r\n                // print the transpose of matrix A\r\n                for (int i = 0; i < matrixColumnA; i++) {\r\n                    for (int j = 0; j < matrixRowA; j++) {\r\n                        printf(\"%d \", transposeA[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n\r\n                printf(\"\\n\");\r\n                break;\r\n            case 4:\r\n                // Swapping rows and columns\r\n                for (int i = 0; i < matrixRowB; i++) {\r\n                    for (int j = 0; j < matrixColumnB; j++) {\r\n                        transposeB[j][i] = matrixB[i][j];\r\n                    }\r\n                }\r\n\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n\r\n                // print the transpose of matrix B\r\n                for (int i = 0; i < matrixColumnB; i++) {\r\n                    for (int j = 0; j < matrixRowB; j++) {\r\n                        printf(\"%d \", transposeB[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n\r\n                printf(\"\\n\");\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                exit(0);\r\n            default:\r\n                printf(\"Invalid choice. Please pick a number between 1 and 5.\\n\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n#define MAX_GROCERY_ITEMS 100\r\n\r\n// Structure to store grocery items\r\nstruct groceryItem {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Grocery inventory array and count\r\nstruct groceryItem inventory[MAX_GROCERY_ITEMS];\r\nint inventoryCount = 0;\r\n\r\n// Declaring all void function to be used in menu\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main () {\r\n    while (1) {\r\n        int choice;\r\n\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Items\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                exit(0);\r\n            default:\r\n                printf(\"Invalid choice. Please pick a number between 1 and 5.\\n\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem() {\r\n    if (inventoryCount >= MAX_GROCERY_ITEMS) {\r\n        printf(\"Inventory is full.\\n\");\r\n    }\r\n\r\n    struct groceryItem item;   // using struct\r\n\r\n    printf(\"Enter Item Name: \");\r\n    getchar(); // Consume leftover newline\r\n    scanf(\"%[^\\n]\", item.name);   // read all characters until newline is found ([^\\n])\r\n\r\n    printf(\"Enter Category: \");\r\n    getchar(); // Consume leftover newline\r\n    scanf(\"%[^\\n]\", item.category);   // read all characters until newline is found ([^\\n])\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n    inventory[inventoryCount++] = item;   // after adding one item, inventory[0] is filled, and inventoryCount becomes 1, next item will be stored in inventory[1]\r\n    printf(\"Grocery item added successfully!\\n\\n\");\r\n}\r\n\r\nvoid listGroceryItems() {\r\n    if (inventoryCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    // using for loop to list grocery item one by one\r\n    for (int i = 0; i < inventoryCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].quantity > 0 ? \"In Stock\" : \"Out of Stock\");   // using ternary operator to decide whether item in stock or not\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar();  // Consume leftover newline from previous input\r\n    scanf(\"%[^\\n]\", itemName);   // Read item name including spaces\r\n\r\n    for (int i = 0; i < inventoryCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {   // Compare input name with inventory\r\n            printf(\"Enter new quantity for %s: \", inventory[i].name);\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            printf(\"Quantity updated successfully!\\n\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    for (int i = 0; i < inventoryCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            // Shift all items after the removed item\r\n            for (int j = i; j < inventoryCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            inventoryCount--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\\n\", itemName);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node (with each student recording including their name, id and grade)\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));   // allocate memory\r\n    strcpy(newStudent->name, name);   // copies the string provided as name(function argument) into name field of structure\r\n    newStudent->id = id;   // set id field in the structure to the value passed as the id argument\r\n    newStudent->grade = grade;   // same as id\r\n    newStudent->next = NULL;   // next pointer is initialized to NULL\r\n    return newStudent;   // return the pointer\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);   // createStudent function called to allocate memory for new Student node\r\n\r\n    // Check if list is empty, if empty new student becomes first node\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {   // if list not empty, find last node in the lust to add the new node at the end\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;   // links the new node to the end of the list\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    // if no students in record\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;\r\n\r\n    // display all students in record with while loop\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n\r\n    // find similar id using while loop\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    // use while loop to delete entire list\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n} \r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    int swapped;   // to track if a swap occureed in current pass\r\n    Student *ptr1;   // for traversing the list\r\n    Student *lptr = NULL;   // mkaing the end of the unsorted portion\r\n\r\n    // Coninute until no swaps are made\r\n    do {\r\n        swapped = 0;   // reset\r\n        ptr1 = head;   // start from head of the list\r\n\r\n        // traverse the list up to the unsorted portion\r\n        while (ptr1->next != lptr) {\r\n            // compare current node's grade with the next node's grade\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the data of the two nodes\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempId = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempId;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;   // mark that swap occured\r\n            }\r\n            // move to next node\r\n            ptr1 = ptr1->next;\r\n        }\r\n        // update the end of the unsorted portion\r\n        lptr = ptr1;\r\n    } while (swapped);   \r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n} \r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n            }\r\n        } while (choice != 6);\r\n\r\n    return 0;\r\n} ",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to sort student records by grade. While this algorithm is simple and understandable, it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20706981",
    "code": "\n/* --- Question1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0) {\r\n        printf(\"Invalid dimensions for Matrix A. Maximum size is 10x10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid dimensions for Matrix B. Maximum size is 10x10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    // Menu loop\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(A, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(B, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\n/* --- Question2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEM_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n#define MAX_INVENTORY_SIZE 100\r\n\r\n// Structure for grocery item\r\ntypedef struct {\r\n    char name[MAX_ITEM_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Structure for availability status\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Structure for grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_INVENTORY_SIZE];\r\n    AvailabilityStatus status[MAX_INVENTORY_SIZE];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listAllGroceryItems(GroceryInventory inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.count = 0;\r\n\r\n    int choice;\r\n    do {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listAllGroceryItems(inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice!= 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_INVENTORY_SIZE) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *newItem = &inventory->items[inventory->count];\r\n    AvailabilityStatus *newStatus = &inventory->status[inventory->count];\r\n\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\"%s\", newItem->name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\"%s\", newItem->category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem->quantity);\r\n    if (newItem->quantity > 0) {\r\n        newStatus->inStock = true;\r\n        newStatus->outOfStock = false;\r\n    } else {\r\n        newStatus->inStock = false;\r\n        newStatus->outOfStock = true;\r\n    }\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem->price);\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listAllGroceryItems(GroceryInventory inventory) {\r\n    if (inventory.count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Grocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    printf(\"Enter your choice: 2\\n\");\r\n\r\n    for (int i = 0; i < inventory.count; i++) {\r\n        printf(\"Name: %s\\n\", inventory.items[i].name);\r\n        printf(\"Category: %s\\n\", inventory.items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory.items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory.items[i].price);\r\n        if (inventory.status[i].inStock) {\r\n            printf(\"Status: In Stock\\n\");\r\n        } else {\r\n            printf(\"Status: Out of Stock\\n\");\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[MAX_ITEM_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\"%s\", name);\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            if (inventory->items[i].quantity > 0) {\r\n                inventory->status[i].inStock = true;\r\n                inventory->status[i].outOfStock = false;\r\n            } else {\r\n                inventory->status[i].inStock = false;\r\n                inventory->status[i].outOfStock = true;\r\n            }\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char name[MAX_ITEM_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\"%s\", name);\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            inventory->count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\n/* --- Question3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// 学生结构体\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student;\r\n\r\n// 链表头指针\r\nStudent *head = NULL;\r\n\r\n// 创建新学生节点\r\nStudent *createStudent(const char *name, int id, float grade) {\r\n    Student *newStudent = (Student *)malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// 插入学生记录\r\nvoid insertStudent(const char *name, int id, float grade) {\r\n    Student *newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student *current = head;\r\n        while (current->next!= NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n}\r\n\r\n// 显示学生记录\r\nvoid displayStudents() {\r\n    Student *current = head;\r\n    if (current == NULL) {\r\n        printf(\"No student records.\\n\");\r\n    } else {\r\n        while (current!= NULL) {\r\n            printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n            current = current->next;\r\n        }\r\n    }\r\n}\r\n\r\n// 按ID搜索学生记录\r\nStudent *searchStudentByID(int id) {\r\n    Student *current = head;\r\n    while (current!= NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// 删除链表\r\nvoid deleteList() {\r\n    Student *current = head;\r\n    Student *next;\r\n    while (current!= NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// 释放内存（调用deleteList）\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// 使用冒泡排序对学生记录按成绩排序\r\nvoid sortStudents() {\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *lptr = NULL;\r\n\r\n    if (head == NULL) return;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next!= lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // 交换节点\r\n                Student *temp = ptr1->next;\r\n                ptr1->next = temp->next;\r\n                temp->next = ptr1;\r\n                if (ptr1 == head) {\r\n                    head = temp;\r\n                } else {\r\n                    Student *prev = head;\r\n                    while (prev->next!= ptr1) {\r\n                        prev = prev->next;\r\n                    }\r\n                    prev->next = temp;\r\n                }\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // 处理换行符\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0';\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student *found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice!= 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement. \nq2-In addGroceryItem, the price should be entered after checking for a valid quantity, but the program first prompts for quantity and then for price. If the quantity is 0, it still allows entering a price, which should not occur if the item is out of stock.\nq3-In the sortStudents function, the swapping of nodes does not correctly adjust the list structure when nodes are swapped. This can lead to incorrect ordering or segmentation faults."
  },
  {
    "student_id": "20598080",
    "code": "\n/* --- Q1.c --- */\n# include <stdio.h>\n\n# define MAX_SIZE 10  // Maximum size for the matrices\n\n// Function prototypes\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int ros, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];  // Matrices A and B\n    int result[MAX_SIZE][MAX_SIZE];  // Resultant matrix\n    int rowsA, colsA, rowsB, colsB;  // Dimensions of matrices\n    int choice;  // User's menu choice\n\n    // Input dimensions of Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and column): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    inputMatrix(A, rowsA, colsA, 'A');\n    \n    // Input dimensions of Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    inputMatrix(B, rowsB, colsB, 'B');\n\n    // Menu for matrix operations\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matric B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                // Check if dimensions match for addtion\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(A, B, result, rowsA, colsA);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    printMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"Addition not possible. Dimensions of A and B must match.\\n\");\n                }\n                break;\n            case 2:\n                // Check if dimensions match for subtraction\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(A, B, result, rowsA, colsA);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    printMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"Subtraction not possible. Dimensions of A and B must match.\\n\");\n                }\n                break;\n            case 3:\n                // Transpose Matrix A\n                transposeMatrix(A, result, rowsA, colsA);\n                printf(\"Transpose of Matrix A: \\n\");\n                printMatrix(result, colsA, rowsA);\n                break;\n            case 4:\n                // Transpose Matrix B\n                transposeMatrix(B, result, rowsB, colsB);\n                printf(\"Transpose of Matrix B:\\n\");\n                printMatrix(result, colsB, rowsB);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice !=5);\n\n    return 0;\n}\n\n// Function to input a matrix\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\n    printf(\"Enter elemetns of Matrix %c:\\n\", name);\n    for (int i = 0; i <rows; i++) {\n        for (int j = 0; j <cols; j++) {\n            printf(\"Element [%d][%d]: \", i+1, j+1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to print a matrix\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols ; j++) {\n            printf(\"%d  \", matrix[i][j]);\n        }\n        printf(\"\\n\");  // Newline after each row\n    }\n}\n\n// Function to add two matrices\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] +B[i][j];  // Element-wise addition\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];  // Element-wise subtraction\n        }\n    }\n}\n\n//Function to transpose a matrix\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];  // Swap rows and columns\n        }\n    }\n}\n/* --- Q2.c --- */\n# include <stdio.h>\n# include <string.h>\n# include <stdbool.h>\n\n# define MAX_ITEMS 100  // Maximum number of items allowed in the inventory\n\n// Struct to define a grocery item\ntypedef struct {\n    char name[100];  // Name of the grocery item\n    char category[50];  // Category of the grocery item\n    int quantity;  // Quantity of the item in stock\n    float price;  // Price of the item\n} GroceryItem;\n\n// Struct to define the availability status\ntypedef struct {\n    bool inStock;  // Indicates if the item is in stock\n} AvailabilityStatus;\n\n// Inventory struct\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];  // Array of grocery items\n    AvailabilityStatus availability[MAX_ITEMS];  // Array of availability statuses\n    int count;  // Number of items currently in the inventory\n} GroceryInventory;\n\n// Function prototypes\nvoid addItem(GroceryInventory *inventory);\nvoid listItems(const GroceryInventory *inventory);\nvoid updateQuantity(GroceryInventory *inventory);\nvoid removeItem(GroceryInventory *inventory);\n\nint main() {\n    GroceryInventory inventory = { .count = 0 };  // Initialize inventory with no items\n    int choice;  // Variable to store user's menu choice\n\n    // Main menu loop\n    do {\n        printf(\"\\nGrocery Inventory Management System:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();  // Consume newline\n\n        switch (choice) {\n            case 1:\n                addItem(&inventory);  // Add a new grocery item\n                break; \n            case 2:\n                listItems(&inventory);  // Display all grocery items\n                break;\n            case 3:\n                updateQuantity(&inventory);  // Update the quantity of a specific item\n                break;\n            case 4:\n                removeItem(&inventory);  // Remove an item from the inventory\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");  // Exit the program\n                break;\n            default: \n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);  // Loop until the user chooses to exit\n\n    return 0;\n}\n\n// Function to add a grocery item to the inventory\nvoid addItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) {\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem *item = &inventory->items[inventory->count];\n    AvailabilityStatus *status = &inventory->availability[inventory->count];\n    \n    // Input item details\n    printf(\"Enter Item Name: \");\n    fgets(item->name, 100, stdin);\n    item->name[strcspn(item->name, \"\\n\")] = '\\0';  // Remove newline\n    \n    printf(\"Enter Category: \");\n    fgets(item->category, 50, stdin);\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';  // Remove newline\n\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &item->quantity);\n\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &item->price);\n    getchar();  // Consume newline\n    \n    // Update availability status\n    status->inStock = item->quantity > 0;\n    \n    // Increment item count in the inventory\n    inventory->count++;\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Functiion to list all grocery items\nvoid listItems(const GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n    \n    // Display details of each item\n    for (int i = 0; i < inventory->count; i++) {\n        const GroceryItem *item = &inventory->items[i];\n        const AvailabilityStatus *status = &inventory->availability[i];\n\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");    \n    }\n}\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity(GroceryInventory *inventory) {\n    if (inventory->count == 0) {  // Check if inventory is empty\n        printf(\"No items in the inventory to update.\\n\");\n        return;\n    }\n\n    char itemName[100];\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets(itemName, sizeof(itemName), stdin);\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';  // Remove newline character\n\n    // Find the item and update its quantity\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            printf(\"Enter new quantity for %s: \",inventory->items[i].name);\n            scanf(\"%d\", &inventory->items[i].quantity);\n            getchar();  // Clear the newline character from the buffer\n            \n            // Update availability status\n            inventory->availability[i].inStock = inventory->items[i].quantity > 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\");\n}\n\n\n// Function to remove a grocery item from the inventory\nvoid removeItem(GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No items in the inventory to remove.\\n\");\n        return;\n    }\n\n    char itemName[100];\n    printf(\"Enter name of the grocery item to remove: \");\n    fgets(itemName, sizeof(itemName), stdin);\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';  // Remove newline character\n    \n    // Find the item and remove it\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            // Shift items to remove the selected one\n            for (int j = i; j<inventory->count - 1; j++) {\n                inventory->items[j] = inventory->items[j +1];\n                inventory->availability[j] = inventory->availability[j + 1];\n            }\n             \n            //  Decrease the count of items in the inventory \n            inventory->count--;\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\n            return;\n        }\n    }\n\n    printf(\"Item '%s' not found in the inventory.\\n\", itemName);\n}\n/* --- Q3.c --- */\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n\n// Structure for Student \ntypedef struct Student {\n    char name[100];  // Name of the student\n    int id;  // Unique ID of the student\n    float grade;  // Grade of the student\n    struct Student* next;  // Pointer to the next student in the list\n} Student;\n\nStudent* head = NULL;  // Head of the linked list (initially empty)\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));  // Allocate memory for a new student\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);  // Exit if memory allocation fails\n    }\n    strcpy(newStudent->name, name);  // Set the student's name\n    newStudent->id = id;  // Set the student's ID\n    newStudent->grade = grade;  // Set the students's grade\n    newStudent->next = NULL;  // Initialize the next pointer to NULL\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char*name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);  // Create a new student node\n    newStudent->next = head;  // Link the new student to the current head\n    head = newStudent;  // Update head to point to the new student\n    printf(\"Student record inserted successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (!head) {  // Check if the list is empty\n        printf(\"No student records found.\\n\");\n        return;\n    }\n\n    printf(\"\\nStudent Records:\\n\");\n    Student* current = head;\n    while (current) {  // Traverse the list and print each student's details\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current =  head;  // Start from the head of the list\n    while (current) {  // Traverse the list\n        if (current->id == id) {  // Check if the current student's ID matches\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;  // Return NULL if the student is not found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;  // Start from the head of the list\n    Student* next;\n\n    while (current != NULL) {  // Traverse the list\n        next = current->next;  // Store the pointer to the next student\n        free(current);  // Free the current node\n        current = next;  // Move to the next student\n    }\n    head = NULL;  // Reset the head to NULL\n}\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\n// Bubble Sort is chosen becasuse it is simple to implement and sufficient for small datasets such as this linked list of student records.\nvoid sortStudents() {\n    if (!head || !head->next) {  // Check if there are less than 2 students\n        printf(\"Not enough records to sort.\\n\");\n        return;\n    }\n\n    int swapped;\n    Student *current, *prev = NULL;\n\n    do {\n        swapped = 0;\n        current = head;\n\n        while (current->next !=prev) {\n            if (current->grade > current->next->grade) { // Compare grades\n                // Swap data\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, current->name);\n                tempID = current->id;\n                tempGrade = current->grade;\n\n                strcpy(current->name, current->next->name);\n                current->id = current->next->id;\n                current->grade = current->next->grade;\n\n                strcpy(current->next->name, tempName);\n                current->next->id = tempID;\n                current->next->grade = tempGrade;\n \n                swapped = 1;  // Mark as swapped\n            }\n            current = current->next;  // Move to the next pair\n        }\n        prev = current;  // Reduce the range of unsorted elements\n    } while (swapped);\n\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    \n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        // Display menu\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (choose sorting method)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();  // To consume the newline character\n\n        switch (choice) {\n            case 1:  // Insert a new student record\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:  // Display all student records\n                displayStudents();\n                break;\n            case 3:  // Sort student recors\n                sortStudents();\n                break;\n            case 4:  // Search for a student by ID\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:  // Delte the entire list\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:  // Exit the program\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid chocie! Please try again.\\n\");\n        }\n    } while (choice != 6);  // Repeat until the user chooses to exit\n\n    return 0;\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function utilizes Bubble Sort to organize student records by grade. While this algorithm is straightforward and works well for small datasets, it has a time complexity of O(n?). For larger datasets, consider more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20702811",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_ROW 10     // Define the max number of rows \n#define MAX_COLUMN 10  // Define the max number of columns\n\n\nint main(void) {\n    // define the following variables to use in the program\n    int rowsA, columnsA, rowsB, columnsB, choice;\n    int elementA[MAX_ROW][MAX_COLUMN], elementB[MAX_ROW][MAX_COLUMN], transposeA[MAX_COLUMN][MAX_ROW], transposeB[MAX_COLUMN][MAX_ROW];\n\n    do {\n        // Asks user to input dimensions for Matrix A and save the values into rowsA and columnsA\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\n        scanf(\"%d %d\", &rowsA, &columnsA);     \n\n    if (rowsA > MAX_ROW || columnsA > MAX_COLUMN) {\n        printf(\"Please only input row and column value as 10 or less, and don't forget the space to differentiate rows and columns.\\n\");\n        // If user inputs a value more than 10, prints the error and repeats the do while loop\n    }\n    } while (rowsA > MAX_ROW || columnsA > MAX_COLUMN);\n\n    // Create a nested for loop where the program asks user to input dimensions for the matrix A and save them into elementA\n    for(int i = 0; i < rowsA; i++) {\n        for(int j = 0; j < columnsA; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);   // i+1 and j+1 is use so that Element [%d][%d] starts at 11 instead of 00\n            scanf(\"%d\", &elementA[i][j]);\n        }\n    }\n\n    do {\n        // Asks user to input dimensions for Matrix A and save the values into rowsA and columnsA\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\n        scanf(\"%d %d\", &rowsB, &columnsB);\n\n    if (rowsB > MAX_ROW || columnsB > MAX_COLUMN) {\n        printf(\"Please only input row and column value as 10 or less, and don't forget the space to differentiate rows and columns.\\n\");\n        // If user inputs a value more than 10, prints the error and repeats the do while loop\n    }\n    } while (rowsB > MAX_ROW || columnsB > MAX_COLUMN);\n\n    // Create a nested for loop where the program asks user to input dimensions for the matrix A and save them into elementA\n    for(int i = 0; i < rowsB; i++) {\n        for(int j = 0; j < columnsB; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);   // i+1 and j+1 is use so that Element [%d][%d] starts at 11 instead of 00\n            scanf(\"%d\", &elementB[i][j]);\n        }\n    }\n    \n    do {\n        // Prints out the menu and prompts user to input their choice\n        printf(\"Matrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice) {\n            case 1: // Add Matrices\n                // To add matrices, the dimension of rows of both matrices and the dimension of columns of both matrices must be equal\n                if (rowsA != rowsB || columnsA != columnsB) {\n                    printf(\"Addition of Matrix A and B not possible.\\n\");  // Prints out an error message if either the rows or columns matrices are not equal\n                    break;\n                } else {\n                    // define a new variable to use in this part of the code\n                    int sumMatrix[MAX_ROW][MAX_COLUMN];\n\n                    // Create a nested for loop to add the two matrice together\n                    for (int i = 0; i < rowsA; i++) {\n                        for (int j = 0; j < columnsA; j++) {\n                            sumMatrix[i][j] = elementA[i][j] + elementB[i][j];\n                            // Stores the sum of each dimension in the matrices into the new variable sumMatrix\n                            // if currently sumMatrix[1][1] (which is the very first or top left dimension), then it will store the sum of elementA[1][1] and elementB[1][1]\n                        }\n                    }\n\n                    // Create another nested for loop to output each stored value of sumMatrix\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    for (int i = 0; i < rowsA; i++) {\n                        for (int j = 0; j < columnsA; j++) {\n                            printf(\"%d\\t\", sumMatrix[i][j]);   // prints out all the stored value in one line spaced by \\t (tab)\n\n                            if (j == columnsA - 1) {           // create an if statement so that when count j is the equal to columnsA of user input (-1 is used since int j starts at 0)\n                                printf(\"\\n\");                  // when equal, make a new line to make the output into a matrix form\n                            }\n                        }\n                        printf(\"\\n\");                          // Create a new line to have a distance before the menu prompt prompts again\n                    }\n                    break;                                     // breaks the case and repeats the do while loop\n                }\n            case 2: // Subtract Matrices\n                // To subtract matrices, the dimension of rows of both matrices and the dimension of columns of both matrices must be equal\n                if (rowsA != rowsB || columnsA != columnsB) {\n                    printf(\"Addition of Matrix A and B not possible.\\n\");    // Prints out an error message if either the rows or columns matrices are not equal\n                    break;\n                } else {\n                    // define a new variable to use in this part of the code\n                    int subtractMatrix[MAX_ROW][MAX_COLUMN];\n\n                    // Create a nested for loop to subtract the two matrice together\n                    for (int i = 0; i < rowsA; i++) {\n                        for (int j = 0; j < columnsA; j++) {\n                            subtractMatrix[i][j] = elementA[i][j] - elementB[i][j];\n                            // Stores the difference of each dimension in the matrices into the new variable subtractMatrix\n                            // if currently subtractMatrix[1][1] (which is the very first or top left dimension), then it will store the difference of elementA[1][1] and elementB[1][1]\n                        }\n                    }\n\n                    // Create another nested for loop to output each stored value of subtractMatrix\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    for (int i = 0; i < rowsA; i++) {\n                        for (int j = 0; j < columnsA; j++) {\n                            printf(\"%d\\t\", subtractMatrix[i][j]);     // prints out all the stored value in one line spaced by \\t (tab)\n\n                            if (j == columnsA - 1) {                  // create an if statement so that when count j is the equal to columnsA of user input (-1 is used since int j starts at 0)\n                                printf(\"\\n\");                         // when equal, make a new line to make the output into a matrix form\n                            }\n                        }\n                        printf(\"\\n\");                                 // Create a new line to have a distance before the menu prompt prompts again\n                    }\n                    break;                                            // breaks the case and repeats the do while loop\n                }\n            case 3:\n                // Create a nested loop to swap (or transpose) the dimensions of elementA into transposeA\n                for (int i = 0; i < rowsA; i++) {\n                    for (int j = 0; j < columnsA; j++) {\n                        transposeA[j][i] = elementA[i][j];     // as long as nested for loop continues, the value stored in rowsA in elementA will be put into columnsA of transposeA and the columnsA in nestedA will be the rowsA in transposeA\n                    }\n                }\n\n                // Create another nested for loop to output each stored value of transposeA\n                printf(\"Transpose of Matrix A:\\n\");\n                for (int i = 0; i < columnsA; i++) {\n                    for (int j = 0; j < rowsA; j++) {\n                        printf(\"%d\\t\", transposeA[i][j]);     // prints out all the stored value in one line spaced by \\t (tab)\n                    }\n                    printf(\"\\n\");        // prints a new line after every time the second for loop breaks\n                }\n                printf(\"\\n\");            // Create a new line to have a distance before the menu prompt prompts again\n                break;                   // breaks the case and repeats the do while loop\n            case 4:\n                // Create a nested loop to swap (or transpose) the dimensions of elementB into transposeB\n                for (int i = 0; i < rowsB; i++) {\n                    for (int j = 0; j < columnsB; j++) {\n                        transposeB[j][i] = elementB[i][j];     // as long as nested for loop continues, the value stored in rowsB in elementB will be put into columnsB of transposeB and the columnsB in nestedB will be the rowsB in transposeB\n                    }\n                }\n\n                // Create another nested for loop to output each stored value of transposeB\n                printf(\"Transpose of Matrix B:\\n\");\n                for (int i = 0; i < columnsB; i++) {\n                    for (int j = 0; j < rowsA; j++) {\n                        printf(\"%d\\t\", transposeB[i][j]);     // prints out all the stored value in one line spaced by \\t (tab)\n                    }\n                    printf(\"\\n\");        // prints a new line after every time the second for loop breaks\n                }\n                printf(\"\\n\");            // Create a new line to have a distance before the menu prompt prompts again\n                break;                   // breaks the case and repeats the do while loop\n            case 5:\n                printf(\"Exiting...\\n\");    // Inform user they have chosen to exit program\n                break;                     // breaks the case\n            default:\n                printf(\"Invalid option choice. Please try again.\\n\");   // Inform user that option choice is invalid and to prompt them to try again\n                break;       // breaks the case and repeats the do while loop\n        }\n    } while (choice != 5);   // do while loop repeats until user inputs 5 which whill finally end the loop and end the program\n\n    return 0;\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100  // Define the maximum number of items able to be input into the list\n\n// Define variables in the struct data type to call upon anytime within the code\nstruct Grocery {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    bool availability;\n};\n\n// Create a void function to code on adding grocery items into the grocery list\nvoid addGroceryItems(struct Grocery Grocer_Item[], int *list_count) {\n    // Prints out an error/following message if the number of grocery items in the list is more than the required max amount\n    if (*list_count >= MAX_ITEMS) {\n        printf(\"List is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    struct Grocery item; // calls the struct data type\n    getchar();           // Clear the buffer before reading strings\n\n    printf(\"Enter Item Name: \");                             // Prompts user to input the item name\n    fgets(item.name, sizeof(item.name), stdin);              // Stores the string into the item.name variable\n    item.name[strcspn(item.name, \"\\n\")] = 0;                 // Remove trailing newline\n\n    printf(\"Enter Category: \");                              // Prompts user to input the item category\n    fgets(item.category, sizeof(item.category), stdin);      // Stores the string into the item.category variable\n    item.category[strcspn(item.category, \"\\n\")] = 0;         // Remove trailing newline\n\n    printf(\"Enter Quantity: \");                              // Prompts user to input the item quantity\n    scanf(\"%d\", &item.quantity);                             // Stores the string into the item.quantity variable\n\n    printf(\"Enter Price: \");                                 // Prompts user to input the item price\n    scanf(\"%f\", &item.price);                                // Stores the string into the item.price variable\n\n    Grocer_Item[*list_count] = item;   // Code assigns the struct type of Grocery (item) to the array Grocer_Item at the position *list_count\n    (*list_count)++;                   // increments the grocery count by 1 after every grocery name is input\n\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Create a void function to code the grocery list to output\nvoid listGroceryItems(struct Grocery *item, int list_count) {\n    // If no grocery items are in the list, system outputs the following message\n    if (list_count == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    printf(\"Grocery List\\n\");\n    // Prints every stored value in the i arrays\n    for (int i = 0; i < list_count; i++) {\n        printf(\"\\nItem %d:\\n\", i + 1);                  // Prints the current item number on the list, up to down 1 - 100\n        printf(\"Name: %s\\n\", item[i].name);             // Prints the name of item stored in the current i array\n        printf(\"Category: %s\\n\", item[i].category);     // Prints the category of stored item in the current i array\n        printf(\"Quantity: %d\\n\", item[i].quantity);     // Prints the quantity of stored item in the current i array\n        printf(\"Price: $%.2f\\n\", item[i].price);        // Prints the price of stored item in the current i array\n\n        // Create an if else statement on whether the quantity of items is either 0 or not 0.\n        if(item[i].quantity > 0) {\n            item[i].availability = true;\n        } else {\n            item[i].availability = false;\n        }\n                    \n        if(item[i].availability) {\n            printf(\"Status: In Stock\\n\");               // Prints \"In Stock\" if quantity > 0\n        } else {\n            printf(\"Status: Out of Stock\\n\");           // Prints \"Out of Stock\" if quantity == 0\n        }\n    }\n}\n\n// Create a void function to update the quantity of an item in the grocery list\nvoid updateQuantity(struct Grocery *item, int list_count) {\n    char tempSearch[100]; // new define char to hold the temporary string input from user to compare with the grocery items saved in the grocery list\n    int tempQ;\n    int index = -1;\n    // If there is no items in the grocery list, print the following message\n    if (list_count == 0) {\n        printf(\"No grocery list to update quantity.\\n\");\n        return;\n    }\n\n    getchar();              // Clear the buffer before reading strings                 \n\n    printf(\"Enter name of the grocery item to update quantity: \");      // Prompt user to input the name of grocery item to change quantity of\n    fgets(tempSearch, sizeof(tempSearch), stdin);                       // Store value into the temporary variable tempSearch\n    tempSearch[strcspn(tempSearch, \"\\n\")] = 0;\n\n    printf(\"Enter new quantity for %s: \", tempSearch);                  // Prompt user to enter the new quantity for the following grocery item\n    scanf(\"%d\", &tempQ);                                                // Store value into the temporary variable tempQ\n\n    // For loop is used to search and compare the item name from user input with what is saved into the list\n    for (int i = 0; i < list_count; i++) {\n        if (strcmp(item[i].name, tempSearch) == 0) {\n            index = i;                                  // If the name is found, index will equal to the following i value on where it was found\n            break;\n        }\n    }\n\n    if (index != -1) { // Since index = -1 is what we used to flag the original index value, and since it's not possible for i to be -1, if index = -1 or it has changed, that means the name has been found\n        item[index].quantity = tempQ;\n        printf(\"Quantity uploaded successfully!\\n\");    // If found print this message\n    } else {\n        printf(\"Grocery item does not exist in the list.\\n\");   // If not print this message\n    }\n\n}\n\n// Create a void function to remove any grocery items from the grocery list\nvoid removeGroceryItems(struct Grocery *item, int *list_count) {\n    char delname[100];   // Holds part of the name of the grocery item to delete\n    int found = -1;      // Flag to track if a matching grocery item is found\n\n    getchar(); // Clear the buffer before reading strings\n    \n    printf(\"Enter name of the grocery item to remove: \");       // Prompts user to input the name of grocery item to remove\n    fgets(delname, sizeof(delname), stdin);                     // Stores the value into the variable delname\n    delname[strcspn(delname, \"\\n\")] = '\\0';                     // Remove newline from input\n\n    // For loop is used to search and compare the item name from user input with what is saved into the list\n    for (int i = 0; i < *list_count; i++) {\n        if (strcmp(item[i].name, delname) == 0) {\n            found = i;                                          // If the name is found, found will equal to the following i value on where it was found\n            break;\n        }\n    }\n\n    if (found != -1) {  // Since found = -1 is what we used to flag the original index value, and since it's not possible for i to be -1, if found = -1 or it has changed, that means the name has been found\n        printf(\"Grocery item '%s' removed successfully!\\n\", item[found].name);\n        // Shift remaining grocery items to fill the gap\n        for (int j = found; j < *list_count - 1; j++) {\n            item[j] = item[j + 1];\n        }\n\n        (*list_count)--; // Decrease the total grocery item count\n    } else {\n        printf(\"The grocery you're looking for is not in the list.\\n\");\n    }\n}\n\nint main() {\n    // define the variables to use in the main function of the code\n    int choice;\n    int list_count = 0;\n    struct Grocery list[MAX_ITEMS];\n    do { // Create a do loop to print out the management system menu and prompt the user to input their choice\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);   // system receives the input from user and stores into choice which is used for the following switch case loop\n\n        switch(choice) {\n            case 1: // Add Grocery Item\n                addGroceryItems(list, &list_count); // Calls the void funtion to add a grocery item\n                break;  // breaks from the switch case before repeating with the do while loop\n            case 2: // List All Grocery Items\n                listGroceryItems(list, list_count); // Calls the void function to print the grocery items in the grocery list\n                break;  // breaks from the switch case before repeating with the do while loop\n            case 3: // Update Quantity\n                updateQuantity(list, list_count);   // Calls the void funtion to update the quantity of a chosen qrocery item\n                break;  // breaks from the switch case before repeating with the do while loop\n            case 4: // Remove Quantity Item\n                removeGroceryItems(list, &list_count);  // Calls the void function to remove an item from the quantity list\n                break;  // breaks from the switch case before repeating with the do while loop\n            case 5: // Exit\n                printf(\"Exiting...\\n\");     // Prints the following message before continuing the do while loop\n                break;  // breaks from the switch case before repeating with the do while loop\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");  // Prints the following message before continuing the do while loop\n                break;  // breaks from the switch case before repeating with the do while loop\n        }\n    } while (choice != 5); // the do while loop will keep repeating until user inputs the value 5, which then will close not only the do while loop but hence closes the system\n\n    return 0;\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student *newStudent = malloc(sizeof(Student));     // Allocate new memory for new student input\n\n    if (newStudent != NULL) {               // An if else statement to ensure memory allocation is successful before the program proceeds\n        strcpy(newStudent -> name, name);   // Copies the student name input into the node\n        newStudent -> id = id;              // Transfers the student id input into the node\n        newStudent -> grade = grade;        // Transfers the student grade input into the node\n        newStudent -> next = NULL;          // After every data has been input, the current node does not link to another node\n    }\n    return newStudent;                      // Returns the pointer to the newly created struct\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student *newStudent = createStudent(name, id, grade);   // Creates a new node and calls the function createStudent to get the values for the node\n\n    if (newStudent != NULL) {           // An if else statement to ensure memory allocation is successful before the program proceeds\n        newStudent -> next = head;      // Program inserts new node at the beginning of the list\n        head = newStudent;\n    }\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {     // Output a message if the student record is empty/no student records have been input yet\n        puts(\"Empty Student Records.\\n\");\n    } else {\n        puts(\"\\nStudent Records:\\n\");\n\n        Student *newStudent = head;             // Start the list from the head\n\n        while (newStudent != NULL) {            // An if else statement to ensure memory allocation is successful before the program proceeds\n            printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", newStudent->name, newStudent->id, newStudent->grade);     // Prints out the following data\n            newStudent = newStudent -> next;    // Move to the next node\n        }\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {    \n    Student *newStudent = head;              // Start the list from the head\n    while (newStudent != NULL) {             // Ensures memory allocation is successful before the program proceeds\n        if (newStudent -> id == id) {        // If the id user input matches a student's id in the list, return with the matching student (in context with menu below, found is true)\n            return newStudent;\n        }\n        newStudent = newStudent -> next;     // Program runs each list until the list with the matching id is found\n    }\n    return NULL;                             // If no matches, program returns a NULL terminatore (or found is false)\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n    current = next;\n    }\n    head = NULL;\n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() {\n    if (head == NULL) {     // Output a message if the student record is empty/no student records have been input yet\n        puts(\"Empty Student Records.\\n\");\n    } else {\n        int swapped;\n        Student *node;              // Start from first node\n        Student *lastNode = NULL;   // Tracks the last node in the sorted order\n\n        do {\n            swapped = 0;\n            node = head;\n\n            // Buffer sort\n            while (node->next != lastNode) {    // Bubble sort continues until the current reading node is the last node\n                if (node->grade > node->next->grade) {    // Swaps data if the current id is more than the next id\n                    // Declare temporary variables to store the information of the current student\n                    int tempID = node->id;\n                    float tempGrade = node->grade;\n                    char tempName[100];\n                    strcpy(tempName, node->name);\n\n                    // Transfer the student information of the next student to the current student\n                    node->id = node->next->id;\n                    node->grade = node->next->grade;\n                    strcpy(node->name, node->next->name);\n\n                    // Finally transfer the temporary variables into the next student\n                    node->next->id = tempID;\n                    node->next->grade = tempGrade;\n                    strcpy(node->next->name, tempName);\n\n                    swapped = 1;\n                }\n                node = node->next; // Once done the program compares the next student to use as the current student and the following student to be the next student\n            }\n            lastNode = node;   // Updates the last node to just be node\n\n        } while (swapped);\n        puts(\"Records sorted by grade using Bubble Sort.\\n\");\n    }\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (choose sorting method)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\n                    found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}",
    "feedback": "q1- In the second for loop for inputting elements of Matrix B, the loop condition should iterate based on rowsB and columnsB, but there is a mistake in the transposing section where rowsA is used instead of rowsB for printing the transposed Matrix B.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is used to sort student records by grade. While this method works correctly for small datasets, it has a time complexity of O(n?), which can lead to inefficiencies with larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20576624",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX 10\n\nvoid inputMatrix(int rows, int columns, int matrix[MAX][MAX], char name) {\n    printf(\"Enter elements for Matrix %c:\\n\", name);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid addMatrices(int rows, int columns, int A[MAX][MAX], int B[MAX][MAX]) {\n    int result[MAX][MAX];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n    printf(\"Result of Matrix A + Matrix B:\\n\");\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            printf(\"%d \", result[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid subtractMatrices(int rows, int columns, int A[MAX][MAX], int B[MAX][MAX]) {\n    int result[MAX][MAX];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n    printf(\"Result of Matrix A - Matrix B:\\n\");\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            printf(\"%d \", result[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid transposeMatrix(int rows, int columns, int matrix[MAX][MAX], char name) {\n    int transpose[MAX][MAX];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            transpose[j][i] = matrix[i][j];\n        }\n    }\n    printf(\"Transpose of Matrix %c:\\n\", name);\n    for (int i = 0; i < columns; i++) {\n        for (int j = 0; j < rows; j++) {\n            printf(\"%d \", transpose[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    int A[MAX][MAX], B[MAX][MAX];\n    int rowsA, columnsA, rowsB, columnsB;\n\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &columnsA);\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &columnsB);\n\n    if (rowsA > MAX || columnsA > MAX || rowsB > MAX || columnsB > MAX) {\n        printf(\"Error!!! Matrix dimensions exceed maximum allowed size of %d\\n\", MAX);\n        return 1;\n    }\n\n    if (rowsA != rowsB || columnsA != columnsB) {\n        printf(\"Error!!! Addition and subtraction require matrices of the same dimensions.\\n\");\n    }\n\n    inputMatrix(rowsA, columnsA, A, 'A');\n    inputMatrix(rowsB, columnsB, B, 'B');\n\n    int choice;\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && columnsA == columnsB) {\n                    addMatrices(rowsA, columnsA, A, B);\n                } else {\n                    printf(\"Error!!! Matrices must have the same dimensions for addition.\\n\");\n                }\n                break;\n            case 2:\n                if (rowsA == rowsB && columnsA == columnsB) {\n                    subtractMatrices(rowsA, columnsA, A, B);\n                } else {\n                    printf(\"Error!!! Matrices must have the same dimensions for subtraction.\\n\");\n                }\n                break;\n            case 3:\n                transposeMatrix(rowsA, columnsA, A, 'A');\n                break;\n            case 4:\n                transposeMatrix(rowsB, columnsB, B, 'B');\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    int inStock; // 1 for in stock, 0 for out of stock\n} GroceryItem;\n\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    int totalItems;\n} GroceryInventory;\n\nvoid addItem(GroceryInventory *inventory) {\n    if (inventory->totalItems >= MAX_ITEMS) {\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n    printf(\"Enter Item Name: \");\n    scanf(\" %[^\\n]\", newItem.name);\n    printf(\"Enter Category: \");\n    scanf(\" %[^\\n]\", newItem.category);\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &newItem.price);\n\n    newItem.inStock = newItem.quantity > 0 ? 1 : 0;\n    inventory->items[inventory->totalItems++] = newItem;\n\n    printf(\"Grocery item added successfully!\\n\");\n}\n\nvoid listItems(GroceryInventory *inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < inventory->totalItems; i++) {\n        GroceryItem item = inventory->items[i];\n        printf(\"Name: %s\\n\", item.name);\n        printf(\"Category: %s\\n\", item.category);\n        printf(\"Quantity: %d\\n\", item.quantity);\n        printf(\"Price: %.2f\\n\", item.price);\n        printf(\"Status: %s\\n\", item.inStock ? \"In Stock\" : \"Out of Stock\");\n        printf(\"\\n\");\n    }\n}\n\nvoid updateQuantity(GroceryInventory *inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No grocery items in the inventory to update.\\n\");\n        return;\n    }\n\n    char itemName[100];\n    printf(\"Enter name of the grocery item to update quantity: \");\n    scanf(\" %[^\\n]\", itemName);\n\n    for (int i = 0; i < inventory->totalItems; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            printf(\"Enter new quantity for %s: \", itemName);\n            scanf(\"%d\", &inventory->items[i].quantity);\n\n            inventory->items[i].inStock = inventory->items[i].quantity > 0 ? 1 : 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Grocery item not found in the inventory.\\n\");\n}\n\nvoid removeItem(GroceryInventory *inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No grocery items in the inventory to remove.\\n\");\n        return;\n    }\n\n    char itemName[100];\n    printf(\"Enter name of the grocery item to remove: \");\n    scanf(\" %[^\\n]\", itemName);\n\n    for (int i = 0; i < inventory->totalItems; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            for (int j = i; j < inventory->totalItems - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n            }\n            inventory->totalItems--;\n            printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\n            return;\n        }\n    }\n\n    printf(\"Grocery item not found in the inventory.\\n\");\n}\n\nint main() {\n    GroceryInventory inventory = { .totalItems = 0 };\n    int choice;\n\n    do {\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Clear newline character from input buffer\n\n        switch (choice) {\n            case 1:\n                addItem(&inventory);\n                break;\n            case 2:\n                listItems(&inventory);\n                break;\n            case 3:\n                updateQuantity(&inventory);\n                break;\n            case 4:\n                removeItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (!head) {\n        printf(\"No student records available.\\n\");\n        return;\n    }\n    Student* current = head;\n    while (current) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n    printf(\"All student records deleted successfully.\\n\");\n}\n\n// Function to sort student records by grade using Bubble Sort\nvoid sortStudents() {\n    if (!head || !head->next) {\n        printf(\"Not enough records to sort.\\n\");\n        return;\n    }\n    Student* i;\n    Student* j;\n    for (i = head; i != NULL; i = i->next) {\n        for (j = i->next; j != NULL; j = j->next) {\n            if (i->grade > j->grade) {\n                // Swap records\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, i->name);\n                tempID = i->id;\n                tempGrade = i->grade;\n\n                strcpy(i->name, j->name);\n                i->id = j->id;\n                i->grade = j->grade;\n\n                strcpy(j->name, tempName);\n                j->id = tempID;\n                j->grade = tempGrade;\n            }\n        }\n    }\n    printf(\"Records sorted by grade.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                name[strcspn(name, \"\\n\")] = 0; // Remove trailing\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                break;\n            case 6:\n                deleteList();\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-In the transposeMatrix function, the output should use the correct dimensions of the transposed matrix. When printing the transposed matrix, the loops should iterate using columns for rows and rows for columns.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly, but it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20610102",
    "code": "\n/* --- Q1.C --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int *rows, int *cols, char *name);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char *name);\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                 int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                      int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int original[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], \r\n                     int *rows, int *cols);\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int A_rows, A_cols, B_rows, B_cols, choice;\r\n    \r\n    printf(\"Matrix Operations Program\\n\");\r\n    \r\n    // Input matrices\r\n    printf(\"\\nEnter Matrix A:\\n\");\r\n    inputMatrix(A, &A_rows, &A_cols, \"A\");\r\n    \r\n    printf(\"\\nEnter Matrix B:\\n\");\r\n    inputMatrix(B, &B_rows, &B_cols, \"B\");\r\n    \r\n    // Main menu loop\r\n    while (1) {\r\n        // Display menu\r\n        printf(\"\\n--- Matrix Operations Menu ---\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice (1-5): \");\r\n        scanf(\"%d\", &choice);\r\n        \r\n        // Perform selected operation\r\n        switch(choice) {\r\n            case 1: \r\n                // Check if matrices can be added\r\n                if (A_rows == B_rows && A_cols == B_cols) {\r\n                    addMatrices(A, B, result, A_rows, A_cols);\r\n                    printf(\"\\nResult of Matrix Addition:\\n\");\r\n                    printMatrix(result, A_rows, A_cols, \"Result\");\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions for addition!\\n\");\r\n                }\r\n                break;\r\n            \r\n            case 2:\r\n                // Check if matrices can be subtracted\r\n                if (A_rows == B_rows && A_cols == B_cols) {\r\n                    subtractMatrices(A, B, result, A_rows, A_cols);\r\n                    printf(\"\\nResult of Matrix Subtraction:\\n\");\r\n                    printMatrix(result, A_rows, A_cols, \"Result\");\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions for subtraction!\\n\");\r\n                }\r\n                break;\r\n            \r\n            case 3:\r\n                transposeMatrix(A, result, &A_rows, &A_cols);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                printMatrix(result, A_cols, A_rows, \"Transposed A\");\r\n                break;\r\n            \r\n            case 4:\r\n                transposeMatrix(B, result, &B_rows, &B_cols);\r\n                printf(\"\\nTranspose of Matrix B:\\n\");\r\n                printMatrix(result, B_cols, B_rows, \"Transposed B\");\r\n                break;\r\n            \r\n            case 5:\r\n                printf(\"Exiting the program. Goodbye!\\n\");\r\n                return 0;\r\n            \r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}\r\n\r\n// Function to input matrix elements\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int *rows, int *cols, char *name) {\r\n    // Input matrix dimensions\r\n    do {\r\n        printf(\"Enter number of rows for Matrix %s (1-%d): \", name, MAX_SIZE);\r\n        scanf(\"%d\", rows);\r\n        printf(\"Enter number of columns for Matrix %s (1-%d): \", name, MAX_SIZE);\r\n        scanf(\"%d\", cols);\r\n        \r\n        if (*rows < 1 || *rows > MAX_SIZE || *cols < 1 || *cols > MAX_SIZE) {\r\n            printf(\"Invalid dimensions. Please enter values between 1 and %d.\\n\", MAX_SIZE);\r\n        }\r\n    } while (*rows < 1 || *rows > MAX_SIZE || *cols < 1 || *cols > MAX_SIZE);\r\n    \r\n    // Input matrix elements\r\n    printf(\"Enter %d elements for Matrix %s:\\n\", (*rows) * (*cols), name);\r\n    for (int i = 0; i < *rows; i++) {\r\n        for (int j = 0; j < *cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print matrix elements\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char *name) {\r\n    printf(\"Matrix %s:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d\\t\", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                 int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], \r\n                      int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            C[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int original[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], \r\n                     int *rows, int *cols) {\r\n    // Swap rows and columns for transposed matrix\r\n    for (int i = 0; i < *rows; i++) {\r\n        for (int j = 0; j < *cols; j++) {\r\n            transposed[j][i] = original[i][j];\r\n        }\r\n    }\r\n    \r\n    // Swap the number of rows and columns\r\n    int temp = *rows;\r\n    *rows = *cols;\r\n    *cols = temp;\r\n}\n/* --- Q2.C --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Define Availability Status structure\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Define Grocery Item structure\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    AvailabilityStatus status;\r\n} GroceryItem;\r\n\r\n// Grocery Inventory structure\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus statuses[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function Prototypes\r\nvoid initializeInventory(GroceryInventory *inventory);\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateItemQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\nint findItemIndex(GroceryInventory *inventory, char *itemName);\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    int choice;\r\n\r\n    // Initialize inventory\r\n    initializeInventory(&inventory);\r\n\r\n    // Main menu loop\r\n    while (1) {\r\n        // Display menu options\r\n        printf(\"\\n--- Grocery Inventory Management System ---\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Item Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice (1-5): \");\r\n        \r\n        // Clear any previous input errors\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            // Clear input buffer\r\n            while (getchar() != '\\n');\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            continue;\r\n        }\r\n        getchar(); // Clear newline\r\n\r\n        // Process user choice\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateItemQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program. Goodbye!\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Initialize inventory\r\nvoid initializeInventory(GroceryInventory *inventory) {\r\n    inventory->itemCount = 0;\r\n}\r\n\r\n// Add a new grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    // Check if inventory is full\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    // Input item name\r\n    printf(\"Enter item name (max %d characters): \", MAX_NAME_LENGTH - 1);\r\n    if (fgets(newItem.name, MAX_NAME_LENGTH, stdin) == NULL) {\r\n        printf(\"Error reading item name.\\n\");\r\n        return;\r\n    }\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0; // Remove newline\r\n\r\n    // Check for duplicate items\r\n    if (findItemIndex(inventory, newItem.name) != -1) {\r\n        printf(\"Item with this name already exists!\\n\");\r\n        return;\r\n    }\r\n\r\n    // Input category\r\n    printf(\"Enter item category (max %d characters): \", MAX_CATEGORY_LENGTH - 1);\r\n    if (fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin) == NULL) {\r\n        printf(\"Error reading item category.\\n\");\r\n        return;\r\n    }\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0; // Remove newline\r\n\r\n    // Input quantity\r\n    printf(\"Enter item quantity: \");\r\n    if (scanf(\"%d\", &newItem.quantity) != 1) {\r\n        printf(\"Invalid quantity input.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n        return;\r\n    }\r\n    while (getchar() != '\\n'); // Clear newline\r\n\r\n    // Input price\r\n    printf(\"Enter item price: \");\r\n    if (scanf(\"%f\", &newItem.price) != 1) {\r\n        printf(\"Invalid price input.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n        return;\r\n    }\r\n    while (getchar() != '\\n'); // Clear newline\r\n\r\n    // Set availability status\r\n    newItem.status.inStock = (newItem.quantity > 0);\r\n    newItem.status.outOfStock = (newItem.quantity == 0);\r\n\r\n    // Add item to inventory\r\n    inventory->items[inventory->itemCount] = newItem;\r\n    inventory->statuses[inventory->itemCount] = newItem.status;\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Rest of the code remains the same as in the previous implementation\r\n// (List, Update, Remove, and Find Item functions)\n/* --- Q3.C --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate memory for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    \r\n    // Check if memory allocation was successful\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    \r\n    // Copy name, set id and grade\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    \r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    \r\n    // If memory allocation failed, return\r\n    if (newStudent == NULL) {\r\n        return;\r\n    }\r\n    \r\n    // If list is empty or new student should be at the beginning\r\n    if (head == NULL || head->id > newStudent->id) {\r\n        newStudent->next = head;\r\n        head = newStudent;\r\n        return;\r\n    }\r\n    \r\n    // Find the right position to insert\r\n    Student* current = head;\r\n    while (current->next != NULL && current->next->id < newStudent->id) {\r\n        current = current->next;\r\n    }\r\n    \r\n    // Insert the new student\r\n    newStudent->next = current->next;\r\n    current->next = newStudent;\r\n    \r\n    printf(\"Student record inserted successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    // Check if list is empty\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    \r\n    printf(\"\\n--- Student Records ---\\n\");\r\n    printf(\"%-30s %-10s %-10s\\n\", \"Name\", \"ID\", \"Grade\");\r\n    printf(\"----------------------------------------------\\n\");\r\n    \r\n    // Traverse the list and print each student's details\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"%-30s %-10d %-10.2f\\n\", \r\n               current->name, \r\n               current->id, \r\n               current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    \r\n    // Traverse the list to find student with matching ID\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    \r\n    // Return NULL if student not found\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    // Free each node in the list\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    \r\n    // Set head to NULL\r\n    head = NULL;\r\n    printf(\"List deleted successfully.\\n\");\r\n}\r\n\r\n// Function to free memory and exit\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to swap two students\r\nvoid swap(Student* a, Student* b) {\r\n    // Temporary struct to hold swap data\r\n    Student temp;\r\n    strcpy(temp.name, a->name);\r\n    temp.id = a->id;\r\n    temp.grade = a->grade;\r\n    \r\n    strcpy(a->name, b->name);\r\n    a->id = b->id;\r\n    a->grade = b->grade;\r\n    \r\n    strcpy(b->name, temp.name);\r\n    b->id = temp.id;\r\n    b->grade = temp.grade;\r\n}\r\n\r\n// Bubble Sort algorithm to sort students by grade\r\n// Chosen for its simplicity and ease of implementation\r\n// Time complexity: O(n^2), Space complexity: O(1)\r\nvoid sortStudents() {\r\n    // Check if list is empty or has only one element\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n    \r\n    int swapped;\r\n    Student* current;\r\n    Student* last = NULL;\r\n    \r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n        \r\n        while (current->next != last) {\r\n            // Compare and swap if current grade is greater than next\r\n            if (current->grade > current->next->grade) {\r\n                swap(current, current->next);\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        last = current;\r\n    } while (swapped);\r\n    \r\n    printf(\"Students sorted by grade successfully!\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    \r\n    do {\r\n        printf(\"\\n--- Student Record Management System ---\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        \r\n        // Input validation\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            // Clear input buffer\r\n            while (getchar() != '\\n');\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            continue;\r\n        }\r\n        \r\n        // Consume newline\r\n        getchar();\r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = 0; // Remove newline\r\n                \r\n                printf(\"Enter ID: \");\r\n                if (scanf(\"%d\", &id) != 1) {\r\n                    printf(\"Invalid ID input.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    continue;\r\n                }\r\n                \r\n                printf(\"Enter Grade: \");\r\n                if (scanf(\"%f\", &grade) != 1) {\r\n                    printf(\"Invalid grade input.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    continue;\r\n                }\r\n                \r\n                insertStudent(name, id, grade);\r\n                break;\r\n            \r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            \r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            \r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                if (scanf(\"%d\", &id) != 1) {\r\n                    printf(\"Invalid ID input.\\n\");\r\n                    while (getchar() != '\\n');\r\n                    continue;\r\n                }\r\n                \r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            \r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            \r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            \r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    \r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to arrange student records by grade. While this algorithm is straightforward and easy to implement, it has a time complexity of O(n?), making it less efficient for larger datasets. For improved performance, consider using a more efficient sorting algorithm like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20605542",
    "code": "",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program utilizes the bubble sort algorithm to sort student records by grade. While this method is straightforward, it has a time complexity of O(n?), which can lead to inefficiencies with larger datasets. For better performance, consider implementing a more efficient sorting algorithm such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20602511",
    "code": "\n/* --- Wong Cheuk Kei (20602511)/Wong Cheuk Kei (20602511)/Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\nvoid displayMenu();\r\nvoid add(int rows, int columns, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int sum[MAX_SIZE][MAX_SIZE]);\r\nvoid subtract(int rows, int columns, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int diff[MAX_SIZE][MAX_SIZE]);\r\nvoid transpose(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE], int trans[MAX_SIZE][MAX_SIZE]);\r\nvoid printMatrix(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE]);\r\n\r\nint main() {\r\n    int rowsA, columnsA, rowsB, columnsB;\r\n    int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE], sum[MAX_SIZE][MAX_SIZE], diff[MAX_SIZE][MAX_SIZE], trans[MAX_SIZE][MAX_SIZE];\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &columnsA);\r\n\r\n    // Validate dimensions for Matrix A\r\n    if (rowsA > MAX_SIZE || columnsA > MAX_SIZE || rowsA <= 0 || columnsA <= 0) {\r\n        printf(\"Invalid dimensions! Rows and columns must be between 1 and 10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rowsA; i++) {\r\n        for (int j = 0; j < columnsA; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &a[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &columnsB);\r\n\r\n    // Validate dimensions for Matrix B\r\n    if (rowsB > MAX_SIZE || columnsB > MAX_SIZE || rowsB <= 0 || columnsB <= 0) {\r\n        printf(\"Invalid dimensions! Rows and columns must be between 1 and 10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Check if the dimensions of Matrix B match Matrix A\r\n    if (rowsA != rowsB || columnsA != columnsB) {\r\n        printf(\"Matrix dimensions of A and B do not match! Cannot perform addition or subtraction.\\n\");\r\n        return 1;  \r\n    }\r\n\r\n    // Input elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < rowsB; i++) {\r\n        for (int j = 0; j < columnsB; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &b[i][j]);\r\n        }\r\n    }\r\n\r\n    while (1) {\r\n        int choice;\r\n\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                add(rowsA, columnsA, a, b, sum);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(rowsA, columnsA, sum);\r\n                break;\r\n\r\n            case 2:\r\n                subtract(rowsA, columnsA, a, b, diff);\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                printMatrix(rowsA, columnsA, diff);\r\n                break;\r\n\r\n            case 3:\r\n                transpose(rowsA, columnsA, a, trans);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(rowsA, columnsA, trans);\r\n                break;\r\n\r\n            case 4:\r\n                transpose(rowsB, columnsB, b, trans);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(rowsB, columnsB, trans);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to print menu\r\nvoid displayMenu() {\r\n    printf(\"\\nMatrix Operation Menu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Function to add two matrices\r\nvoid add(int rows, int columns, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int sum[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < columns; ++j) {\r\n            sum[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtract(int rows, int columns, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int diff[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < columns; ++j) {\r\n            diff[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transpose(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE], int trans[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < columns; ++j) {\r\n            trans[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; ++i) {\r\n        for (int j = 0; j < columns; ++j) {\r\n            printf(\"%d  \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\n/* --- Wong Cheuk Kei (20602511)/Wong Cheuk Kei (20602511)/Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_NAMES 100\r\n#define MAX_CATEGORY 50\r\n#define MAX_ITEMS 100\r\n\r\n// Define a structure for grocery items\r\nstruct GroceryItem {\r\n    char name[MAX_NAMES];\r\n    char category[MAX_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Define a structure to represent availability status\r\nstruct AvailabilityStatus {\r\n    bool inStock;\r\n    bool outOfStock;\r\n};\r\n\r\n// Define the inventory structure\r\nstruct GroceryInventory {\r\n    struct GroceryItem items[MAX_ITEMS];\r\n    struct AvailabilityStatus status[MAX_ITEMS];\r\n    int totalItems;\r\n};\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(struct GroceryInventory *inventory);\r\nvoid listGroceryItems(struct GroceryInventory inventory);\r\nvoid updateQuantity(struct GroceryInventory *inventory);\r\nvoid removeGroceryItem(struct GroceryInventory *inventory);\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    struct GroceryInventory inventory = { .totalItems = 0 };  // Initialise the inventory\r\n\r\n    int choice;\r\n\r\n    while (1) {\r\n        displayMenu();  // Display menu options\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);  // Add a grocery item\r\n                break;\r\n            case 2:\r\n                listGroceryItems(inventory);  // List all grocery items\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);  // Update the quantity of a grocery item\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);  // Remove a grocery item from inventory\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;  \r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display the menu\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(struct GroceryInventory *inventory) {\r\n    if (inventory->totalItems >= MAX_ITEMS) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    struct GroceryItem newItem;\r\n    struct AvailabilityStatus newStatus;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    getchar();  \r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; \r\n    \r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';  \r\n    \r\n    do {\r\n        printf(\"Enter Quantity: \");\r\n        if (scanf(\"%d\", &newItem.quantity) != 1) {\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            while (getchar() != '\\n'); \r\n            continue;\r\n        }\r\n        if (newItem.quantity < 0) {\r\n            printf(\"Quantity cannot be negative. Please try again.\\n\"); // Input validation for quantity (no negative values)\r\n        }\r\n    } while (newItem.quantity < 0);\r\n\r\n    do {\r\n        printf(\"Enter Price: \");\r\n        if (scanf(\"%f\", &newItem.price) != 1) {\r\n            printf(\"Invalid input. Please enter a number.\\n\");\r\n            while (getchar() != '\\n'); \r\n            continue;\r\n        }\r\n        if (newItem.price <= 0) {\r\n            printf(\"Price must be greater than 0. Please try again.\\n\"); // Input validation for prices (no negative values)\r\n        }\r\n    } while (newItem.price <= 0);\r\n\r\n    // Set availability status based on quantity\r\n    if (newItem.quantity > 0) {\r\n        newStatus.inStock = true;\r\n        newStatus.outOfStock = false;\r\n    } else {\r\n        newStatus.inStock = false;\r\n        newStatus.outOfStock = true;\r\n    }\r\n\r\n    // Add the item to inventory\r\n    inventory->items[inventory->totalItems] = newItem;\r\n    inventory->status[inventory->totalItems] = newStatus;\r\n    inventory->totalItems++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items and their availability status\r\nvoid listGroceryItems(struct GroceryInventory inventory) {\r\n    if (inventory.totalItems == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory.totalItems; i++) {\r\n        printf(\"Name : %s\\n\", inventory.items[i].name);\r\n        printf(\"Category: %s\\n\", inventory.items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory.items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory.items[i].price);\r\n        if (inventory.status[i].inStock) {\r\n            printf(\"Status: In Stock\\n\");\r\n        } else {\r\n            printf(\"Status: Out of Stock\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(struct GroceryInventory *inventory) {\r\n    char itemName[50];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", itemName);  \r\n\r\n    // Search for the item by name\r\n    int index = -1;\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1) {\r\n        printf(\"Item not found in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    int newQuantity;\r\n    printf(\"Enter new quantity for %s: \", inventory->items[index].name);\r\n    scanf(\"%d\", &newQuantity);\r\n\r\n    // Update the quantity\r\n    inventory->items[index].quantity = newQuantity;\r\n\r\n    // Update the availability status based on the new quantity\r\n    if (newQuantity > 0) {\r\n        inventory->status[index].inStock = true;\r\n        inventory->status[index].outOfStock = false;\r\n    } else {\r\n        inventory->status[index].inStock = false;\r\n        inventory->status[index].outOfStock = true;\r\n    }\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from inventory\r\nvoid removeGroceryItem(struct GroceryInventory *inventory) {\r\n    char itemName[50];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", itemName);  \r\n\r\n    // Search for the item by name\r\n    int index = -1;\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index == -1) {\r\n        printf(\"Item not found in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift the items index to remove the item\r\n    for (int i = index; i < inventory->totalItems - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->status[i] = inventory->status[i + 1];\r\n    }\r\n\r\n    // Decrease the total item count\r\n    inventory->totalItems--;\r\n\r\n    printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n}\n/* --- Wong Cheuk Kei (20602511)/Wong Cheuk Kei (20602511)/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        perror(\"Memory allocation failed\");\r\n        exit(1);\r\n    }\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\r\n    newStudent->name[sizeof(newStudent->name) - 1] = '\\0';  // Ensuring null termination\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        newStudent->next = head;\r\n        head = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;  // Return NULL if student not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Utility function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;  // No need to sort if the list is empty or has only one element\r\n    }\r\n    int swapped;\r\n    Student* current;\r\n    Student* last = NULL;\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n        while (current->next != last) {\r\n            if (current->grade > current->next->grade) {\r\n\r\n                // Swap grades and associated student data\r\n                float tempGrade = current->grade;\r\n                int tempID = current->id;\r\n                char tempName[100];\r\n                strncpy(tempName, current->name, sizeof(tempName));\r\n\r\n                current->grade = current->next->grade;\r\n                current->id = current->next->id;\r\n                strncpy(current->name, current->next->name, sizeof(current->name));\r\n\r\n                current->next->grade = tempGrade;\r\n                current->next->id = tempID;\r\n                strncpy(current->next->name, tempName, sizeof(current->next->name));\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        last = current;\r\n        \r\n    } while (swapped);\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    \r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  // To consume the newline character\r\n        \r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    \r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. While this algorithm is straightforward, it has a time complexity of O(n?), which may not be efficient for larger datasets. For a more optimal solution, consider using algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20704636",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include <stdarg.h>\r\n\r\nstatic void error_exit(const char *msg) {\r\n\tfprintf(stderr, msg);\r\n\texit(1);\r\n}\r\n\r\nstatic void free_matrix(int **m, int rows) {\r\n\tfor (int i = 0; i < rows; ++i) {\r\n\t\tfree(m[i]);\r\n\t}\r\n\tfree(m);\r\n}\r\n\r\nstatic int get_int(int *input, const char *format, ...) {\r\n\tva_list args;\r\n\r\n    // print the formatted string\r\n    va_start(args, format);\r\n    vprintf(format, args);\r\n    va_end(args);\r\n\r\n    if (scanf(\"%d\", input) == EOF) {\r\n\t\treturn EOF;\t\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nstatic int **get_matrix_values(const char *name, int *rows, int *cols) {\r\n\t// get rows and cols\r\n\tprintf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n\tif (scanf(\" %d %d\", rows, cols) == EOF) {\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (*rows > 10 || *cols > 10) {\r\n\t\tfprintf(stderr, \"The maximum size of the matrix is 10 * 10\\n\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\tif (rows <= 0 || cols <= 0) {\r\n\t\tfprintf(stderr, \"Invalid rows or columns.\\n\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t// malloc the 2D matrix\r\n\tint **m = malloc(sizeof(int *) * (*rows));\r\n\tif (m == NULL) {\r\n\t\terror_exit(\"malloc error.\\n\");\r\n\t}\r\n\r\n\tfor (int i = 0; i < *rows; ++i) {\r\n\t\tm[i] = malloc(sizeof(int) * (*cols));\r\n\t\tif (m[i] == NULL) {\r\n\t\t\terror_exit(\"malloc error.\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\t// loop to get each value of the matrix\r\n\tfor (int i = 0; i < *rows; ++i) {\r\n\t\tfor (int j = 0; j < *cols; ++j) {\r\n\t\t\tif (get_int(&(m[i][j]), \"Element [%d][%d]: \", i + 1, j + 1) == EOF) {\r\n\t\t\t\tfree_matrix(m, *rows);\r\n\t\t\t\treturn NULL;\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn m;\r\n}\r\n\r\nstatic void print_matrix_op_menu(void) {\r\n\tputs(\"Matrix Operations Menu:\");\r\n\tputs(\"1. Add Matrices\");\r\n\tputs(\"2. Subtract Matrices\");\r\n\tputs(\"3. Transpose Matrix A\");\r\n\tputs(\"4. Transpose Matrix B\");\r\n\tputs(\"5. Exit\");\r\n}\r\n\r\n// the operator for matrix addition\r\nstatic int add(int a, int b) {\r\n\treturn a + b;\r\n}\r\n\r\n// the operator for matrix subtraction\r\nstatic int sub(int a, int b) {\r\n\treturn a - b;\r\n}\r\n\r\nstatic void matrices_op(int **A, int **B, int ra, int ca, int rb, int cb, char operator) {\r\n\t// error handling\r\n\tif (ra != rb || ca != cb) {\r\n\t\tfprintf(stderr, \"Matrix A and B doesn't have the same shape!\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tint (*op)(int, int) = NULL;\t\r\n\r\n\tif (operator == '+') {\r\n\t\top = add;\r\n\t} else if (operator == '-') {\r\n\t\top = sub;\r\n\t} else {\r\n\t\tfprintf(stderr, \"Invalid operator.\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\t// print out the added matrix\r\n\tfor (int i = 0; i < ra; ++i) {\r\n\t\tfor (int j = 0; j < ca; ++j) {\r\n\t\t\tint result = op(A[i][j], B[i][j]);\r\n\t\t\tprintf(\"%d\", result);\r\n\t\t\tif (j != ca - 1) {\r\n\t\t\t\tprintf(\" \");\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid transpose(int **m, int rows, int cols) {\r\n\tfor (int i = 0; i < cols; ++i) {\r\n\t\tfor (int j = 0; j < rows; ++j) {\r\n\t\t\tprintf(\"%d\", m[j][i]);\r\n\t\t\tif (j != rows - 1) {\r\n\t\t\t\tprintf(\" \");\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid loop_do_op(int **A, int **B, int ra, int ca, int rb, int cb) {\r\n\tint choice = 0;\r\n\twhile (true) {\r\n\t\tprint_matrix_op_menu();\r\n\r\n\t\t// scanf for choice\r\n\t\tif (get_int(&choice, \"Enter your choice: \") == EOF) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// do op, print result (or exit)\r\n\t\tswitch (choice) {\r\n\t\t\tcase 1:\r\n\t\t\t\tputs(\"Result of Matrix A + Matrix B:\");\r\n\t\t\t\tmatrices_op(A, B, ra, ca, rb, cb, '+');\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tputs(\"Result of Matrix A - Matrix B:\");\r\n\t\t\t\tmatrices_op(A, B, ra, ca, rb, cb, '-');\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tputs(\"Tranpose of Matrix A:\");\r\n\t\t\t\ttranspose(A, ra, ca);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tputs(\"Tranpose of Matrix B:\");\r\n\t\t\t\ttranspose(B, rb, cb);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tputs(\"Exiting...\");\r\n\t\t\t\treturn;\r\n\t\t\tdefault:\r\n\t\t\t\tprintf(\"Invalid choice.\\n\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(void) {\r\n\tint **A, **B, ra, ca, rb, cb;\r\n\r\n\tA = get_matrix_values(\"A\", &ra, &ca);\r\n\tif (A == NULL) {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tB = get_matrix_values(\"B\", &rb, &cb);\r\n\tif (B == NULL) {\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tloop_do_op(A, B, ra, ca, rb, cb);\r\n\r\n\tfree_matrix(A, ra);\r\n\tfree_matrix(B, rb);\r\n\r\n\treturn 0;\r\n}\n/* --- q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include <stdarg.h>\r\n\r\n#define NAME_MAX_LEN 100\r\n#define CATEGORY_MAX_LEN 50\r\n#define GROCERY_MAX_LEN 100\r\n\r\ntypedef struct s_grocery {\r\n\tchar name[NAME_MAX_LEN + 1];\r\n\tchar category[CATEGORY_MAX_LEN + 1];\r\n\tint quantity;\r\n\tfloat price;\r\n}\tt_grocery;\r\n\r\ntypedef bool t_in_stock;\r\n\r\ntypedef struct s_inventory {\r\n\tt_grocery groceries[GROCERY_MAX_LEN];\r\n\tt_in_stock availability[GROCERY_MAX_LEN];\r\n\tsize_t items_count;\r\n}\tt_inventory;\r\n\r\nstatic int get_int(int *input, const char *format, ...) {\r\n\tva_list args;\r\n\r\n    // print the formatted string\r\n    va_start(args, format);\r\n    vprintf(format, args);\r\n    va_end(args);\r\n\r\n    if (scanf(\"%d\", input) == EOF) {\r\n\t\treturn EOF;\t\r\n\t}\r\n\r\n\tfflush(stdin);\r\n\treturn 0;\r\n}\r\n\r\nstatic void print_menu(void) {\r\n\tputs(\"Grocery Inventory Management System\");\r\n\tputs(\"1. Add Grocery Item\");\r\n\tputs(\"2. List All Grocery Items\");\r\n\tputs(\"3. Update Quantity\");\r\n\tputs(\"4. Remove Grocery Item\");\r\n\tputs(\"5. Exit\");\r\n}\r\n\r\nstatic void add_grocery_item(t_inventory *inventory) {\r\n\tif (inventory->items_count >= 100) {\r\n\t\tfprintf(stderr, \"Inventory full.\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tt_grocery *current_empty_item = &(inventory->groceries[inventory->items_count]);\r\n\r\n\t// get grocery item name\r\n\tprintf(\"Enter Item Name: \");\r\n\tif (scanf(\" %100[^\\n]\", current_empty_item->name) == EOF) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// get grocery item category\r\n\tprintf(\"Enter Category: \");\r\n\tif (scanf(\" %50[^\\n]\", current_empty_item->category) == EOF) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// get grocery item quantity\r\n\tif (get_int(&(current_empty_item->quantity), \"Enter Quantity: \") == EOF) {\r\n\t\treturn;\r\n\t}\r\n\tif (current_empty_item->quantity < 0) {\r\n\t\tfprintf(stderr, \"Quantity shouldn't be less than 0.\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\t// get grocery item price\r\n\tprintf(\"Enter Price: \");\r\n\tif (scanf(\" %f\", &(current_empty_item->price)) == EOF) {\r\n\t\treturn;\r\n\t}\r\n\tif (current_empty_item->price < 0) {\r\n\t\tfprintf(stderr, \"Price shouldn't be less than 0.\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\t// update availability and increment items_count\r\n\tinventory->availability[inventory->items_count] = current_empty_item->quantity > 0;\r\n\tinventory->items_count++;\r\n\r\n\tputs(\"Grocery item added successfully!\");\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void list_grocery_items(t_inventory *inventory) {\r\n\tif (inventory->items_count == 0) {\r\n\t\tputs(\"No grocery items in inventory.\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (size_t i = 0; i < inventory->items_count; ++i) {\r\n\t\tt_grocery *current_item = &(inventory->groceries[i]);\r\n\t\tprintf(\"Name: %s\\n\", current_item->name);\r\n\t\tprintf(\"Category: %s\\n\", current_item->category);\r\n\t\tprintf(\"Quantity: %d\\n\", current_item->quantity);\r\n\t\tprintf(\"Price: %.2f\\n\", current_item->price);\r\n\t\tprintf(\"Status: %s\\n\", inventory->availability[i] ? \"In Stock\" : \"Out of Stock\");\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void update_quantity(t_inventory *inventory) {\r\n\tchar name[NAME_MAX_LEN + 1];\r\n\tprintf(\"Enter the name of the grocery item to update quantity: \");\r\n\tif (scanf(\" %100[^\\n]\", name) == EOF) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (size_t i = 0; i < inventory->items_count; ++i) {\r\n\t\tt_grocery *current_item = &(inventory->groceries[i]);\r\n\t\tif (strcmp(current_item->name, name) == 0) {\r\n\t\t\tint new_quantity = 0;\r\n\t\t\tif (get_int(&new_quantity, \"Enter new quantity for %s: \", name) == EOF) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (new_quantity < 0) {\r\n\t\t\t\tfprintf(stderr, \"Quantity shouldn't be less than 0.\\n\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// update quantity\r\n\t\t\tcurrent_item->quantity = new_quantity;\r\n\t\t\tinventory->availability[i] = new_quantity > 0;\r\n\t\t\tputs(\"Quantity updated successfully!\");\r\n\t\t\tprintf(\"\\n\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tfprintf(stderr, \"Item not found.\\n\");\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void remove_grocery_item(t_inventory *inventory) {\r\n\tchar name[NAME_MAX_LEN + 1];\r\n\tprintf(\"Enter the name of the grocery item to remove: \");\r\n\tif (scanf(\" %100[^\\n]\", name) == EOF) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (size_t i = 0; i < inventory->items_count; ++i) {\r\n\t\tt_grocery *current_item = &(inventory->groceries[i]);\r\n\t\tif (strcmp(current_item->name, name) == 0) {\r\n\t\t\tfor (size_t j = i; j < inventory->items_count - 1; ++j) {\r\n\t\t\t\t// shift the items on the right of the current item to the left by 1 position\r\n\t\t\t\tinventory->groceries[j] = inventory->groceries[j + 1];\r\n\t\t\t\tinventory->availability[j] = inventory->availability[j + 1];\r\n\t\t\t}\r\n\t\t\tinventory->items_count--;\r\n\t\t\tputs(\"Item removed successfully!\");\r\n\t\t\tprintf(\"\\n\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tfprintf(stderr, \"Item not found.\\n\");\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void loop_do_op(t_inventory *inventory) {\r\n\tint choice = 0;\r\n\twhile (true) {\r\n\t\tprint_menu();\r\n\r\n\t\t// scanf for choice\r\n\t\tif (get_int(&choice, \"Enter your choice: \") == EOF) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// do op, or exit\r\n\t\tswitch (choice) {\r\n\t\t\tcase 1:\r\n\t\t\t\tadd_grocery_item(inventory);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tlist_grocery_items(inventory);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tupdate_quantity(inventory);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tremove_grocery_item(inventory);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tputs(\"Exiting...\");\r\n\t\t\t\treturn;\r\n\t\t\tdefault:\r\n\t\t\t\tprintf(\"Invalid choice.\\n\\n\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(void) {\r\n\tt_inventory *inventory = malloc(sizeof(t_inventory));\r\n\tif (inventory == NULL) {\r\n\t\tfprintf(stderr, \"malloc error.\\n\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tinventory->items_count = 0;\r\n\r\n\tloop_do_op(inventory);\r\n\tfree(inventory);\r\n\treturn 0;\r\n}\n/* --- q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include <stdarg.h>\r\n\r\ntypedef struct s_student {\r\n\tchar name[100];\r\n\tint id;\r\n\tfloat grade;\r\n}\tt_student;\r\n\r\ntypedef struct s_list {\r\n\tt_student *student;\r\n\tstruct s_list *next;\r\n}\tt_list;\r\n\r\nstatic void print_menu(void) {\r\n\tputs(\"1. Insert Student Record\");\r\n\tputs(\"2. Display Student Records\");\r\n\tputs(\"3. Sort Records\");\r\n\tputs(\"4. Search Record by ID\");\r\n\tputs(\"5. Delete List\");\r\n\tputs(\"6. Exit\");\r\n}\r\n\r\nstatic int get_int(int *input, const char *format, ...) {\r\n\tva_list args;\r\n\r\n    // print the formatted string\r\n    va_start(args, format);\r\n    vprintf(format, args);\r\n    va_end(args);\r\n\r\n    if (scanf(\"%d\", input) == EOF) {\r\n\t\treturn EOF;\t\r\n\t}\r\n\r\n\tfflush(stdin);\r\n\treturn 0;\r\n}\r\n\r\nvoid list_add_back(t_list **head, t_student *student) {\r\n\tt_list *new_node = (t_list *)malloc(sizeof(t_list));\r\n\tif (*head == NULL) {\r\n\t\t// If the list is empty\r\n\t\tnew_node->student = student;\r\n\t\tnew_node->next = NULL;\r\n\t\t*head = new_node;\r\n\t\treturn;\r\n\t}\r\n\r\n\tt_list *tmp = *head;\r\n\t// Find the last node\r\n\twhile (tmp != NULL) {\r\n\t\tif (tmp->student->id == student->id) {\r\n\t\t\tfprintf(stderr, \"Student with ID %d already exists.\\n\", student->id);\r\n\t\t\tfree(new_node);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (tmp->next == NULL) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\ttmp = tmp->next;\r\n\t}\r\n\r\n\t// Add the new node to the last node\r\n\tnew_node->student = student;\r\n\tnew_node->next = NULL;\r\n\ttmp->next = new_node;\r\n}\r\n\r\nvoid list_display(t_list *head) {\r\n\tfor (t_list *tmp = head; tmp != NULL; tmp = tmp->next) {\r\n\t\tprintf(\"Name: %s, ID: %d, Grade: %.2f\\n\", tmp->student->name, tmp->student->id, tmp->student->grade);\r\n\t}\r\n}\r\n\r\nt_student *list_search_by_id(t_list *head, int id) {\r\n\tt_list *tmp = head;\r\n\r\n\twhile (tmp != NULL) {\r\n\t\tif (tmp->student->id == id) {\r\n\t\t\treturn tmp->student;\r\n\t\t}\r\n\t\ttmp = tmp->next;\r\n\t}\r\n\r\n\treturn NULL;\r\n}\r\n\r\nvoid list_delete(t_list **head) {\r\n\tt_list *tmp = *head;\r\n\tt_list *next = NULL;\r\n\r\n\twhile (tmp != NULL) {\r\n\t\tnext = tmp->next;\r\n\t\tfree(tmp->student);\r\n\t\tfree(tmp);\r\n\t\ttmp = next;\r\n\t}\r\n\r\n\t*head = NULL;\r\n}\r\n\r\n/**\r\n * Bubble sort\r\n * I use bubble sort because it is in-place, simple and easy to implement.\r\n * If the dataset is large, I would use quicksort, but quicksort will need to convert the linked list to array first.\r\n * Which needs extra memory.\r\n */\r\nvoid list_sort_by_grade(t_list *head) {\r\n\tif (head == NULL) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tt_list *tmp = head;\r\n\tt_list *tmp2 = head;\r\n\tt_student *student = NULL;\r\n\r\n\twhile (tmp != NULL) {\r\n\t\twhile (tmp2 != NULL) {\r\n\t\t\tif (tmp->student->grade > tmp2->student->grade) {\r\n\t\t\t\tstudent = tmp->student;\r\n\t\t\t\ttmp->student = tmp2->student;\r\n\t\t\t\ttmp2->student = student;\r\n\t\t\t}\r\n\t\t\ttmp2 = tmp2->next;\r\n\t\t}\r\n\t\ttmp = tmp->next;\r\n\t}\r\n}\r\n\r\nstatic void cmd_add_student(t_list **head) {\r\n\tt_student *student = (t_student *)malloc(sizeof(t_student));\r\n\tif (student == NULL) {\r\n\t\tfprintf(stderr, \"Failed to allocate memory\\n\");\r\n\t\texit(1);\r\n\t}\r\n\r\n\tprintf(\"Enter name: \");\r\n\tscanf(\" %100[^\\n]\", student->name);\r\n\r\n\tif (get_int(&student->id, \"Enter ID: \") == EOF) {\r\n\t\tfree(student);\r\n\t\treturn;\r\n\t}\r\n\r\n\tprintf(\"Enter grade: \");\r\n\tif (scanf(\" %f\", &student->grade) == EOF) {\r\n\t\tfree(student);\r\n\t\treturn;\r\n\t}\r\n\r\n\tlist_add_back(head, student);\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void cmd_display_students(t_list *head) {\r\n\tif (head == NULL) {\r\n\t\tputs(\"No records found.\");\r\n\t\tprintf(\"\\n\");\r\n\t\treturn;\r\n\t}\r\n\tlist_display(head);\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void cmd_sort_students(t_list *head) {\r\n\tlist_sort_by_grade(head);\r\n\tputs(\"Records sorted by grade using bubble sort.\");\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void cmd_search_student_by_id(t_list *head) {\r\n\tint id = 0;\r\n\tif (get_int(&id, \"Enter ID to search: \") == EOF) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tt_student *student = list_search_by_id(head, id);\r\n\tif (student == NULL) {\r\n\t\tputs(\"Student not found.\");\r\n\t} else {\r\n\t\tprintf(\"Name: %s, ID: %d, Grade: %.2f\\n\", student->name, student->id, student->grade);\r\n\t}\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nstatic void cmd_list_delete(t_list **head) {\r\n\tlist_delete(head);\r\n\tputs(\"List deleted.\");\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid loop_do_op(t_list **head) {\r\n\tint choice = 0;\r\n\twhile (true) {\r\n\t\tprint_menu();\r\n\r\n\t\tif (get_int(&choice, \"Enter your choice: \") == EOF) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tswitch (choice) {\r\n\t\t\tcase 1:\r\n\t\t\t \tcmd_add_student(head);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tcmd_display_students(*head);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tcmd_sort_students(*head);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tcmd_search_student_by_id(*head);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 5:\r\n\t\t\t\tcmd_list_delete(head);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 6:\r\n\t\t\t\tlist_delete(head);\r\n\t\t\t\tputs(\"Exiting...\");\r\n\t\t\t\treturn;\r\n\t\t\tdefault:\r\n\t\t\t\tprintf(\"Invalid choice.\\n\\n\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main(void) {\r\n\tt_list *head = NULL;\r\n\r\n\tloop_do_op(&head);\r\n\r\n\treturn 0;\r\n}",
    "feedback": "q1-The code does not validate the dimensions of the matrices after getting the values. If the user inputs invalid dimensions (e.g., negative values), it may lead to undefined behavior during matrix operations.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly to sort student records by grade. While Bubble Sort is straightforward, it has a time complexity of O(n?), which can be inefficient for larger datasets. If performance becomes an issue, consider using more efficient sorting algorithms like Quick Sort or Merge Sort, especially for larger lists."
  },
  {
    "student_id": "20581109",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n//Function\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    //Input dimensions for matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    //Input elements for matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    //Input dimensions for matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    //Validate dimensions\r\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsB > MAX_SIZE || colsB > MAX_SIZE) {\r\n        printf(\"Error: Maximum allowed size for matrices is 10x10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //Input elements for matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions to add.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions to subtract.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#define MAX_ITEMS 100\r\n\r\n//Struct for grocery items\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int inStock;\r\n} GroceryItem;\r\n\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n//Function\r\nvoid addItem();\r\nvoid listItems();\r\nvoid updateQuantity();\r\nvoid removeItem();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n\r\n    printf(\"Enter item name: \");\r\n    getchar();\r\n    fgets(item.name, sizeof(item.name), stdin);\r\n    strtok(item.name, \"\\n\");\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(item.category, sizeof(item.category), stdin);\r\n    strtok(item.category, \"\\n\");\r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n    item.inStock = (item.quantity > 0) ? 1 : 0;\r\n\r\n    inventory[itemCount++] = item;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\nvoid listItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar();\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    int found = 0;\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcasecmp(inventory[i].name, itemName) == 0) {\r\n            int newQuantity;\r\n            printf(\"Enter new quantity for %s: \", inventory[i].name);\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            inventory[i].quantity = newQuantity;\r\n            inventory[i].inStock = (newQuantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found in inventory.\\n\");\r\n    }\r\n}\r\n\r\nvoid removeItem() {\r\n    if (itemCount == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    getchar();\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    int found = 0;\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcasecmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", inventory[i].name);\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found in inventory.\\n\");\r\n    }\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n//Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n//Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n//Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n//Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) return current;\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n\r\n    head = NULL;\r\n    printf(\"All student records deleted successfully.\\n\");\r\n}\r\n\r\n//Function to free memory (utility)\r\nvoid freeMemory() {\r\n    deleteList();\r\n    printf(\"Exiting...\\n\");\r\n}\r\n\r\n//Function to sort students by grade in ascending order (Bubble Sort)\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) return;\r\n\r\n    int swapped;\r\n    Student *current, *prev = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != prev) {\r\n            if (current->grade > current->next->grade) {\r\n                char tempName[100];\r\n                strcpy(tempName, current->name);\r\n                strcpy(current->name, current->next->name);\r\n                strcpy(current->next->name, tempName);\r\n\r\n                int tempID = current->id;\r\n                current->id = current->next->id;\r\n                current->next->id = tempID;\r\n\r\n                float tempGrade = current->grade;\r\n                current->grade = current->next->grade;\r\n                current->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        prev = current;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade in ascending order using Bubble Sort.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove trailing newline\r\n\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-While the inStock field is appropriately set when adding an item and updating the quantity, the logic for determining stock status could be improved. If the quantity is updated to zero, the status should reflect \"Out of Stock,\" but the program does not prompt the user or display the updated status in the listItems function.\nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20720379",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10\n\n// Function declarations\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nint isValidDimension(int rows, int cols);\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions and matrix elements for A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    while (!isValidDimension(rowsA, colsA)) {\n        printf(\"Invalid dimensions. Please enter again (rows and columns): \");\n        scanf(\"%d %d\", &rowsA, &colsA);\n    }\n\n    printf(\"Enter elements of Matrix A:\\n\");\n    inputMatrix(A, rowsA, colsA);\n\n    // Input dimensions and matrix elements for B\n    printf(\"Enter the number of rows and columns for Matrix B (rows and colunms): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    while (!isValidDimension(rowsB, colsB) || rowsA != rowsB || colsA != colsB) {\n        if (rowsA != rowsB || colsA != colsB) {\n            printf(\"Matrix dimensions must match for addition or subtraction.\\n\");\n        }\n        printf(\"Invalid dimensions. Please enter again (rows and columns): \");\n        scanf(\"%d %d\", &rowsB, &colsB);\n    }\n\n    printf(\"Enter elements of Matrix B:\\n\");\n    inputMatrix(B, rowsB, colsB);\n\n    // Menu-driven program loop\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                printf(\"\\nAddition of Matrices:\\n\");\n                addMatrices(A, B, result, rowsA, colsA);\n                printMatrix(result, rowsA, colsA);\n                break;\n            case 2:\n                printf(\"\\nSubtraction of Matrices:\\n\");\n                subtractMatrices(A, B, result, rowsA, colsA);\n                printMatrix(result, rowsA, colsA);\n                break;\n            case 3:\n                printf(\"\\nTranspose of Matrix A:\\n\");\n                transposeMatrix(A, result, rowsA, colsA);\n                printMatrix(result, colsA, rowsA); // Transpose changes the dimension\n                break;\n            case 4:\n                printf(\"\\nTranspose of Matrix B:\\n\");\n                transposeMatrix(B, result, rowsB, colsB);\n                printMatrix(result, colsB, rowsB); // Transpose changes the dimension\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please enter a valid option.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to input matrix elements\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Enter element (%d, %d): \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to print a matrix\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to add two matrices\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n// Function to check if the matrix dimensions are valid (<= 10x10)\nint isValidDimension(int rows, int cols) {\n    return (rows > 0 && rows <= MAX_SIZE && cols > 0 && cols <= MAX_SIZE);\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LENGTH 100\n#define MAX_CATEGORY_LENGTH 50\n\n// Define a boolean type for convenience\ntypedef enum { FALSE, TRUE } bool;\n\n// Define a struct for Availability Status\ntypedef struct {\n    bool inStock;\n    bool outOfStock;\n} AvailabilityStatus;\n\n// Define a struct for a Grocery Item\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    char category[MAX_CATEGORY_LENGTH];\n    int quantity;\n    float price;\n    AvailabilityStatus availability;\n} GroceryItem;\n\n// Define a struct for Grocery Inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    int totalItems;\n} GroceryInventory;\n\n// Function Declarations\nvoid addGroceryItem(GroceryInventory* inventory);\nvoid listGroceryItems(const GroceryInventory* inventory);\nvoid updateQuantity(GroceryInventory* inventory);\nvoid removeGroceryItem(GroceryInventory* inventory);\nvoid displayMenu();\n\nint main() {\n    GroceryInventory inventory = { .totalItems = 0 };\n    int choice;\n\n    do {\n        displayMenu();\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory);\n                break;\n            case 2:\n                listGroceryItems(&inventory);\n                break;\n            case 3:\n                updateQuantity(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting the program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to display the menu\nvoid displayMenu() {\n    printf(\"\\nGrocery Inventory Management\\n\");\n    printf(\"1. Add Grocery Item\\n\");\n    printf(\"2. List All Grocery Items\\n\");\n    printf(\"3. Update Quantity\\n\");\n    printf(\"4. Remove Grocery Item\\n\");\n    printf(\"5. Exit\\n\");\n}\n\n// Function to add a new grocery item to the inventory\nvoid addGroceryItem(GroceryInventory* inventory) {\n    if (inventory->totalItems >= MAX_ITEMS) {\n        printf(\"Inventory is full, cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n\n    // Input the name of the item\n    printf(\"Enter item name: \");\n    getchar(); // To clear the newline character from the buffer\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; // Remove newline character\n\n    // Input the category\n    printf(\"Enter category: \");\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0'; // Remove newline character\n\n    // Input the quantity\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n\n    // Input the price\n    printf(\"Enter price: \");\n    scanf(\"%f\", &newItem.price);\n\n    // Determine availability based on quantity\n    if (newItem.quantity > 0) {\n        newItem.availability.inStock = TRUE;\n        newItem.availability.outOfStock = FALSE;\n    } else {\n        newItem.availability.inStock = FALSE;\n        newItem.availability.outOfStock = TRUE;\n    }\n\n    // Add the new item to the inventory\n    inventory->items[inventory->totalItems] = newItem;\n    inventory->totalItems++;\n\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items with their availability status\nvoid listGroceryItems(const GroceryInventory* inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No items in the inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\nList of Grocery Items:\\n\");\n    for (int i = 0; i < inventory->totalItems; i++) {\n        const GroceryItem* item = &inventory->items[i];\n        printf(\"\\nItem %d:\\n\", i + 1);\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Availability: %s\\n\", item->availability.inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of a specific grocery item\nvoid updateQuantity(GroceryInventory* inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No items in the inventory to update.\\n\");\n        return;\n    }\n\n    int itemIndex;\n    printf(\"Enter the name of the grocery item to update quantity: \", inventory->totalItems);\n    scanf(\"%d\", &itemIndex);\n    \n    if (itemIndex < 1 || itemIndex > inventory->totalItems) {\n        printf(\"Invalid item index.\\n\");\n        return;\n    }\n\n    itemIndex--; // Convert to 0-based index\n\n    int newQuantity;\n    printf(\"Enter the new quantity for item '%s': \", inventory->items[itemIndex].name);\n    scanf(\"%d\", &newQuantity);\n\n    inventory->items[itemIndex].quantity = newQuantity;\n\n    // Update availability based on new quantity\n    if (newQuantity > 0) {\n        inventory->items[itemIndex].availability.inStock = TRUE;\n        inventory->items[itemIndex].availability.outOfStock = FALSE;\n    } else {\n        inventory->items[itemIndex].availability.inStock = FALSE;\n        inventory->items[itemIndex].availability.outOfStock = TRUE;\n    }\n\n    printf(\"Quantity updated successfully!\\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem(GroceryInventory* inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No items in the inventory to remove.\\n\");\n        return;\n    }\n\n    int itemIndex;\n    printf(\"Enter the index of the item to remove (1 to %d): \", inventory->totalItems);\n    scanf(\"%d\", &itemIndex);\n    \n    if (itemIndex < 1 || itemIndex > inventory->totalItems) {\n        printf(\"Invalid item index.\\n\");\n        return;\n    }\n\n    itemIndex--; // Convert to 0-based index\n\n    // Shift items after the removed one to fill the gap\n    for (int i = itemIndex; i < inventory->totalItems - 1; i++) {\n        inventory->items[i] = inventory->items[i + 1];\n    }\n\n    // Decrease the item count\n    inventory->totalItems--;\n\n    printf(\"Grocery item removed successfully!\\n\");\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NAME_LENGTH 100\n\n// Structure for Student\ntypedef struct Student {\n char name[100];\n int id;\n float grade;\n struct Student* next;\n} Student;\nStudent* head = NULL;\n// Function to create a new student node \nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid freeMemory();\nStudent* createStudent(const char* name, int id, float grade);\nvoid sortStudents();\nvoid bubbleSortStudents();\nvoid displayMenu();\n\n// Main program\nint main() {\n    int choice, id;\n    float grade;\n    char name[MAX_NAME_LENGTH];\n    do {\n        displayMenu();\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            case 1:\n                // Insert new student\n                printf(\"Enter student name: \");\n                getchar();  // To clear the buffer\n                fgets(name, MAX_NAME_LENGTH, stdin);\n                name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\n                \n                printf(\"Enter student ID: \");\n                scanf(\"%d\", &id);\n                \n                printf(\"Enter student grade: \");\n                scanf(\"%f\", &grade);\n                \n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                // Display all students\n                displayStudents();\n                break;\n            case 3:\n                // Sort students by grade\n                sortStudents();\n                break;\n            case 4:\n                // Search for student by ID\n                printf(\"Enter student ID to search: \");\n                scanf(\"%d\", &id);\n                \n                Student* student = searchStudentByID(id);\n                if (student != NULL) {\n                    printf(\"Student found: %s (ID: %d, Grade: %.2f)\\n\", student->name, student->id, student->grade);\n                } else {\n                    printf(\"Student with ID %d not found.\\n\", id);\n                }\n                break;\n            case 5:\n                // Delete entire list\n                deleteList();\n                printf(\"All student records have been deleted.\\n\");\n                break;\n            case 6:\n                // Exit program\n                freeMemory();\n                printf(\"Exiting the program...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n\n// Function to display the menu\nvoid displayMenu() {\n    printf(\"\\nStudent Records Management\\n\");\n    printf(\"1. Insert Student Record\\n\");\n    printf(\"2. Display Student Records\\n\");\n    printf(\"3. Sort Student Records by Grade\\n\");\n    printf(\"4. Search Student by ID\\n\");\n    printf(\"5. Delete All Records\\n\");\n    printf(\"6. Exit\\n\");\n}\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed!\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student into the linked list\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    \n    // Insert the new student at the beginning of the list\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records found.\\n\");\n        return;\n    }\n    \n    Student* current = head;\n    printf(\"\\nStudent Records:\\n\");\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student record by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;  // Return pointer to the student found\n        }\n        current = current->next;\n    }\n    return NULL;  // Return NULL if student not found\n}\n\n// Function to delete the entire list and free the memory\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    \n    while (current != NULL) {\n        next = current->next;\n        free(current);  // Free current student node\n        current = next;\n    }\n    \n    head = NULL;  // Set head to NULL to indicate the list is empty\n}\n\n// Function to free all memory when exiting the program\nvoid freeMemory() {\n    deleteList();  // Delete the list and free memory before exit\n}\n\n// Bubble sort implementation to sort students by grade (ascending order)\nvoid bubbleSortStudents() {\n    if (head == NULL) {\n        return;  // No students to sort\n    }\n    \n    int swapped;\n    Student* current;\n    Student* lastPtr = NULL;\n\n    do {\n        swapped = 0;\n        current = head;\n\n        while (current->next != lastPtr) {\n            if (current->grade > current->next->grade) {\n                // Swap the students\n                float tempGrade = current->grade;\n                int tempID = current->id;\n                char tempName[MAX_NAME_LENGTH];\n                strcpy(tempName, current->name);\n\n                current->grade = current->next->grade;\n                current->id = current->next->id;\n                strcpy(current->name, current->next->name);\n\n                current->next->grade = tempGrade;\n                current->next->id = tempID;\n                strcpy(current->next->name, tempName);\n\n                swapped = 1;\n            }\n            current = current->next;\n        }\n        lastPtr = current;\n    } while (swapped);\n    printf(\"Student records sorted by grade.\\n\");\n}\n\n// Function to sort the student records\nvoid sortStudents() {\n    bubbleSortStudents();  // Using Bubble Sort\n}\n",
    "feedback": "q1-Meet requirement\nq2-In the updateQuantity function, the prompt for entering the item name is misleading. It should ask for the item index instead of the name.\nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While simple and straightforward, Bubble Sort has a time complexity of O(n?), making it inefficient for larger datasets. For improved efficiency, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20699501",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Matrix declarations\r\nint MatrixA[10][10];\r\nint MatrixB[10][10];\r\nint transpose[10][10];  // For transpose operations\r\nint sum[10][10];\r\nint difference[10][10];\r\nint rows1, columns1, rows2, columns2;\r\n\r\n// Add Matrices\r\nint AddMatrices() {\r\n    if (rows1 != rows2 || columns1 != columns2) {\r\n        printf(\"Matrix dimensions do not match for addition!\\n\");\r\n        return -1;\r\n    }\r\n\r\n    for (int i = 0; i < rows1; i++)\r\n        for (int j = 0; j < columns1; j++) {\r\n            sum[i][j] = MatrixA[i][j] + MatrixB[i][j];\r\n        }\r\n\r\n    printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n    for (int i = 0; i < rows1; i++) {\r\n        for (int j = 0; j < columns1; j++) {\r\n            printf(\"%d   \", sum[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Subtract Matrices\r\nint SubtractMatrices() {\r\n    if (rows1 != rows2 || columns1 != columns2) {\r\n        printf(\"Matrix dimensions do not match for subtraction!\\n\");\r\n        return -1;\r\n    }\r\n\r\n    for (int i = 0; i < rows1; i++) {\r\n        for (int j = 0; j < columns1; j++) {\r\n            difference[i][j] = MatrixA[i][j] - MatrixB[i][j];\r\n        }\r\n    }\r\n\r\n    printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n    for (int i = 0; i < rows1; i++) {\r\n        for (int j = 0; j < columns1; j++) {\r\n            printf(\"%d   \", difference[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Transpose Matrix A\r\nint TransposeMatrixA() {\r\n    for (int i = 0; i < rows1; i++) {\r\n        for (int j = 0; j < columns1; j++) {\r\n            transpose[j][i] = MatrixA[i][j];\r\n        }\r\n    }\r\n\r\n    printf(\"Transpose of Matrix A:\\n\");\r\n    for (int i = 0; i < columns1; i++) {\r\n        for (int j = 0; j < rows1; j++) {\r\n            printf(\"%d   \", transpose[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Transpose Matrix B\r\nint TransposeMatrixB() {\r\n    for (int i = 0; i < rows2; i++) {\r\n        for (int j = 0; j < columns2; j++) {\r\n            transpose[j][i] = MatrixB[i][j];\r\n        }\r\n    }\r\n\r\n    printf(\"Transpose of Matrix B:\\n\");\r\n    for (int i = 0; i < columns2; i++) {\r\n        for (int j = 0; j < rows2; j++) {\r\n            printf(\"%d   \", transpose[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n// Main Function\r\nint main() {\r\n    int choice;\r\n    printf(\"\\nEnter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rows1, &columns1);\r\n\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    for (int i = 0; i < rows1; i++) {\r\n        for (int j = 0; j < columns1; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &MatrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rows2, &columns2);\r\n\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    for (int i = 0; i < rows2; i++) {\r\n        for (int j = 0; j < columns2; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &MatrixB[i][j]);\r\n        }\r\n    }\r\n        \r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                AddMatrices();\r\n                break;\r\n            case 2:\r\n                SubtractMatrices();\r\n                break;\r\n            case 3:\r\n                TransposeMatrixA();\r\n                break;\r\n            case 4:\r\n                TransposeMatrixB();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Struct for Grocery item\r\nstruct Grocery_item {\r\n    char Name[100];\r\n    char Category[100];\r\n    int Quantity;\r\n    float Price;\r\n    bool In_stock; // Boolean to track availability\r\n};\r\n\r\n// Array of Grocery_item structs\r\nstruct Grocery_item Inventory[100];\r\n\r\n// Counter to keep track of the current number of items\r\nint Counter = 0;\r\n\r\n// Function to add a new item to the inventory\r\nvoid addItem() {\r\n    if (Counter >= 100) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]%*c\", Inventory[Counter].Name);\r\n\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]%*c\", Inventory[Counter].Category);\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &Inventory[Counter].Quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &Inventory[Counter].Price);\r\n\r\n    // Set availability based on quantity\r\n    Inventory[Counter].In_stock = Inventory[Counter].Quantity > 0;\r\n\r\n    Counter++;  // Increment counter\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to display availability status\r\nvoid displayAvailability(bool in_stock) {\r\n    if (in_stock) {\r\n        printf(\"Availability: In stock\\n\");\r\n    } else {\r\n        printf(\"Availability: Out of stock\\n\");\r\n    }\r\n}\r\n\r\n// Function to list all items in the inventory\r\nvoid listItems() {\r\n    if (Counter == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < Counter; i++) {\r\n        printf(\"Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\n\", \r\n               Inventory[i].Name, Inventory[i].Category, Inventory[i].Quantity, Inventory[i].Price);\r\n        displayAvailability(Inventory[i].In_stock);\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an item\r\nvoid updateQuantity() {\r\n    char search_name[100];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]%*c\", search_name);\r\n\r\n    for (int i = 0; i < Counter; i++) {\r\n        if (strcasecmp(Inventory[i].Name, search_name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", Inventory[i].Name);\r\n            scanf(\"%d\", &Inventory[i].Quantity);\r\n\r\n            // Update availability based on the new quantity\r\n            Inventory[i].In_stock = Inventory[i].Quantity > 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Function to remove an item from the inventory\r\nvoid removeItem() {\r\n    char name[100];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]%*c\", name);\r\n\r\n    for (int i = 0; i < Counter; i++) {\r\n        if (strcasecmp(Inventory[i].Name, name) == 0) {\r\n            // Shift all items after the removed one to fill the gap\r\n            for (int j = i; j < Counter - 1; j++) {\r\n                Inventory[j] = Inventory[j + 1];\r\n            }\r\n            Counter--;  // Decrease counter after removal\r\n            printf(\"Grocery item \\\"%s\\\" removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];      // Student's name\r\n    int id;              // Student's ID\r\n    float grade;         // Student's grade\r\n    struct Student* next; // Pointer to the next student in the list\r\n} Student;\r\n\r\nStudent* head = NULL; // Pointer to the head of the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    \r\n    // Step 1: Create a new node\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL; // Return NULL if memory allocation fails\r\n    }\r\n    // Copy data into the new node\r\n    strcpy(newStudent->name, name); // Copy name\r\n    newStudent->id = id;           // Set ID\r\n    newStudent->grade = grade;     // Set grade\r\n    newStudent->next = NULL;       // Initialize 'next' to NULL\r\n    return newStudent;             // Return the new node\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new node using createStudent\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) {\r\n        printf(\"Failed to insert student record.\\n\");\r\n        return;\r\n    }\r\n    // Insert the new node at the beginning of the list\r\n    newStudent->next = head; // Link new node to the current head\r\n    head = newStudent;       // Update head to the new node\r\n    \r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        // Check if the list is empty\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    // Traverse the list and display each student's details\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    // Traverse the list to find the student with the given ID\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) { // Check if the current student's ID matches\r\n            return current; // Return the student node if found\r\n        }\r\n        current = current->next; // Move to the next node\r\n    }\r\n    return NULL; // Return NULL if the student is not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    // Iterate through the list and free memory for each node\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        Student* next = current->next; // Store the next node\r\n        free(current);                 // Free the current node\r\n        current = next;                // Move to the next node\r\n    }\r\n    head = NULL; // Set head to NULL to indicate the list is empty\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\n\r\n// Function to sort the students by grade\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        // If the list is empty or has only one node, no sorting is needed\r\n        printf(\"Not enough students to sort.\\n\");\r\n        return;\r\n    }\r\n    // Perform a simple bubble sort to arrange students by grade in ascending order\r\n    for (Student* i = head; i != NULL; i = i->next) {\r\n        for (Student* j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) { // Compare grades\r\n                // Swap the data of nodes i and j\r\n                char tempName[100];\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n\r\n                int tempId = i->id;\r\n                i->id = j->id;\r\n                j->id = tempId;\r\n\r\n                float tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Students sorted by grade in ascending order.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display the menu\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); // Read user input\r\n        getchar(); // Consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Insert a new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin); // Read name\r\n                strtok(name, \"\\n\");              // Remove trailing newline\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id); // Read ID\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade); // Read grade\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                // Display all student records\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                // Sort student records by grade\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                // Search for a student by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    // Display the student's details if found\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                // Delete the entire list\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                // Exit the program\r\n                deleteList(); // Free memory before exiting\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                // Handle invalid menu choices\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The program uses Bubble Sort to sort student records by grade. While this method is straightforward, it has a time complexity of O(n?), making it less efficient for larger datasets. For improved performance, consider implementing a more efficient algorithm like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20607904",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\nvoid print_matrix(int row, int col, int matrix[][col]) {\r\n    int element;\r\n    for(int i = 0; i<row; i++) {\r\n        for(int j = 0; j<col; j++){\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n\r\nvoid matrix_addition(int row, int col, int matrix_A[][col], int matrix_B[][col]) {\r\n    int added_matrix[row][col];\r\n    for(int i = 0; i<row; i++) {\r\n        for(int j = 0; j<col; j++){\r\n            added_matrix[i][j] = matrix_A[i][j] + matrix_B[i][j];\r\n        }\r\n    }\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n    print_matrix(row, col, added_matrix);\r\n}\r\n\r\nvoid matrix_subtraction(int row, int col, int matrix_A[][col], int matrix_B[][col]) {\r\n    int subtracted_matrix[row][col];\r\n    for(int i = 0; i<row; i++) {\r\n        for(int j = 0; j<col; j++){\r\n            subtracted_matrix[i][j] = matrix_A[i][j] - matrix_B[i][j];\r\n        }\r\n    }\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    print_matrix(row, col, subtracted_matrix);\r\n}\r\n\r\nvoid matrix_transposition(int row, int col, int matrix[][col], char mat) {\r\n    int transposed_matrix[col][row];\r\n    for(int i = 0; i<col; i++) {\r\n        for(int j = 0; j<row; j++){\r\n            transposed_matrix[i][j] = matrix[j][i];\r\n        }\r\n    }\r\n    printf(\"Transpose of Matrix %c:\\n\", mat);\r\n    print_matrix(col, row, transposed_matrix);\r\n}\r\n\r\n\r\nvoid add_elements_to_matrix(int matrix_max_i, int matrix_max_j, int matrix[][matrix_max_j]) {\r\n    int element;\r\n    for(int row = 0; row<matrix_max_i; row++) {\r\n        for(int col = 0; col<matrix_max_j; col++) {\r\n            printf(\"Element [%d][%d]: \", row+1, col+1);\r\n            scanf(\"%d\", &element);\r\n            matrix[row][col] = element;\r\n        }\r\n    }\r\n}\r\n\r\nint main(void) {\r\n    int function;\r\n    int matrix_max_i, matrix_max_j;\r\n    //matrix A initialisation\r\n    int first_time = 1;\r\n    printf(\"Enter the dimensions for Matrix A (rows and columns): \");\r\n    do\r\n    {\r\n        if (first_time = 0) {\r\n            printf(\"Error, maximum size is 10 by 10 matrix. Please try again.\\n\");\r\n        }\r\n        scanf(\"%d %d\", &matrix_max_i, &matrix_max_j);\r\n        first_time = 0;\r\n    } while (matrix_max_i > 10 || matrix_max_j > 10);\r\n\r\n    int matrix_A[matrix_max_i][matrix_max_j];\r\n    int row_A = matrix_max_i, col_A = matrix_max_j;\r\n    add_elements_to_matrix(matrix_max_i, matrix_max_j, matrix_A);\r\n\r\n    // matrix B initialisation\r\n    first_time = 1;\r\n    printf(\"Enter the dimensions for Matrix B (rows and columns): \");\r\n    do\r\n    {\r\n        if (first_time = 0) {\r\n            printf(\"Error, maximum size is 10 by 10 matrix. Please try again.\\n\");\r\n        }\r\n        scanf(\"%d %d\", &matrix_max_i, &matrix_max_j);\r\n        first_time = 0;\r\n    } while (matrix_max_i > 10 || matrix_max_j > 10);\r\n\r\n    int matrix_B[matrix_max_i][matrix_max_j];\r\n    int row_B = matrix_max_i, col_B = matrix_max_j;\r\n    add_elements_to_matrix(matrix_max_i, matrix_max_j, matrix_B);\r\n    \r\n    //operations loop\r\n    while(1) {\r\n        printf(\"Matrix Operations Menu:\\n1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix A\\n4. Transpose Matrix B\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &function);\r\n\r\n        switch (function)\r\n            {\r\n            case 1: //Add matrices\r\n                if(row_A != row_B || col_A != col_B) {\r\n                    printf(\"Error, the 2 matrix are not the same size\\n\");\r\n                    break;\r\n                }\r\n                matrix_addition(row_A, col_A, matrix_A, matrix_B);\r\n                break;\r\n            \r\n            case 2: //Subtract matrices\r\n                if(row_A != row_B || col_A != col_B) {\r\n                    printf(\"Error, the 2 matrix are not the same size\\n\");\r\n                    break;\r\n                }\r\n                matrix_subtraction(row_A, col_A, matrix_A, matrix_B);\r\n                break;\r\n\r\n            case 3: //Transpose matrix A\r\n                matrix_transposition(row_A, col_A, matrix_A, 'A');\r\n                break;\r\n            \r\n            case 4: //Transpose matrix B\r\n                matrix_transposition(row_B, col_B, matrix_B, 'B');\r\n                break;\r\n\r\n            case 5: //Exit\r\n            printf(\"Exiting...\");\r\n                exit(1);\r\n\r\n            default:\r\n            printf(\"Invalid choice, please try again\\n\");\r\n                break;\r\n            }\r\n    }\r\n    \r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <time.h>\r\n\r\n#define MAX_INVENTORY 100 //store up to 100 groceries\r\n#define MAX_NAME 101 //store up to 100 letters in the string + 1 null terminator\r\n#define MAX_CATEGORY 51 //store up to 50 letters in the string + 1 null terminator\r\n\r\nstruct grocery\r\n{\r\n    char item_name[MAX_NAME];\r\n    char item_category[MAX_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n    char colour[5]; //colour for when displaying category\r\n};\r\n\r\nvoid list_inventory(struct grocery inventory[], int availability[], int count) {\r\n    if (count == 0) {\r\n        printf(\"\\nNo grocery items in inventory\\n\");\r\n        return;\r\n    }\r\n    for(int i = 0; i<count; i++){\r\n        printf(\"\\nName: %s\", inventory[i].item_name);\r\n        printf(\"%sCategory: %s\\033[0m\", inventory[i].colour, inventory[i].item_category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        if (availability[i] == 0)\r\n        {\r\n            printf(\"Status: Out of Stock\\n\");\r\n        } else {\r\n            printf(\"Status: In Stock\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid add_item(struct grocery inventory[], int availability[], int* count) {\r\n    char colours[][5] = {\r\n        \"\\033[31m\", // Red\r\n        \"\\033[32m\", // Green\r\n        \"\\033[33m\", // Yellow\r\n        \"\\033[34m\", // Blue\r\n        \"\\033[35m\", // Magenta\r\n        \"\\033[36m\"  // Cyan\r\n    };\r\n    char item_name[101];\r\n    char item_category[51];\r\n    int quantity;\r\n    float price;\r\n\r\n    //reading item name\r\n    printf(\"Enter item name: \");\r\n    fgets(item_name, 101, stdin); //101 because 1 reserve space for null terminator\r\n\r\n    //reading item category\r\n    printf(\"Enter Category: \");\r\n    fgets(item_category, 51, stdin);\r\n\r\n    //reading item quantity\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &quantity);\r\n\r\n    //reading item price\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &price);\r\n\r\n    //adding everything to inventory\r\n    strcpy(inventory[*count].item_name, item_name);\r\n    strcpy(inventory[*count].item_category, item_category);\r\n    inventory[*count].quantity = quantity;\r\n    inventory[*count].price = price;\r\n    int random_colour_number = rand() % 6; //random number from 1-6 for colour\r\n    strcpy(inventory[*count].colour, colours[rand() % 6]/*random number from 1-6 for colour*/);\r\n\r\n    if (quantity<=0) {\r\n        availability[*count] = 0;\r\n    } else {\r\n        availability[*count] = 1;\r\n    }\r\n    printf(\"\\nGrocery item added successfully!\\n\");\r\n    (*count) += 1;\r\n    return;\r\n}\r\n\r\nvoid update_quantity(struct grocery inventory[], int availability[], int count) {\r\n    if (count == 0) {\r\n        printf(\"\\nNo grocery items in inventory\\n\");\r\n        return;\r\n    }\r\n    char input_name[101];\r\n    int index = -1;\r\n    char buffer;\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(input_name, 101, stdin);\r\n\r\n    for(int i = 0; i<count; i++) {\r\n        if(strcmp(input_name, inventory[i].item_name) == 0) {\r\n            index = i;\r\n        }\r\n    }\r\n     \r\n    if (index == -1) {\r\n        printf(\"\\nNo grocery item with the input name: %s\\n\", input_name);\r\n        return;\r\n    }\r\n\r\n    int new_quantity;\r\n    printf(\"Enter new quantity for \");\r\n    for(int i = 0; i<=strlen(input_name); i++) {\r\n        if(input_name[i] != '\\0' && input_name[i] != '\\n'){\r\n            printf(\"%c\", input_name[i]);\r\n        }\r\n    }\r\n    printf(\": \");\r\n    scanf(\"%d\", &new_quantity);\r\n    inventory[index].quantity = new_quantity;\r\n\r\n    if (inventory[index].quantity<=0) {\r\n        availability[index] = 0;\r\n    } else {\r\n        availability[index] = 1;\r\n    }\r\n    printf(\"\\nQuantity updated successfully!\\n\");\r\n\r\n}\r\n\r\n\r\nvoid remove_item(struct grocery inventory[], int availability[], int* count) {\r\n    if (*count == 0) {\r\n        printf(\"\\nNo grocery items in inventory\\n\");\r\n        return;\r\n    }\r\n    char input_name[101];\r\n    int index = -1;\r\n    char buffer;\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(input_name, 101, stdin);\r\n\r\n    for(int i = 0; i<*count; i++) {\r\n        if(strcmp(input_name, inventory[i].item_name) == 0) {\r\n            index = i;\r\n        }\r\n    }\r\n     \r\n    if (index == -1) {\r\n        printf(\"\\nNo grocery item with the input name: %s\\n\", input_name);\r\n        return;\r\n    }\r\n    for (int i = index; i < *count - 1; i++) {\r\n        inventory[i] =inventory[i + 1]; // Move the next contact into the current position\r\n    }\r\n\r\n    for (int i = index; i < *count - 1; i++) {\r\n        availability[i] = availability[i + 1]; // Move the next contact into the current position\r\n    }\r\n\r\n    printf(\"\\nGrocery item '\");\r\n    for(int i = 0; i<=strlen(input_name); i++) {\r\n        if(input_name[i] != '\\0' && input_name[i] != '\\n'){\r\n            printf(\"%c\", input_name[i]);\r\n        }\r\n    }\r\n    printf(\"' removed successfully! \\n\");\r\n\r\n    (*count) -= 1;\r\n    return;\r\n}\r\n\r\n\r\nint main(void) {\r\n    srand(time(NULL));\r\n    int function;\r\n    int count = 0;\r\n    struct grocery inventory[MAX_INVENTORY];\r\n    int availability[MAX_INVENTORY];\r\n\r\n    while(1) {\r\n        char buffer = 'a'; \r\n        printf(\"\\nGrocery Inventory Management System:\\n1. Add Grocery Item\\n2. List All Grocery Items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &function);\r\n        while(buffer != '\\n') {\r\n            scanf(\"%c\", &buffer);\r\n        }\r\n\r\n        switch (function)\r\n        {\r\n        case 1:\r\n            buffer = 'a'; \r\n            add_item(inventory, availability, &count);\r\n            while(buffer != '\\n') {\r\n                scanf(\"%c\", &buffer);\r\n            }\r\n            break;\r\n        \r\n        case 2:\r\n            list_inventory(inventory, availability, count);\r\n            break;\r\n\r\n        case 3:\r\n            update_quantity(inventory, availability, count);\r\n            break;\r\n\r\n        case 4:\r\n            remove_item(inventory, availability, &count);\r\n            break;\r\n\r\n        case 5: //Exit\r\n            printf(\"Exiting...\");\r\n            exit(1);\r\n\r\n        default:\r\n            printf(\"Invalid choice, please try again\\n\");\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* new_student = (Student*)malloc(sizeof(Student));\r\n    if (new_student == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1); // Exit program if memory allocation fails\r\n    }\r\n\r\n    strcpy(new_student->name, name);\r\n    new_student->id = id;\r\n    new_student->grade = grade;\r\n    new_student->next = NULL;\r\n    return new_student;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* new_student = createStudent(name, id, grade);\r\n    if (!head) {\r\n        head = new_student;\r\n        printf(\"Successfully added student to record\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while(current->next != NULL) {\r\n        current = current->next;\r\n    }\r\n    current->next = new_student;\r\n\r\n    printf(\"Successfully added student to record\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if(!head) {\r\n        printf(\"No student records\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\",current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    if(!head) {\r\n        printf(\"No student records\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if(current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n    \r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n\r\n\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) { //check is list is empty or has one element\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* current;\r\n    Student* last_sorted = NULL; // To mark the end of the sorted portion\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != last_sorted) {\r\n            if (current->grade > current->next->grade) {\r\n                // Swap the data of current and next nodes\r\n                float temp_grade = current->grade;\r\n                current->grade = current->next->grade;\r\n                current->next->grade = temp_grade;\r\n\r\n                int temp_id = current->id;\r\n                current->id = current->next->id;\r\n                current->next->id = temp_id;\r\n\r\n                char temp_name[100];\r\n                strcpy(temp_name, current->name);\r\n                strcpy(current->name, current->next->name);\r\n                strcpy(current->next->name, temp_name);\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        last_sorted = current; // Reduce the range of unsorted elements\r\n    } while (swapped);\r\n}\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        //print menu\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using Bubble Sort\");\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                found->name, found->id, found->grade);\r\n                } else {\r\n                printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n                break;\r\n            }\r\n    } while (choice != 6);\r\n    return 0;\r\n}",
    "feedback": "q1-    The line if (first_time = 0) should use == for comparison instead of =. This is present in the matrix dimension input loops. The matrix_max_i and matrix_max_j variables are reused for both matrices. This could lead to confusion or errors since the dimensions of the second matrix are based on the first matrix's dimensions.\nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While this algorithm works, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using a more efficient algorithm like Quick Sort or Merge Sort for better performance."
  },
  {
    "student_id": "20687076",
    "code": "\n/* --- Q1.C --- */\n#include <stdio.h>\r\n\r\n// Function declarations\r\nvoid getMatrix(int mat[10][10], int rows, int cols);\r\nvoid displayMatrix(int mat[10][10], int rows, int cols);\r\nvoid addMatrices(int mat1[10][10], int mat2[10][10], int result[10][10], int rows, int cols);\r\nvoid subtractMatrices(int mat1[10][10], int mat2[10][10], int result[10][10], int rows, int cols);\r\nvoid transposeMatrix(int mat[10][10], int transposed[10][10], int rows, int cols);\r\n\r\nint main() {\r\n    int r1, c1, r2, c2;\r\n    int matrix1[10][10], matrix2[10][10], output[10][10];\r\n    int option;\r\n\r\n    // Input matrix dimensions\r\n    printf(\"Enter rows and columns of Matrix A: \");\r\n    scanf(\"%d %d\", &r1, &c1);\r\n    printf(\"Enter rows and columns of Matrix B: \");\r\n    scanf(\"%d %d\", &r2, &c2);\r\n\r\n    // Dimension check\r\n    if (r1 > 10 || c1 > 10 || r2 > 10 || c2 > 10 || r1 <= 0 || c1 <= 0 || r2 <= 0 || c2 <= 0) {\r\n        printf(\"Matrix dimensions should be between 1 and 10.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input matrix elements\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    getMatrix(matrix1, r1, c1);\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    getMatrix(matrix2, r2, c2);\r\n\r\n    // Menu-driven program\r\n    do {\r\n        printf(\"\\nOptions:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Choose an option: \");\r\n        scanf(\"%d\", &option);\r\n\r\n        switch (option) {\r\n            case 1:\r\n                if (r1 == r2 && c1 == c2) {\r\n                    addMatrices(matrix1, matrix2, output, r1, c1);\r\n                    printf(\"Sum of Matrices:\\n\");\r\n                    displayMatrix(output, r1, c1);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (r1 == r2 && c1 == c2) {\r\n                    subtractMatrices(matrix1, matrix2, output, r1, c1);\r\n                    printf(\"Difference of Matrices:\\n\");\r\n                    displayMatrix(output, r1, c1);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(matrix1, output, r1, c1);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(output, c1, r1);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(matrix2, output, r2, c2);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(output, c2, r2);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n        }\r\n    } while (option != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input matrix elements\r\nvoid getMatrix(int mat[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &mat[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int mat[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", mat[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int mat1[10][10], int mat2[10][10], int result[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = mat1[i][j] + mat2[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int mat1[10][10], int mat2[10][10], int result[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = mat1[i][j] - mat2[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int mat[10][10], int transposed[10][10], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = mat[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.C --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Struct for storing grocery item details\r\ntypedef struct {\r\n    char itemName[100];\r\n    char itemCategory[50];\r\n    int itemQuantity;\r\n    float itemPrice;\r\n} Grocery;\r\n\r\n// Struct for item availability status\r\ntypedef struct {\r\n    bool isAvailable;\r\n    bool isOutOfStock;\r\n} Availability;\r\n\r\n// Struct to manage the inventory\r\ntypedef struct {\r\n    Grocery items[100];        // Array to store items\r\n    Availability statuses[100]; // Array to track availability\r\n    int totalItems;             // Total number of items in inventory\r\n} Inventory;\r\n\r\n// Function Prototypes\r\nvoid addGroceryItem(Inventory* inventory);\r\nvoid displayInventory(const Inventory* inventory);\r\nvoid modifyQuantity(Inventory* inventory);\r\nvoid deleteItem(Inventory* inventory);\r\nvoid printMenu();\r\n\r\nint main() {\r\n    Inventory inventory = { .totalItems = 0 }; // Initialize inventory with no items\r\n    int userChoice;\r\n\r\n    do {\r\n        printMenu();\r\n        printf(\"Choose an option: \");\r\n        scanf(\"%d\", &userChoice);\r\n\r\n        switch (userChoice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                displayInventory(&inventory);\r\n                break;\r\n            case 3:\r\n                modifyQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                deleteItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program. Goodbye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid option! Please try again.\\n\");\r\n        }\r\n    } while (userChoice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to display menu options\r\nvoid printMenu() {\r\n    printf(\"\\n--- Grocery Inventory Menu ---\\n\");\r\n    printf(\"1. Add a Grocery Item\\n\");\r\n    printf(\"2. View All Items\\n\");\r\n    printf(\"3. Update Item Quantity\\n\");\r\n    printf(\"4. Remove an Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Function to add a grocery item to the inventory\r\nvoid addGroceryItem(Inventory* inventory) {\r\n    if (inventory->totalItems >= 100) {\r\n        printf(\"The inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    Grocery* newItem = &inventory->items[inventory->totalItems];\r\n    Availability* newStatus = &inventory->statuses[inventory->totalItems];\r\n\r\n    printf(\"Enter item name: \");\r\n    getchar(); // Clear input buffer\r\n    fgets(newItem->itemName, sizeof(newItem->itemName), stdin);\r\n    newItem->itemName[strcspn(newItem->itemName, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(newItem->itemCategory, sizeof(newItem->itemCategory), stdin);\r\n    newItem->itemCategory[strcspn(newItem->itemCategory, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &newItem->itemQuantity);\r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &newItem->itemPrice);\r\n\r\n    // Set availability status based on quantity\r\n    newStatus->isAvailable = newItem->itemQuantity > 0;\r\n    newStatus->isOutOfStock = !newStatus->isAvailable;\r\n\r\n    inventory->totalItems++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Function to display all items in the inventory\r\nvoid displayInventory(const Inventory* inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"The inventory is currently empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n--- Inventory List ---\\n\");\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        const Grocery* item = &inventory->items[i];\r\n        const Availability* status = &inventory->statuses[i];\r\n\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"  Name: %s\\n\", item->itemName);\r\n        printf(\"  Category: %s\\n\", item->itemCategory);\r\n        printf(\"  Quantity: %d\\n\", item->itemQuantity);\r\n        printf(\"  Price: %.2f\\n\", item->itemPrice);\r\n        printf(\"  Status: %s\\n\", status->isAvailable ? \"Available\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an item\r\nvoid modifyQuantity(Inventory* inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items available to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char nameToUpdate[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    getchar(); // Clear input buffer\r\n    fgets(nameToUpdate, sizeof(nameToUpdate), stdin);\r\n    nameToUpdate[strcspn(nameToUpdate, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].itemName, nameToUpdate) == 0) {\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &inventory->items[i].itemQuantity);\r\n\r\n            // Update availability status\r\n            inventory->statuses[i].isAvailable = inventory->items[i].itemQuantity > 0;\r\n            inventory->statuses[i].isOutOfStock = !inventory->statuses[i].isAvailable;\r\n\r\n            printf(\"Item quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Function to delete a grocery item from the inventory\r\nvoid deleteItem(Inventory* inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items available to delete.\\n\");\r\n        return;\r\n    }\r\n\r\n    char nameToRemove[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar(); // Clear input buffer\r\n    fgets(nameToRemove, sizeof(nameToRemove), stdin);\r\n    nameToRemove[strcspn(nameToRemove, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].itemName, nameToRemove) == 0) {\r\n            // Shift remaining items\r\n            for (int j = i; j < inventory->totalItems - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->statuses[j] = inventory->statuses[j + 1];\r\n            }\r\n            inventory->totalItems--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Q3.C --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define the structure for a student\r\ntypedef struct Student {\r\n    char studentName[100];\r\n    int studentID;\r\n    float studentGrade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Global pointer to the head of the list\r\nStudent* listHead = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Error: Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->studentName, name);\r\n    newStudent->studentID = id;\r\n    newStudent->studentGrade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to add a student to the list\r\nvoid addStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n\r\n    if (listHead == NULL) {\r\n        listHead = newStudent;\r\n    } else {\r\n        Student* current = listHead;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n    printf(\"Student added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayAllStudents() {\r\n    if (listHead == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = listHead;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->studentName, current->studentID, current->studentGrade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* findStudentByID(int id) {\r\n    Student* current = listHead;\r\n    while (current != NULL) {\r\n        if (current->studentID == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // If no student is found\r\n}\r\n\r\n// Function to sort students by their grades\r\nvoid sortStudentRecords() {\r\n    if (listHead == NULL || listHead->next == NULL) {\r\n        return; // No need to sort if 0 or 1 student exists\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lastPtr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = listHead;\r\n\r\n        while (ptr1->next != lastPtr) {\r\n            if (ptr1->studentGrade > ptr1->next->studentGrade) {\r\n                // Swap student records by swapping the data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->studentName);\r\n                tempID = ptr1->studentID;\r\n                tempGrade = ptr1->studentGrade;\r\n\r\n                strcpy(ptr1->studentName, ptr1->next->studentName);\r\n                ptr1->studentID = ptr1->next->studentID;\r\n                ptr1->studentGrade = ptr1->next->studentGrade;\r\n\r\n                strcpy(ptr1->next->studentName, tempName);\r\n                ptr1->next->studentID = tempID;\r\n                ptr1->next->studentGrade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lastPtr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Student records sorted by grade in ascending order.\\n\");\r\n}\r\n\r\n// Function to delete all student records\r\nvoid deleteAllStudents() {\r\n    Student* current = listHead;\r\n    while (current != NULL) {\r\n        Student* next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    listHead = NULL;\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\n\r\n// Main function to handle the menu and program flow\r\nint main() {\r\n    int choice, id;\r\n    float grade;\r\n    char name[100];\r\n\r\n    do {\r\n        printf(\"\\nStudent Records Menu:\\n\");\r\n        printf(\"1. Add Student Record\\n\");\r\n        printf(\"2. Display All Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Student Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove trailing newline\r\n                printf(\"Enter Student ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Student Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                addStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayAllStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudentRecords();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter Student ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* student = findStudentByID(id);\r\n                if (student) {\r\n                    printf(\"Record Found - Name: %s, ID: %d, Grade: %.2f\\n\", student->studentName, student->studentID, student->studentGrade);\r\n                } else {\r\n                    printf(\"No student found with ID: %d\\n\", id);\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteAllStudents();\r\n                break;\r\n\r\n            case 6:\r\n                deleteAllStudents();\r\n                printf(\"Exiting program. Goodbye!\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-Meet requirement."
  },
  {
    "student_id": "20611302",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX 10 // Maximum matrix size\r\n\r\n// Function to input a matrix\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX], char name) {\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to compute the transpose of a matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print matrix\r\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB, choice;\r\n\r\n    // Input matrix dimensions\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Validate dimensions\r\n    if (rowsA <= 0 || colsA <= 0 || rowsB <= 0 || colsB <= 0 || rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX) {\r\n        printf(\"Invalid dimensions. Exiting program.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for both matrices\r\n    inputMatrix(rowsA, colsA, A, 'A');\r\n    inputMatrix(rowsB, colsB, B, 'B');\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Add matrices if dimensions match\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // Subtract matrices if dimensions match\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Transpose Matrix A\r\n                transposeMatrix(rowsA, colsA, A, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n            case 4:\r\n                // Transpose Matrix B\r\n                transposeMatrix(rowsB, colsB, B, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n            case 5:\r\n                // Exit the program\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define ITEMS 100       // Maximum number of grocery items\r\n#define NAME 100        // Maximum length for item name\r\n#define CATEGORY 50     // Maximum length for item category\r\n\r\n// Struct for Grocery Item\r\ntypedef struct {\r\n    char name[NAME];\r\n    char category[CATEGORY];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;                   // Availability status, true = in stock, false = out of stock\r\n} GroceryItem;\r\n\r\n// Inventory\r\nGroceryItem inventory[ITEMS]; // Array to store grocery items\r\nint itemCount = 0;                // Current count of items in inventory\r\n\r\n// Function prototypes\r\nvoid addGroceryItem();\r\nvoid listAllGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    // Menu loop\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character left by scanf\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(); \r\n                break;\r\n            case 2:\r\n                listAllGroceryItems(); \r\n                break;\r\n            case 3:\r\n                updateQuantity(); \r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Display menu options\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Add a new grocery item\r\nvoid addGroceryItem() {\r\n    if (itemCount >= ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    // Input item details\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.name, NAME, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, CATEGORY, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar();\r\n\r\n    // Set stock status based on quantity\r\n    newItem.inStock = (newItem.quantity > 0);\r\n\r\n    // Add item to inventory and increment item count\r\n    inventory[itemCount++] = newItem;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// List all grocery items\r\nvoid listAllGroceryItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        // Print details of each item\r\n        printf(\"\\nName: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Update the quantity of a specific item\r\nvoid updateQuantity() {\r\n    char name[NAME];\r\n\r\n    // Input the name of the item to update\r\n    printf(\"Enter the name of the grocery item to update: \");\r\n    fgets(name, NAME, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            // If item found, update its quantity\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            getchar();\r\n\r\n            // Update stock status based on the new quantity\r\n            inventory[i].inStock = (inventory[i].quantity > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    // If item is not found\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Remove a specific item from the inventory\r\nvoid removeGroceryItem() {\r\n    char name[NAME];\r\n\r\n    // Input the name of the item to remove\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(name, NAME, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            // If item found, shift remaining items to fill the gap\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n\r\n            // Decrement item count\r\n            itemCount--;\r\n            printf(\"Grocery item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    // If item is not found\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for a Student Node\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL; // Head pointer for the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Merge Sort - using merge sort because it works efficiently with linked lists due to its pointer-based merging process\r\n//https://www.geeksforgeeks.org/c-program-for-merge-sort/ (Merge sort learnt from the link provided)\r\n// Merge two sorted linked lists\r\nStudent* merge(Student* left, Student* right) {\r\n    if (!left) return right;\r\n    if (!right) return left;\r\n\r\n    Student* result = NULL;\r\n    if (left->grade <= right->grade) {\r\n        result = left;\r\n        result->next = merge(left->next, right);\r\n    } else {\r\n        result = right;\r\n        result->next = merge(left, right->next);\r\n    }\r\n    return result;\r\n}\r\n\r\n// Function to split the linked list into two\r\nvoid splitList(Student* source, Student** leftRef, Student** rightRef) {\r\n    Student* slow = source;\r\n    Student* fast = source->next;\r\n\r\n    // Use the fast/slow pointer strategy to find the middle\r\n    while (fast) {\r\n        fast = fast->next;\r\n        if (fast) {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n    }\r\n\r\n    *leftRef = source;\r\n    *rightRef = slow->next;\r\n    slow->next = NULL;\r\n}\r\n\r\n// Merge Sort\r\nStudent* mergeSort(Student* head) {\r\n    if (!head || !head->next) {\r\n        return head; // Base case: empty or single-element list\r\n    }\r\n\r\n    Student* left = NULL;\r\n    Student* right = NULL;\r\n\r\n    // Split the list into two \r\n    splitList(head, &left, &right);\r\n\r\n    // Recursively sort both halves\r\n    left = mergeSort(left);\r\n    right = mergeSort(right);\r\n\r\n    // Merge the sorted halves\r\n    return merge(left, right);\r\n}\r\n\r\n// Wrapper function to call Merge Sort and update the head pointer\r\nvoid sortStudents() {\r\n    if (!head) {\r\n        printf(\"No student records to sort.\\n\");\r\n        return;\r\n    }\r\n    head = mergeSort(head);\r\n    printf(\"Records sorted by grade successfully!\\n\");\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id)\r\n            return current;\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire linked list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"List deleted successfully.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                deleteList(); // Free all memory before exiting\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation of Merge Sort is appropriate for linked lists due to its efficiency and stability. It effectively handles large datasets with a time complexity of O(n log n), which is an improvement over simpler sorting algorithms like Bubble Sort."
  },
  {
    "student_id": "20614355",
    "code": "\n/* --- 20615031_Yew Xin Nie_LA3/20615031_Yew Xin Nie_LA3/Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Declare FUnction Prototypes// \r\nint inputMatrix();\r\nint displayMatrix();\r\nint additionMatrix();\r\nint subtractMatrix();\r\nint transposeMatrix();\r\n\r\n\r\nint main(void){\r\n    // Declare variable zone //\r\n    int rowA, rowB, columnA, columnB = 0;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result [MAX_SIZE] [MAX_SIZE];\r\n    int choice = 0;\r\n    \r\n    //Matrix A//\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowA, &columnA);\r\n\r\n    // Output for invalid range from 1 to 10 //\r\n    while(rowA < 1 || rowA > 10 || columnA < 1 || columnA > 10){\r\n        printf(\"Invalid dimension.\");\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowA, &columnA);\r\n    }\r\n\r\n     // Ask user to enter the elements for matrix //\r\n        printf(\"Enter elements for Matrix A:\\n\");\r\n        inputMatrix(rowA, columnA, matrixA);\r\n\r\n    //Matrix B//\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowB, &columnB);\r\n\r\n    // Output for invalid range from 1 to 10 //\r\n     while(rowB < 1 || rowB > 10 || columnB < 1 || columnB > 10){\r\n        printf(\"Invalid dimension.\");\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowB, &columnB);\r\n    }\r\n\r\n    // Ask user to enter the elements for matrix //\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(rowA, rowB, matrixB);\r\n\r\n    do{\r\n\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice){\r\n            case 1:\r\n                if (rowA == rowB && columnA == columnB){\r\n                    additionMatrix(rowA, columnA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(rowA, columnA, result);\r\n                }\r\n                else{\r\n                    printf(\"Addition is not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowA == rowB && columnA == columnB){\r\n                    subtractMatrix(rowA, columnA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(rowA, columnA, result);\r\n                }\r\n                else{\r\n                    printf(\"Subtraction is not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(rowA, columnA, matrixA, result);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                displayMatrix(columnA, rowA, result);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(rowB, columnB, matrixB, result);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                displayMatrix(columnB, rowB, result);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            \r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n\r\n    }while(choice != 5);\r\n\r\n\r\n\r\n}\r\n\r\n// FUNCTIONS //\r\nint inputMatrix (int rows, int cols, int mat[MAX_SIZE][MAX_SIZE]){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            printf(\"Enter element [%d][%d]: \", i + 1 , j + 1);\r\n            scanf(\"%d\", &mat[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nint displayMatrix (int rows, int cols, int mat[MAX_SIZE][MAX_SIZE]){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            printf(\"%d\\t\", mat[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n}\r\n\r\nint additionMatrix (int rows, int cols, int a [MAX_SIZE][MAX_SIZE], int b [MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]){\r\n    for (int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint subtractMatrix (int rows, int cols, int a [MAX_SIZE][MAX_SIZE], int b [MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]){\r\n    for (int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint transposeMatrix(int rows, int cols, int mat[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]){\r\n    for (int i = 0; i < rows; i++){\r\n        for(int j = 0; j < cols; j++){\r\n            result[j][i] = mat[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n\n/* --- 20615031_Yew Xin Nie_LA3/20615031_Yew Xin Nie_LA3/Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>    // for boolean\r\n\r\n#define MAX_ITEMS 100   // MAX SIZE for Grocery Items\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Struct definitions //\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    bool inStock;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];   // array of GroceryItem (all grocery list in array)\r\n    int itemCount;  // track how many items are currently in the inventory\r\n} GroceryInventory;\r\n\r\n// Function prototypes //\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateItemQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    // Initialize the inventory //\r\n    GroceryInventory inventory = { .itemCount = 0 };    \r\n    int choice = 0;\r\n\r\n\r\n    do {\r\n        // Display Menu //\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity of Grocery Item\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateItemQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program. Have a nice day, Bye bye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item //\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    // Check the inventory does not exceed the maximum size //\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n    \r\n    // Create a pointer (item) directly points the next slot in the array //\r\n    GroceryItem *item = &inventory->items[inventory->itemCount];\r\n\r\n    printf(\"Enter item name: \");\r\n    getchar(); // Clear newline from input buffer \r\n    fgets(item->name, MAX_NAME_LENGTH, stdin); // Recieve data input for item name\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove trailing newline\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(item->category, MAX_CATEGORY_LENGTH, stdin); // Receive data input of category\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0'; \r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    // Automatically update the stock availability status //\r\n    // inStock = true : item > 0 \r\n    // inStock = false: item < 0 (Out of stock)\r\n    item->inStock = (item->quantity > 0);\r\n\r\n    // increment of itemCount as each time the user add\r\n    inventory->itemCount++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    // Check if inventory is empty or not\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\tListing All Grocery Items\\t\\n\");\r\n    printf(\"\\nGrocery Items:\\n\");\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory -> items[i];\r\n\r\n        printf(\"Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: %s\\n\",\r\n               item->name, item->category, item->quantity, item->price,\r\n               item->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateItemQuantity(GroceryInventory *inventory) {\r\n    //Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to update: \");\r\n    getchar(); // Clear newline from input buffer\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';   // remove new line character from the input string\r\n\r\n    // Search grocery item in inventory //\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory -> items[i];\r\n        if (strcmp(item->name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &item->quantity);\r\n            item->inStock = (item->quantity > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    //Check if inventory is empty\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar(); // Clear newline from input buffer\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    // Search grocery item in inventory //\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n            }\r\n            inventory->itemCount--;     // removing item from inventory\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return; // return value to the function\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in inventory.\\n\");\r\n}\r\n\n/* --- 20615031_Yew Xin Nie_LA3/20615031_Yew Xin Nie_LA3/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Struct definition for a student node\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Head pointer for the linked list //\r\nStudent* head = NULL;\r\n\r\n                // Function prototypes //\r\n// Function to create a new student node//\r\nStudent* createStudent(const char* name, int id, float grade){\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a student into the linked list\r\nvoid insertStudent(const char* name, int id, float grade){\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records in the linked list\r\nvoid displayStudents(){\r\n    if (!head) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id){\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire linked list and frees the allocated memory\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to ensure all memory is freed \r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort the student records by grades using bubble sorting alogrithm\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return; // No sorting needed for empty or single-node list\r\n    }\r\n\r\n    // Bubble Sort for simplicity\r\n    int swapped; // keep track of swaps were made during an iteration\r\n    Student* pass;  // a pointer that traverses the lsit during each pass\r\n    Student* last_pass = NULL;  // marks the last sorted position in the list\r\n\r\n// Ensure sorting until no swaps until end of the list\r\n    do {\r\n        swapped = 0;    // Reset swapped flag for each pass\r\n        pass = head;    // Starting of the list\r\n\r\n        // Make sure the list is in the correct order\r\n        while (pass->next != last_pass) {\r\n            if (pass -> grade > pass -> next -> grade) {\r\n                // Swap grades\r\n                float tempGrade = pass ->grade;\r\n                pass ->grade = pass -> next -> grade;\r\n                pass-> next -> grade = tempGrade;\r\n\r\n                // Swap IDs\r\n                int tempID = pass -> id;\r\n                pass -> id = pass -> next -> id;\r\n                pass -> next -> id = tempID;\r\n\r\n                // Swap names\r\n                char tempName[100];\r\n                strcpy(tempName, pass -> name);\r\n                strcpy(pass -> name, pass -> next -> name);\r\n                strcpy(pass -> next -> name, tempName);\r\n\r\n                swapped = 1; // Shows that list is unsorted\r\n            }\r\n            pass = pass -> next;\r\n        }\r\n        last_pass = pass;   // the last node is in the correct position\r\n    } while (swapped == 0); \r\n}\r\n\r\nint main() {\r\n    // Decalre variable and intialize zone//\r\n    int choice, id = 0;\r\n    char name[100];\r\n    float grade = 0.0;\r\n    Student* foundStudent;\r\n\r\n    do {\r\n        printf(\"\\nStudent Records Management System\\n\");\r\n        printf(\"\\t1. Insert Student Record\\n\");\r\n        printf(\"\\t2. Display Student Records\\n\");\r\n        printf(\"\\t3. Sort Records by Grade\\n\");\r\n        printf(\"\\t4. Search Record by ID\\n\");\r\n        printf(\"\\t5. Delete All Records\\n\");\r\n        printf(\"\\t6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  // To consume the newline character\r\n\r\n        switch (choice) {\r\n            // Insert Student Record //\r\n            case 1:\r\n                printf(\"Enter student's name: \");\r\n                getchar();              // Clear newline from input buffer\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");     // Remove newline\r\n\r\n                printf(\"Enter student's ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter student's grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                printf(\"Student record inserted successfully.\\n\");\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Student records sorted by grade.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter the ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Student Found:\\n\");\r\n                    printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting program. Goodbye!\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "feedback": "q1-Meet requirement. \nq2-In the remove_grocery_item function, after decrementing item_count, the loop should iterate up to item_count (not item_count - 1). This can lead to accessing uninitialized memory.\nq3- The implementation uses Bubble Sort to sort student records by grade. While it is straightforward, it has a time complexity of O(n?), which may not be efficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20595218",
    "code": "\n/* --- qn1.c --- */\n#include <stdio.h>\n#define MAX 10\n\n// Function prototypes\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]);\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]);\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]);\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]);\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]);\n\n// Functions\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX])\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX])\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX])\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            result[i][j] = a[i][j] + b[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX])\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            result[i][j] = a[i][j] - b[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX])\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n// Main function\nint main()\n{\n    int rowsA, colsA, rowsB, colsB;\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\n    int choice;\n\n    printf(\"Enter dimensions for Matrix A (rows columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n\n    printf(\"Enter dimensions for Matrix B (rows columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX)\n    {\n        printf(\"Matrix size exceeds the maximum limit of %dx%d.\\n\", MAX, MAX);\n        return 1;\n    }\n\n    printf(\"Enter elements for Matrix A:\\n\");\n    inputMatrix(rowsA, colsA, matrixA);\n\n    printf(\"Enter elements for Matrix B:\\n\");\n    inputMatrix(rowsB, colsB, matrixB);\n\n    do\n    {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice)\n        {\n        case 1:\n            if (rowsA == rowsB && colsA == colsB)\n            {\n                addMatrices(rowsA, colsA, matrixA, matrixB, result);\n                printf(\"Matrix after Addition:\\n\");\n                printMatrix(rowsA, colsA, result);\n            }\n            else\n            {\n                printf(\"Addition isn't possible. Dimensions don't match.\\n\");\n            }\n            break;\n        case 2:\n            if (rowsA == rowsB && colsA == colsB)\n            {\n                subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\n                printf(\"Matrix after Subtraction:\\n\");\n                printMatrix(rowsA, colsA, result);\n            }\n            else\n            {\n                printf(\"Subtraction isn't possible. Dimensions don't match.\\n\");\n            }\n            break;\n        case 3:\n            transposeMatrix(rowsA, colsA, matrixA, result);\n            printf(\"Transpose of Matrix A:\\n\");\n            printMatrix(colsA, rowsA, result);\n            break;\n        case 4:\n            transposeMatrix(rowsB, colsB, matrixB, result);\n            printf(\"Transpose of Matrix B:\\n\");\n            printMatrix(colsB, rowsB, result);\n            break;\n        case 5:\n            printf(\"Exiting\\n\");\n            break;\n        default:\n            printf(\"Invalid choice. Try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n/* --- qn2.c --- */\n#include <stdio.h>\n#include <string.h>\n#define MAX_ITEMS 100\n\ntypedef struct\n{\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    int inStock; // 1 for in stock & 0 for out of stock\n} GroceryItem;\n\nGroceryItem inventory[MAX_ITEMS];\nint itemCount = 0;\n\nvoid addGroceryItem()\n{\n    if (itemCount >= MAX_ITEMS)\n    {\n        printf(\"Inventory full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem item;\n    printf(\"Enter item name: \");\n    scanf(\" %[^\\n]\", item.name);\n    printf(\"Enter category: \");\n    scanf(\" %[^\\n]\", item.category);\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &item.quantity);\n    printf(\"Enter price: \");\n    scanf(\"%f\", &item.price);\n    item.inStock = item.quantity > 0 ? 1 : 0;\n\n    inventory[itemCount++] = item;\n    printf(\"Item added successfully.\\n\");\n}\n\nvoid listGroceryItems()\n{\n    if (itemCount == 0)\n    {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\nInventory List:\\n\");\n    for (int i = 0; i < itemCount; i++)\n    {\n        printf(\"Item %d:\\n\", i + 1);\n        printf(\"Name: %s\\n\", inventory[i].name);\n        printf(\"Category: %s\\n\", inventory[i].category);\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\n        printf(\"Price: %.2f\\n\", inventory[i].price);\n        printf(\"Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\n        printf(\"\\n\");\n    }\n}\n\nvoid updateQuantity()\n{\n    char name[100];\n    printf(\"Enter the name of the item to update quantity: \");\n    scanf(\" %[^\\n]\", name);\n\n    for (int i = 0; i < itemCount; i++)\n    {\n        if (strcmp(inventory[i].name, name) == 0)\n        {\n            printf(\"Current quantity: %d\\n\", inventory[i].quantity);\n            printf(\"Enter new quantity: \");\n            scanf(\"%d\", &inventory[i].quantity);\n            inventory[i].inStock = inventory[i].quantity > 0 ? 1 : 0;\n            printf(\"Quantity updated successfully.\\n\");\n            return;\n        }\n    }\n    printf(\"Item not found.\\n\");\n}\n\nvoid removeGroceryItem()\n{\n    char name[100];\n    printf(\"Enter the name of the item to remove: \");\n    scanf(\" %[^\\n]\", name);\n\n    for (int i = 0; i < itemCount; i++)\n    {\n        if (strcmp(inventory[i].name, name) == 0)\n        {\n            for (int j = i; j < itemCount - 1; j++)\n            {\n                inventory[j] = inventory[j + 1];\n            }\n            itemCount--;\n            printf(\"Item removed successfully.\\n\");\n            return;\n        }\n    }\n    printf(\"Item not found.\\n\");\n}\n\nint main()\n{\n    int choice;\n    do\n    {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice)\n        {\n        case 1:\n            addGroceryItem();\n            break;\n        case 2:\n            listGroceryItems();\n            break;\n        case 3:\n            updateQuantity();\n            break;\n        case 4:\n            removeGroceryItem();\n            break;\n        case 5:\n            printf(\"Exiting\\n\");\n            break;\n        default:\n            printf(\"Invalid choice. Try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n/* --- qn3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Student\n{\n    char name[100];\n    int id;\n    char grade;\n    struct Student *next;\n} Student;\n\nStudent *head = NULL;\n\n// Function prototypes\nStudent *createStudent(const char *name, int id, char grade);\nvoid insertStudent(const char *name, int id, char grade);\nvoid displayStudents();\nStudent *searchStudentByID(int id);\nvoid deleteList();\nvoid sortStudents();\nvoid freeMemory();\n\n// Function to create a new student node\nStudent *createStudent(const char *name, int id, char grade)\n{\n    Student *newStudent = (Student *)malloc(sizeof(Student));\n    if (!newStudent)\n    {\n        printf(\"Memory allocation failed!\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record into the linked list\nvoid insertStudent(const char *name, int id, char grade)\n{\n    if (grade < 'A' || grade > 'F')\n    {\n        printf(\"Invalid grade. Please enter a capital letter between A and F.\\n\");\n        return;\n    }\n    Student *newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n}\n\n// Function to display all student records\nvoid displayStudents()\n{\n    if (!head)\n    {\n        printf(\"No student records available.\\n\");\n        return;\n    }\n    printf(\"\\nStudent Records:\\n\");\n    Student *current = head;\n    while (current)\n    {\n        printf(\"Name: %s, ID: %d, Grade: %c\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student record by ID\nStudent *searchStudentByID(int id)\n{\n    Student *current = head;\n    while (current)\n    {\n        if (current->id == id)\n        {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire linked list\nvoid deleteList()\n{\n    Student *current = head;\n    while (current)\n    {\n        Student *temp = current;\n        current = current->next;\n        free(temp);\n    }\n    head = NULL;\n}\n\n// Function to sort the student records by grade\nvoid sortStudents()\n{\n    if (!head || !head->next)\n    {\n        printf(\"\\nNo sorting needed. The list has one or no records.\\n\");\n        return;\n    }\n\n    Student *sorted = NULL;\n    Student *current = head;\n\n    while (current)\n    {\n        Student *next = current->next;\n\n        if (!sorted || current->grade < sorted->grade)\n        {\n            current->next = sorted;\n            sorted = current;\n        }\n        else\n        {\n            Student *temp = sorted;\n            while (temp->next && temp->next->grade <= current->grade)\n            {\n                temp = temp->next;\n            }\n            current->next = temp->next;\n            temp->next = current;\n        }\n\n        current = next;\n    }\n\n    head = sorted;\n    printf(\"\\nRecords sorted by grade.\\n\");\n    displayStudents();\n}\n\n// Function to free all allocated memory\nvoid freeMemory()\n{\n    deleteList();\n}\n\nint main()\n{\n    int choice;\n    char name[100];\n    int id;\n    char grade;\n\n    do\n    {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete All Records\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice)\n        {\n        case 1:\n            printf(\"\\nEnter name: \");\n            scanf(\"%s\", name);\n            printf(\"Enter ID: \");\n            scanf(\"%d\", &id);\n            do\n            {\n                printf(\"Enter grade (A-F): \");\n                scanf(\" %c\", &grade);\n                if (grade < 'A' || grade > 'F')\n                {\n                    printf(\"Invalid grade. Please enter a capital letter between A and F.\\n\");\n                }\n            } while (grade < 'A' || grade > 'F');\n            insertStudent(name, id, grade);\n            break;\n        case 2:\n            displayStudents();\n            break;\n        case 3:\n            sortStudents();\n            break;\n        case 4:\n            printf(\"\\nEnter ID to search: \");\n            scanf(\"%d\", &id);\n            Student *found = searchStudentByID(id);\n            if (found)\n            {\n                printf(\"Record found: Name: %s, ID: %d, Grade: %c\\n\", found->name, found->id, found->grade);\n            }\n            else\n            {\n                printf(\"No record found with ID %d.\\n\", id);\n            }\n            break;\n        case 5:\n            deleteList();\n            printf(\"All records deleted.\\n\");\n            break;\n        case 6:\n            freeMemory();\n            printf(\"Exiting program.\\n\");\n            break;\n        default:\n            printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The sorting algorithm is efficient for linked lists, operating in O(n?) in the worst case but is appropriate for smaller datasets. The implementation correctly handles the insertion of nodes in sorted order based on grades."
  },
  {
    "student_id": "20720830",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Declare functions\r\nvoid add(int a[10][10], int b[10][10], int rowa, int cola, int rowb, int colb);\r\nvoid subtract(int a[10][10], int b[10][10], int rowa, int cola, int rowb, int colb);\r\nvoid transpose(int c[10][10], int row, int col);\r\nvoid output(int c[10][10], int row, int col);\r\n\r\nint a[10][10];\r\nint b[10][10];\r\nint rowa, cola, rowb, colb;\r\n\r\nint main(){\r\n    do{\r\n        rowa,cola = 0;\r\n\r\n        //Input dimensions for Matrix A\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n\r\n        // Validate input to be a number\r\n        if (scanf(\"%d %d\", &rowa, &cola) != 2) {\r\n            printf(\"Invalid input. Please enter numbers only.\\n\");\r\n            while (getchar() != '\\n'); // Loop to clear buffer if input is not a number\r\n            continue;\r\n        }\r\n\r\n        // Validate matrix dimensions\r\n        if (rowa > 10 || cola > 10 || rowa <= 0 || cola <= 0){\r\n            printf(\"Invalid Input. Matrix dimensions cannot exceed 10x10 and should be more than 0.\\n\");\r\n            continue;\r\n        }\r\n\r\n        printf(\"Enter elements for Matrix A: \\n\");\r\n\r\n        //Loop and input elements for Matrix A\r\n        for(int i=0; i<rowa; i++){\r\n            for(int j=0; j<cola; j++){\r\n                printf(\"Element [%d][%d]: \", i+1, j+1);\r\n                // Validate input to be a number\r\n                if (scanf(\"%d\", &a[i][j]) != 1){\r\n                    printf(\"Invalid input. Please enter a number.\\n\");\r\n                    while (getchar() != '\\n'); // Loop to clear buffer if input is not a number\r\n                    j--;\r\n                }\r\n            }\r\n        }\r\n\r\n    } while (rowa > 10 || cola > 10 || rowa <= 0 || cola <= 0 );\r\n\r\n    do{\r\n        rowb,colb = 0;\r\n        \r\n        //Input dimensions for Matrix B\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n\r\n        // Validate input to be a number\r\n        if (scanf(\"%d %d\", &rowb, &colb) != 2) {\r\n            printf(\"Invalid input. Please enter numbers only.\\n\");\r\n            while (getchar() != '\\n'); // Loop to clear buffer if input is not a number\r\n            continue;\r\n        }\r\n\r\n        // Validate matrix dimensions\r\n        if (rowb > 10 || colb > 10 || rowb <= 0 || colb <= 0){\r\n            printf(\"Invalid Input. Matrix dimensions cannot exceed 10x10 and should be more than 0\\n\");\r\n            continue;\r\n        }\r\n\r\n        printf(\"Enter elements for Matrix B: \\n\");\r\n\r\n        //Loop and input elements for Matrix B\r\n        for(int i=0; i<rowb; i++){\r\n            for(int j=0; j<colb; j++){\r\n                printf(\"Element [%d][%d]: \", i+1, j+1);\r\n                // Validate input to be a number\r\n                if (scanf(\"%d\", &b[i][j]) != 1){\r\n                    printf(\"Invalid input. Please enter a number.\\n\");\r\n                    while (getchar() != '\\n'); // Loop to clear buffer if input is not a number\r\n                    j--;\r\n                }\r\n            }\r\n        }\r\n\r\n    } while (rowb > 10 || colb > 10 || rowb <= 0 || colb <= 0 );\r\n\r\n    int choice;\r\n    //Loop menu for matrix operations\r\n    do{\r\n        printf(\"\\nMatrix Operations Menu:\");\r\n        printf(\"\\n1. Add Matrices\");\r\n        printf(\"\\n2. Subtract Matrices\");\r\n        printf(\"\\n3. Transpose Matrix A\");\r\n        printf(\"\\n4. Transpose Matrix B\");\r\n        printf(\"\\n5. Exit\");\r\n        printf(\"\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        switch(choice){\r\n            case 1:\r\n                add(a, b, rowa, cola, rowb, colb);\r\n                break;\r\n            case 2:\r\n                subtract(a, b, rowa, cola, rowb, colb);\r\n                break;\r\n            case 3:\r\n                transpose(a, rowa, cola);\r\n                break;\r\n            case 4:\r\n                transpose(b, rowb, colb);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice\");\r\n                continue;\r\n        }\r\n    }while(choice!=5);//Exit when choice is 5\r\n}\r\n\r\n//Function to add matrices\r\nvoid add(int a[10][10], int b[10][10], int rowa, int cola, int rowb, int colb){\r\n    //Check if matrices can be added\r\n    if(rowa!=rowb || cola!=colb){\r\n        printf(\"Matrices cannot be added\");\r\n        return;\r\n    }\r\n    int c[10][10];\r\n    //Loop and add elements of matrices to c\r\n    for(int i=0; i<rowa; i++){\r\n        for(int j=0; j<cola; j++){\r\n            c[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n    //Output result\r\n    printf(\"Result of Matrix A + Matrix B: \\n\");\r\n    output(c, rowa, cola);\r\n}\r\n\r\n//Function to subtract matrices\r\nvoid subtract(int a[10][10], int b[10][10], int rowa, int cola, int rowb, int colb){\r\n    //Check if matrices can be subtracted\r\n    if(rowa!=rowb || cola!=colb){\r\n        printf(\"Matrices cannot be subtracted\");\r\n        return;\r\n    }\r\n    int c[10][10];\r\n    //Loop and subtract elements of matrices to c\r\n    for(int i=0; i<rowa; i++){\r\n        for(int j=0; j<cola; j++){\r\n            c[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n    //Output result\r\n    printf(\"Result of Matrix A - Matrix B: \\n\");\r\n    output(c, rowa, cola);\r\n}\r\n\r\n//Function to transpose matrices\r\nvoid transpose(int c[10][10], int row, int col){\r\n    int d[10][10];\r\n    //Loop and transpose elements of matrices to d\r\n    for(int i=0; i<row; i++){\r\n        for(int j=0; j<col; j++){\r\n            d[j][i] = c[i][j];\r\n        }\r\n    }\r\n    //Output result\r\n    if (c == a) {\r\n        printf(\"Transpose of Matrix A:\\n\");\r\n    } else if (c == b) {\r\n        printf(\"Transpose of Matrix B:\\n\");\r\n    }\r\n    output(d, col, row);\r\n}\r\n\r\n//Function to output matrices\r\nvoid output(int c[10][10], int row, int col){\r\n    //Loop and display elements of matrix\r\n    for(int i=0; i<row; i++){\r\n        for(int j=0; j<col; j++){\r\n            printf(\"%d \", c[i][j]);\r\n        }\r\n        printf(\"\\n\");//New line for next row\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n// Structure for Grocery Item\r\ntypedef struct{\r\n    char Name[100];\r\n    char Category[50];\r\n    int Quantity;\r\n    float Price;\r\n}GroceryItem;\r\n\r\n// Structure for Availability\r\ntypedef struct{\r\n    bool instock;\r\n    bool outofstock;\r\n}Availablity;\r\n\r\n// Structure for Inventory\r\ntypedef struct{\r\n    GroceryItem item[100];\r\n    Availablity status;\r\n    int num;\r\n}Inventory;\r\n\r\nInventory inven;\r\n\r\n// Declare functions\r\nvoid addGroceryItem();\r\nvoid listAllGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main(){\r\n    int choice;\r\n    //Loop menu for grocery inventory management system\r\n    do{\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n        switch(choice){\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listAllGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice\");\r\n                continue;\r\n        }\r\n    }while(choice!=5);//Exit when choice is 5\r\n    return 0;\r\n}\r\n\r\n//Function to add grocery item\r\nvoid addGroceryItem(){\r\n    //Input grocery item details\r\n    printf(\"Enter Item Name: \");\r\n    fgets(inven.item[inven.num].Name, 100, stdin);\r\n    inven.item[inven.num].Name[strcspn(inven.item[inven.num].Name, \"\\n\")] = '\\0';//Remove newline character\r\n    printf(\"Enter Category: \");\r\n    fgets(inven.item[inven.num].Category, 50, stdin);\r\n    inven.item[inven.num].Category[strcspn(inven.item[inven.num].Category, \"\\n\")] = '\\0'; //Remove newline character\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &inven.item[inven.num].Quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &inven.item[inven.num].Price);\r\n    inven.num++; //Increment to number of grocery items\r\n    printf(\"Grocery item added successfully\\n\");\r\n}\r\n\r\n//Function to list all grocery items\r\nvoid listAllGroceryItems(){\r\n    //Check if inventory is empty\r\n    if (inven.num==0){\r\n        printf(\"No grocery items in the inventory\\n\");\r\n        return;\r\n    }\r\n    //Loop and display all grocery items\r\n    for(int i=0; i<inven.num; i++){\r\n        printf(\"Name: %s\\n\", inven.item[i].Name);\r\n        printf(\"Category: %s\\n\", inven.item[i].Category);\r\n        printf(\"Quantity: %d\\n\", inven.item[i].Quantity);\r\n        printf(\"Price: %.2f\\n\", inven.item[i].Price);\r\n        printf(\"Status: \");\r\n\r\n        //Reset status\r\n        inven.status.instock = false;\r\n        inven.status.outofstock = false;\r\n        \r\n        //Check the status of grocery item\r\n        if(inven.item[i].Quantity>0){\r\n            inven.status.instock = true;\r\n        }\r\n        else{\r\n            inven.status.outofstock = true;\r\n        }\r\n        if(inven.status.instock){\r\n            printf(\"In Stock\\n\");\r\n        }\r\n        else if(inven.status.outofstock){\r\n            printf(\"Out of Stock\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n//Function to update quantity of grocery item\r\nvoid updateQuantity(){\r\n    char name[100];\r\n    //Input name of grocery item to update quantity\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; //Remove newline character\r\n\r\n    //Loop and search(compare) for the grocery item\r\n    for(int i=0; i<inven.num; i++){\r\n        if(strcasecmp(inven.item[i].Name, name)==0){\r\n            //Update quantity\r\n            printf(\"Enter new quantity for %s: \", inven.item[i].Name);\r\n            scanf(\"%d\", &inven.item[i].Quantity);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    //If grocery item not found\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\n//Function to remove grocery item\r\nvoid removeGroceryItem(){\r\n    char name[100];\r\n    //Input name of grocery item to remove\r\n    printf(\"Enter name of grocery item to remove: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';// Remove newline character\r\n\r\n    //Loop and search(compare) for the grocery item\r\n    for(int i=0; i<inven.num; i++){\r\n        if(strcasecmp(inven.item[i].Name, name)==0){\r\n            for(int j=i; j<inven.num-1; j++){\r\n                //Replace and delete the matched grocery item\r\n                inven.item[j] = inven.item[j+1];\r\n            }\r\n            inven.num--;//Decrement to the number of grocery items\r\n            printf(\"Grocery item '%s' removed successfully\\n\", inven.item[i].Name);   \r\n            return;\r\n        }\r\n    }\r\n    //If grocery item not found\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate memory for new student\r\n    Student* newStud = (Student*)malloc(sizeof(Student));\r\n    strcpy(newStud->name, name);// Copy name to new student\r\n    newStud->id = id;\r\n    newStud->grade = grade;\r\n    newStud->next = NULL;\r\n    return newStud;\r\n}\r\n\r\n// Function to insert a new student record at the beginning\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStud = createStudent(name, id, grade);\r\n    newStud->next = head; //move the head pointer to the next node\r\n    head = newStud;//set the new student as the head\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        // Display student information\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Move to next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        // If student ID matches, return the current student\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;// Move to next student\r\n    }\r\n    // If student not found, return NULL\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    \r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    \r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to get the length of the linked list\r\nint getLength(Student *head)\r\n{\r\n    int len = 0;\r\n    Student *current = head;\r\n    //Loop through the list and add up the length\r\n    while (current != NULL)\r\n    {\r\n        len++;\r\n        current = current->next;\r\n    }\r\n    return len;\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    Student* current = head;\r\n    int len = getLength(head);\r\n    int itr = 0;\r\n    int swapped;\r\n    //Loop through the list and sort the records by grade using Bubble Sort\r\n    while (itr < len)\r\n    {\r\n        Student *traverseNode = head; \r\n        Student *prevNode = head;\r\n        swapped = 0;\r\n\r\n        while (traverseNode->next != NULL)\r\n        {\r\n            // Temporary pointer to store the next node\r\n            Student *ptr = traverseNode->next;\r\n            // If the grade of the current node is greater than the grade of the next node, swap the nodes\r\n            if (traverseNode->grade > ptr->grade)\r\n            {\r\n                swapped = 1; // Set swapped flag to 1\r\n                // Check if the current node is the head of the linked list\r\n                if (traverseNode == head)\r\n                {\r\n                    // Performing swap operations and updating the head of the linked list\r\n                    traverseNode->next = ptr->next;\r\n                    ptr->next = traverseNode;\r\n                    prevNode = ptr;\r\n                    head = prevNode;\r\n                }\r\n                else\r\n                {\r\n                    // Performing swap operation\r\n                    traverseNode->next = ptr->next;\r\n                    ptr->next = traverseNode;\r\n                    prevNode->next = ptr;\r\n                    prevNode = ptr;\r\n                }\r\n                continue;\r\n            }\r\n            prevNode = traverseNode; // Update the previous node\r\n            traverseNode = traverseNode->next; // Move to the next node\r\n        }\r\n\r\n        // If no swap occurred, break the loop\r\n        if (!swapped)\r\n        {\r\n            break;\r\n        }\r\n\r\n        ++itr;\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n    return;\r\n}\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-In the removeGroceryItem function, the message printf(\"Grocery item '%s' removed successfully\\n\", inven.item[i].Name); should be updated to reflect the correct item name after removal.\nq3-There is a logic error in the sortStudents function regarding the swapping of nodes. The swapping mechanism does not correctly update the links between nodes when they are swapped, which can lead to inconsistent list states."
  },
  {
    "student_id": "20593889",
    "code": "",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While this method is simple and effective for small datasets, it has a time complexity of O(n?), which can be inefficient for larger lists. Consider using a more efficient sorting algorithm, such as Quick Sort or Merge Sort, for better performance."
  },
  {
    "student_id": "20590120",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX_SIZE 10\r\n\r\n\r\n// Function to add matrices\r\nint AddMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int total[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            total[i][j] = A[i][j]+B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nint SubtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int total[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            total[i][j] = A[i][j]-B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose matrices A\r\nint TransposeMatricesA(int A[MAX_SIZE][MAX_SIZE],int result[MAX_SIZE][MAX_SIZE],int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[j][i];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose matrices B\r\nint TransposeMatricesB(int B[MAX_SIZE][MAX_SIZE],int result[MAX_SIZE][MAX_SIZE],int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = B[j][i];\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE];\r\n    int B[MAX_SIZE][MAX_SIZE];\r\n    int total[MAX_SIZE][MAX_SIZE];\r\n    int transposeA[MAX_SIZE][MAX_SIZE], transposeB[MAX_SIZE][MAX_SIZE];\r\n    int rowA, columnA;\r\n    int rowB, columnB;\r\n    int choice;\r\n\r\n    \r\n    printf(\"Enter dimensions for Matrix A (rows and column): \");\r\n    scanf(\"%d %d\", &rowA, &columnA);\r\n    if (rowA > 10 || columnA > 10) {\r\n        printf(\" Maximum size is 10x10\\n\");        //message send to user if row and column is over 10x10\r\n        return 1;\r\n    }\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n     for (int i = 0; i < rowA; i++) {\r\n        for (int j = 0; j < columnA; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    \r\n    printf(\"Enter dimensions for Matrix B (rows and column): \");\r\n    scanf(\"%d %d\", &rowB, &columnB);\r\n    if (rowB > 10 || columnB > 10) {\r\n        printf(\"Maximum size is 10x10\\n\");\r\n        return 1;\r\n    }\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n     for (int i = 0; i < rowA; i++) {\r\n        for (int j = 0; j < columnA; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n    }\r\n    \r\n    while(1){\r\n       \r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice) {\r\n            case 1:\r\n                if (rowA == rowB && columnA == columnB) {\r\n                    AddMatrices(A, B, total, rowA, columnA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    for (int i = 0; i < rowA; i++) {       \r\n                     for (int j = 0; j < columnA; j++) {   \r\n                    printf(\"%d \", total[i][j]);\r\n                     }\r\n                        printf(\"\\n\");\r\n                    }                 \r\n                } else {\r\n                    printf(\"Invalid matrix dimensions\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowA == rowB && columnA == columnB) {\r\n                    SubtractMatrices(A, B, total, rowA, columnA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    for (int i = 0; i < rowA; i++) {       \r\n                     for (int j = 0; j < columnA; j++) {  \r\n                    printf(\"%d \", total[i][j]);\r\n                        }\r\n                        printf(\"\\n\");\r\n                     }\r\n                } else {\r\n                    printf(\"Invalid matrix dimensions\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n             TransposeMatricesA(A, transposeA, rowA, columnA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                for (int i = 0; i < rowA; i++) {\r\n                for (int j = 0; j < columnA; j++) {\r\n                 printf(\"%d \", total[i][j]);\r\n                }\r\n                printf(\"\\n\");\r\n              }\r\n                break;\r\n            case 4:\r\n             TransposeMatricesB(B, transposeB, rowB, columnB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                for (int i = 0; i < rowB; i++) {\r\n                for (int j = 0; j < columnB; j++) {\r\n                printf(\"%d \", total[i][j]);\r\n                }\r\n                printf(\"\\n\");\r\n              }\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice\\n\");\r\n        }\r\n    } \r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define Max_Name 100\r\n#define Max_Category 50\r\n#define Max_Items 100\r\n\r\n// Grocery Item struct\r\ntypedef struct {\r\n    char name[Max_Name];\r\n    char category[Max_Category];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n//  Availability status struct\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outStock;\r\n} AvailabilityStatus;\r\n\r\nGroceryItem inventory[Max_Items];\r\nAvailabilityStatus availability[Max_Items];\r\nint numItems = 0;\r\n\r\n// Function to add grocery item\r\nvoid addGroceryItem() {\r\n    if (numItems >= Max_Items) {\r\n        printf(\"Inventory is full\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.name, Max_Name, stdin);\r\n    \r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, Max_Category, stdin);\r\n    \r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    getchar(); \r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar(); \r\n\r\n    inventory[numItems] = newItem;\r\n    availability[numItems].inStock = newItem.quantity > 0;                //new item more than 0 mean in stock\r\n    availability[numItems].outStock = newItem.quantity == 0;              //new item equal to 0 mean out stock\r\n\r\n    numItems++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list grocery items\r\nvoid listGroceryItems() {\r\n    if (numItems == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < numItems; i++) {\r\n        printf(\"\\nName: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        if (availability[i].inStock) {\r\n            printf(\"Status: In Stock\\n\");\r\n        } else if (availability[i].outStock) {\r\n            printf(\"Status: Out of Stock\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update the quantity of grocery item\r\nvoid updateQuantity() {\r\n    char name[Max_Name];\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(name, Max_Name, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; \r\n\r\n    for (int i = 0; i < numItems; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter the new quantity for %s: \", inventory[i].name);\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            getchar(); \r\n\r\n            availability[i].inStock = inventory[i].quantity > 0;        //item in inventory more than 0 mean in stock\r\n            availability[i].outStock = inventory[i].quantity == 0;       //item in inventory equal to 0 mean out stock\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\n// Function to remove a grocery item \r\nvoid removeGroceryItem() {\r\n    char name[Max_Name];\r\n\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(name, Max_Name, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; \r\n\r\n    for (int i = 0; i < numItems; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            \r\n            for (int j = i; j < numItems - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n                availability[j] = availability[j + 1];\r\n            }\r\n            numItems--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    while (1) {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting system\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    //Validation for Student name\r\n     if ( strlen(name) == 0 || strlen(name) >= 100 ) {\r\n        printf(\" Invalid name\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Validation for ID \r\n    if (id <= 0) {\r\n        printf(\"Invalid ID\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Validation for grade \r\n    if (grade < 0 || grade > 100) {\r\n        printf(\" Invalid grade\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    Student* newStudent = malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n     Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student record by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list \r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n    next = current->next;\r\n    free(current);\r\n    current = next;\r\n   }\r\n    head = NULL;\r\n}\r\n    \r\n\r\n\r\n// Function to free all memory when the program exits\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    Student* temp1 = head;\r\n    Student* temp2 = NULL;\r\n\r\n    \r\n    while (temp1 != NULL) {\r\n        temp2 = temp1->next;\r\n        while (temp2 != NULL) {\r\n            // Compare the grade of temp1 with temp2\r\n            if (temp1->grade > temp2->grade) {  \r\n               \r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                // Swap the student data\r\n                strcpy(tempName, temp1->name);\r\n                tempID = temp1->id;\r\n                tempGrade = temp1->grade;\r\n\r\n                strcpy(temp1->name, temp2->name);\r\n                temp1->id = temp2->id;\r\n                temp1->grade = temp2->grade;\r\n\r\n                strcpy(temp2->name, tempName);\r\n                temp2->id = tempID;\r\n                temp2->grade = tempGrade;\r\n            }\r\n            temp2 = temp2->next;\r\n        }\r\n        temp1 = temp1->next;\r\n    }\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program \r\nint main() {\r\n int choice, id;\r\n char name[100];\r\n float grade;\r\n do {\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records (choose sorting method)\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar(); \r\n\r\n    switch (choice) {\r\n    case 1:\r\n        printf(\"Enter Name: \");\r\n        fgets(name, sizeof(name), stdin);\r\n        strtok(name, \"\\n\");\r\n        printf(\"Enter ID: \");\r\n        scanf(\"%d\", &id);\r\n        printf(\"Enter Grade: \");\r\n        scanf(\"%f\", &grade);\r\n        insertStudent(name, id, grade);\r\n        break;\r\n    case 2:\r\n        displayStudents();\r\n        break;\r\n    case 3:\r\n        sortStudents();\r\n        break;\r\n    case 4:\r\n        printf(\"Enter ID to search: \");\r\n        scanf(\"%d\", &id);\r\n        Student* found = searchStudentByID(id);\r\n        if (found) {\r\n        printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n        found->name, found->id, found->grade);\r\n    } else {\r\n    printf(\"Student not found.\\n\");\r\n    }\r\n    break;\r\n    case 5:\r\n        deleteList();\r\n        printf(\"List deleted.\\n\");\r\n        break;\r\n    case 6:\r\n        freeMemory();\r\n        printf(\"Exiting...\\n\");\r\n        break;\r\n    default:\r\n        printf(\"Invalid choice! Please try again.\\n\");\r\n    }\r\n    } while (choice != 6);\r\n    return 0;\r\n    } ",
    "feedback": "q1-In the input section for Matrix B, you should use rowB and columnB instead of rowA and columnA. For displaying the transposed matrices, you should use transposeA and transposeB instead of total\nq2-The AvailabilityStatus struct is used to track both inStock and outStock, but you only need one status indicator. You can simplify the logic to use a single boolean for availability (e.g., isInStock) or union. In the removeGroceryItem function, after shifting the items left upon removal, the last item in the array is not cleared or reset. This could lead to displaying stale data if the last item is accessed.\nq3-    The bubble sort implementation effectively sorts student records by grade. However, bubble sort has a time complexity of O(n?), which may not be efficient for larger datasets. Consider using more efficient algorithms, like Merge Sort or Quick Sort, especially for larger collections of student records."
  },
  {
    "student_id": "20580127",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 // define the maximum size for the matrices instead of typing 10 each time\r\n\r\n//declare all the functions that are below here\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX]; // matrices A B and result\r\n    int rowsA, colsA, rowsB, colsB; // dimensions of matrices A and B\r\n    int choice; // user menu choice\r\n\r\n    // input dimensions for Matrix A bt user has to input next to eachother\r\n    printf(\"Enter the number of rows and columns for Matrix A (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // input dimensions for Matrix B bt user has to input next to eachother\r\n    printf(\"Enter the number of rows and columns for Matrix B (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // check if the dimensions exceed the maximum allowed size\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX) {\r\n        printf(\"Matrix dimensions exceed the maximum allowed size of 10x10.\\n\");\r\n        return 1; // Exit the program if dimensions are invalid\r\n    }\r\n\r\n    // input elements for Matrix A\r\n    printf(\"Enter the elements of Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // input elements for Matrix B\r\n    printf(\"Enter the elements of Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    \r\n    do {\r\n        \r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //switch case to check which case (operation) user wants to do\r\n        switch (choice) {\r\n            case 1:\r\n                //check if dimensions match for addition\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrices dimensions do not match for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                //check if dimensions match for subtraction\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Matrices sizes dont match for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Transpose Matrix A\r\n                transposeMatrix(A, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                // Transpose Matrix B\r\n                transposeMatrix(B, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                //exit the program\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5); // loop until the user chooses to exit (choose option 5)\r\n\r\n    return 0;\r\n}\r\n\r\n//function to input elements of a matrix\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i, j);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//function to print a matrix\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//function to add two matrices\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//function to subtract one matrix from another\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n//ftruct to hold grocery item information\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n//struct to hold availability status\r\ntypedef struct {\r\n    int inStock;\r\n    int outOfStock;\r\n} AvailabilityStatus;\r\n\r\n//struct to hold the grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n//declare all the below functions here\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateGroceryItemQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .itemCount = 0 };\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); //takes away newline character so input buffer is cleared otherwise everything gets jumbled up\r\n\r\n        // Perform the selected operation using a switch case\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateGroceryItemQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item to the inventory\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->itemCount];\r\n    AvailabilityStatus *status = &inventory->status[inventory->itemCount];\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(item->name, MAX_NAME_LENGTH, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets(item->category, MAX_CATEGORY_LENGTH, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    getchar(); // Consume newline character  so input buffer is cleared \r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &item->price);\r\n    getchar(); // Consume newline character\r\n\r\n    // Set availability status based on quantity\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = item->quantity == 0;\r\n\r\n    inventory->itemCount++;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their availability\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        AvailabilityStatus *status = &inventory->status[i];\r\n\r\n        printf(\"Item Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateGroceryItemQuantity(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    int index;\r\n    printf(\"Enter the item number to update quantity: \");\r\n    scanf(\"%d\", &index);\r\n    getchar(); // Consume newline character\r\n\r\n    if (index < 1 || index > inventory->itemCount) {\r\n        printf(\"Invalid item number.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[index - 1];\r\n    AvailabilityStatus *status = &inventory->status[index - 1];\r\n\r\n    printf(\"Enter new quantity for %s: \", item->name);\r\n    scanf(\"%d\", &item->quantity);\r\n    getchar(); // Consume newline character\r\n\r\n    // Update availability status based on new quantity\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = item->quantity == 0;\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    int index;\r\n    printf(\"Enter the item number to remove: \");\r\n    scanf(\"%d\", &index);\r\n    getchar(); // Consume newline character so  input buffer is cleared \r\n\r\n    if (index < 1 || index > inventory->itemCount) {\r\n        printf(\"Invalid item number.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift items to fill the gap\r\n    for (int i = index - 1; i < inventory->itemCount - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->status[i] = inventory->status[i + 1];\r\n    }\r\n\r\n    inventory->itemCount--;\r\n    printf(\"Item removed successfully.\\n\");\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next;\r\n        }\r\n        current->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n//function to search for a student by thei ID number\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// A utility function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on Bubble Sort\r\n// Reason is beacause Bubble Sort is simple to implement and good enough for a small dataset like this.\r\nvoid sortStudents() {\r\n\r\n    int swapped;\r\n    Student *current, *prev = NULL;\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != prev) {\r\n            if (current->grade > current->next->grade) {\r\n                \r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n//swap grades and IDs and names\r\n                strcpy(tempName, current->name);\r\n                strcpy(current->name, current->next->name);\r\n                strcpy(current->next->name, tempName);\r\n                tempID = current->id;\r\n                current->id = current->next->id;\r\n                current->next->id = tempID;\r\n                tempGrade = current->grade;\r\n                current->grade = current->next->grade;\r\n                current->next->grade = tempGrade;\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        prev = current;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade in ascending order.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (by Grade)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        \r\n        \r\n//switch case depending on which option user chooses\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-Meet requirement."
  },
  {
    "student_id": "20718893",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n#define MAXIMUM_SIZE 100\r\n\r\nint validation(int row, int column) {\r\n    if(row > 0 && row <= 10 && column > 0 && column <=10) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid present(int *result, int row, int column){\r\n    for (int i = 0; i < row * column; i++) {\r\n        printf(\"%d \", result[i]);\r\n        if ((i + 1) % row == 0) {\r\n            printf(\"\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid Print_Menu(int a) {\r\n    printf(\"Matrix Operations Menu:\\n\");\r\n    if (a == 1) {\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n    }\r\n    else {\r\n        printf(\"1. Transpose Matrix A\\n\");\r\n        printf(\"2. Transpose Matrix B\\n\");\r\n        printf(\"3. Exit\\n\");\r\n    }\r\n}\r\n\r\nvoid add(int result[], int A[], int B[], int row, int column) {\r\n    for (int i = 0; i < row * column; i++) {\r\n        result[i] = A[i] + B[i];\r\n    }\r\n}\r\n\r\nvoid subtract(int result[], int A[], int B[], int row, int column) {\r\n    for (int i = 0; i < row *column; i++) {\r\n        result[i] = A[i] - B[i];\r\n    }\r\n}\r\n\r\nvoid Transpose(int *matrix, int row_matrix, int column_matrix) {\r\n    for (int i = 0; i < column_matrix; i++) {\r\n        for (int j = 0; j < row_matrix; j++) {\r\n            printf(\"%d \", matrix[j * column_matrix + i]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rowA, rowB, columnA, columnB, choice, ch;\r\n    int A[MAXIMUM_SIZE], B[MAXIMUM_SIZE], result[MAXIMUM_SIZE];\r\n    do {\r\n        printf(\"Enter dimensions for Matrix A(rows and columns): \");\r\n        scanf(\" %d %d\", &rowA, &columnA);\r\n        while((ch = getchar()) != '\\n' && ch != EOF){}\r\n    }\r\n    while (validation(rowA, columnA) == 0);\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rowA * columnA; i++) {\r\n        printf(\"Element[%d][%d]:\", ((i - (i % rowA)) / rowA) + 1, (i % rowA) + 1);\r\n        scanf(\" %d\", &A[i]);\r\n    }\r\n    do {\r\n        printf(\"Enter dimensions for Matrix B(rows and columns): \");\r\n        scanf(\"%d %d\", &rowB, &columnB);\r\n        while((ch = getchar()) != '\\n' && ch != EOF){}\r\n    }\r\n    while (validation(rowB, columnB) == 0);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < rowB * columnB; i++) {\r\n        printf(\"Element[%d][%d]:\", ((i - (i % rowB)) / rowB) + 1, (i % rowB) + 1);\r\n        scanf(\" %d\", &B[i]);\r\n    }\r\n    for (int i = 0; i < rowA * columnA; i++) {\r\n        printf(\"%d \", A[i]);\r\n        if ((i + 1) % rowA == 0) {\r\n            printf(\"\\n\");\r\n        }\r\n}\r\n    int same = 0;\r\n    if (rowA == rowB && columnA == columnB) {\r\n        same = 1;\r\n    }\r\n    if (same == 1) {\r\n        while (1) {\r\n            Print_Menu(same);\r\n            printf(\"Enter your choice:\");\r\n            scanf(\"%d\", &choice);\r\n            switch (choice)\r\n            {\r\n            case 1:\r\n                add(result, A, B, rowA, columnA);\r\n                present(result, rowA, columnA);\r\n                break;\r\n            case 2:\r\n                subtract(result, A, B, rowA, columnA);\r\n                present(result, rowA, columnA);\r\n                break;\r\n            case 3:\r\n                Transpose(A, rowA, columnA);\r\n                break;\r\n            case 4:\r\n                Transpose(B, rowB, columnB);\r\n                break;\r\n            case 5:\r\n                return 0;\r\n            default:\r\n                break;\r\n            }\r\n\r\n        }\r\n    } else {\r\n        while (1) {\r\n            Print_Menu(same);\r\n            printf(\"Enter your choice:\");\r\n            scanf(\"%d\", &choice);\r\n            switch (choice)\r\n            {\r\n            case 1:\r\n                Transpose(A, rowA, columnA);\r\n                break;\r\n            case 2:\r\n                Transpose(B, rowB, columnB);\r\n                break;\r\n            case 3:\r\n                return 0;\r\n            default:\r\n                break;\r\n            \r\n            }\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char Name[MAX_NAME_LENGTH];\r\n    char Category[MAX_CATEGORY_LENGTH];\r\n    int Quantity;\r\n    float Price;\r\n} Groceryitem;\r\n\r\ntypedef struct {\r\n    int stock;\r\n} stock;\r\n\r\ntypedef struct {\r\n    Groceryitem item[MAX_ITEMS];\r\n    stock availablility[MAX_ITEMS];\r\n    int Counter;\r\n} Groceryinventory;\r\n//Functio to add grocery item\r\nvoid Add_Grocery_item(Groceryinventory *inventory){\r\n    Groceryitem new_item;\r\n    printf(\"Enter Item Name: \");\r\n    fgets(new_item.Name, sizeof(new_item.Name), stdin);\r\n    new_item.Name[strcspn(new_item.Name, \"\\n\")] = '\\0';\r\n    \r\n    printf(\"Enter Category: \");\r\n    fgets(new_item.Category,sizeof(new_item.Category), stdin);\r\n    new_item.Category[strcspn(new_item.Category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &new_item.Quantity);\r\n    getchar();\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &new_item.Price);\r\n    getchar();\r\n\r\n    inventory->item[inventory->Counter] = new_item;\r\n    inventory->availablility[inventory->Counter].stock = (new_item.Quantity > 0 ) ? 1 : 0;\r\n    inventory->Counter++;\r\n\r\n    printf(\"Grocery Item added successfully!\\n\");\r\n}\r\n//Function to list all grocery items with their availability \r\nvoid List_Grocery_item(const Groceryinventory *inventory) {\r\n    if (inventory->Counter == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    for(int i = 0; i < inventory->Counter; i++) {\r\n        printf(\"Name: %s\\n\", inventory->item[i].Name);\r\n        printf(\"Category: %s\\n\", inventory->item[i].Category);\r\n        printf(\"Quantity: %d\\n\", inventory->item[i].Quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->item[i].Price);\r\n        printf(\"Status: %s\\n\", inventory->availablility[i].stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n//Function to update the quantity of a frocery item\r\nvoid Update_Quantity(Groceryinventory *inventory) {\r\n    if (inventory->Counter == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    char item_Name[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the frocery item to update quantity: \");\r\n    fgets(item_Name, sizeof(item_Name), stdin);\r\n    item_Name[strcspn(item_Name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i <= inventory->Counter; i++) {\r\n        if (strcmp(inventory->item[i].Name, item_Name) == 0) {  //Search the grocery item from the inventory\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory->item[i].Quantity);\r\n            getchar();\r\n\r\n            inventory->availablility[i].stock = (inventory->item[i].Quantity > 0) ? 1 : 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n//Function to remove a grocery item from the inventory\r\nvoid Remove_Grocery_item(Groceryinventory *inventory) {\r\n    if (inventory->Counter == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    char item_Name[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(item_Name, sizeof(item_Name), stdin);\r\n    item_Name[strcspn(item_Name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->Counter; i++) {\r\n        if (strcmp(inventory->item[i].Name, item_Name) == 0) {  //Search the grocery item from the inventory\r\n            for(int j = i; j < inventory->Counter - 1; j++) {\r\n                inventory->item[j] = inventory->item[j + 1];\r\n                inventory->availablility[j] = inventory->availablility[j + 1];\r\n            }\r\n            inventory->Counter--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", item_Name);\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main(){\r\n    Groceryinventory inventory = { .Counter = 0};\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            Add_Grocery_item(&inventory);\r\n            break;\r\n        case 2:\r\n            List_Grocery_item(&inventory);\r\n            break;\r\n        case 3 :\r\n            Update_Quantity(&inventory);\r\n            break;\r\n        case 4 :\r\n            Remove_Grocery_item(&inventory);\r\n            break;\r\n        default:\r\n            break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h> \r\n#include <string.h> \r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student; \r\n \r\nStudent* head = NULL; \r\n \r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n// Write your code (1 mark) \r\n    Student* NewStudent = (Student*)malloc(sizeof(Student));\r\n    if (NewStudent == NULL) {\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    strcpy(NewStudent->name,name);\r\n    NewStudent->id = id; \r\n    NewStudent->grade = grade;\r\n    NewStudent->next = NULL;\r\n    return NewStudent;\r\n} \r\n \r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n// Write your code (1 mark)\r\n    Student* node = createStudent(name, id, grade);\r\n    if(head == NULL) {\r\n        head = node;\r\n    } else {\r\n        Student* temp =head;\r\n        while (temp->next = NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = node;\r\n    }\r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n   // Write your code (1 mark)\r\n   if (head ==NULL) {\r\n    printf(\"Empty student records.\");\r\n    return;\r\n   }\r\n   Student* temp = head;\r\n   printf(\"Student Records:\\n\");\r\n   while(temp != NULL) {\r\n    printf(\"Name: %s, ID: %d, Grade: %.2f\", temp->name, temp->id, temp->grade);\r\n    temp = temp->next;\r\n   }\r\n} \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n   // Write your code (1 mark)\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id){\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n} \r\n \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n    head = NULL; \r\n} \r\n\r\n \r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n// Sort function to sort the student records by grade based on an algorithm of your choice \r\nvoid sortStudents() { \r\n// Write your code (1 mark) \r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"No records to sort.\");\r\n        return;\r\n    }\r\n    int swap;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n    //bubble sort\r\n    do {\r\n        swap = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade < ptr1->next->grade) {\r\n                char temp_name[100];\r\n                int temp_ID;\r\n                float temp_Grade;\r\n\r\n                strcpy(temp_name, ptr1->name);\r\n                temp_ID = ptr1->id;\r\n                temp_Grade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, temp_name);\r\n                ptr1->next->id = temp_ID;\r\n                ptr1->next->grade = temp_Grade;\r\n\r\n                swap = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swap == 1);\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n} \r\n \r\n// Main function to drive the program \r\nint main() { \r\n \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n     sortStudents();                 \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\nfound->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n}",
    "feedback": "q1-Meet requirement\nq2-In the Update_Quantity function, the loop condition should be i < inventory->Counter instead of i <= inventory->Counter to avoid accessing out-of-bounds memory.\nq3-The sorting mechanism in the sortStudents function uses a bubble sort that sorts in descending order. If ascending order is required, the comparison operator should be reversed."
  },
  {
    "student_id": "20618336",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h> // Include standard input/output header file\r\n#define MAX 10 // Define the maximum size for matrices\r\n\r\n// Function declarations\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols, char name); // Function to take input for a matrix\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int rows, int cols); // Function to add two matrices\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int rows, int cols); // Function to subtract one matrix from another\r\nvoid transposeMatrix(int matrix[MAX][MAX], int rows, int cols, char name); // Function to transpose a matrix\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX]; // Declare matrices A and B\r\n    int rowsA, colsA, rowsB, colsB; // Variables to store dimensions of matrices\r\n    int choice; // Variable to store user's menu choice\r\n\r\n    \r\n    printf(\"Enter the number of rows and columns for Matrix A: \"); // Gather dimensions and elements for Matrix A\r\n    scanf(\"%d %d\", &rowsA, &colsA); // Input dimensions for Matrix A\r\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0) { // Validate dimensions\r\n        printf(\"Error: Dimensions must be between 1 and %d.\\n\", MAX);\r\n\r\n\r\n        return 1;\r\n    }\r\n    inputMatrix(A, rowsA, colsA, 'A'); // Input elements for Matrix A\r\n\r\n    \r\n    printf(\"Enter the number of rows and columns for Matrix B: \"); // Gather dimensions and elements for Matrix B\r\n    scanf(\"%d %d\", &rowsB, &colsB); // Input dimensions for Matrix B\r\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) { // Validate dimensions\r\n        printf(\"Error: Dimensions must be between 1 and %d.\\n\", MAX);\r\n        return 1;\r\n    }\r\n    inputMatrix(B, rowsB, colsB, 'B'); // Input elements for Matrix B\r\n\r\n\r\n\r\n    // Display menu for matrix operations\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Choose an option: \");\r\n        scanf(\"%d\", &choice); // Input user's menu choice\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) { // Check if dimensions match for addition\r\n                    addMatrices(A, B, rowsA, colsA); // Perform addition\r\n                } else {\r\n                    printf(\"Addition not possible: Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) { // Check if dimensions match for subtraction\r\n                    subtractMatrices(A, B, rowsA, colsA); // Perform subtraction\r\n                } else {\r\n                    printf(\"Subtraction not possible: Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(A, rowsA, colsA, 'A'); // Transpose Matrix A\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(B, rowsB, colsB, 'B'); // Transpose Matrix B\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting program. Goodbye!\\n\"); // Exit the program\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid option. Please select a valid choice.\\n\"); // Handle invalid input\r\n        }\r\n    } while (choice != 5); // Repeat until user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input elements for a matrix\r\n\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols, char name) {\r\n    printf(\"Enter the elements for Matrix %c:\\n\", name); // Prompt user for elements\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1); // Indicate position of element\r\n            scanf(\"%d\", &matrix[i][j]); // Input element value\r\n        }\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\n\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int rows, int cols) {\r\n    printf(\"Result of Matrix A + Matrix B:\\n\"); // Indicate addition result\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", A[i][j] + B[i][j]); // Compute and print sum of elements\r\n        }\r\n        printf(\"\\n\"); // Newline after each row\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\n\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int rows, int cols) {\r\n    printf(\"Result of Matrix A - Matrix B:\\n\"); // Indicate subtraction result\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", A[i][j] - B[i][j]); // Compute and print difference of elements\r\n        }\r\n        printf(\"\\n\"); // Newline after each row\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\n\r\nvoid transposeMatrix(int matrix[MAX][MAX], int rows, int cols, char name) {\r\n    printf(\"Transpose of Matrix %c:\\n\", name); // Indicate transposition result\r\n    for (int i = 0; i < cols; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            printf(\"%d \", matrix[j][i]); // Print transposed element\r\n        }\r\n        printf(\"\\n\"); // Newline after each row\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Struct for Grocery Item\r\ntypedef struct {\r\n    char name[100]; // Name of the grocery item\r\n    char category[50]; // Category of the grocery item\r\n    int quantity; // Quantity available\r\n    float price; // Price per item\r\n} GroceryItem;\r\n\r\n// Array for Grocery Items\r\nGroceryItem inventory[MAX_ITEMS];\r\nint total_items = 0; // Total number of items in the inventory\r\n\r\n// Function prototypes\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem() {\r\n    if (total_items >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item.name, 100, stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, 50, stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n    getchar(); // Consume newline character\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n    getchar(); // Consume newline character\r\n\r\n    inventory[total_items++] = item;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems() {\r\n    if (total_items == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < total_items; i++) {\r\n        printf(\"\\nName: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    for (int i = 0; i < total_items; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            getchar(); // Consume newline character\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    for (int i = 0; i < total_items; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            for (int j = i; j < total_items - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            total_items--;\r\n            printf(\"Grocery item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define the structure for a student record\r\ntypedef struct Student {\r\n    char name[100]; // Store the student's name\r\n    int id;         // Store the student's ID\r\n    float grade;    // Store the student's grade\r\n    struct Student* next; // Pointer to the next student in the linked list\r\n} Student;\r\n\r\nStudent* head = NULL; // Initialize the head of the linked list to NULL\r\n\r\n// Function to create a new student\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\r\n    if (newStudent == NULL) {\r\n        printf(\"Error: Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name); // Copy the name\r\n    newStudent->id = id;           // Assign the ID\r\n    newStudent->grade = grade;     // Assign the grade\r\n    newStudent->next = NULL;       // Set the next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to add a student to the linked list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head; // Add the new student at the beginning\r\n    head = newStudent;\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to sort students by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student *ptr1, *lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data between nodes\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempID = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempID;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade successfully.\\n\");\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current; // Return the student if found\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // Return NULL if not found\r\n}\r\n\r\n// Function to delete all student records\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp); // Free memory of the current student\r\n    }\r\n    head = NULL; // Reset the head to NULL\r\n    printf(\"All records deleted successfully.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found != NULL) {\r\n                    printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"No student found with ID %d.\\n\", id);\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While Bubble Sort is easy to understand and implement, it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20716304",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// Define row and column and Matrix A and B globally\r\nint **matrix_A;\r\nint row_A, col_A;\r\nint **matrix_B;\r\nint row_B, col_B;\r\n\r\n// Function to create matrix with given row and column\r\nint **create_matrix(int row, int col) {\r\n    // Create an array first\r\n    int **matrix = malloc(sizeof(int*) * row);\r\n    if (matrix == NULL) {\r\n        printf(\"Memory allocation failed\\n\");\r\n        return NULL;\r\n    }\r\n    \r\n    // Allocate n columns for each row\r\n    for (int i = 0; i < row; i++) {\r\n        matrix[i] = malloc(sizeof(int) * col);\r\n        if (matrix[i] == NULL) {\r\n            printf(\"Memory allocation failed\\n\");\r\n            for (int j = 0; j < i; j++) {\r\n                free(matrix[j]);\r\n            }\r\n            free(matrix);\r\n            return NULL;\r\n        }\r\n    }\r\n    return matrix;\r\n}\r\n\r\n// Function to delete all elements and the matrix\r\nvoid delete_matrix(int **matrix, unsigned int row) {\r\n    for (int i = 0; i < row; i++) {\r\n        free(matrix[i]);\r\n    }\r\n    free(matrix);\r\n}\r\n\r\n// Function to define matrix\r\nvoid get_matrix_info() {\r\n    // User input for matrix A\r\n    while (1) {\r\n        // Dimension for matrix A\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        if (scanf(\"%d %d\", &row_A, &col_A) != 2 || row_A <= 0 || row_A > 10 || col_A <= 0 || col_A > 10) {\r\n            printf(\"Invalid input (Maximum size: 10x10)\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Create matrix A\r\n    matrix_A = create_matrix(row_A, col_A);\r\n\r\n    // Elements for matrix A\r\n    printf(\"Enter elements for Matrix A: \\n\");\r\n    for (int i = 0; i < row_A; i++) {\r\n        for (int j = 0; j < col_A; j++) {\r\n            while (1) {\r\n                printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n                if (scanf(\"%d\", &matrix_A[i][j]) != 1) {\r\n                    printf(\"Invalid input. Enter again\\n\");\r\n                    while (getchar() != '\\n'); // Clear input buffer\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // User input for matrix B\r\n    while (1) {\r\n        // Dimension for matrix B\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        if (scanf(\"%d %d\", &row_B, &col_B) != 2 || row_B <= 0 || row_B > 10 || col_B <= 0 || col_B > 10) {\r\n            printf(\"Invalid input (Maximum size: 10x10)\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            continue;\r\n        } else if (row_B != row_A || col_B != col_A) {      // Caution for different dimension with matrix A\r\n            printf(\"\\033[33mCaution! - The row or column of Matrix A and B are different!\\033[0m\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n        }\r\n        break;\r\n    }\r\n    \r\n    // Create matrix B\r\n    matrix_B = create_matrix(row_B, col_B);\r\n\r\n    // Elements for matrix B\r\n    printf(\"Enter elements for Matrix B: \\n\");\r\n    for (int i = 0; i < row_B; i++) {\r\n        for (int j = 0; j < col_B; j++) {\r\n            while (1) {\r\n                printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n                if (scanf(\"%d\", &matrix_B[i][j]) != 1) {\r\n                    printf(\"Invalid input. Enter again\\n\");\r\n                    while (getchar() != '\\n'); // Clear input buffer\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            \r\n        }\r\n    }\r\n}\r\n\r\n// Function to display menu and get choice\r\nint menu_get_choice() {\r\n    int choice;\r\n    while (1) {\r\n        printf(\"\\nMatrix Operations Menu: \\n\");\r\n        printf(\"1. Add Matrices\\n2. Subtract Matrices\\n3.Transpose Matrix A\\n4.Transpose Matrix B\\n5.Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1 || choice < 1 || choice > 5) {\r\n            printf(\"Invalid input. Enter again\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return choice;\r\n}\r\n\r\n// Function to perform addition\r\nvoid add_matrices(int **matrix_A, int row_A, int col_A, int **matrix_B, int row_B, int col_B) {\r\n    // Check for dimensions\r\n    if (row_A != row_B || col_A != col_B) {\r\n        printf(\"Cannot add two matrices that have different dimension!\\n\");\r\n        return;\r\n    }\r\n    // Define result matrix\r\n    int **result = create_matrix(row_A, col_A);\r\n    printf(\"Result of Matrix A + Matrix B: \\n\");\r\n    // Add each elements\r\n    for (int i = 0; i < row_A; i++) {\r\n        for (int j = 0; j < col_B; j++) {\r\n            result[i][j] = matrix_A[i][j] + matrix_B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        puts(\"\");\r\n    }\r\n    // Free the result matrix\r\n    delete_matrix(result, row_A);\r\n}\r\n\r\n// Function to perform subtraction\r\nvoid sub_matrices(int **matrix_A, int row_A, int col_A, int **matrix_B, int row_B, int col_B) {\r\n    // Check for dimensions\r\n    if (row_A != row_B || col_A != col_B) {\r\n        printf(\"Cannot subtract two matrices that have different dimension!\\n\");\r\n        return;\r\n    }\r\n    // Define result matrix\r\n    int **result = create_matrix(row_A, col_A);\r\n    printf(\"Result of Matrix A - Matrix B: \\n\");\r\n    // Subtract each elements\r\n    for (int i = 0; i < row_A; i++) {\r\n        for (int j = 0; j < col_B; j++) {\r\n            result[i][j] = matrix_A[i][j] - matrix_B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        puts(\"\");\r\n    }\r\n    // Free the result matrix\r\n    delete_matrix(result, row_A);\r\n}\r\n\r\n// Function to perform transpose\r\nvoid transpose(int **matrix, int row, int col, char name) {\r\n    // Define result matrix\r\n    int **result = create_matrix(col, row);     // Swap dimensions \r\n    if (result == NULL) { \r\n        printf(\"Memory allocation failed\\n\");\r\n    } \r\n    printf(\"Transpose of Matrix %c:\\n\", name);\r\n    for (int i = 0; i < row; i++) { \r\n        for (int j = 0; j < col; j++) { \r\n            result[j][i] = matrix[i][j]; // Swap row and column indices (can just printf the elements)\r\n        }\r\n    }\r\n    // Printing the result\r\n    for (int i = 0; i < col; i++) {\r\n        for (int j = 0; j < row; j++) {\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        puts(\"\");\r\n    }\r\n    // Free the result matrix\r\n    delete_matrix(result, col);\r\n}\r\n\r\n\r\nint main(void) {\r\n    get_matrix_info();\r\n    int choice;\r\n    while (1) {\r\n        choice = menu_get_choice();\r\n        switch (choice) {\r\n            case 1:\r\n                add_matrices(matrix_A, row_A, col_A, matrix_B, row_B, col_B);\r\n                break;\r\n            case 2 :\r\n                sub_matrices(matrix_A, row_A, col_A, matrix_B, row_B, col_B);\r\n                break;\r\n            case 3 :\r\n                transpose(matrix_A, row_A, col_A, 'A');\r\n                break;\r\n            case 4 :\r\n                transpose(matrix_B, row_B, col_B, 'B');\r\n                break;\r\n            case 5 :\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid input. Enter again.\\n\");\r\n        }\r\n        if (choice == 5) {\r\n            // Free both matrix A and B\r\n            delete_matrix(matrix_A, row_A);\r\n            delete_matrix(matrix_B, row_B);\r\n            break;  // Exit the loop\r\n        }\r\n    }\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Define all the maximum length\r\n#define MAX_NAME 101\r\n#define MAX_CATEGORY 51\r\n#define MAX_ITEMS 100\r\n\r\n// Define three struct for store data\r\ntypedef struct {\r\n    char name[MAX_NAME];\r\n    char category[MAX_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n} Grocery_Item;\r\n\r\ntypedef struct{\r\n    int in_stock;   // 1 = in stock, 0 = out of stock\r\n} Availability_Status;\r\n\r\ntypedef struct {\r\n    Grocery_Item items[MAX_ITEMS];\r\n    Availability_Status status[MAX_ITEMS];\r\n    int total_item;\r\n} Grocery_Inventory;\r\n\r\n// Function to display the menu and get option\r\nint menu() {\r\n    int option;\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    while (1) {\r\n        printf(\"1. Add Grocery Item\\n2. List All Grocery Items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if(scanf(\"%d\", &option) != 1 || option <= 0 || option > 5) {\r\n            printf(\"Invalid input. Enter again\\n\\n\");\r\n            while (getchar() != '\\n');\r\n        } else {\r\n            while (getchar() != '\\n');\r\n            break;\r\n        }\r\n    }  \r\n    return option;\r\n}\r\n\r\n// Function to add an item to the inventory\r\nvoid add_items(Grocery_Inventory* inventory) {\r\n    // If there are 100 items(max)\r\n    if (inventory->total_item >= MAX_ITEMS) {\r\n        printf(\"Inventory is full\\n\");\r\n        return;\r\n    } else {\r\n        Grocery_Item new_item;\r\n        // Get user input\r\n        printf(\"Enter Item Name: \");\r\n        fgets(new_item.name, MAX_NAME, stdin);\r\n        new_item.name[strcspn(new_item.name, \"\\n\")] = 0;    // Delete \\n\r\n\r\n        printf(\"Enter Category: \");\r\n        fgets(new_item.category, MAX_CATEGORY, stdin);\r\n        new_item.category[strcspn(new_item.category, \"\\n\")] = 0;\r\n\r\n        printf(\"Enter Quantity: \");\r\n        while (1) {\r\n            if (scanf(\"%d\", &new_item.quantity) != 1 || new_item.quantity < 0) {\r\n                printf(\"Invalid quantity. Enter again: \");\r\n                while (getchar() != '\\n');  // Clear buffer\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        printf(\"Enter Price: \");\r\n        while (1) {\r\n            if (scanf(\"%f\", &new_item.price) != 1 || new_item.price < 0.0) {\r\n                printf(\"Invalid price. Enter again: \");\r\n                while (getchar() != '\\n');  // Clear buffer\r\n            } else {\r\n                break;\r\n            }\r\n        }     \r\n\r\n        while (getchar() != '\\n'); // Clear the input buffer\r\n        // Update inventory with the input item\r\n        inventory->items[inventory->total_item] = new_item; \r\n        inventory->status[inventory->total_item].in_stock = (new_item.quantity > 0) ? 1 : 0; \r\n        inventory->total_item++;\r\n        printf(\"Grocery item added successfully!\\n\");\r\n    }\r\n    \r\n}\r\n\r\n// Function to display all the items\r\nvoid list_items(Grocery_Inventory* inventory) {\r\n    // If there is no items\r\n    if (inventory->total_item == 0) {\r\n        printf(\"There is no items.\\n\");\r\n        return;\r\n    }\r\n    // For loop to display all the items\r\n    for (int i = 0; i < inventory->total_item; i++) {\r\n        printf(\"\\nName: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: %s\", \r\n        inventory->items[i].name, \r\n        inventory->items[i].category,\r\n        inventory->items[i].quantity,\r\n        inventory->items[i].price,\r\n        inventory->status[i].in_stock ? \"In Stock\" : \"Out of Stock\");\r\n        puts(\"\");\r\n    }\r\n}\r\n\r\n// Function to update the item quantity\r\nvoid update_quantity(Grocery_Inventory* inventory) {\r\n    // If there is no items\r\n    if (inventory->total_item == 0) {\r\n        printf(\"There is no items\\n\");\r\n        return;\r\n    }\r\n    char finding[MAX_NAME];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(finding, MAX_NAME, stdin);\r\n    finding[strcspn(finding, \"\\n\")] = 0;\r\n    // Find the matching item in the inventory\r\n    for (int i = 0; i < inventory->total_item; i++) {\r\n        // If there is matching item\r\n        if (strcmp(inventory->items[i].name, finding) == 0) {\r\n            printf(\"Enter new quantitiy for %s: \", finding);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            inventory->status[i].in_stock = (inventory->items[i].quantity > 0) ? 1 : 0; // Indicates \"in stock\" or \"out of stock\"\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            while (getchar() != '\\n');\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\n// Function to remove item from the inventory\r\nvoid remove_item(Grocery_Inventory* inventory) {\r\n    // If there is no items\r\n    if (inventory->total_item == 0) {\r\n        printf(\"There is no items\\n\");\r\n        return;\r\n    }\r\n    // Get user input\r\n    char finding[MAX_NAME];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(finding, MAX_NAME, stdin);\r\n    finding[strcspn(finding, \"\\n\")] = 0;\r\n    // Search for the matching item in the inventory\r\n    for (int i = 0; i < inventory->total_item; i++) {\r\n        // Search for the matching item\r\n        if (strcmp(inventory->items[i].name, finding) == 0) {\r\n            // Shift every items to the front to delete\r\n            for (int j = i; j < inventory->total_item - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            // Update the total number of items\r\n            inventory->total_item--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", finding);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\nint main() {\r\n    Grocery_Inventory inventory = { .total_item = 0 };  // Initialise the total number to 0\r\n    int choice;\r\n    while (1) {\r\n        choice = menu();\r\n        switch (choice){\r\n            case 1:\r\n                add_items(&inventory);\r\n                break;\r\n            case 2:\r\n                list_items(&inventory);\r\n                break;\r\n            case 3:\r\n                update_quantity(&inventory);\r\n                break;\r\n            case 4:\r\n                remove_item(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid input. Enter again\\n\");\r\n                break;\r\n        }\r\n    }\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX_NAME 101\r\n\r\n// Define Linked List\r\ntypedef struct Student{\r\n    char name[MAX_NAME];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;   // Pointer to the next student node\r\n} Student;\r\n\r\n// Head of the linked list\r\nStudent* head = NULL;\r\n\r\n\r\n// Function to create new student struct\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Create student node\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed\\n\");\r\n        return NULL;\r\n    }\r\n    // Copy all the infomation to the new student node\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert new student infomation\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) {\r\n        return;\r\n    }\r\n    // Put the newStudent to the first node (head)\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all the student infomation\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"There is no student records.\\n\");\r\n        return;\r\n    }\r\n    // Get current node (Initialise with the first node)\r\n    Student* current = head;\r\n    // Until current node reaches the last node(NULL)\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search student by using id\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    // Until current node reaches the last node(NULL)\r\n    while (current != NULL) { \r\n        if (current->id == id) { \r\n            printf(\"Matching ID found\\n\");  \r\n            return current; \r\n        } \r\n        // If not match with the current node id then update the current node with the next node\r\n        current = current->next; \r\n    }\r\n    printf(\"The provided ID was not found in the student records.\\n\");\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    // Until current node reaches the last node(NULL)\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        // Shift all node to one front\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to perform bubble sort about student grades\r\nvoid sortStudents() {\r\n    if (head == NULL) {\r\n        return;\r\n    }\r\n    // flag which indicates that the two current and the next node are sorted -> go to sort the next node\r\n    int pass;\r\n    Student* current = head;\r\n    Student* last = NULL;   // pointer to the last\r\n    \r\n    do {\r\n        pass = 0;\r\n        current = head;\r\n        // Until current node reaches the last node(NULL)\r\n        while (current->next != last) {\r\n            if (current->grade > current->next->grade) {\r\n                // Define temporary variables to hold information\r\n                char tmp_name[MAX_NAME];\r\n                strcpy(tmp_name, current->name);\r\n                int tmp_id = current->id;\r\n                int tmp_grade = current->grade;\r\n                // Swipe the current with the next node\r\n                strcpy(current->name, current->next->name);\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade;\r\n                // Swipe the next node with the current\r\n                strcpy(current->next->name, tmp_name);\r\n                current->next->id = tmp_id;\r\n                current->next->grade = tmp_grade;\r\n\r\n                pass = 1;\r\n            }\r\n            // Go to the next node\r\n            current = current->next;\r\n        }\r\n        last = current; // update the last to the last sorted element\r\n    } while (pass);\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (Bubble Sort)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        while (1) {\r\n            printf(\"Enter your choice: \");\r\n            if (scanf(\"%d\", &choice) != 1 || choice < 1 || choice > 6) {\r\n                printf(\"Invalid input. Enter again.\\n\");\r\n                while (getchar() != '\\n'); // To consume the newline character\r\n                continue;\r\n            }\r\n            getchar(); // To consume the newline character\r\n            break;\r\n        }\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                while (1) {\r\n                    printf(\"Enter ID: \");\r\n                    if (scanf(\"%d\", &id) != 1 || id < 0) {\r\n                        printf(\"Invalid ID. Enter again.\\n\");\r\n                        while (getchar() != '\\n');\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                \r\n                while (1) {\r\n                    printf(\"Enter Grade: \");\r\n                    if (scanf(\"%f\", &grade) != 1 || grade < 0) {\r\n                        printf(\"Invalid Grade. Enter again.\\n\");\r\n                        while (getchar() != '\\n');\r\n                        continue;\r\n                    }\r\n                    break;\r\n                }\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                    found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n            }\r\n        } while (choice != 6);\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation correctly sorts student records by grade. While bubble sort is easy to implement, its time complexity of O(n?) can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20612258",
    "code": "\n/* --- L3 Q1.c --- */\n/******************************************************************************\r\n\r\nWelcome to GDB Online.\r\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\r\nC#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\r\nCode, Compile, Run and Debug online from anywhere in world.\r\n\r\n*******************************************************************************/\r\n#include <stdio.h>\r\n\r\n#define MAX_DIM 10 // Maximum dimension for matrices\r\n\r\n// Function prototypes\r\nvoid getMatrixInput(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]);\r\nvoid matrixAddition(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]);\r\nvoid matrixSubtraction(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]);\r\nvoid matrixTranspose(int rows, int cols, int matrix[MAX_DIM][MAX_DIM], int transposed[MAX_DIM][MAX_DIM]);\r\n\r\nint main() {\r\n    int rows1, cols1, rows2, cols2;\r\n    int mat1[MAX_DIM][MAX_DIM], mat2[MAX_DIM][MAX_DIM];\r\n    int result[MAX_DIM][MAX_DIM];\r\n    int option;\r\n\r\n    // Input Matrix A dimensions and elements\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rows1, &cols1);\r\n    if (rows1 <= 0 || rows1 > MAX_DIM || cols1 <= 0 || cols1 > MAX_DIM) {\r\n        printf(\"Error: Invalid dimensions for Matrix A.\\n\");\r\n        return 1;\r\n    }\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    getMatrixInput(rows1, cols1, mat1);\r\n\r\n    // Input Matrix B dimensions and elements\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rows2, &cols2);\r\n    if (rows2 <= 0 || rows2 > MAX_DIM || cols2 <= 0 || cols2 > MAX_DIM) {\r\n        printf(\"Error: Invalid dimensions for Matrix B.\\n\");\r\n        return 1;\r\n    }\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    getMatrixInput(rows2, cols2, mat2);\r\n\r\n    do {\r\n        // Display menu for operations\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n\r\n        switch (option) {\r\n            case 1:\r\n                if (rows1 == rows2 && cols1 == cols2) {\r\n                    matrixAddition(rows1, cols1, mat1, mat2, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(rows1, cols1, result);\r\n                } else {\r\n                    printf(\"Error: Matrices have incompatible dimensions for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rows1 == rows2 && cols1 == cols2) {\r\n                    matrixSubtraction(rows1, cols1, mat1, mat2, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(rows1, cols1, result);\r\n                } else {\r\n                    printf(\"Error: Matrices have incompatible dimensions for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                matrixTranspose(rows1, cols1, mat1, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(cols1, rows1, result);\r\n                break;\r\n            case 4:\r\n                matrixTranspose(rows2, cols2, mat2, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(cols2, rows2, result);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid option. Please choose again.\\n\");\r\n        }\r\n    } while (option != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to take matrix input\r\nvoid getMatrixInput(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print matrix\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function for matrix addition\r\nvoid matrixAddition(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = mat1[i][j] + mat2[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function for matrix subtraction\r\nvoid matrixSubtraction(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = mat1[i][j] - mat2[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid matrixTranspose(int rows, int cols, int matrix[MAX_DIM][MAX_DIM], int transposed[MAX_DIM][MAX_DIM]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- L3Q2.c --- */\n/******************************************************************************\r\n\r\nWelcome to GDB Online.\r\nGDB online is an online compiler and debugger tool for C, C++, Python, Java, PHP, Ruby, Perl,\r\nC#, OCaml, VB, Swift, Pascal, Fortran, Haskell, Objective-C, Assembly, HTML, CSS, JS, SQLite, Prolog.\r\nCode, Compile, Run and Debug online from anywhere in world.\r\n\r\n*******************************************************************************/\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Structure for Grocery Item\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];\r\n    char category[MAX_CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n    bool inStock; // Availability status\r\n} GroceryItem;\r\n\r\n// Global Variables\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n// Function Prototypes\r\nvoid addItem();\r\nvoid listItems();\r\nvoid updateItemQuantity();\r\nvoid removeItem();\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    int option;\r\n\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n        getchar(); // Clear newline character from input buffer\r\n\r\n        switch (option) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateItemQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program. Goodbye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid option! Please try again.\\n\");\r\n        }\r\n    } while (option != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to display menu\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n    printf(\"Enter Item Name: \");\r\n    fgets(newItem.name, MAX_NAME_LEN, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0; // Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LEN, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0; // Remove newline\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar(); // Clear newline character\r\n\r\n    newItem.inStock = newItem.quantity > 0;\r\n    inventory[itemCount++] = newItem;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an item\r\nvoid updateItemQuantity() {\r\n    char itemName[MAX_NAME_LEN];\r\n    int newQuantity;\r\n\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(itemName, MAX_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity for \\\"%s\\\": \", inventory[i].name);\r\n            scanf(\"%d\", &newQuantity);\r\n            getchar(); // Clear newline character\r\n\r\n            inventory[i].quantity = newQuantity;\r\n            inventory[i].inStock = newQuantity > 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeItem() {\r\n    char itemName[MAX_NAME_LEN];\r\n\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(itemName, MAX_NAME_LEN, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, itemName) == 0) {\r\n            // Shift items to fill the gap\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\" Grocery item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\r\n\n/* --- L3Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    while (temp) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\nvoid freeMemory() {\r\n deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return; // No need to sort if the list has 0 or 1 element\r\n    }\r\n    int swapped;\r\n    Student *ptr1, *ptr2 = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != ptr2) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                int tempID = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempID;\r\n\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        ptr2 = ptr1;\r\n    } while (swapped);\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to sort the student records by grade. While this algorithm is straightforward, it has a time complexity of O(n?), making it inefficient for larger datasets. For improved performance, consider implementing a more efficient sorting algorithm like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20718385",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX 10\r\n\r\n// Function to add matrices\r\nvoid addition(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int columns){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < columns; j++){\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtraction(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int columns){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < columns; j++){\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose Matrix A\r\nvoid transposeA(int matrixA[MAX][MAX], int result[MAX][MAX], int rows, int columns){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < columns; j++){\r\n            result[j][i] = matrixA[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose Matrix B\r\nvoid transposeB(int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int columns){\r\n    for(int i = 0; i < rows; i++){\r\n        for(int j = 0; j < columns; j++){\r\n            result[j][i] = matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    int rowA, colA, rowB, colB = 0;\r\n    int matrixA[MAX][MAX];\r\n    int matrixB[MAX][MAX];\r\n    int result[MAX][MAX];\r\n    int choice;\r\n\r\n    // Prompt user to enter dimensions of Matrix A\r\n    printf(\"Enter the dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowA, &colA);\r\n\r\n    // Validate matrix dimensions\r\n    if (rowA > MAX || colA > MAX) {\r\n        printf(\"Maximum matrix size is %dx%d\\n\", MAX, MAX);\r\n        return 1;\r\n    }\r\n\r\n    // Prompt user to enter elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rowA; i++) {\r\n        for (int j = 0; j < colA; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    // Prompt user to enter dimensions of Matrix B\r\n    printf(\"Enter the dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowB, &colB);\r\n\r\n    // Validate matrix dimensions\r\n    if (rowB > MAX || colB > MAX) {\r\n        printf(\"Maximum matrix size is %dx%d\\n\", MAX, MAX);\r\n        return 1;\r\n    }\r\n   \r\n    // Prompt user to enter elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < rowB; i++) {\r\n        for (int j = 0; j < colB; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n    while(choice != 5) {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice){\r\n            // Addition\r\n            case 1:\r\n                if(rowA == rowB && colA == colB){\r\n                    addition(matrixA, matrixB, result, rowA, colA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    for(int i = 0; i < rowA; i++){\r\n                        for(int j = 0; j < colA; j++){\r\n                            printf(\"%d \", result[i][j]);\r\n                        }\r\n                        printf(\"\\n\");\r\n                    }\r\n                }\r\n                else{\r\n                    printf(\"Matrices can be added if (if and only if) the order of the matrices are equal\");\r\n                }\r\n                break;\r\n            // Subtraction\r\n            case 2:\r\n                if(rowA == rowB && colA == colB){\r\n                    subtraction(matrixA, matrixB, result, rowA, colA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    for(int i = 0; i < rowA; i++){\r\n                        for(int j = 0; j < colA; j++){\r\n                            printf(\"%d \", result[i][j]);\r\n                        }\r\n                        printf(\"\\n\");\r\n                    }\r\n                }\r\n                else{\r\n                    printf(\"Matrices can be added if (if and only if) the order of the matrices are equal\");\r\n                }\r\n                break;\r\n            // Transpose Matrix A\r\n            case 3:\r\n                transposeA(matrixA, result, rowA, colA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                for(int i = 0; i < rowA; i++){\r\n                        for(int j = 0; j < colA; j++){\r\n                            printf(\"%d \", result[i][j]);\r\n                        }\r\n                        printf(\"\\n\");\r\n                    }\r\n                break;\r\n            // Transpose Matrix B\r\n            case 4:\r\n                transposeA(matrixB, result, rowB, colB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                for(int i = 0; i < rowB; i++){\r\n                        for(int j = 0; j < colB; j++){\r\n                            printf(\"%d \", result[i][j]);\r\n                        }\r\n                        printf(\"\\n\");\r\n                    }\r\n                break;\r\n            // Exit\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Enter a valid choice!\");\r\n        }\r\n\r\n    }\r\n    \r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n#define MAX_NAME 100\r\n#define MAX_CATEGORY 100\r\n#define MAX_ITEM 100\r\n\r\n// Struct for grocery item\r\ntypedef struct {\r\n        char name[MAX_NAME];\r\n        char category[MAX_CATEGORY];\r\n        int quantity;\r\n        float price;\r\n        bool inStock;\r\n        bool outOfStock;\r\n    } item;\r\n\r\nitem inventory[MAX_ITEM];\r\nint total = 0;\r\n\r\n// Function to add item\r\nvoid addItem(){\r\n    if(total >= MAX_ITEM){\r\n        printf(\"Inventory is full!\\n\");\r\n        return;\r\n    }\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", inventory[total].name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", inventory[total].category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &inventory[total].quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &inventory[total].price);\r\n    total++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list item\r\nvoid listItem(){\r\n    if (total == 0){\r\n        printf(\"Grocery inventory is empty.\\n\");\r\n        return;\r\n    }\r\n    for(int i = 0; i < total; i++){\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: $%.2f\\n\", inventory[i].price);      \r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to update quantity\r\nvoid updateQuantity(){\r\n    char name[MAX_NAME];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter name of grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", &name);\r\n\r\n    for(int i = 0; i < total; i++){\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &newQuantity);\r\n            inventory[i].quantity = newQuantity;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item not found!\\n\");\r\n}\r\n\r\n// Funtion to remove item\r\nvoid removeItem(){\r\n    char name[MAX_NAME];\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", &name);\r\n    for (int i = 0; i < total; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            for (int j = i; j < total - 1; j++) {\r\n            inventory[j] = inventory[j + 1];\r\n            }\r\n            total--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Error: Grocery item not found.\\n\");\r\n}\r\n\r\n\r\nint main(){\r\n    int choice = 0;\r\n\r\n    while(choice != 5){\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice){\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItem();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Enter a valid choice!\\n\");\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* new = (Student*)malloc(sizeof(Student));\r\n    strcpy(new->name, name);\r\n    new->id = id;\r\n    new->grade = grade;\r\n    new->next = NULL;\r\n    return new;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* new = createStudent(name, id, grade);\r\n    if(head == NULL){\r\n        head = new;\r\n        return;\r\n    }\r\n    else{\r\n        Student* now = head;\r\n        while(now->next != NULL){\r\n            now = now->next;\r\n        }\r\n        now->next = new;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* now = head;\r\n    while(now != NULL){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", now->name, now->id, now->grade);\r\n        now = now->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* now = head;\r\n    while(now){\r\n        if(now->id == id){\r\n            return now;\r\n        }\r\n        now = now->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on bubble sort\r\nvoid sortStudents() {\r\n    Student* ptr1;\r\n    Student* ptr2 = NULL;\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n// Main function to drive the program\r\nint main() {\r\n \r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                            found->name, found->id, found->grade);\r\n                 } else {\r\n                    printf(\"Student not found.\\n\");\r\n                 }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n                default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n} \r\n",
    "feedback": "q1-    In the transposeB function case within the switch statement, the call to transposeA should be transposeB. This results in trying to transpose Matrix A instead of Matrix B.\n    The condition for the exit loop (while(choice != 5)) uses an uninitialized variable choice, which may lead to undefined behavior. It should be initialized before the loop starts.\nq2-Meet requirement. \nq3-While Bubble Sort is straightforward, it has a time complexity of O(n?) and is inefficient for larger datasets. The sortStudents function is currently a placeholder and needs to be implemented."
  },
  {
    "student_id": "20579147",
    "code": "\n/* --- Qst1.c --- */\n\r\n#include <math.h>\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n\r\n// Function to add  thetwo matrices\r\nvoid addMatrices(int rows, int cols, int A[10][10], int B[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {// loop through each elemt of matrices\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];// add elements form A and B  store in resukt\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract  the two matrices\r\nvoid subtractMatrices(int rows, int cols, int A[10][10], int B[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];//ssubtract corresponding  elements B form A\r\n        }\r\n    }\r\n}\r\n\r\n//  Function to transpose the matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];// swap row with columns\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display the matrix\r\nvoid displayMatrix(int rows, int cols, int matrix[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");// print new line after each row\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rows=0; // initialization\r\n    int  cols=0; // initialization\r\n    int A[10][10], B[10][10], result[10][10];\r\n    int choice;\r\n\r\n    // Input the dimensions of the matrices\r\n    printf(\"Enter the number of rows and columns of the matrices (max 10x10): \");\r\n    scanf(\"%d %d\", &rows, &cols);\r\n\r\n    // Input elements of matrix A\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input elements of matrix B\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            scanf(\"%d\", &B[i][j]);\r\n        }\r\n    }\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nChoose an operation:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {//  the switch statement to handle different choices\r\n            case 1:\r\n                addMatrices(rows, cols, A, B, result);\r\n                printf(\"Result of Addition:\\n\");\r\n                displayMatrix(rows, cols, result);\r\n                break;\r\n\r\n            case 2:\r\n                subtractMatrices(rows, cols, A, B, result);\r\n                printf(\"Result of Subtraction:\\n\");\r\n                displayMatrix(rows, cols, result);\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(rows, cols, A, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(cols, rows, result);\r\n                break;\r\n\r\n            case 4:\r\n\r\n\r\n                transposeMatrix(rows, cols, B, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(cols, rows, result);\r\n                break;\r\n\r\n\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);// continue till the user decides to exit\r\n\r\n    return 0;\r\n}\r\n\n/* --- Qst2.c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n\r\n// Structure to hold the availability status of an item\r\nstruct AvailabilityStatus {\r\n    int inStock;  // 1 means in stock, 0 means out of stock\r\n};\r\n\r\n// Structure to hold the details of a grocery item\r\nstruct GroceryItem {\r\n    char name[100];       // Name of the grocery item\r\n    char category[50];    // Category of the grocery ite\r\n    int quantity;         // Quantity available in the store\r\n    float price;          // Price of the item\r\n};\r\n\r\n// Structure to hold the entire grocery inventory\r\nstruct GroceryInventory {\r\n    struct GroceryItem items[100];          // Array of  the grocery items\r\n    struct AvailabilityStatus availability[100]; // Array of the  availability status for each item\r\n    int totalItems;      // Total number of items in stock\r\n};\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addGroceryItem(struct GroceryInventory *inventory) {\r\n    // Check if the inventory is full\r\n    if (inventory->totalItems < 100) {\r\n        struct GroceryItem newItem;\r\n        struct AvailabilityStatus newStatus;\r\n\r\n        // Ask the user to input item details\r\n        printf(\"Enter item name: \");\r\n        getchar(); // Clear the newline character left by previous input\r\n        fgets(newItem.name, 100, stdin);\r\n        newItem.name[strcspn(newItem.name, \"\\n\")] = 0; // Remove the newline character\r\n\r\n        printf(\"Enter item category: \");\r\n        fgets(newItem.category, 50, stdin);\r\n        newItem.category[strcspn(newItem.category, \"\\n\")] = 0; // Remove the newline character\r\n\r\n        printf(\"Enter item quantity: \");\r\n        scanf(\"%d\", &newItem.quantity);\r\n\r\n        printf(\"Enter item price: \");\r\n        scanf(\"%f\", &newItem.price);\r\n\r\n        // Ask if the item is in stock\r\n        printf(\"Is the item in stock? (1 for In Stock, 0 for Out of Stock): \");\r\n        scanf(\"%d\", &newStatus.inStock);\r\n\r\n        // Add the new item to the inventory\r\n        inventory->items[inventory->totalItems] = newItem;\r\n        inventory->availability[inventory->totalItems] = newStatus;\r\n        inventory->totalItems++;\r\n\r\n        printf(\"Item added successfully!\\n\");\r\n    } else {\r\n        printf(\"Inventory is full, cannot add more items.\\n\");\r\n    }\r\n}\r\n\r\n// Function to list all the grocery items in the inventory along with their availability\r\nvoid listGroceryItems(struct GroceryInventory *inventory) {\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"List of Grocery Items:\\n\");\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: $%.2f\\n\", inventory->items[i].price);\r\n        printf(\"Availability: %s\\n\", inventory->availability[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"------------------------------\\n\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an existing grocery item\r\nvoid updateGroceryItemQuantity(struct GroceryInventory *inventory) {\r\n    char itemName[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    getchar(); // To clear the newline character\r\n    fgets(itemName, 100, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline\r\n\r\n    // Search for the item by name and update its quantity\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            int newQuantity;\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n            inventory->items[i].quantity = newQuantity;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(struct GroceryInventory *inventory) {\r\n    char itemName[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar(); // To clear the newline character\r\n    fgets(itemName, 100, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline\r\n\r\n    // Search for the item by name and remove it\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            // Shift items to fill the gap\r\n            for (int j = i; j < inventory->totalItems - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->totalItems--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nint main() {\r\n    struct GroceryInventory inventory = { .totalItems = 0 };  // Initialize  empty inventory\r\n    int choice;\r\n\r\n    do {\r\n        // Display the menu of options\r\n        printf(\"\\nGrocery Inventory Management:\\n\");\r\n        printf(\"1. Add grocery item\\n\");\r\n        printf(\"2. List all grocery items with their availability\\n\");\r\n        printf(\"3. Update quantity of a grocery item\\n\");\r\n        printf(\"4. Remove a grocery item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Perform the corresponding action based on the user's choice snd call the fucntion\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);  \r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory); \r\n                break;\r\n            case 3:\r\n                updateGroceryItemQuantity(&inventory);  \r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);  \r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);  // Repeat until the user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\n/* --- Qst3.c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n\r\n// Structure for Student \r\n typedef struct Student { \r\n    char name[100]; // Array to store student names\r\n    int id; // to student id\r\n    float grade;\r\n    struct Student* next; // pointer to the next student in the list\r\n} Student; \r\n\r\nStudent* head = NULL; \r\n\r\n// Function to create a new student \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    // Allocate memory for a new student \r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); \r\n    \r\n    // Copy the student data into the new student\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL; // The  next pointer will be NULL ,it is a new student\r\n    \r\n    return newStudent; \r\n} \r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    // Create a new student node using the provided data\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    \r\n    // If the list is empty, the new student becomes the head\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        // Otherwise, we need to insert it at the end of the list\r\n        Student* current = head;\r\n        while (current->next != NULL) {\r\n            current = current->next; // Move to the last student\r\n        }\r\n        current->next = newStudent; // Add the new student after the last student\r\n    }\r\n    \r\n    printf(\"Student record inserted successfully.\\n\");\r\n} \r\n\r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    // If the list is empty, print a message\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n    \r\n    // loop through the list and display each students data\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Move to the next student\r\n    }\r\n} \r\n\r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n    // Loop through the list to find a student with the matching ID\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current; // Return the student if found\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // Return NULL if the student is not found\r\n} \r\n\r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n    \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); // Free the memory of the current student node\r\n        current = next; // Move to the next student\r\n    } \r\n    \r\n    head = NULL; // Set head to NULL since the list is empty now\r\n} \r\n\r\n// Sort function to sort the student records by grade using Bubble Sort \r\nvoid sortStudents() { \r\n    if (head == NULL) {\r\n        printf(\"No records to sort.\\n\");\r\n        return;\r\n    }\r\n    \r\n    int swapped;\r\n    \r\n    // Bubble Sort to sort students by grade in ascending order\r\n    do {\r\n        swapped = 0;\r\n        Student* current = head;\r\n        Student* prev = NULL;\r\n        Student* next = head->next;\r\n        \r\n        while (next != NULL) {\r\n            if (current->grade > next->grade) {\r\n                // Swap the students' data without using a temporary variable\r\n                if (prev != NULL) {\r\n                    prev->next = next;  \r\n                }\r\n                \r\n                current->next = next->next;  // Point the current node to the node after next\r\n                next->next = current;  // Point the next record to the current node\r\n                \r\n                if (current == head) {\r\n                    head = next; // If we swapped the head record, update head\r\n                }\r\n                \r\n                swapped = 1; // Set swapped to 1 to continue sorting\r\n            }\r\n            \r\n            prev = current;\r\n            current = next;\r\n            next = next->next;\r\n        }\r\n    } while (swapped);\r\n    \r\n    printf(\"Student records sorted by grade.\\n\");\r\n} \r\n\r\n// Free memory to ensure that all memory is freed when the program exits\r\nvoid freeMemory() { \r\n    deleteList(); \r\n}\r\n\r\nint main() { \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n    \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records by Grade\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n        \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); // Remove newline character from input\r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents();                 \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                           found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n    \r\n    return 0; \r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program implements bubble sort to sort student records by grade. While this method works correctly, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using a more efficient sorting algorithm, such as Quick Sort or Merge Sort, for improved performance."
  },
  {
    "student_id": "20611298",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define Value 10\r\n\r\n// Function Prototype\r\nvoid Dimensions_input(int *rows, int *columns, char Matrix_Name);\r\nvoid Matrix_Add(int A[Value][Value], int B[Value][Value], int result[Value][Value], int rows, int columns);\r\nvoid Matrix_subtract(int A[Value][Value], int B[Value][Value], int result[Value][Value], int rows, int columns);\r\nvoid Matrix_Input(int matrix[Value][Value], int rows, int columns, char name);\r\nvoid Matrix_Print(int matrix[Value][Value], int rows, int columns);\r\nvoid Matrix_Tranposed(int matrix[Value][Value], int transposed[Value][Value], int rows, int columns);\r\n\r\n// Function for the input matric including the error validation\r\n// use of do while loop to repeat it until getting the valid input\r\nvoid Dimensions_input(int *rows, int *columns, char Matrix_Name)\r\n{\r\n    int valid = 0;\r\n\r\n    do\r\n    {\r\n        printf(\"Enter the dimensions of Matrix %c (rows and columns): \", Matrix_Name);\r\n\r\n        // Read and validate the input\r\n        // To make sure theres two input\r\n        if (scanf(\"%d %d\", rows, columns) == 2)\r\n        {\r\n            if (*rows > 0 && *rows <= Value && *columns > 0 && *columns <= Value)\r\n            {\r\n                // valid input\r\n                valid = 1;\r\n            }\r\n            else\r\n            {\r\n                printf(\"Invalid dimensions. Please enter positive integers within the range 1 to %d.\\n\", Value);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            printf(\"Invalid input. Please enter two integers separated by a space.\\n\");\r\n        }\r\n\r\n        // Clear the buffer\r\n        while (getchar() != '\\n')\r\n            ;\r\n\r\n    } while (!valid);\r\n}\r\n\r\n// Matrices Adding\r\nvoid Matrix_Add(int A[Value][Value], int B[Value][Value], int result[Value][Value], int rows, int columns)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Matrices subtarcting by using For loop\r\nvoid Matrix_subtract(int A[Value][Value], int B[Value][Value], int result[Value][Value], int rows, int columns)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Matrices inputing\r\nvoid Matrix_Input(int matrix[Value][Value], int rows, int columns, char name)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            printf(\"%c[%d][%d]: \", name, i + 1, j + 1);\r\n            while (scanf(\"%d\", &matrix[i][j]) != 1)\r\n            {\r\n                printf(\"Invalid input. Please enter an integer\\n%c[%d][%d]: \", name, i + 1, j + 1);\r\n                // clear the input buffer\r\n                while (getchar() != '\\n')\r\n                    ;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Matrices printing\r\nvoid Matrix_Print(int matrix[Value][Value], int rows, int columns)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Matrix transposed\r\nvoid Matrix_Tranposed(int matrix[Value][Value], int transposed[Value][Value], int rows, int columns)\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int rowsA, columnsA, rowsB, columnsB;\r\n    int A[Value][Value], B[Value][Value], result[Value][Value];\r\n    int choices;\r\n\r\n    // input function for matrix A\r\n    Dimensions_input(&rowsA, &columnsA, 'A');\r\n\r\n    // prompt the user to input the value of Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    Matrix_Input(A, rowsA, columnsA, 'A');\r\n\r\n    // Input function for matrix B\r\n    Dimensions_input(&rowsB, &columnsB, 'B');\r\n\r\n    // prompt the user to input the value of Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    Matrix_Input(B, rowsB, columnsB, 'B');\r\n\r\n    // Start the matrix operation menu\r\n    do\r\n    {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        // make sure the user enter valid value\r\n        if (scanf(\"%d\", &choices) != 1)\r\n        { // clear input buffer\r\n            printf(\"Invalid choice. Please enter a number between 1 and 5.\");\r\n            while (getchar() != '\\n')\r\n                ;\r\n            choices = -1;\r\n            continue;\r\n        }\r\n\r\n        switch (choices)\r\n        {\r\n        case 1:\r\n            if (rowsA == rowsB && columnsA == columnsB)\r\n            {\r\n                Matrix_Add(A, B, result, rowsA, columnsA);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                Matrix_Print(result, rowsA, columnsA);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrix addition not possible. Dimensions must match.\\n\");\r\n            }\r\n            break;\r\n        case 2:\r\n            if (rowsA == rowsB && columnsA == columnsB)\r\n            {\r\n                Matrix_subtract(A, B, result, rowsA, columnsA);\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                Matrix_Print(result, rowsA, columnsA);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrix subtraction not possible. Dimensions must match.\\n\");\r\n            }\r\n            break;\r\n        case 3:\r\n        {\r\n            int transposed[Value][Value];\r\n            Matrix_Tranposed(A, transposed, rowsA, columnsA);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            Matrix_Print(transposed, columnsA, rowsA);\r\n        }\r\n        break;\r\n        case 4:\r\n        {\r\n            int transposed[Value][Value];\r\n            Matrix_Tranposed(B, transposed, rowsB, columnsB);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            Matrix_Print(transposed, columnsB, rowsB);\r\n        }\r\n        break;\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n        }\r\n    } while (choices != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n//maximum 100 item can be added in this array later\r\n#define ITEMS 100\r\n//Use of ANSI escape code for the 92 is green, and 0 is reset its colour\r\n#define GREEN \"\\033[92m\"\r\n#define RESET \"\\033[0m\"\r\n\r\n// Define Grocery Item including size\r\ntypedef struct { \r\n    char name[100];\r\n    char category[50]; \r\n    int quantity;\r\n    float price;\r\n} Grocery_Item;\r\n\r\n// Stocks boolean\r\ntypedef struct { \r\n    bool in_stock; \r\n    } AvailabilityStatus;\r\n\r\n// Inventory structure\r\ntypedef struct {\r\n    //define a array for grocery item\r\n    Grocery_Item items[ITEMS];\r\n    //define an array for availability statuses\r\n    AvailabilityStatus statuses[ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid Add_Item(GroceryInventory *inventory);\r\nvoid Items_List(const GroceryInventory *inventory);\r\nvoid Update_Quantity(GroceryInventory *inventory);\r\nvoid Remove_Item(GroceryInventory *inventory);\r\n\r\nvoid Add_Item(GroceryInventory *inventory) {\r\n    if (inventory->count >= ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    Grocery_Item *item = &inventory->items[inventory->count];\r\n    AvailabilityStatus *status = &inventory->statuses[inventory->count];\r\n\r\n    printf(\"Enter Item Name: \");\r\n    //clear new line\r\n    fgets(item->name, 100, stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0; \r\n\r\n    printf(\"Enter Category: \");\r\n    //clear new line\r\n    fgets(item->category, 50, stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0; \r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n    //clear input buffer\r\n    getchar(); \r\n\r\n    status->in_stock = item->quantity > 0;\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n//Display all grocery items and their availability status base on it quantity\r\nvoid Items_List(const GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        const Grocery_Item *item = &inventory->items[i];\r\n        const AvailabilityStatus *status = &inventory->statuses[i];\r\n\r\n        printf(\"Name: %s\\n\", item->name);\r\n        //use of the ANSI escape codes to mek the category line green, \r\n        //Reset after this row to make others still in normal colour\r\n        printf(\"%sCategory: %s%s\\n\", GREEN, item->category, RESET);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", status->in_stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid Update_Quantity(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; // Remove newline\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        Grocery_Item *item = &inventory->items[i];\r\n        if (strcmp(item->name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", item->name);\r\n            scanf(\"%d\", &item->quantity);\r\n            getchar(); // Clear newline from buffer\r\n\r\n            //Available status\r\n            inventory->statuses[i].in_stock = item->quantity > 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nvoid Remove_Item(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    //remove new line\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; \r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Shift items to remove the current item\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->statuses[j] = inventory->statuses[j + 1];\r\n            }\r\n\r\n            inventory->count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .count = 0 };\r\n    int Choices;\r\n\r\n    //use do while loop to start the menu\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &Choices);\r\n        //get rid of newline buffer\r\n        getchar();\r\n\r\n        //switch case to handle each written function\r\n        switch (Choices) {\r\n            case 1:\r\n                Add_Item(&inventory);\r\n                break;\r\n            case 2:\r\n                Items_List(&inventory);\r\n                break;\r\n            case 3:\r\n                Update_Quantity(&inventory);\r\n                break;\r\n            case 4:\r\n                Remove_Item(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (Choices != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\ntypedef struct Student\r\n{\r\n    // Student's name\r\n    char name[100];\r\n    // student id\r\n    int id;\r\n    // student grade\r\n    float grade;\r\n    // point to the next student in the linked list\r\n    struct Student *next;\r\n} Student;\r\n\r\n// head pointer\r\nStudent *head = NULL;\r\n\r\n// main menu funtion to let user chose the options\r\nvoid displayMenu()\r\n{\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n}\r\n\r\n// create student funtion, by creating a new student and return the function\r\nStudent *createStudent(const char *name, int id, float grade)\r\n{\r\n    // this part is used to allocate  memory for new student\r\n    Student *newNode = (Student *)malloc(sizeof(Student));\r\n    if (newNode == NULL)\r\n    {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Used to initialize the student node\r\n    strcpy(newNode->name, name);\r\n    newNode->id = id;\r\n    newNode->grade = grade;\r\n    newNode->next = NULL;\r\n    return newNode;\r\n}\r\n\r\n// insert a new student record into the linked list\r\nvoid insertStudent(const char *name, int id, float grade)\r\n{\r\n\r\n    Student *newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL)\r\n        return;\r\n\r\n    // if the inserted list is empty set the first student as the head  of the list\r\n    if (head == NULL)\r\n    {\r\n        head = newStudent;\r\n    }\r\n    else\r\n    {\r\n        // point to the last of the list and than connect the new student to the end of the list\r\n        Student *temp = head;\r\n        while (temp->next != NULL)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Displaying all the listed out\r\nvoid displayStudents()\r\n{\r\n    // error handling , ensure the list is not empty\r\n    if (head == NULL)\r\n    {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student *temp = head;\r\n    while (temp != NULL)\r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        // pointer point to the next student to display out the whole list\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Search function\r\n// point to one by one than return the search value, returning Null if none of it match\r\nStudent *searchStudentByID(int id)\r\n{\r\n    Student *temp = head;\r\n    while (temp != NULL)\r\n    {\r\n        if (temp->id == id)\r\n        {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//\r\nvoid deleteList()\r\n{\r\n    Student *current = head;\r\n    Student *next;\r\n\r\n    // loop through the list until the current pointer is NUll\r\n    while (current != NULL)\r\n    {\r\n        next = current->next;\r\n        // free the memory\r\n        free(current);\r\n        current = next;\r\n    }\r\n    // reseting the head to NULL after the process\r\n    head = NULL;\r\n    printf(\"List deleted.\\n\");\r\n}\r\n\r\n// free memory function\r\nvoid freeMemory()\r\n{\r\n    deleteList();\r\n}\r\n\r\n// Bubble sort function , to sort the list in ascending order by grade  after choosing option 3\r\nvoid sortStudents()\r\n{\r\n    // validation if the list enough student to sort or not\r\n    if (head == NULL || head->next == NULL)\r\n    {\r\n        printf(\"Not enough student to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int sort;\r\n    Student *Current, *Last_Sorted = NULL;\r\n\r\n    do\r\n    {\r\n        sort = 0;\r\n        Current = head;\r\n\r\n        while (Current->next != Last_Sorted)\r\n        {\r\n            // Exchanging the current and next data to sort\r\n            if (Current->grade > Current->next->grade)\r\n            {\r\n\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, Current->name);\r\n                tempID = Current->id;\r\n                tempGrade = Current->grade;\r\n\r\n                strcpy(Current->name, Current->next->name);\r\n                Current->id = Current->next->id;\r\n                Current->grade = Current->next->grade;\r\n\r\n                strcpy(Current->next->name, tempName);\r\n                Current->next->id = tempID;\r\n                Current->next->grade = tempGrade;\r\n\r\n                sort = 1;\r\n            }\r\n            // move to the next pair\r\n            Current = Current->next;\r\n        }\r\n\r\n        // update for the last sorted node\r\n        Last_Sorted = Current;\r\n    } while (sort);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    // used to display the Menu and options, than prompt the user to enter the choices\r\n    do\r\n    {\r\n        displayMenu();\r\n\r\n        printf(\"Enter your choice: \");\r\n        while (scanf(\"%d\", &choice) != 1)\r\n        {\r\n            printf(\"Invalid choice. Please try again. \");\r\n            // clear buffer\r\n            while (getchar() != '\\n')\r\n                ;\r\n        }\r\n        // get rid of the new line\r\n        getchar();\r\n\r\n        // create few cases for entering the details of student\r\n        // and do error handling for the user enter value\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            while (1)\r\n            {\r\n                if (fgets(name, sizeof(name), stdin))\r\n                {\r\n                    name[strcspn(name, \"\\n\")] = '\\0';\r\n                    // remove newline character\r\n                    if (strlen(name) > 0)\r\n                        break;\r\n                }\r\n                printf(\"Invalid input. Please enter a valid Name: \");\r\n            }\r\n\r\n            printf(\"Enter ID: \");\r\n            while (scanf(\"%d\", &id) != 1 || id <= 0)\r\n            {\r\n                printf(\"Invalid input! Please enter a positive integer : \");\r\n                // clear buffer\r\n                while (getchar() != '\\n')\r\n                    ;\r\n            }\r\n\r\n            printf(\"Enter Grade: \");\r\n            while (scanf(\"%f\", &grade) != 1 || grade < 0.0 || grade > 100.0)\r\n            {\r\n                printf(\"Invalid input! Please enter a positive integer between 0 and 100: \");\r\n                while (getchar() != '\\n')\r\n                    ;\r\n            }\r\n\r\n            // implement each created function to the menu\r\n            insertStudent(name, id, grade);\r\n            break;\r\n\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            while (scanf(\"%d\", &id) != 1 || id <= 0)\r\n            {\r\n                printf(\"Invalid input! Please enter a positive integer for ID: \");\r\n                while (getchar() != '\\n')\r\n                    ;\r\n            }\r\n\r\n            Student *found = searchStudentByID(id);\r\n            if (found)\r\n            {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 5:\r\n            deleteList();\r\n            break;\r\n\r\n        case 6:\r\n            // free memory and exit\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-The program does not handle cases where the quantity is updated to zero correctly. While it sets the in_stock status, it should also ensure that the item is marked as \"Out of Stock\" in the output when listed.In the Remove_Item function, the program does not properly handle the case where the last item is removed. The loop that shifts items does not account for the fact that the last item is being removed, which may lead to accessing uninitialized memory in the statuses array.\nq3-    Bubble Sort is correctly implemented, but it is inefficient for larger datasets, with a time complexity of O(n?). While it works for small lists, a more efficient sorting algorithm, such as Quick Sort or Merge Sort, would be more suitable for larger datasets."
  },
  {
    "student_id": "20677174",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct {\r\n    int row; // Number of rows of the matrix\r\n    int col; // Number of columns of the matrix\r\n    int * matrix;\r\n} matrix2D;\r\n\r\n\r\nint validateDimension (int dimension) {\r\n    // Max size is 10 x 10 so dimension is <= 10\r\n    // Dimension also cannot be < 1\r\n    return dimension >= 1 && dimension <= 10; \r\n}\r\n\r\n// Function to print the matrix out\r\nvoid printMatrices (matrix2D m) {\r\n    int * ptr; // Temp pointer\r\n    for (int i = 0; i < m.row; ++i) {\r\n        ptr = m.matrix + (i * m.col); // Make temp ptr point to each ROW during each entry into the loop\r\n        for (int j = 0; j < m.col; ++j) {\r\n            printf(\"%d \", ptr[j]); // Make temp ptr point to elements in each COL in this loop\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Add two matrices\r\nvoid addMatrices(matrix2D mA, matrix2D mB) {\r\n    if ((mA.row != mB.row) || (mA.col != mB.col)) {\r\n        printf(\"The two matrices have different sizes. Unable to add\\n\");\r\n        return;\r\n    }\r\n    int resultVals[mA.row][mA.col];\r\n    int * ptrA; // Temp pointer used for matrix A\r\n    int * ptrB; // Temp pointer used for matrix B\r\n    matrix2D result; // Result matrix\r\n    result.row = mA.row;\r\n    result.col = mA.col;\r\n    for (int i = 0; i < mA.row; ++i) {\r\n        ptrA = mA.matrix + (i * mA.col); // Make ptrA point to each ROW during each entry into the loop\r\n        ptrB = mB.matrix + (i * mB.col); // Make ptrB point to each ROW during each entry into the loop\r\n        for (int j = 0; j < mB.col; ++j) {\r\n            resultVals[i][j] = ptrA[j] + ptrB[j];\r\n        }\r\n    }\r\n    result.matrix = *resultVals;\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n    printMatrices(result);\r\n}\r\n\r\nvoid subtractMatrices(matrix2D mA, matrix2D mB) {\r\n    if ((mA.row != mB.row) || (mA.col != mB.col)) {\r\n        printf(\"The two matrices have different sizes. Unable to subtract\\n\");\r\n        return;\r\n    }\r\n    int resultVals[mA.row][mA.col]; // 2D array used to hold the result matrix\r\n    int * ptrA; // Temp pointer used for matrix A\r\n    int * ptrB; // Temp pointer used for matrix B\r\n    matrix2D result; // Result matrix\r\n    result.row = mA.row;\r\n    result.col = mA.col;\r\n    for (int i = 0; i < mA.row; ++i) {\r\n        ptrA = mA.matrix + (i * mA.col); // Make ptrA point to each ROW during each entry into the loop\r\n        ptrB = mB.matrix + (i * mB.col); // Make ptrB point to each ROW during each entry into the loop\r\n        for (int j = 0; j < mA.col; ++j) {\r\n            // a - b = a + (-b) = a + (-1 * b)\r\n            // Therefore, multiply the element in matrix B by -1 before adding it to element in matrix A\r\n            resultVals[i][j] = ptrA[j] + (ptrB[j] * -1); \r\n        }\r\n    }\r\n    result.matrix = *resultVals;\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    printMatrices(result);\r\n}\r\n\r\n// Transpose a matrix\r\nmatrix2D transposeMatrices(matrix2D m) {\r\n    int temp; // Store temp values\r\n    int * ptr = m.matrix; // temp ptr\r\n    // Transpose operation swaps number of rows and number of columns of the matrix\r\n    int resultVals[m.col][m.row]; // 2D array used to hold the values of the result matrix\r\n    // Read horrizontally, write vertically\r\n    for (int i = 0; i < m.row; ++i) {\r\n        ptr = m.matrix + (i * m.col); // Make ptr point to each ROW during each entry into the loop\r\n        for (int j = 0; j < m.col; ++j) {\r\n            resultVals[j][i] = ptr[j];\r\n        }\r\n    }\r\n    temp = m.row;\r\n    m.row = m.col;\r\n    m.col = temp;\r\n    int * newM = malloc(sizeof(int) * m.col * m.row);\r\n    memcpy(newM, resultVals, sizeof(resultVals)); // Copy the transposed matrix to the dynamic memory allocated to store it\r\n    free(m.matrix); // Free the dynamic memory allocated to store the old matrix to prevent memory leaking\r\n    m.matrix = newM;\r\n    printMatrices(m);\r\n    return m;\r\n}\r\n\r\n\r\n\r\nint main(void){\r\n    // Declare a vairable to store the user's choice for the operation to be performed\r\n    int choice;\r\n    // Create two structs to hold the matrices\r\n    matrix2D matrixA;\r\n    matrix2D matrixB;\r\n    // Prompt user input for the dimensions of matrix A and validate it\r\n    // Loop until the user input valid dimensions for matrix A\r\n    while (1) {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &matrixA.row, &matrixA.col);\r\n        if (!validateDimension(matrixA.row) || !validateDimension(matrixA.col)) {\r\n            printf(\"Invalid input. Please enter valid matrix dimensions\\n\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // Create the matrix A (use 2D array as the data structure to hold the values of the matrix)\r\n    int arr1[matrixA.row][matrixA.col];\r\n    // Prompt user input to populate the matrix\r\n    printf(\"Enter elements for matrix A: \\n\");\r\n    for (int i = 0; i < matrixA.row; ++i) {\r\n        for (int j = 0; j < matrixA.col; ++j) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &arr1[i][j]);\r\n        }\r\n    }\r\n\r\n    int * mA = malloc(sizeof(int) * matrixA.row * matrixA.col);\r\n    memcpy(mA, arr1, sizeof(arr1));\r\n    matrixA.matrix = mA;\r\n    // Prompt user input for the dimensions of matrix B and validate it\r\n    // Loop until the user input valid dimensions for matrix B\r\n    while (1) {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &matrixB.row, &matrixB.col);\r\n        if (!validateDimension(matrixB.row) || !validateDimension(matrixB.col)) {\r\n            printf(\"Invalid input. Please enter valid matrix dimensions\\n\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // Create the matrix B (use 2D array as the data structure to hold the values of the matrix)\r\n    int arr2[matrixB.row][matrixB.col];\r\n    // Prompt user input to populate the matrix\r\n    printf(\"Enter elements for matrix B: \\n\");\r\n    for (int i = 0; i < matrixB.row; ++i) {\r\n        for (int j = 0; j < matrixB.col; ++j) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &arr2[i][j]);\r\n        }\r\n    }\r\n\r\n    int * mB = malloc(sizeof(int) * matrixB.row * matrixB.col);\r\n    memcpy(mB, arr2, sizeof(arr2));\r\n    matrixB.matrix = mB;\r\n\r\n    // Display the menu and allow the user to select operations based on different choices\r\n    // Loop until the user chooses to exit\r\n    do {\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        switch (choice) {\r\n            case 1:\r\n                addMatrices(matrixA, matrixB);\r\n                break;\r\n            case 2:\r\n                subtractMatrices(matrixA, matrixB);\r\n                break;\r\n            case 3:\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                matrixA = transposeMatrices(matrixA);\r\n                break;\r\n            case 4:\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                matrixB = transposeMatrices(matrixB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter again!\\n\");\r\n        }\r\n    } while (choice != 5);\r\n    \r\n    return 0;\r\n}\r\n\n/* --- q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#define MAX_SIZE 100\r\n\r\ntypedef struct{\r\n    char name[101]; // Max length 100 !! Additional 1 space is included to store NULL terminator in case of max length\r\n    char category[51]; // Max length 50\r\n    int quantity; // Quantity of the grocery item\r\n    float price; // Price of the grocery item\r\n} groceryItem;\r\n\r\ntypedef union { // Use union to represent the availabilityStatus to save space. Only inStock is accessed in all operations\r\n    int inStock;\r\n    int outOfStock;\r\n} availabilityStatus;\r\n\r\ntypedef struct {\r\n    groceryItem groceryItems[MAX_SIZE]; // Array of grocery items\r\n    availabilityStatus status [MAX_SIZE]; // Array of availability status\r\n    int count; // Total number of grocery items in the system\r\n} groceryInventory;\r\n\r\nvoid addGroceryItem(groceryInventory * inventory) {\r\n    if ((*inventory).count >= MAX_SIZE) { // Check if the inventory is already full before adding\r\n        printf(\"Inventory full. Unable to add new grocery items anymore.\\n\\n\");\r\n        return;\r\n    }\r\n    // Get name of new item\r\n    printf(\"Enter Item Name: \");\r\n    fgets((*inventory).groceryItems[(*inventory).count].name, 101, stdin);\r\n    // Get category of new item\r\n    printf(\"Enter Category: \");\r\n    fgets((*inventory).groceryItems[(*inventory).count].category, 51, stdin);\r\n    // Get quantity of new item\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &(*inventory).groceryItems[(*inventory).count].quantity);\r\n    // Set the availability status of the new item based on the quantity\r\n    if ((*inventory).groceryItems[(*inventory).count].quantity == 0) {\r\n        (*inventory).status[(*inventory).count].inStock = 0;\r\n    } else {\r\n        (*inventory).status[(*inventory).count].inStock = 1;\r\n    }\r\n    // Get price of new item\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &(*inventory).groceryItems[(*inventory).count].price);\r\n    ++(*inventory).count;\r\n    printf(\"Grocery item added successfully!\\n\\n\");\r\n}\r\n\r\nvoid listGroceryItems(groceryInventory * inventory) {\r\n    if ((*inventory).count == 0) { // Check if the inventory is empty before displaying all items\r\n        printf(\"No grocery items in the inventory.\\n\\n\");\r\n        return;\r\n    }\r\n    for (int i = 0; i < (*inventory).count; ++i){\r\n        printf(\"Name: %s\", (*inventory).groceryItems[i].name); // Print the name\r\n        printf(\"Category: %s\", (*inventory).groceryItems[i].category); // Print the category\r\n        printf(\"Quantity: %d\\n\", (*inventory).groceryItems[i].quantity); // Print the quantity\r\n        printf(\"Price: %.2f\\n\", (*inventory).groceryItems[i].price); // Print the quantity\r\n        if ((*inventory).status[i].inStock) {\r\n            printf(\"Status: In Stock\\n\\n\");\r\n        } else {\r\n            printf(\"Status: Out of Stock\\n\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid updateQuantity(groceryInventory * inventory) {\r\n    if ((*inventory).count == 0) { // Check if the inventory is empty before allowing user to update quantity\r\n        printf(\"No grocery items in the inventory.\\n\\n\");\r\n        return;\r\n    }\r\n    char target[101];\r\n    int newQuantity;\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(target, 101, stdin);\r\n    for (int i = 0; i < (*inventory).count; ++i) {\r\n        if (strcmp(target, (*inventory).groceryItems[i].name) == 0) {\r\n            target[strcspn(target, \"\\n\")] = '\\0';\r\n            printf(\"Enter new quantity for %s: \", target);\r\n            scanf(\"%d\", &newQuantity);\r\n            (*inventory).groceryItems[i].quantity = newQuantity;\r\n            printf(\"Quantity updated successfully!\\n\\n\");\r\n            // Reset the availability status accordingly\r\n            if ((*inventory).groceryItems[i].quantity <= 0) {\r\n                (*inventory).status[i].inStock = 0;\r\n            } else {\r\n                (*inventory).status[i].inStock = 1;\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item not found.\\n\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(groceryInventory * inventory) {\r\n    if ((*inventory).count == 0) { // Check if the inventory is empty before allowing user to remove grocery\r\n        printf(\"No grocery items in the inventory.\\n\\n\");\r\n        return;\r\n    }\r\n    char target[101];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(target, 101, stdin);\r\n    for (int i = 0; i < (*inventory).count; ++i) {\r\n        if (strcmp(target, (*inventory).groceryItems[i].name) == 0) {\r\n            target[strcspn(target, \"\\n\")] = '\\0';\r\n            printf(\"Grocery item '%s' removed successfully!\\n\\n\", target);\r\n            // Move backwards 1 position for all the remaining grocery items located after the removed grocery item\r\n            // Move backwards 1 position for all the remaining status located after the status of the removed grocery item\r\n            // Remaining grocery items that must stay = (*inventory).count - 1 - i, where i is index of grocery item to be removed\r\n            memcpy((*inventory).groceryItems + i, (*inventory).groceryItems + i + 1, sizeof(groceryItem) * ((*inventory).count - 1 - i));\r\n            memcpy((*inventory).status + i, (*inventory).status + i + 1, sizeof(availabilityStatus) * ((*inventory).count - 1 - i));\r\n            --(*inventory).count;\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item not found.\\n\\n\");\r\n}\r\n\r\nint main (void) {\r\n    groceryInventory inventory; // Create a new inventory\r\n    inventory.count = 0; // Initialise count to 0\r\n\r\n    int choice; // Store the choice of the user about which operation to perform\r\n    do{\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Clear the remaining newline '\\n' in input buffer\r\n        // Pass the inventory by reference to modify or use it directly\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please input again\\n\");\r\n        }\r\n    } while (choice != 5);\r\n    return 0;\r\n}\n/* --- q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student *sPtr = malloc(sizeof(Student)); // Allocate dynamic memory to store the Student\r\n    strcpy((*sPtr).name, name); // Copy the user input name to the name field of the Student\r\n    (*sPtr).id = id; // Store the user input id into the id field of the Student\r\n    (*sPtr).grade = grade; // Store the user input grade into the grade field of the Student\r\n    (*sPtr).next = NULL; // Assign NULL to next pointer of the newly created Student\r\n    return sPtr;\r\n}\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student * sPtr = createStudent(name, id, grade); // Create a new student and get a pointer to it\r\n    if (head == NULL) { // \r\n        head = sPtr; // If head is NULL, just assign pointer to new student to it\r\n    } else {\r\n        Student * current = head; // Otherwise loop until the last node where the next is NULL\r\n        while((*current).next != NULL) {\r\n            current = (*current).next;\r\n        }\r\n        (*current).next = sPtr; // Assign the pointer to the new node to the next field of the last node\r\n    }\r\n}\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student * current = head; // Start from the first node\r\n    while(current != NULL) { // Loop until the current node is NULL\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", (*current).name, (*current).id, (*current).grade);\r\n        current = (*current).next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student * current = head; // Start from the first node\r\n    while (current != NULL) { // Loop until the current node is NULL or if the current node is the targeted node\r\n        if ((*current).id == id) { // Check if the id of current node is the is the id we want to find\r\n            return current; // If yes return the current node\r\n        }\r\n        current = (*current).next; // Or else move to the next node\r\n    }\r\n    return current; // If not found, current is NULL and is returned\r\n}\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head; \r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// merge function that merges two sorted halve\r\nStudent* merge(Student* left, Student* right) {\r\n    // Dummy node used for merging (makes it easier)\r\n    Student dummy;\r\n    dummy.next = NULL;\r\n    Student* tail = &dummy;\r\n\r\n\r\n    // Merge the two lists\r\n    while (left != NULL && right != NULL) {\r\n        if ((*left).grade <= (*right).grade) { // Start by comparing the first element of the two halves\r\n            // If left one is smaller, assign the pointer to the left element to the next field of dummy node\r\n            (*tail).next = left; \r\n            left = (*left).next; // Move left pointer forward\r\n        } else {\r\n            // Otherwise, assign the pointer to the right element to the next field of dummy node\r\n            (*tail).next = right; \r\n            right = (*right).next; // Move right pointer forward\r\n        }\r\n        tail = (*tail).next; // Make tail point to newly added node\r\n    }\r\n\r\n    // Append the remaining elements to the merged list starting from tail\r\n    if (left != NULL) { // If left is not NULL that means the left halve have remaining elements\r\n        (*tail).next = left;\r\n    } else {\r\n        (*tail).next = right;\r\n    }\r\n\r\n    return dummy.next; // Return the pointer at the next field of dummy that points to the next node (begining of merged list)\r\n}\r\n\r\n// Split the list into parts (left part and right part)\r\nvoid splitHalf(Student ** left, Student ** right, Student * head) {\r\n    // Use slow and fast pointer method to split the list\r\n    Student *slow = head;\r\n    Student *fast = (*head).next;\r\n\r\n    while (fast != NULL && (*fast).next != NULL) {\r\n        slow = (*slow).next;\r\n        fast = (*(*fast).next).next; // Fast pointer moves 1 additional position compared to slow pointer\r\n    }\r\n\r\n    // Split the list into two halves\r\n    *left = head;            // Left part starts from head (Assign head to left)\r\n    *right = (*slow).next;   // Right part starts from the node right after slow\r\n    (*slow).next = NULL;     // End the left part with NULL (disconnect it from right part)\r\n}   \r\n\r\n// Main mergeSort function\r\nStudent * mergeSort(Student * head) {\r\n    if ((*head).next == NULL) {\r\n        return head; // base case (size = 1)\r\n    } else {\r\n        // Normal procedure: split --> mergeSort each half --> finally merge them up\r\n        Student * left = NULL;\r\n        Student * right = NULL;\r\n        splitHalf(&left, &right, head);\r\n        left = mergeSort(left);\r\n        right = mergeSort(right);\r\n        return merge(left, right);\r\n    }\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an\r\n//algorithm of your choice\r\nvoid sortStudents() {\r\n    if (head != NULL) {\r\n        head = mergeSort(head);\r\n        printf(\"Records sorted using Merge Sort\\n\");\r\n    } else {\r\n        printf(\"No students stored.\\n\");\r\n    }\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\");\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student* found = searchStudentByID(id);\r\n            if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                found->name, found->id, found->grade);\r\n            } else {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n return 0;\r\n} \r\n",
    "feedback": "q1-    In the addMatrices and subtractMatrices functions, result.matrix is incorrectly assigned using *resultVals. This should be dynamically allocated memory instead of attempting to assign a pointer to an array that is out of scope.     The memcpy function in the transposeMatrices function attempts to copy a variable-length array resultVals without proper dynamic memory allocation, which can lead to undefined behavior.\nq2-Meet requirement. \nq3-Merge Sort is efficient with a time complexity of O(n log n) and is well-suited for linked lists, as it doesn't require random access. This choice is more efficient than Bubble Sort for larger datasets."
  },
  {
    "student_id": "20617520",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n//function prototypes\r\nvoid AddMatrix(int matrixA[10][10], int matrixB[10][10], int row, int col);\r\nvoid SubtractMatrix(int matrixA[10][10], int matrixB[10][10], int row, int col);\r\nvoid TransposeMatrix(int matrix[10][10], int row, int col);\r\nvoid PrintMatrix(int matrix[10][10], int row, int col);\r\nvoid InputMatrix(int matrix[10][10], int row, int col);\r\n\r\n\r\nint main()\r\n{\r\n    int matrixA[10][10];\r\n    int matrixB[10][10];\r\n    int rowA, colA;\r\n    int rowB, colB;\r\n    int option;\r\n    char again = 'y';\r\n    \r\n    while ((again == 'Y')||(again == 'y'))\r\n    {\r\n        //print menu\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices \\n2. Subtract Matrices \\n3. Transpose Matrix A \\n4. Transpose Matrix B \\n5. Exit \\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n\r\n        switch (option)\r\n        {\r\n            case 1: //addition\r\n                //prompt user for dimentions for addition\r\n                printf(\"Enter dimensions (rows and columns) for Matrix A: \");\r\n                scanf(\"%d %d\", &rowA, &colA);\r\n                while (rowA <= 0 || colA <= 0 || rowA > MAX_SIZE || colA > MAX_SIZE)\r\n                {\r\n                    printf(\"Invalid dimensions! Rows and Columns must be positive integers and not exceed %d. \\n\", MAX_SIZE);\r\n                    printf(\"Enter dimensions (rows and columns) for Matrix A: \");\r\n                    scanf(\"%d %d\", &rowA, &colA);\r\n                }\r\n\r\n\r\n                printf(\"Enter dimensions (rows and columns) for Matrix B: \");\r\n                scanf(\"%d %d\", &rowB, &colB);\r\n                while (rowB <= 0 || colB <= 0 || rowB > MAX_SIZE || colB > MAX_SIZE)\r\n                {\r\n                    printf(\"Invalid dimensions! Rows and Columns must be positive integers. \\n\");\r\n                    printf(\"Enter dimensions (rows and columns) for Matrix B: \");\r\n                    scanf(\"%d %d\", &rowB, &colB);\r\n                }\r\n\r\n\r\n                if (rowA != rowB || colA != colB)\r\n                {\r\n                    printf(\"Matrices must be the same size! \\n\");\r\n                    break;\r\n                }\r\n\r\n                //input matrix\r\n                printf(\"Enter elements of Matrix A: \\n\");\r\n                InputMatrix(matrixA, rowA, colA);\r\n                printf(\"Enter elements of Matrix B: \\n\");\r\n                InputMatrix(matrixB, rowA, colB);\r\n\r\n                //addition\r\n                printf(\"Result after addition: \\n\");\r\n                AddMatrix(matrixA, matrixB, rowA, colA);\r\n                break;\r\n\r\n            case 2: //subtraction\r\n                printf(\"Enter dimensions (rows and columns) for Matrix A: \");\r\n                scanf(\"%d %d\", &rowA, &colA);\r\n                while (rowA <= 0 || colA <= 0 || rowA > MAX_SIZE || colA > MAX_SIZE)\r\n                {\r\n                    printf(\"Invalid dimensions! Rows and Columns must be positive integers and not exceed %d. \\n\", MAX_SIZE);\r\n                    printf(\"Enter dimensions (rows and columns) for Matrix A: \");\r\n                    scanf(\"%d %d\", &rowA, &colA);\r\n                }\r\n\r\n\r\n                printf(\"Enter dimensions (rows and columns) for Matrix B: \");\r\n                scanf(\"%d %d\", &rowB, &colB);\r\n                while (rowB <= 0 || colB <= 0 || rowB > MAX_SIZE || colB > MAX_SIZE)\r\n                {\r\n                    printf(\"Invalid dimensions! Rows and Columns must be positive integers. \\n\");\r\n                    printf(\"Enter dimensions (rows and columns) for Matrix B: \");\r\n                    scanf(\"%d %d\", &rowB, &colB);\r\n                }\r\n\r\n\r\n                if (rowA != rowB || colA != colB)\r\n                {\r\n                    printf(\"Matrices must be the same size! \\n\");\r\n                    break;\r\n                }\r\n\r\n                //input matrix\r\n                printf(\"Enter elements of Matrix A: \\n\");\r\n                InputMatrix(matrixA, rowA, colA);\r\n                printf(\"Enter elements of Matrix B: \\n\");\r\n                InputMatrix(matrixB, rowA, colB);\r\n\r\n                //subtraction\r\n                SubtractMatrix(matrixA, matrixB, rowA, colA);\r\n                break;\r\n\r\n            case 3: //transpose matrix A\r\n                //input dimensions for transpose\r\n                printf(\"Enter dimensions (rows and columns) for Matrix A: \");\r\n                scanf(\"%d %d\", &rowA, &colA);\r\n                while (rowA <= 0 || colA <= 0 || rowA > MAX_SIZE || colA > MAX_SIZE)\r\n                {\r\n                    printf(\"Invalid dimensions! Rows and Columns must be positive integersand not exceed %d. \\n\", MAX_SIZE);\r\n                    printf(\"Enter rows and columns for Matrix A: \\n\");\r\n                    scanf(\"%d %d\", &rowA, &colA);\r\n                }\r\n\r\n                //input matrix\r\n                printf(\"Enter elements of Matrix A: \\n\");\r\n                InputMatrix(matrixA, rowA, colA);\r\n\r\n                printf(\"Transpose of Matrix A: \\n\");\r\n\r\n                //transpose matrix A\r\n                TransposeMatrix(matrixA, rowA, colA);\r\n                break;\r\n\r\n            case 4: //case to transpose matrix B\r\n                //input dimensions for transpose\r\n                printf(\"Enter dimensions (rows and columns) for Matrix B: \");\r\n                scanf(\"%d %d\", &rowB, &colB);\r\n                while (rowB <= 0 || colB <= 0 || rowB > MAX_SIZE || colB > MAX_SIZE)\r\n                {\r\n                    printf(\"Invalid dimensions! Rows and Columns must be positive integers and not exceed %d. \\n\", MAX_SIZE);\r\n                    printf(\"Enter rows and columns for Matrix B: \\n\");\r\n                    scanf(\"%d %d\", &rowB, &colB);\r\n                }\r\n\r\n                //input elements into matrix\r\n                printf(\"Enter elements of Matrix B: \\n\");\r\n                InputMatrix(matrixB, rowB, colB);\r\n\r\n                printf(\"Transpose of Matrix B: \\n\");\r\n                //transpose matrix B\r\n                TransposeMatrix(matrixB, rowB, colB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Invalid option. Please enter a valid option. \\n\");\r\n\r\n        }\r\n\r\n        printf(\"Do you want to perform another operation? (y/n): \");\r\n        scanf(\" %c\", &again);\r\n    }\r\n\r\n    return 0;\r\n    \r\n}\r\n\r\nvoid InputMatrix(int matrix[10][10], int row, int col)\r\n{\r\n    for(int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            printf(\"Element [%d] [%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid PrintMatrix(int matrix[10][10], int row, int col)\r\n{\r\n    int result[10][10];\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid AddMatrix(int matrixA[10][10], int matrixB[10][10], int row, int col)\r\n{\r\n    int result[10][10];\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j]; \r\n        }\r\n    }\r\n    PrintMatrix(result, row, col);\r\n}\r\n\r\nvoid SubtractMatrix(int matrixA[10][10], int matrixB[10][10], int row, int col)\r\n{\r\n    int result[10][10];\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n    PrintMatrix(result, row, col);\r\n}\r\n\r\nvoid TransposeMatrix(int matrix[10][10], int row, int col)\r\n{\r\n    int result[10][10];\r\n    for (int i = 0; i < col; i++)\r\n    {\r\n        for (int j = 0; j < row; j++)\r\n        {\r\n            result[i][j] = matrix[j][i];\r\n        }\r\n    }\r\n    PrintMatrix(result, col, row);\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME 100\r\n#define MAX_CATEGORY 50\r\n\r\n\r\ntypedef struct\r\n{\r\n    char name[MAX_NAME];\r\n    char category[MAX_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n} groceryItem;\r\n\r\ntypedef struct \r\n{\r\n    bool inStock;\r\n    bool outOfStock;\r\n} availabilityStatus;\r\n\r\ntypedef struct \r\n{\r\n    groceryItem items[MAX_ITEMS];\r\n    availabilityStatus status[MAX_ITEMS];\r\n    int count; \r\n}groceryInventory;\r\n\r\ngroceryInventory inventory;\r\n\r\n\r\n//function prototypes\r\nvoid clearInputBuffer();\r\nvoid addItem();\r\nvoid displayItems();\r\nvoid updateQuantity();\r\nvoid removeItem();\r\n\r\nint main()\r\n{\r\n    inventory.count = 0;\r\n\r\n    int option;\r\n\r\n    do\r\n    {\r\n        printf(\"Grocery Inventory Management System \\n1. Add Grocery Item \\n2. List All Grocery Items \\n3. Update Quantity \\n4. Remove Grocery Item \\n5. Exit \\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n        clearInputBuffer();\r\n\r\n\r\n        switch (option)\r\n        {\r\n            case 1: //add grocery item\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                displayItems();\r\n                break;\r\n\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Thank you for using Grocery Inventory Management System. \\nExiting... \\n\");\r\n                break;\r\n\r\n            default: \r\n            printf(\"Invalid option. Please enter a valid option. \\n\");\r\n        }\r\n    } while(option != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid clearInputBuffer()\r\n{\r\n    int c;\r\n    while((c = getchar()) != '\\n' && c != EOF);\r\n}\r\n\r\nvoid addItem()\r\n{\r\n    if (inventory.count >= MAX_ITEMS) //check if the inventory is full\r\n    {\r\n        printf(\"Inventory is full! Cannot add more items. \\n\"); \r\n        return;\r\n    }\r\n\r\n    //create pointers  to point to the memory location of the new grocery item and its availability status\r\n    groceryItem *item = &inventory.items[inventory.count];  //the new item will be added at inventory.count\r\n    availabilityStatus *status = &inventory.status[inventory.count];\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(item -> name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0; //remove null terminator\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0;\r\n\r\n    do\r\n    {\r\n        printf(\"Enter quantity: \");\r\n        scanf(\"%d\", &item->quantity);\r\n        clearInputBuffer();\r\n        if (item->quantity < 0)\r\n        {\r\n            printf(\"Quantity cannot be negative. Try again.\\n\");\r\n        }\r\n    } while (item->quantity < 0);\r\n\r\n    do\r\n    {\r\n        printf(\"Enter price: \");\r\n        scanf(\"%f\", &item->price);\r\n        clearInputBuffer();\r\n        if (item->price < 0)\r\n        {\r\n            printf(\"Price cannot be negative. Try again.\\n\");\r\n        }\r\n    } while (item->price < 0);\r\n    \r\n    //update avalilability status\r\n    status->inStock = (item->quantity > 0); //if item->quantity > 0, status->inStock is set to true\r\n    status->outOfStock = !status->inStock; //if not, status->outOfStock is set to true\r\n\r\n    inventory.count++;\r\n    printf(\"Grocery item added successfully! \\n\");\r\n    \r\n}\r\n\r\nvoid displayItems()\r\n{\r\n    //check if inventory is empty\r\n    if (inventory.count == 0)\r\n    {\r\n        printf(\"No grocery items in the inventory. \\n\");\r\n        return;\r\n    }\r\n\r\n    for(int i = 0; i < inventory.count; i++)\r\n    {\r\n        groceryItem *item = &inventory.items[i]; //item points to the ith item in inventory.item arr\r\n        availabilityStatus *status = &inventory.status[i]; //status points to ith availability ststus in the inventory.status arr\r\n        \r\n        printf(\"Item %d: \\n\", i+1);\r\n        printf(\"Name: %s \\n\", item->name);\r\n        printf(\"Category: %s \\n\", item->category);\r\n        printf(\"Quantity: %d \\n\", item->quantity);\r\n        printf(\"Price: %.2f \\n\", item->price);\r\n        printf(\"Status: %s \\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity()\r\n{\r\n    char name[MAX_NAME];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory.count; i++)\r\n    {\r\n        if (strcmp(inventory.items[i].name, name) == 0)//compares the name of current inventory item with the name the user entered\r\n        {\r\n            int newQuantity; //new variable declared to hold the new quantity value for the item\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            clearInputBuffer();\r\n            inventory.items[i].quantity = newQuantity; //update the quantity of the found inventory item to the new value entered by user\r\n\r\n            //update the inStock status of the item based on the new quantity\r\n            inventory.status[i].inStock = (newQuantity > 0);\r\n            inventory.status[i].outOfStock = !inventory.status[i].inStock;\r\n\r\n            printf(\"Quantity updated successfully! \\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory. \\n\");\r\n}\r\n\r\nvoid removeItem()\r\n{\r\n    char name[MAX_NAME]; //declared to hold the name of the grocery item user wants to remove\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;\r\n\r\n    for (int i = 0; i < inventory.count; i++) //iterate through the items in the inventory array\r\n    {\r\n        if (strcmp(inventory.items[i].name, name) == 0) //compare the name of current inventory item with the item entered by user\r\n        {\r\n            for (int j = i; j < inventory.count - 1; j++) //when the item is found, this will shift the items in the inventory.items and inventory.status arrays to the left\r\n            {\r\n                inventory.items[j] = inventory.items[j + 1]; //each item at j is replaced by the item at position j+1, shifted to the left one position\r\n                inventory.status[j] = inventory.status [j + 1]; //this is also the same as above\r\n            }\r\n            inventory.count--;\r\n            printf(\"Item '%s' removed from inventory. \\n\", name);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found inventory. \\n\");\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student \r\n{\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\nStudent* createStudent(const char* name, int id, float grade)  \r\n{\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); //dynamically allocates memory for new Student node using malloc\r\n    if (newStudent == NULL)  //check if malloc is successful\r\n    {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name); //copies the name entered into the name parameter to the name field of the Student structure\r\n    newStudent->id = id; //access the id field of the new Student structure and sets the id field of the new student to the value of the id parameter\r\n    newStudent->grade = grade; //set the grade field of the new Student structire to the value of the grade parameter\r\n    newStudent->next = NULL; //initialize the next ptr of the Student struct to NULL to make sure the newly created node is not linked to any other node initially\r\n    return newStudent; //return the pointer to the newly created and initialized Student struct so can be used by other parts of the program\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nvoid sortStudents();\r\nvoid searchStudentID(int id);\r\nvoid deleteList();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records \\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) \r\n        {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                searchStudentID(id);\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) //insert new student record into the linked list\r\n{\r\n    Student* newStudent = createStudent(name, id, grade); //dynamically allocate memory and iniitializes the fields of the new node with name, id and grade and stored in newStudent\r\n    newStudent->next = head; //link the new student node to the current list\r\n    head = newStudent; //updates the head ptr to point to the new node bc the new node is inserted at the beginning of the list\r\n    printf(\"Student record inserted.\\n\");\r\n}\r\n\r\nvoid displayStudents() \r\n{\r\n    if (head == NULL) \r\n    {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    printf(\"Student Records:\\n\");\r\n    while (current != NULL) \r\n    {\r\n        printf(\"Name: %s\\nID: %d\\nGrade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n//sort student records in ascending order based on grades\r\nvoid sortStudents() //sorted using bubble sort because student records is a small dataset and can be sorted efficiently using bubble sort\r\n{\r\n    if (head == NULL || head->next == NULL)  //if the list is empty, there are no nodes to sort or, if the list has only one node, so we dont need to sort\r\n    {\r\n        printf(\"No sorting needed.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped; //flag to track whethere any elements were swapped and used to determine if the swapping is complete\r\n    Student* ptr1; //pointer to TRAVERSE the list during sorting\r\n    Student* lptr = NULL; //pointer to mark the last sorted element so we can reduce the range of traversal in each iteration\r\n    do //continue sorting until no swaps are performed\r\n    {\r\n        swapped = 0;\r\n        ptr1 = head; //reset the traversal pointer to the beginning of the list\r\n\r\n        while (ptr1->next != lptr)  //traverses the list until ptr1->next reaches lptr which is the last sorted element\r\n        {\r\n            if (ptr1->grade > ptr1->next->grade) //if grade of the current node (ptr->grade) > than grade of nect node (ptr1->next->grade), the two nodes are swapped \r\n            {\r\n                //temporarily store current node's data (ptr1) in local variables\r\n                float tempGrade = ptr1->grade; \r\n                int tempId = ptr1->id;\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n\r\n                //copy data from the next node (ptr->next) into the current node (ptr1)\r\n                ptr1->grade = ptr1->next->grade; \r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                //copy the data stored in the temp variables into the next node(ptr->next)\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempId;\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1; //update the swap flag\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n    printf(\"Student records sorted by grade using bubble sort. \\n\");\r\n}\r\n\r\nvoid searchStudentID(int id) \r\n{\r\n    Student* current = head; //a pointer current is initialized to point to the first node (head) of the linked list\r\n    while (current != NULL) \r\n    {\r\n        if (current->id == id) \r\n        {\r\n            printf(\"Student found:\\n\");\r\n            printf(\"Name: %s\\nID: %d\\nGrade: %.2f\\n\", current->name, current->id, current->grade);\r\n            return;\r\n        }\r\n        current = current->next;\r\n    }\r\n    printf(\"Student not found.\\n\");\r\n}\r\n\r\nvoid deleteList() \r\n{\r\n    Student* current = head;\r\n    while (current != NULL) \r\n    {\r\n        Student* next = current->next; //a ptr next is initialized to point to the next node in the list to make sure the reference to the rest of the linked list \r\n                                        //is not lost after the current node is deleted\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"List deleted.\\n\");\r\n}",
    "feedback": "q1-The result matrices in AddMatrix, SubtractMatrix, and TransposeMatrix functions are declared but not initialized or returned, which may lead to unintended behavior if used without being filled.\nq2-Meet requirement. \nq3-Using Bubble Sort is suitable for small datasets, as the program suggests. However, for larger datasets, you might consider more efficient algorithms like Quick Sort or Merge Sort due to Bubble Sort's O(n?) time complexity."
  },
  {
    "student_id": "20717304",
    "code": "\n/* --- 20717304_Q1.c --- */\n#include <stdio.h>\r\n\r\nvoid print_matrices(int matrix[10][10], int rows, int columns){   // function to display matrices\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            printf(\"%d \\t\", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }    \r\n\r\n}\r\n\r\nvoid construct_matrix(int matrix[10][10], int *rows, int *columns, const char *name) { // function to construct the matrix according to user input\r\n    while (1)\r\n    {\r\n        printf(\"Enter the number of rows you want in %s (max 10): \", name);\r\n        scanf(\"%d\", rows);\r\n\r\n        printf(\"Enter the number of columns you want in %s (max 10): \", name);\r\n        scanf(\"%d\", columns);\r\n\r\n        if (*rows <= 0 || *rows > 10 || *columns <= 0 || *columns > 10)\r\n        {\r\n            printf(\"Invalid number of rows or columns. Please re-enter the values.\\n\");  // validating user input\r\n            continue;\r\n        }\r\n        else\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    printf(\"Enter the elements for %s:\\n\", name);\r\n    for (int i = 0; i < *rows; i++)\r\n    {\r\n        for (int j = 0; j < *columns; j++)\r\n        {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid add_matrices(int matrix_1[10][10], int matrix_2[10][10], int rows, int columns, int sum[10][10]) { // function to add matrices ( will not work unless the dimensions of the matrices are the same)\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            sum[i][j] = matrix_1[i][j] + matrix_2[i][j];\r\n        }\r\n    }\r\n\r\n    printf(\"The sum of the Matrices :\\n\");\r\n    print_matrices(sum, rows, columns);\r\n}\r\n\r\nvoid subtract_matrices(int matrix_1[10][10], int matrix_2[10][10], int rows, int columns, int difference[10][10]) { // function to subtract matrices ( will not work unless the dimensions of the matrices are the same)\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            difference[i][j] = matrix_1[i][j] - matrix_2[i][j];\r\n        }\r\n    }\r\n\r\n    printf(\"The difference between the Matrices :\\n\");\r\n    print_matrices(difference, rows, columns);\r\n\r\n}\r\n\r\nvoid transpose(int matrix[10][10], int rows, int columns){ //  function to invert or transpose the matrices\r\n    int transpose[10][10];\r\n\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < columns; j++)\r\n        {\r\n            transpose[j][i] = matrix[i][j];\r\n        }\r\n    }  \r\n    print_matrices(transpose, rows, columns);  \r\n\r\n}\r\n\r\nint main() {\r\n    int Matrix_1[10][10];\r\n    int Matrix_2[10][10];\r\n    int sum[10][10];\r\n    int rows_1, columns_1;\r\n    int rows_2, columns_2;\r\n    int choice;\r\n\r\n    construct_matrix(Matrix_1, &rows_1, &columns_1, \"Matrix 1\");\r\n    construct_matrix(Matrix_2, &rows_2, &columns_2, \"Matrix 2\");\r\n\r\n    while (1)\r\n    {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");        // user input menu\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice)\r\n        {\r\n            case 1:\r\n                if (rows_1 == rows_2 && columns_1 == columns_2)\r\n                {\r\n                    add_matrices(Matrix_1, Matrix_2, rows_1, columns_1, sum);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Error: Matrices should be of the same dimensions for them to be added together.\\n\"); // erroe message\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rows_1 == rows_2 && columns_1 == columns_2)\r\n                {\r\n                    subtract_matrices(Matrix_1, Matrix_2, rows_1, columns_1, sum);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Error: Matrices should be of the same dimensions for them to be subtracted.\\n\"); // error message\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transpose(Matrix_1, rows_1, columns_1);\r\n                break;\r\n\r\n            case 4:\r\n                transpose(Matrix_2, rows_2, columns_2);\r\n                break;    \r\n\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Not a valid choice. Please re-enter.\\n\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- 20717304_Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include <ctype.h>\r\n\r\ntypedef struct  // struct for items \r\n{\r\n    char name[100];\r\n    char cat[50];\r\n    int qty;\r\n    float price;\r\n    bool stock_status;\r\n} groc_item;\r\n\r\ntypedef struct // struct for the whole inventory\r\n{\r\n    groc_item items[100];\r\n    int item_count;\r\n} groc_inventory;\r\n\r\nvoid add_item(groc_inventory *invtry) {  // function for adding items to the inventory with user input\r\n    if (invtry->item_count >= 100) {\r\n        printf(\"Inventory is full, more items cannot be added \\n\");\r\n        return;\r\n    }\r\n\r\n    groc_item *new_item = &invtry->items[invtry->item_count]; \r\n    getchar(); \r\n    printf(\"Enter item name : \");\r\n    scanf(\"%[^\\n]\", new_item->name);\r\n    getchar();\r\n\r\n    printf(\"Enter category : \");\r\n    scanf(\"%[^\\n]\", new_item->cat);\r\n    getchar();\r\n\r\n    printf(\"Enter quantity : \");\r\n    scanf(\"%d\", &new_item->qty);\r\n\r\n    printf(\"Enter price : \");\r\n    scanf(\"%f\", &new_item->price);\r\n\r\n    new_item->stock_status = (new_item->qty > 0); \r\n    invtry->item_count++;\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\nvoid list_items(const groc_inventory *invtry) {  // function to list details of every item from the inventory struct\r\n    if (invtry->item_count == 0) {\r\n        printf(\"Inventory is empty, there is no item to list \\n\");\r\n        return;\r\n    } \r\n\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    for (int i = 0; i < invtry->item_count; i++) {\r\n        groc_item item = invtry->items[i];\r\n        printf(\"Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.cat);\r\n        printf(\"Quantity: %d\\n\", item.qty);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\", item.stock_status ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"---------------------------------------------\\n\");  // blank line to diffrentiate between products :)\r\n    }       \r\n}\r\n\r\nvoid update_qty(groc_inventory *invtry) { // function to update quantity x\r\n    if (invtry->item_count == 0) {\r\n        printf(\"Inventory is empty, there is no item to update the quantity for\\n\");\r\n        return;\r\n    }\r\n\r\n    getchar(); \r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\"%[^\\n]\", name);\r\n    getchar();\r\n\r\n    for (int i = 0; i < invtry->item_count; i++) {\r\n        if (strcasecmp(invtry->items[i].name, name) == 0) { // strcasecmp for case insensitivty in search \r\n            printf(\"Enter new quantity for %s: \", invtry->items[i].name);\r\n            scanf(\"%d\", &invtry->items[i].qty);\r\n            if (invtry->items[i].qty < 0) {\r\n                printf(\"Enter a positive number or 0\\n\");\r\n                return;\r\n            }\r\n            invtry->items[i].stock_status = (invtry->items[i].qty > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found\\n\");\r\n}\r\n\r\nvoid remove_item(groc_inventory *invtry) { // function to remove items from the struct\r\n    if (invtry->item_count == 0) {\r\n        printf(\"Inventory is empty, there is nothing to remove\\n\");\r\n        return;\r\n    }    \r\n\r\n    getchar(); // \r\n    char name[100];\r\n    printf(\"Enter name of grocery item to remove: \");\r\n    scanf(\"%[^\\n]\", name);\r\n    getchar();\r\n\r\n    for (int i = 0; i < invtry->item_count; i++) {\r\n        if (strcasecmp(invtry->items[i].name, name) == 0) { // Case-insensitive comparison\r\n            for (int j = i; j < invtry->item_count - 1; j++) {\r\n                invtry->items[j] = invtry->items[j + 1];\r\n            }\r\n            invtry->item_count--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory\\n\");\r\n}\r\n\r\nint main() {\r\n    groc_inventory invtry;\r\n    invtry.item_count = 0;\r\n    int choice;\r\n\r\n    while (1) {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List all Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                add_item(&invtry);\r\n                break;\r\n            \r\n            case 2:\r\n                list_items(&invtry);\r\n                break;\r\n\r\n            case 3:\r\n                update_qty(&invtry);\r\n                break;\r\n\r\n            case 4:\r\n                remove_item(&invtry);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting system\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Invalid choice, please re-enter your choice\\n\");\r\n        }\r\n    }\r\n}\r\n\n/* --- 20717304_Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct stud {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct stud* next;\r\n} stud;\r\n\r\nstud* head = NULL;\r\n\r\nstud* createStudent(const char* name, int id, float grade) { // add student to struct\r\n    stud* new_stud = (stud*)malloc(sizeof(stud));\r\n    strcpy(new_stud->name, name);\r\n    new_stud->id = id;\r\n    new_stud->grade = grade;\r\n    new_stud->next = NULL;\r\n    return new_stud;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) { // insert a new student to the list\r\n    stud* new_stud = createStudent(name, id, grade);\r\n\r\n    if (head == NULL) {\r\n        head = new_stud;\r\n    } else {\r\n        stud* temp = head;\r\n        while (temp->next) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = new_stud;\r\n    }\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\nvoid displayStudents() { // display all of the students\r\n    if (head == NULL) {\r\n        printf(\"No student records found to display\\n\");\r\n        return;\r\n    }\r\n\r\n    stud* disp_node = head;\r\n    while (disp_node) {\r\n        printf(\"Name : %s\\t ID : %d\\t Grade : %.2f\\n\", disp_node->name, disp_node->id, disp_node->grade);\r\n        disp_node = disp_node->next;\r\n    }\r\n}\r\n\r\nvoid sortStudents() { // sorts students  using their ID with bubble sort \r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"No records found to sort\\n\");  // i used bubble sort because it is simple, and efficient and it is easy to execute\r\n        return;\r\n    }\r\n\r\n    stud* i;\r\n    stud* j;\r\n    for (i = head; i->next != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                char temp_name[100];\r\n                int temp_id = i->id;\r\n                float temp_grade = i->grade;\r\n\r\n                strcpy(temp_name, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, temp_name);\r\n                i->id = j->id;\r\n                j->id = temp_id;\r\n                i->grade = j->grade;\r\n                j->grade = temp_grade;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nstud* searchStudentByID(int id) {  // function to search student records by ID\r\n    stud* search = head;\r\n    while (search) {\r\n        if (search->id == id) {\r\n            printf(\"Name : %s\\t ID : %d\\t Grade : %.2f\\n\", search->name, search->id, search->grade);\r\n            return search;\r\n        }\r\n        search = search->next;\r\n    }\r\n    printf(\"Student with ID %d not found.\\n\", id);\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() { // function to clear the list\r\n    stud* current_node = head;\r\n    stud* next;\r\n\r\n    while (current_node) {\r\n        next = current_node->next;\r\n        free(current_node);\r\n        current_node = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records deleted.\\n\");\r\n}\r\n\r\nvoid freeMemory() { // extra function to clear buffer or list \r\n    deleteList();\r\n    head = NULL;\r\n    printf(\"Memory cleared\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record \\n2. Display Student Records \\n3. Sort Records \\n4. Search Record by ID\\n5. Delete List\\n6. Exit\\n\");\r\n        printf(\"Enter your choice : \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            printf(\"Enter name : \");\r\n            scanf(\" %[^\\n]\", name);\r\n\r\n            printf(\"Enter ID : \");\r\n            scanf(\"%d\", &id);\r\n\r\n            printf(\"Enter Grade : \");\r\n            scanf(\"%f\", &grade);\r\n\r\n            insertStudent(name, id, grade);\r\n            break;\r\n\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n\r\n        case 3:\r\n            sortStudents();\r\n            printf(\"Records sorted using Bubble Sort\\n\");\r\n            break;\r\n\r\n        case 4:\r\n            printf(\"Enter search ID : \");\r\n            scanf(\"%d\", &id);\r\n            searchStudentByID(id);\r\n            break;\r\n\r\n        case 5:\r\n            deleteList();\r\n            break;\r\n\r\n        case 6:\r\n            freeMemory();\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice\\n\");\r\n        }\r\n    } while (choice != 6);\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. While Bubble Sort is straightforward and suitable for small datasets, it has a time complexity of O(n?), which can be inefficient for larger lists. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20615047",
    "code": "\n/* --- Question 1.c --- */\n#include <stdio.h>\r\n\r\n// Function prototypes\r\nvoid addition(int a, int b, int ElementA[10][10], int c, int d, int ElementB[10][10]);\r\nvoid subtract(int a, int b, int ElementA[10][10], int c, int d, int ElementB[10][10]);\r\nvoid transposeA(int a, int b, int ElementA[10][10]);\r\nvoid transposeB(int c, int d, int ElementB[10][10]);\r\n\r\nint main(void) {\r\n    int a, b, c, d;\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns, max 10x10): \");\r\n    scanf(\"%d %d\", &a, &b);\r\n    while (1) {    \r\n    if (a > 10 || b > 10 || a <= 0 || b <= 0) {\r\n        printf(\"Invalid dimensions for Matrix A. Enter Again: \\n\");\r\n        scanf(\"%d %d\", &a, &b);\r\n        continue;\r\n    }\r\n    break; }\r\n\r\n    int ElementA[a][b];\r\n\r\n    // Input elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int x = 0; x < a; x++) {\r\n        for (int y = 0; y < b; y++) {\r\n            printf(\"Element [%d][%d]: \", x + 1, y + 1);\r\n            scanf(\"%d\", &ElementA[x][y]);\r\n        }\r\n    }\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns, max 10x10): \");\r\n    scanf(\"%d %d\", &c, &d);\r\n    while (1) {\r\n    if (c > 10 || d > 10 || c <= 0 || d <= 0) {\r\n        printf(\"Invalid dimensions for Matrix B. Enter Again: \\n\");\r\n        scanf(\"%d %d\", &c, &d);\r\n        continue;\r\n    }\r\n    break; }\r\n\r\n    int ElementB[c][d];\r\n\r\n    // Input elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int x = 0; x < c; x++) {\r\n        for (int y = 0; y < d; y++) {\r\n            printf(\"Element [%d][%d]: \", x + 1, y + 1);\r\n            scanf(\"%d\", &ElementB[x][y]);\r\n        }\r\n    }\r\n\r\n    int choice = 0;\r\n    do {\r\n        // Menu\r\n        printf(\"\\nMatrix Operation Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addition(a, b, ElementA, c, d, ElementB);\r\n                break;\r\n\r\n            case 2:\r\n                subtract(a, b, ElementA, c, d, ElementB);\r\n                break;\r\n\r\n            case 3:\r\n                transposeA(a, b, ElementA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeB(c, d, ElementB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add matrices\r\nvoid addition(int a, int b, int ElementA[a][b], int c, int d, int ElementB[c][d]) {\r\n    if (a != c || b != d) {\r\n        printf(\"Matrices dimensions do not match for addition.\\n\");\r\n        return;\r\n    }\r\n\r\n    int result[10][10];\r\n    printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n    for (int x = 0; x < a; x++) {\r\n        for (int y = 0; y < b; y++) {\r\n            result[x][y] = ElementA[x][y] + ElementB[x][y];\r\n            printf(\"%d \", result[x][y]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtract(int a, int b, int ElementA[a][b], int c, int d, int ElementB[c][d]) {\r\n    if (a != c || b != d) {\r\n        printf(\"Matrices dimensions do not match for subtraction.\\n\");\r\n        return;\r\n    }\r\n\r\n    int result[10][10];\r\n    printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n    for (int x = 0; x < a; x++) {\r\n        for (int y = 0; y < b; y++) {\r\n            result[x][y] = ElementA[x][y] - ElementB[x][y];\r\n            printf(\"%d \", result[x][y]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to transpose Matrix A\r\nvoid transposeA(int a, int b, int ElementA[a][b]) {\r\n    printf(\"\\nTranspose of Matrix A:\\n\");\r\n    for (int x = 0; x < b; x++) {\r\n        for (int y = 0; y < a; y++) {\r\n            printf(\"%d \", ElementA[y][x]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to transpose Matrix B\r\nvoid transposeB(int c, int d, int ElementB[c][d]) {\r\n    printf(\"\\nTranspose of Matrix B:\\n\");\r\n    for (int x = 0; x < d; x++) {\r\n        for (int y = 0; y < c; y++) {\r\n            printf(\"%d \", ElementB[y][x]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\n/* --- Question 2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Define the Grocery Item structure\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Define the Availability Status union\r\ntypedef union {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Define the Grocery Inventory structure\r\ntypedef struct {\r\n    GroceryItem items[100];\r\n    AvailabilityStatus status[100];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.itemCount = 0;\r\n    int choice;\r\n\r\n    do {\r\n        // Menu\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= 100) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    printf(\"Enter Item Name: \");\r\n    getchar(); // Consume the newline character left by previous input\r\n    fgets(item.name, sizeof(item.name), stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = '\\0'; // Remove the newline character\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, sizeof(item.category), stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = '\\0'; // Remove the newline character\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n\r\n    inventory->items[inventory->itemCount] = item;\r\n    inventory->status[inventory->itemCount].inStock = item.quantity > 0;\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their availability\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Items:\\n\");\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        GroceryItem item = inventory->items[i];\r\n        printf(\"Name: %s \\nCategory: %s \\nQuantity: %d \\nPrice: %.2f \\nStatus: %s \\n\",\r\n               item.name, item.category, item.quantity, item.price,\r\n               inventory->status[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    getchar(); // Consume the newline character left by previous inputs\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove the newline character\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcasecmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", inventory->items[i]);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            inventory->status[i].inStock = inventory->items[i].quantity > 0;\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char Deletename[100];\r\n    printf(\"Enter name of the item to remove: \");\r\n    getchar(); // Consume the newline character left by previous inputs\r\n    fgets(Deletename, sizeof(Deletename), stdin);\r\n    Deletename[strcspn(Deletename, \"\\n\")] = '\\0'; // Remove the newline character\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcasecmp(inventory->items[i].name, Deletename) == 0) {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully\\n\", Deletename);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\n/* --- Question 3.c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student; \r\n \r\nStudent* head = NULL;\r\n \r\n// Function to create a new student\r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    // Allocate memory for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL; // Return NULL on failure\r\n    }\r\n    // Copy the name, id, and grade to the new student\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL; // Initialize the next pointer to NULL\r\n    return newStudent;\r\n} \r\n \r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    // Create a new student\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) {\r\n        return; // Exit if memory allocation failed\r\n    }\r\n    // Insert the new student at the beginning of the linked list\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully.\\n\");\r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    if (!head) {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    printf(\"Student Records:\\n\");\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n} \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current; // Return if found\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // Return NULL if the student is not found\r\n} \r\n \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; // Save the next pointer\r\n        free(current); // Free the current student node\r\n        current = next; // Move to the next student node\r\n    } \r\n    head = NULL; // Set the head pointer to NULL\r\n} \r\n \r\n// Function to ensure all memory is freed before exiting\r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n// Sort function to sort the student records by grade based on an algorithm of your choice \r\nvoid sortStudents() { \r\n    // Bubble sort is chosen\r\n    if (!head || !head->next) {\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* current;\r\n    Student* last = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != last) {\r\n            if (current->grade > current->next->grade) {\r\n                // Swap the data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, current->name);\r\n                tempID = current->id;\r\n                tempGrade = current->grade;\r\n\r\n                strcpy(current->name, current->next->name);\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade;\r\n\r\n                strcpy(current->next->name, tempName);\r\n                current->next->id = tempID;\r\n                current->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n        last = current;\r\n    } while (swapped);\r\n} \r\n \r\n// Main function to drive the program \r\nint main() { \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); // Remove the newline character\r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents();                 \r\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); // Ensure all memory is freed before exiting\r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n}",
    "feedback": "q1-Meet requirement. \nq2-    In the list function, the check for empty inventory is not executed correctly. The condition to check if no items are read (fread(&new_item, sizeof(struct GroceryItem), 1, fPtr) == 0) is incorrectly placed inside the loop, leading to potential misreporting of inventory status.\n    In the update function, if the item is found and updated, it does not write the updated item back to the temporary file unless it is found in the inventory.\nq3-The program uses Selection Sort to sort student records by grade. While it is simple and easy to follow, Selection Sort has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider implementing more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20711819",
    "code": "\n/* --- 20711819_LabAssessment3/Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// give int[][] a name \"matrix\" for easir recognition\r\ntypedef int **matrix;\r\n// typedef size as int for easier reference\r\ntypedef int size;\r\n// typedef for operation type cause why not\r\ntypedef int operationType;\r\n// typedef for sentient check CAUSE WHY NOT\r\ntypedef int sentientType;\r\n\r\nenum EnumOperationType{\r\n    ADDITION = 1,\r\n    SUBTRACTION = -1\r\n};\r\n\r\nenum EnumSentientType{\r\n    CONTINUE = 1,\r\n    STOP = 0\r\n};\r\n\r\n// function to print the matrix\r\nvoid uwuPrintMatrix(matrix thisMatrix){\r\n    size row, column;\r\n\r\n    // record the size of row and column of ua matrix\r\n    row = sizeof(thisMatrix) / sizeof(size);\r\n    column = sizeof(thisMatrix[0]) / sizeof(size);\r\n\r\n    // loop and print\r\n    for (size i = 0; i < row; i++){\r\n        for (size j = 0; j < column; j++){\r\n            printf(\"%d \", thisMatrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// function to create and return a pointer to matrix\r\nmatrix createMatrix(char *matrixName){\r\n    size row = 1, column = 1; // variables for the row and column of matrix\r\n    printf(\"uwu Enter the dimensions for Matrix %s (row, column): \", matrixName); // prompt the user to enter the row and column\r\n    // loop scanf until user enter a valid row and column\r\n    for(scanf(\"%d %d\", &row, &column); (row < 1 || row > 10) || (column < 1 || column > 10) ; scanf(\"%d %d\", &row, &column)){\r\n        printf(\"Invalid row/column input, pwease try again uwu.\\n(maximum row/column: 10; minimum row/column: 1)\\n\\n\");\r\n        printf(\"uwu Enter the dimensions for Matrix %s: \", matrixName);\r\n    }\r\n\r\n    // create a new matrix\r\n    matrix uwuNewMatrix = malloc(sizeof(matrix));\r\n    // loop and prompt the user to input elements\r\n    for (size i = 0; i < row; i++){\r\n        // create a placeholder int[] for recording the element in row i\r\n        int *thisRow = malloc(sizeof(int) * column);\r\n        for (size j = 0; j < column; j++){\r\n            // read input element from user\r\n            printf(\"Element[%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &thisRow[j]);\r\n        }\r\n        // assign the row to the matrix\r\n        uwuNewMatrix[i] = thisRow;\r\n    }\r\n\r\n    return uwuNewMatrix;\r\n}\r\n\r\n// function to add 2 matrix (A + B) or subtract (A - B)\r\nmatrix uwuAddOrSubMatrix(matrix A, matrix B, operationType operation){\r\n    size ARow, AColumn, BRow, BColumn;\r\n\r\n    // record the size of row and column of A & B\r\n    ARow = sizeof(A) / sizeof(size);\r\n    AColumn = sizeof(A[0]) / sizeof(size);\r\n    BRow = sizeof(B) / sizeof(size);\r\n    BColumn = sizeof(B[0]) / sizeof(size);\r\n\r\n    // cannot add or subtract the two matrices if their size are not the same\r\n    if (ARow != AColumn || BRow != BColumn){\r\n        printf(\"Unable to add or subtract matrices with different size of row/column :<\\n\");\r\n        printf(\"Size of first matrix: %d x %d\\n\", ARow, AColumn);\r\n        printf(\"Size of second matrix: %d x %d\\n\", BRow, BColumn);\r\n        return NULL;\r\n    }else{\r\n        // create new matrix to return\r\n        matrix uwuNewMatrix = malloc(sizeof(matrix));\r\n        for (size i = 0; i < ARow; i++){\r\n            // placeholder int[] to store the current row\r\n            int *thisRow = malloc(sizeof(int) * AColumn);\r\n            for (size j = 0; j < BRow; j++){\r\n                // add the values together and store to the new row; * operation because if subtraction, operation = -1\r\n                // and A - B == A + (B*-1)\r\n                thisRow[j] = A[i][j] + (B[i][j] * operation);\r\n            }\r\n            // add the new row into the new matrix\r\n            uwuNewMatrix[i] = thisRow;\r\n        }\r\n        printf(\"Result of Matrix A %c Matrix B:\\n\", (operation ? '+' : '-'));\r\n        uwuPrintMatrix(uwuNewMatrix);\r\n        // return the matrix in case it needs to be use again\r\n        return uwuNewMatrix;\r\n    }\r\n}\r\n\r\n// function to return transpose matrix\r\nmatrix uwuTransposeMatrix(matrix thisMatrix){\r\n    size row, column;\r\n\r\n    // record the size of row and column of ua matrix\r\n    row = sizeof(thisMatrix) / sizeof(size);\r\n    column = sizeof(thisMatrix[0]) / sizeof(size);\r\n\r\n    // create new matrix to return uwu\r\n    matrix uwuNewMatrix = malloc(sizeof(matrix));\r\n\r\n    for (size i = 0; i < column; i++){\r\n        // create a int[] row placeholder\r\n        int *thisRow = malloc(sizeof(int) * row);\r\n        for (size j = 0; j < row; j++){\r\n            thisRow[j] = thisMatrix[j][i];\r\n        }\r\n        // add the new row\r\n        uwuNewMatrix[i] = thisRow;\r\n    }\r\n    uwuPrintMatrix(uwuNewMatrix);\r\n    // return the matrix in case it needs to be use again\r\n    return uwuNewMatrix;\r\n}\r\n\r\nint main(){\r\n    matrix A, B;\r\n    A = createMatrix(\"A\"); // create first matrix\r\n    B = createMatrix(\"B\"); // create second matrix\r\n    sentientType sentient = CONTINUE; // sentient check\r\n    int choice = 0;\r\n    while(sentient){\r\n        choice = 0; // choice = 0\r\n        // print options\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        // repeat until valid choice\r\n        while (choice < 1 || choice > 5){\r\n            printf(\"Invalid choice, please try again.\\n\");\r\n            printf(\"Enter your choice: \");\r\n            scanf(\"%d\", &choice);\r\n        }\r\n        // perform operation base on choice\r\n        switch(choice){\r\n            case 1:\r\n                uwuAddOrSubMatrix(A, B, ADDITION);\r\n                break;\r\n            case 2:\r\n                uwuAddOrSubMatrix(A, B, SUBTRACTION);\r\n                break;\r\n            case 3:\r\n                uwuTransposeMatrix(A);\r\n                break;\r\n            case 4:\r\n                uwuTransposeMatrix(B);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting... uwu\\n\");\r\n                sentient = STOP;\r\n                break;\r\n        }\r\n    }\r\n}\n/* --- 20711819_LabAssessment3/Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// create a typedef to reference to stock status\r\ntypedef int availabilityStatus;\r\n\r\nenum EnumAvailabilityStatus{\r\n    OUT_OF_STOCK = 0,\r\n    IN_STOCK = 1\r\n};\r\n\r\n// typedef for operation type cause why not\r\ntypedef int operationType;\r\n// typedef for sentient check CAUSE WHY NOT\r\ntypedef int sentientType;\r\n\r\nenum EnumSentientType{\r\n    CONTINUE = 1,\r\n    STOP = 0\r\n};\r\n\r\n// struct for grocery item\r\nstruct GroceryItem{\r\n    char name[101];\r\n    char category[51];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// struct for grocery inventory\r\nstruct GroceryInventory{\r\n    struct GroceryItem *itemList[100];\r\n    availabilityStatus itemAvailability[100];\r\n    int itemCount;\r\n};\r\n\r\n// function to read string\r\nvoid readString(char *storeTo){\r\n    int i = 0;\r\n    char hold = ' ';\r\n    // scanf until encounter return\r\n    for (scanf(\" %c\", &hold); hold != '\\n'; scanf(\"%c\", &hold))\r\n        storeTo[i++] = hold;\r\n    // make sure the ending char is \\0\r\n    storeTo[i] = '\\0';\r\n}\r\n\r\n// add grocery item\r\nvoid addGrocery(struct GroceryInventory *thisInventory){\r\n    struct GroceryItem *newGroceryItem = malloc(sizeof(struct GroceryItem));\r\n    printf(\"\\nAdding new item...\\n\");\r\n    printf(\"Enter item name: \");\r\n    readString(newGroceryItem->name);\r\n    printf(\"Enter category: \");\r\n    readString(newGroceryItem->category);\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newGroceryItem->quantity);\r\n    printf(\"Enter price: RM\");\r\n    scanf(\"%f\", &newGroceryItem->price);\r\n\r\n    for (int i = 0; i < 100; i++){\r\n        if (thisInventory->itemList[i] == NULL){\r\n            ((*thisInventory).itemList)[i] = newGroceryItem;\r\n            (thisInventory->itemAvailability)[i] = (newGroceryItem->quantity > 0 ? IN_STOCK : OUT_OF_STOCK);\r\n            (thisInventory->itemCount)++;\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// update quantity uwu\r\nvoid updateGroceryItemQuantity(struct GroceryInventory *thisInventory){\r\n    int hasUpdated = 0;\r\n    char updateItem[101];\r\n    printf(\"\\nUpdating grocery item's quantity...\\n\");\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    readString(updateItem);\r\n    for (int i = 0; i < 100; i++){\r\n        if (thisInventory->itemList[i] != NULL){\r\n            if (strcmp(updateItem, thisInventory->itemList[i]->name) == 0){\r\n                printf(\"Enter new quantity for %s: \", updateItem);\r\n                scanf(\"%d\", &(thisInventory->itemList[i]->quantity));\r\n                if (thisInventory->itemList[i]->quantity < 1){\r\n                    thisInventory->itemAvailability[i] = OUT_OF_STOCK;\r\n                }\r\n                hasUpdated++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (hasUpdated == 0){\r\n        printf(\"Unable to locate item '%s'...\\n\", updateItem);\r\n    }\r\n}\r\n\r\n// remove grocery item\r\nvoid removeGroceryItem(struct GroceryInventory *thisInventory){\r\n    int hasUpdated = 0;\r\n    char updateItem[101];\r\n    printf(\"\\nRemoving a grocery item...\\n\");\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    readString(updateItem);\r\n\r\n    for (int i = 0; i < 100; i++){\r\n        if (thisInventory->itemList[i] != NULL){\r\n            if (strcmp(updateItem, thisInventory->itemList[i]->name) == 0){\r\n                (thisInventory->itemList[i]) = NULL;\r\n                (thisInventory->itemAvailability[i]) = OUT_OF_STOCK;\r\n                (thisInventory->itemCount)--;\r\n                hasUpdated++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (hasUpdated == 0){\r\n        printf(\"Unable to locate item '%s'...\\n\", updateItem);\r\n    }\r\n}\r\n\r\n// function to print all items in grocery inventory\r\nvoid printGroceryInventory(struct GroceryInventory *thisInventory){\r\n    int itemPrint = 0;\r\n    printf(\"\\nPrinting all items in grocery inventory...\\n\");\r\n    for (int i = 0; i < 100; i++){\r\n        if (thisInventory->itemList[i] != NULL){\r\n            printf(\"_________________________\\n\");\r\n            printf(\"Item %d\\n\", ++itemPrint);\r\n            printf(\"Name: %s\\n\", thisInventory->itemList[i]->name);\r\n            printf(\"Category: %s\\n\", thisInventory->itemList[i]->category);\r\n            printf(\"Quantity: %d\\n\", thisInventory->itemList[i]->quantity);\r\n            printf(\"Price: RM%.2f\\n\", thisInventory->itemList[i]->price);\r\n            printf(\"Status: %s\\n\", (thisInventory->itemAvailability[i] == IN_STOCK ? \"In stock\" : \"Out of stock\"));\r\n        }\r\n    }\r\n}\r\n\r\nint main(){\r\n    struct GroceryInventory myGroceryInventory = {{}, {}, 0}; // variable for grocery inventory\r\n    sentientType sentient = CONTINUE; // sentient check\r\n    int choice = 0;\r\n    while(sentient){\r\n        choice = 0; // choice = 0\r\n        // print options\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add grocery item\\n\");\r\n        printf(\"2. List all grocery items\\n\");\r\n        printf(\"3. Update quantity\\n\");\r\n        printf(\"4. Remove grocery item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        // repeat until valid choice\r\n        while (choice < 1 || choice > 5){\r\n            printf(\"Invalid choice, please try again.\\n\");\r\n            printf(\"Enter your choice: \");\r\n            scanf(\"%d\", &choice);\r\n        }\r\n        // perform operation base on choice\r\n        switch(choice){\r\n            case 1:\r\n                addGrocery(&myGroceryInventory);\r\n                break;\r\n            case 2:\r\n                printGroceryInventory(&myGroceryInventory);\r\n                break;\r\n            case 3:\r\n                updateGroceryItemQuantity(&myGroceryInventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&myGroceryInventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting... uwu\\n\");\r\n                sentient = STOP;\r\n                break;\r\n        }\r\n    }\r\n}\n/* --- 20711819_LabAssessment3/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// student structure\r\nstruct UwUstudent{\r\n    char name[101];\r\n    char id[101];\r\n    float grade;\r\n};\r\n\r\n// struct uwu node for linked list\r\nstruct UwUNode{\r\n    struct UwUstudent* student; // point to a student struct\r\n    struct UwUNode *next; // point to next node\r\n};\r\n\r\nstruct UwUNode *head = NULL; // head node\r\n\r\n// create a new node uwu\r\nstruct UwUNode* createNode(char *name, char *id, float grade){\r\n    struct UwUNode *newNode = (struct UwUNode*)malloc(sizeof(struct UwUNode)); // create a new node pointer\r\n    struct UwUstudent *newStudent = (struct UwUstudent*)malloc(sizeof(struct UwUstudent)); // create a new student object\r\n    \r\n    int i = 0;\r\n    // copy the char in name to newStudent's name\r\n    for (; name[i] != '\\0'; i++)\r\n        newStudent->name[i] = name[i];\r\n    newStudent->name[i] = '\\0';\r\n\r\n    int j = 0;\r\n    // copy the char in id to newStudent's id\r\n    for (; id[j] != '\\0'; j++)\r\n        newStudent->id[j] = id[j];\r\n    newStudent->id[j] = '\\0';\r\n\r\n    newStudent->grade = grade;\r\n    newNode->student = newStudent;\r\n    return newNode;\r\n}\r\n\r\n// insert the node to linked list\r\nvoid insertNode(char *name, char *id, float grade){\r\n    struct UwUNode *newNode = (struct UwUNode*)malloc(sizeof(struct UwUNode));\r\n    newNode = createNode(name, id, grade);\r\n    newNode->next = head; // point to the current head\r\n    head = newNode; // the new node becomes the new head\r\n}\r\n\r\n// function to display the student record in linked list\r\nvoid displayLinkedList(){\r\n    struct UwUNode *temp = head; // temp to traverse through the linked list\r\n    while (temp != NULL){\r\n        printf(\"Name: %s, ID: %s, Grade: %.2f\\n\", temp->student->name, temp->student->id, temp->student->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// function to sort the linked list\r\nvoid sortLinkedList(){\r\n    struct UwUNode *temp = head; // temp to traverse through the linked list\r\n    int count = 0;\r\n    while (temp != NULL){\r\n        count++;\r\n        temp = temp->next;\r\n    }\r\n    struct UwUstudent **hold = (struct UwUstudent**)malloc(sizeof(struct UwUstudent) * count);\r\n    struct UwUstudent *hold2 = (struct UwUstudent*)malloc(sizeof(struct UwUstudent));\r\n    temp = head;\r\n    for (int i = 0; i < count; i++){\r\n        hold[i] = temp->student;\r\n        temp = temp->next;\r\n    }\r\n\r\n    for (int i = 0; i < count; i++){ // bubble sort cause I was slacking and do it last minute and didnt go on to do my research, teehee\r\n        for (int j = 0; j < count-1; j++){\r\n            if (hold[j]->grade > hold[j+1]->grade){\r\n                hold2 = hold[j+1];\r\n                hold[j+1] = hold[j];\r\n                hold[j] = hold2;\r\n            }\r\n        }\r\n    }\r\n\r\n    temp = head;\r\n    int i = 0;\r\n    while (temp != NULL){\r\n        temp->student = hold[i++];\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// search record by id\r\nvoid searchStudent(){\r\n    int printed = 0;\r\n    char hold[101];\r\n    printf(\"\\nSearching student by ID...\\n\");\r\n    printf(\"Please enter the student's ID: \");\r\n    scanf(\"%s\", hold);\r\n\r\n    struct UwUNode *temp = head; // temp to traverse through the linked list\r\n    while (temp != NULL){\r\n        if (strcmp(hold, temp->student->id) == 1){\r\n            printf(\"Found studnet!\\n\");\r\n            printf(\"Name: %s, ID: %s, Grade: %.2f\\n\", temp->student->name, temp->student->id, temp->student->grade);\r\n            printed++;\r\n            break;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    if (printed == 0)\r\n        printf(\"No record of %s found.\\n\", hold);\r\n}\r\n\r\n// delete the list\r\nvoid deleteList(){\r\n    struct UwUNode *temp = head; // temp to traverse through the linked list\r\n    while (head != NULL){\r\n        temp = head;\r\n        head = head->next;\r\n        free(temp);\r\n    }\r\n}\r\n\r\nint main(){\r\n    int choice, i, j;\r\n    char name[101], id[101], hold;\r\n    float grade;\r\n    do{\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        i = 0;\r\n        j = 0;\r\n        switch (choice){\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                for (scanf(\" %c\", &hold); hold != '\\n'; scanf(\"%c\", &hold))\r\n                    name[i++] = hold;\r\n                name[i] = '\\0';\r\n                printf(\"Enter ID: \");\r\n                for (scanf(\" %c\", &hold); hold != '\\n'; scanf(\"%c\", &hold))\r\n                    id[j++] = hold;\r\n                id[j] = '\\0';\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertNode(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayLinkedList();\r\n                break;\r\n            case 3:\r\n                sortLinkedList();\r\n                printf(\"Sorted list:\\n\");\r\n                displayLinkedList();\r\n                break;\r\n            case 4:\r\n                searchStudent();\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice, please try again!\");\r\n                break;\r\n        }\r\n    }while(choice != 6);\r\n}",
    "feedback": "q1-The way matrix dimensions are calculated using sizeof will not work as intended for dynamically allocated matrices. You need to pass dimensions explicitly.Memory allocation for the matrix should be done correctly to ensure space is allocated for both rows and columns.\nq2-Meet requirement. \nq3-in the searchStudent function where the condition strcmp(hold, temp->student->id) == 1 should be strcmp(hold, temp->student->id) == 0 for successful ID matching.) \n    The program uses bubble sort to sort student records by grade. While bubble sort is simple, it has a time complexity of O(n?), which may not be efficient for large datasets. For better performance, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20714680",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n\r\nvoid addMatrices(int A[10][10], int B[10][10], int result[10][10], int row, int column) { //defining function for adding matrices\r\n            for(int i = 0; i<row; i++) {\r\n                for(int j = 0; j<column; j++) {\r\n                    result[i][j] = A[i][j] + B[i][j];   //Each element of matrix A is added to corresponding element of matrix B and answer is stored in result matrix\r\n                }\r\n            }\r\n}\r\n\r\nvoid subtractMatrices(int A[10][10], int B[10][10], int result[10][10], int row, int column) {    //defining function for subtracting matrices\r\n            for(int i = 0; i<row; i++) {\r\n                for(int j = 0; j<column; j++) {\r\n                    result[i][j] = A[i][j] - B[i][j];   //Each element of matrix B is subtracted from corresponding element of matrix A and answer is stored in result matrix\r\n                }\r\n            }\r\n}\r\n\r\nvoid transposeA(int A[10][10], int result[10][10], int row, int column) {       //defining function for transpose of matrix A\r\n            for(int i = 0; i<row; i++) {\r\n                for(int j = 0; j<column; j++) {\r\n                   result[j][i] = A[i][j];  //swap the row and column indices\r\n                }\r\n            }\r\n}\r\n\r\nvoid transposeB(int B[10][10], int result[10][10], int row, int column) {       //defining function for transpose of matrix B\r\n            for(int i = 0; i<row; i++) {\r\n                for(int j = 0; j<column; j++) {\r\n                   result[j][i] = B[i][j];  //swap the row and column indices\r\n                }\r\n            }\r\n}\r\n\r\nvoid printMatrix(int matrix[10][10], int row, int column) {   //defining function for printing each element of resultant matrix\r\n    for (int i = 0; i < row; i++) {\r\n        for (int j = 0; j < column; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n\r\nint main(void) {\r\n    int rowA, columnA;\r\n    int A[10][10];\r\n    int rowB, columnB;\r\n    int B[10][10];\r\n    int result[10][10];\r\n    int choice = 0;\r\n\r\n    printf(\"Enter the dimensions for matrix A (rows and columns): \");       //Prompt the user to enter dimensions for matrix A\r\n    scanf(\" %d%d\", &rowA, &columnA);\r\n\r\n    for(int i = 0; i<rowA; i++) {\r\n        for(int j = 0; j<columnA; j++) {\r\n            printf(\"Element [%d][%d]: \", i+1, j+1);\r\n            scanf(\"%d\", &A[i][j]);\r\n        }\r\n    }\r\n\r\n    printf(\"Enter the dimensions for matrix B (rows and columns): \");       //Prompt the user to enter dimensions for matrix B\r\n    scanf(\" %d%d\", &rowB, &columnB);\r\n\r\n    for(int a = 0; a<rowB; a++) {\r\n        for(int b = 0; b<columnB; b++) {\r\n            printf(\"Element [%d][%d]: \", a+1, b+1);\r\n            scanf(\"%d\", &B[a][b]);\r\n        }\r\n    }\r\nwhile(choice!=5)    {\r\n    printf(\"Matrix Operations Menu:\\n1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n5. Exit\\n\");\r\n    printf(\"Enter your choice:\");\r\n    scanf(\"%d\", &choice);   //Stores the number entered by user\r\n\r\n    switch (choice) {       //Used switch case to control loop\r\n        case 1:\r\n            if (rowA==rowB && columnA==columnB) {           //Checks whether matrix A and matrix B have same number of rows and columns\r\n                addMatrices( A, B, result, rowA, columnA);      //call the addMatrices function to add each element of matrix A to corresponding element of matrix B\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(result, rowA, columnA);     //call the printMatrix function to display the resultant matrix after adding both matrices\r\n            } else {\r\n                printf(\"Please enter valid dimensions for matrices\");   //Gives error message when matrix A and matrix B dont have same number of rows and columns\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            if (rowA==rowB && columnA==columnB) {           //Checks whether matrix A and matrix B have same number of rows and columns\r\n                subtractMatrices( A, B, result, rowA, columnA);    //call the subtractMatrices function to subtract each element of matrix A with corresponding element of matrix B\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                printMatrix(result, rowA, columnA);      //call the printMatrix function to display the resultant matrix after subtracting both matrices\r\n            } else {\r\n                printf(\"Please enter valid dimensions for matrices\");   //Gives error message when matrix A and matrix B dont have same number of rows and columns\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            transposeA(A, result, rowA, columnA);     //call the transposeA function to perform transpose of matrix A\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(result, rowA, columnA);     //call the printMatrix function to display the resultant matrix after transpose of matrix A\r\n            break;\r\n\r\n        case 4:\r\n            transposeB(B, result, rowB, columnB);    //call the transposeB function to perform transpose of matrix B\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(result, rowB, columnB);     //call the printMatrix function to display the resultant matrix after transpose of matrix B\r\n            break;\r\n\r\n        case 5:\r\n            printf(\"Exiting...\\n\");     //If user enters five, exit the loop\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice! Please enter a number from 1 to 5\");    //Gives error message when user enters invalid input\r\n        }\r\n    }\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\nstruct groceryItem {        //defining a struct which stores infromation about the grocery item\r\n    char Name[100];\r\n    char Category[50];\r\n    int Quantity;\r\n    float Price;\r\n};\r\n\r\nstruct availabilityStatus {     //defining a struct to store information about the availability status of the grocery item\r\n    bool inStock;           //Returns true if item is in stock\r\n    bool outofStock;        //Returns true if item is not in stock\r\n};\r\n\r\nstruct groceryInventory {\r\n    struct groceryItem items[100];      //Array of grocery items\r\n    struct availabilityStatus status[100];      //Array of availability status\r\n    int totalCount;     //Stores the total number of grocery items\r\n};\r\n\r\nvoid addGroceryItem (struct groceryInventory *inventory) {      //defining a function to add new grocery item\r\n    if (inventory->totalCount >= 100) {\r\n        printf(\"The inventory is full!\\n\");     //Gives error message if total count exceeds 100\r\n        return;\r\n    }\r\n    struct groceryItem newItem;     //initializing struct groceryItem variable to store all information of the new item added\r\n    printf(\"Enter Item name: \");\r\n    scanf(\"%s\", newItem.Name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\"%s\", newItem.Category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.Quantity);\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &newItem.Price);\r\n    printf(\"Item added successfully!\\n\");\r\n\r\n    inventory->items[inventory->totalCount] = newItem;      //This adds the new item to the inventory\r\n    // Update the availability status\r\n    inventory->status[inventory->totalCount].inStock = newItem.Quantity > 0;    //If the quantity is greater than zero, then the inStock field of the status array at index i is set to true otherwise false\r\n    inventory->status[inventory->totalCount].outofStock = newItem.Quantity == 0;    //If the quantity is exactly zero, then the outofStock field of the status array at index i is set to true otherwise false\r\n    inventory->totalCount++;    //This increments the total count of grocery items by 1 when new item is added\r\n    \r\n}\r\n\r\nvoid listGroceryItems(struct groceryInventory *inventory) {     //function to list all grocery items with their name, category, quantity, price and availability status\r\n    for (int i = 0; i < inventory->totalCount; i++) {\r\n        struct groceryItem item = inventory->items[i];  //Initializing a struct variable of type groceryItem and assigning it to element at index i of items array in the inventory structure\r\n        struct availabilityStatus status = inventory->status[i]; //Initializing a struct variable of type availabilityStatus and assigning it to element at index i of status array in the inventory structure\r\n        printf(\"Name: %s\\n\", item.Name);\r\n        printf(\"Category: %s\\n\", item.Category);\r\n        printf(\"Quantity: %d\\n\", item.Quantity);\r\n        printf(\"Price: %.2f\\n\", item.Price);\r\n        if(status.inStock) {\r\n            printf(\"Status: In stock\\n\");\r\n        } else {\r\n            printf(\"Status: Out of stock\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid updateQuantity (struct groceryInventory *inventory) {  //function to update the quantity of a grocery item\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");  //Prompts the user to enter grocery item name\r\n    scanf(\" %s\", itemName);     //Stores the name of the grocery item entered by user\r\n\r\n    for (int i = 0; i<inventory->totalCount ; i++) {\r\n        if(strncmp(inventory->items[i].Name, itemName , strlen(itemName)) == 0) {   //strncmp compares the size of item entered by user with other grocery items in the list\r\n            printf(\"Enter new quantity for %s:\", itemName);\r\n            scanf(\"%d\", &inventory->items[i].Quantity);\r\n            inventory->status[i].inStock = inventory->items[i].Quantity > 0;    //If the quantity is greater than zero, then the inStock field of the status array at index i is set to true otherwise false\r\n            inventory->status[i].outofStock = inventory->items[i].Quantity == 0;    //If the quantity is exactly zero, then the outofStock field of the status array at index i is set to true otherwise false\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"The item doesnt exist in the list!\\n\");     //Gives error message when item name entered by user doesnt match with any of the grocery items in the list\r\n}\r\n\r\nvoid removeGroceryItem (struct groceryInventory *inventory) {   //function to delete a grocery item from the list\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to remove: \");   //Prompts the user to enter grocery item name\r\n    scanf(\" %s\", itemName);     //Stores the name of the grocery item entered by user\r\n\r\n\r\n    for (int i = 0; i<inventory->totalCount ; i++) {\r\n        if(strncmp(inventory->items[i].Name, itemName , strlen(itemName)) == 0) {   //strncmp compares the size of item entered by user with other grocery items in the list\r\n            for (int j = i; j < inventory->totalCount - 1; j++) {   //The loop starts at the index i (the position of the item to be removed) and goes up to inventory->totalCount - 1\r\n                inventory->items[j] = inventory->items[j + 1];  //This moves the item one position (index) to the left of the array\r\n                inventory->status[j] = inventory->status[j + 1];      //This moves the status one position (index) to the left of the array\r\n            }\r\n        inventory->totalCount--;    //This reduces the total count of grocery items by 1 after removing an item\r\n        printf(\"Item has been removed successfully!\\n\");\r\n        return;\r\n        }\r\n    }\r\n    printf(\"The item doesnt exist in the list!\\n\");     //Gives error message when item name entered by user doesnt match with any of the grocery items in the list\r\n}\r\n\r\nint main(void) {\r\n    struct groceryInventory inventory;    //Initializing a struct variable \r\n    inventory.totalCount = 0;   //Setting total count to 0 means that initially there were no any grocery item\r\n    int choice;\r\n\r\n    while (choice!=5) {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n2. List All Grocery Items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n        printf(\"Enter your choice:\");       //Prompts the user to enter a number of his/her choice\r\n        scanf(\"%d\", &choice);       //Stores the number entered by user\r\n\r\n        switch(choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);     //calling the addGroceryItem function to add a new item to the list\r\n                break;\r\n\r\n            case 2:\r\n                listGroceryItems(&inventory);   //calling the listGroceryItems function to display all the items in the list\r\n                break;\r\n\r\n            case 3:\r\n                updateQuantity(&inventory);     //calling the updateQuantity function to update the quantity of an item in the list\r\n                break;\r\n\r\n            case 4:\r\n                removeGroceryItem(&inventory);  //calling the removeGrocery function to delete an item in the list\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");     //Exits the loop\r\n                break;\r\n\r\n            default:\r\n                printf(\"You have entered an invalid choice! Please enter a number from 1 to 5\");       //Gives error message if user enters invalid input\r\n        }\r\n    } \r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n\r\n// Structure for Student \r\ntypedef struct Student {    //defining the struct Student for storing student records\r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n    }Student; \r\n\r\nStudent* head = NULL;   //declaring a pointer to the struct Student and initializing it to NULL\r\n\r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    //Allocate node \r\n    Student *new_student = (Student*) malloc(sizeof(Student)); //determines the size of Student structure, allocates memory of that number of bytes and stores a pointer to the allocated memory in the pointer new_student\r\n    //Put in the information\r\n    strncpy(new_student->name, name, strlen(name));\r\n    new_student->id = id;\r\n    new_student->grade = grade;\r\n    new_student->next = NULL;\r\n    return new_student;\r\n} \r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) {\r\n     Student *new_student = createStudent(name, id, grade);     //This creates a new node by calling the function and assigning it to the pointer new_student\r\n     new_student->next = head;  //This makes the next pointer of the new_student node to point to the head i.e the beginning of the list\r\n     head = new_student;    //head is now pointing to the new node\r\n} \r\n\r\n// Function to display all student records \r\nvoid displayStudents() {\r\n     Student* current = head;   //declaring a pointer current of type Student and initializing it to head \r\n     //Traverse through the linked list\r\n     while (current != NULL) {\r\n        printf(\"Name: %s\\n\", current->name);\r\n        printf(\"ID: %d\\n\", current->id);\r\n        printf(\"Grade: %.2f\\n\", current->grade);\r\n        current = current->next;    //This line accesses the next pointer of current node. Hence, updates current to point to next node in the linked list\r\n    } \r\n}\r\n\r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;     //declaring a pointer current of type Student and initializing it to head\r\n    //Traverse through the linked list\r\n    while(current!=NULL) {\r\n        if(current->id == id) {     //This checks if the current node in the linked list has the same id as the id being searched for\r\n            return current;         //Returns a pointer to the node containing the specified id\r\n        }\r\n        current = current->next;    //This line accesses the next pointer of current node. Hence, updates current to point to next node in the linked list\r\n    } \r\n    return NULL;    //If no node with the specified id is found, it returns NULL\r\n} \r\n\r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head;    //declaring a pointer current of type Student and initializing it to head\r\n    Student* next;      //declaring a pointer next of type Student\r\n    //Traverse through the linked list\r\n    while (current != NULL) { \r\n        next = current->next;   //This accesses the next pointer of the current node and sets next to point to the next node in the linked list\r\n        free(current);      //deallocate memory\r\n        current = next;     //updates current to the next node in the linked list\r\n    } \r\n    head = NULL;    //This sets the head pointer to NULL after everything has been deleted\r\n}\r\n\r\nvoid freeMemory() { \r\n    deleteList();   //This deletes the entire linked list to deallocate memory to prevent memory leaks\r\n} \r\n\r\n//function to swap information stored in two nodes\r\nvoid swap(Student* student1, Student* student2) {\r\n    char hold_Name[50];\r\n    strcpy(hold_Name, student1->name);\r\n    strcpy(student1->name, student2->name);\r\n    strcpy(student2->name, hold_Name);\r\n\r\n    int hold_ID = student1->id;\r\n    student1->id = student2->id;\r\n    student2->id = hold_ID;\r\n\r\n    float hold_Grade = student1->grade;\r\n    student1->grade = student2->grade;\r\n    student2->grade = hold_Grade;\r\n}\r\n\r\n//Used bubble sort to sort the student records because it simple and easy to understand and implement\r\nvoid sortStudents() {\r\n    int swapped, i;\r\n    Student *ptr1;  //declaring a pointer ptr1 of type Student\r\n    Student *lptr = NULL;   //declaring a pointer lptr of type Student and intializing it to NULL\r\n    if (head == NULL) {     //This checks if the list is empty\r\n        return;\r\n    }\r\n\r\n    do\r\n    {  \r\n        swapped = 0;  \r\n        ptr1 = head;    //This sets the ptr1 to point to head of the linked list\r\n  \r\n        while (ptr1->next != lptr) { //The loop continues to run as long as ptr1->next is not equal to lptr\r\n            if (ptr1->grade > ptr1->next->grade) {  //If the grade in previous node is larger than the grade in next node\r\n                swap(ptr1, ptr1->next); //call the swap function\r\n                swapped = 1;    //This sets swapped to 1 to show that a swap has been made\r\n            }\r\n            ptr1 = ptr1->next;  //Updates the ptr1 to point to the next node\r\n        }\r\n        lptr = ptr1;    //Updates the lptr to point to ptr1\r\n    } while (swapped);\r\n}   \r\n\r\n// Main function to drive the program \r\nint main() { \r\n    //Initializing variables\r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n\r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n\r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade);     //call the function to insert a new student record\r\n                break; \r\n            case 2: \r\n                displayStudents();      //call the function to display all student records\r\n                break; \r\n            case 3: \r\n                sortStudents();     //call the sortStudents function to arrange the students records\r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id);     //call the function to search a student record with specific ID\r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\");\r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList();       //call the function to delete the records\r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory();   //call the function to free the allocated memory\r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\");  //Gives error if user enters invalid input\r\n            } \r\n        } while (choice != 6); \r\n    return 0; \r\n} ",
    "feedback": "q1-Meet requirement. \nq2-The variable choice in main() is uninitialized before being used in the condition of the while loop. This can lead to undefined behavior. It should be initialized to a default value, such as 0.\nq3-The program uses Bubble Sort to sort student records by grade. While this algorithm is simple and easy to implement, it has a time complexity of O(n?), making it inefficient for larger datasets. For better performance, consider implementing a more efficient algorithm such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20713670",
    "code": "\n/* --- Q1.c --- */\n\r\n#include <stdio.h>\r\n#define MAX 10\r\n\r\nvoid inputmatrix(int rows,int cols,int matrix[rows][cols],char name){\r\n    printf(\"Enter elements of Matrix %c (%dx%d):\\n\",name,rows,cols);\r\n    for(int i=0;i<rows;i++){\r\n        for(int j=0; j <cols;j++) {\r\n            printf(\"Matrix%c[%d][%d]:\",name,i,j);\r\n            scanf(\"%d\",&matrix[i][j]);\r\n        }//get matrix from user\r\n    }\r\n}\r\nvoid printmatrix(int rows,int cols,int matrix[rows][cols]){\r\n    for(int i=0;i<rows;i++){\r\n        for(int j=0;j<cols;j++){\r\n            printf(\"%d \",matrix[i][j]);\r\n        }//print matrix\r\n        printf(\"\\n\");/*when I printed, I noticed that \r\n        the output only had one column, so I thought, \r\n        I should probably add a newline when printing*/\r\n    }\r\n}\r\nvoid addmatrices(int rows,int cols,int A[rows][cols],int B[rows][cols],int result[rows][cols]){\r\n    for(int i=0;i<rows;i++)\r\n        for(int j = 0;j<cols;j++)\r\n            result[i][j]=A[i][j]+B[i][j];\r\n}//this is the addition between matrices\r\nvoid subtractmatrices(int rows,int cols,int A[rows][cols], int B[rows][cols],int result[rows][cols]){\r\n    for(int i=0;i<rows;i++)\r\n        for(int j=0; j<cols;j++)\r\n            result[i][j]=A[i][j]-B[i][j];\r\n}//this is the subtraction between matrices\r\nvoid transposematrix(int rows,int cols,int matrix[rows][cols],int transposed[cols][rows]){\r\n    for(int i=0;i<rows;i++)\r\n        for(int j=0;j<cols;j++)\r\n            transposed[j][i]=matrix[i][j];\r\n}//this is the matrix transpose\r\nint main() {\r\n    int rows,cols,choice;\r\n    int A[MAX][MAX],B[MAX][MAX],result[MAX][MAX];\r\n\r\n    printf(\"Enter dimensions of matrices(rows and columns):\");\r\n    scanf(\"%d %d\",&rows,&cols);\r\n\r\n    inputmatrix(rows,cols,A,'A');\r\n    inputmatrix(rows,cols,B,'B');\r\n\r\n    do{\r\n        printf(\"\\nMenu:\\n1.Add Matrices\\n2.Subtract Matrices\\n3.Transpose Matrix A\\n4.Transpose Matrix B\\n5.Exit\\n\");\r\n        printf(\"Choose an option:\");\r\n        scanf(\"%d\", &choice);//provide choices\r\n\r\n        switch(choice){//specific choices\r\n            case 1:\r\n                addmatrices(rows,cols,A,B,result);\r\n                printf(\"Result of Addition:\\n\");\r\n                printmatrix(rows,cols,result);\r\n                break;//add\r\n            case 2:\r\n                subtractmatrices(rows,cols,A,B,result);\r\n                printf(\"Result of Subtraction:\\n\");\r\n                printmatrix(rows,cols,result);\r\n                break;//sub\r\n            case 3:\r\n                transposematrix(rows,cols,A,result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printmatrix(cols,rows,result);\r\n                break;//transpose A\r\n            case 4:\r\n                transposematrix(rows,cols,B,result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printmatrix(cols,rows,result);\r\n                break;//transpose B\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice,try again.\\n\");\r\n        }\r\n    }\r\n    while(choice!= 5);//do while \r\n\r\n    return 0;\r\n}\r\n\r\n\n/* --- Q2.c --- */\n\n#include <stdio.h>\n#define MAX_ITEMS 100 \n\n\ntypedef struct {\n    char name[100]; \n    int quantity;   \n    float price;    \n} groceryitem;\n\n//add groceryitem\nvoid add(groceryitem inventory[], int *itemcount) {\n    printf(\"Enter item name: \");\n    scanf(\"%s\", inventory[*itemcount].name);\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &inventory[*itemcount].quantity);\n    printf(\"Enter price: \");\n    scanf(\"%f\", &inventory[*itemcount].price);\n    (*itemcount)++;\n    printf(\"Item added!\\n\");\n}\n\n// list groceryitem\nvoid list(groceryitem inventory[], int itemcount) {\n    if (itemcount == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n    for (int i = 0; i < itemcount; i++) {\n        printf(\"Item %d: %s - Quantity: %d, Price: $%.2f\\n\", i + 1, inventory[i].name, inventory[i].quantity, inventory[i].price);\n    }\n}\n\n//update groceryitem\nvoid update(groceryitem inventory[], int itemcount){\n    int index, quantity;\n    printf(\"Enter item number to update (1 to %d): \", itemcount);\n    scanf(\"%d\", &index);\n    if (index < 1 || index > itemcount) {\n        printf(\"Invalid item number!\\n\");\n        return;\n    }\n    printf(\"Enter new quantity: \");\n    scanf(\"%d\", &quantity);\n    inventory[index - 1].quantity = quantity;\n    printf(\"Quantity updated!\\n\");\n}\n\n// Remove grocery items\nvoid Remove(groceryitem inventory[], int *itemcount){\n    int index;\n    printf(\"Enter item number to remove (1 to %d): \",*itemcount);\n    scanf(\"%d\",&index);\n    if(index<1 || index> *itemcount){\n        printf(\"Invalid item number!\\n\");\n        return;\n    }\n    for(int i = index-1; i < *itemcount - 1; i++){\n        inventory[i] = inventory[i + 1];//move items at the back to the front\n    }\n    (*itemcount)--;//decrease item count by one\n    printf(\"Item removed!\\n\");\n}\n\nint main(){\n    groceryitem inventory[MAX_ITEMS]; // Define inventory array\n    int itemcount = 0; // initialization\n    int choice;\n\n    do {\n        printf(\"\\nMenu:\\n1.add item\\n2.list items\\n3.update quantity\\n4.remove item\\n5.exit\\nenter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice){\n            case 1:\n                if (itemcount < MAX_ITEMS)\n                    add(inventory, &itemcount);\n                else\n                    printf(\"Inventory is full!\\n\");\n                break;\n            case 2:\n                list(inventory, itemcount);\n                break;\n            case 3:\n                update(inventory, itemcount);\n                break;\n            case 4:\n                \n                Remove(inventory, &itemcount);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice, try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n\n\n/* --- Q3.c --- */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL; \nStudent* createstudent(const char* name, int id, float grade) {\n    Student* newstudent = (Student*)malloc(sizeof(Student));\n    strcpy(newstudent->name, name);\n    newstudent->id = id;\n    newstudent->grade = grade;\n    newstudent->next = NULL;\n    return newstudent;// create student node\n}\n\n\nvoid insertstudent(const char* name, int id, float grade) {\n    Student* newstudent = createstudent(name, id, grade);\n    newstudent->next = head; // Insert into the head of the linked list\n    head = newstudent;\n    printf(\"Student added!\\n\");\n}\n\n\nvoid displaystudents() {//display all student records\n    Student* temp = head;\n    if (!temp) {\n        printf(\"No students found.\\n\");\n        return;\n    }\n    while (temp) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// bubble sort\nvoid sortstudents() {\n    if (!head || !head->next) return; // only one，no need sort\n\n    int swapped;\n    do {\n        swapped = 0;\n        Student *current = head, *prev = NULL;\n        while (current->next) {//If the score of the current node is greater than the score of the next node, exchange the two nodes.\n            if (current->grade > current->next->grade) {\n                Student* temp = current->next;\n                current->next = temp->next;\n                temp->next = current;\n                if (prev) prev->next = temp;\n                else head = temp;\n                swapped = 1;\n            }\n            prev = current;\n            current = current->next;\n        }\n    } while (swapped);\n    printf(\"Students sorted by grade.\\n\");\n}\n\n// search students by student number\nvoid searchstudentbyID(int id) {\n    Student* temp = head;\n    while (temp) {\n        if (temp->id == id) {\n            printf(\"Found:Name:%s,ID:%d,Grade:%.2f\\n\",temp->name,temp->id,temp->grade);\n            return;\n        }\n        temp = temp->next;\n    }\n    printf(\"Student with ID %d not found.\\n\", id);\n}\n\n// delete student information\nvoid deletelist() {\n    Student* temp;\n    while (head) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n    printf(\"All students deleted.\\n\");\n}\n\nint main() {\n    int choice, id;\n    float grade;\n    char name[100];\n\n    do{\n        printf(\"\\nmenu:\\n1.add student\\n2.display students\\n3.sort students by grade\\n4.search student by ID\\n5.delete all records\\n6.exiting\\nenter your choice:\");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                printf(\"enter Name: \");\n                scanf(\"%s\", name);\n                printf(\"enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertstudent(name, id, grade);\n                break;\n            case 2:\n                displaystudents();\n                break;\n            case 3:\n                sortstudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                searchstudentbyID(id);\n                break;\n            case 5:\n            deletelist();\n            break;\n            case 6:\n                deletelist();\n                printf(\"Exiting...\\n\");\n                break;\n            \n            default:\n                printf(\"Invalid choice, try again.\\n\");\n            }\n            \n        }\n     while(choice!=6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-   The bubble sort implementation correctly sorts student records by grade. While bubble sort is simple and easy to understand, its O(n?) time complexity can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance with larger lists."
  },
  {
    "student_id": "20705519",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXROW 10\n#define MAXCOL 10\n\n// prototype declaration\nint initMatrices ();\nvoid displaymatrices ( int matrixDisplay[MAXROW][MAXCOL], int rows, int cols);\nvoid addmatrices ();\nvoid subtractmatrices ();\nvoid transposeMatrix ( int targetMatrix [MAXROW][MAXCOL], char matrixLetter);\n\n// global variable declaration\nint rowA, colA, rowB, colB;\nint matrixA[MAXROW][MAXCOL];\nint matrixB[MAXROW][MAXCOL];\nint matrixSum[MAXROW][MAXCOL];\nint matrixDiff[MAXROW][MAXCOL];\nint matrixTemp[MAXROW][MAXCOL];\n\nint main () \n{\n    // initialise Matrix A and B\n    while (1)\n    {\n        int n = initMatrices();\n        if (n > 0)\n        {\n            break;\n        }\n    }\n\n    while (1)\n    {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n\n        int choice;\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();\n        switch (choice)\n        {\n        case 1:\n            addmatrices();\n            break;\n        case 2:\n            subtractmatrices ();\n            break;\n        case 3:\n            transposeMatrix(matrixA, 'A');\n            break;\n        case 4:\n            transposeMatrix(matrixB, 'B');\n            break;\n        case 5:\n            printf(\"Exiting...\\n\");\n            exit(0);\n        default:\n            printf(\"Enter a proper choice.\\n\");\n            break;\n        }\n    }\n    return 0;\n}\n\n// function to create Matrix A and B\nint initMatrices ()\n{\n    // input for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns):\");\n    scanf(\"%d %d\", &rowA, &colA);\n    getchar();\n\n    if (rowA > MAXROW || colA > MAXCOL)\n    {\n        printf(\"Invalid number of rows and/or columns entered (maximum size: 10x10).\\n\");\n        return 0;       // return error flag\n    }\n    \n    printf(\"Enter elements for Matrix A:\\n\");\n    for (int i = 0; i < rowA; i++)\n    {\n        for (int j = 0; j < colA; j++)\n        {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrixA[i][j]);\n        }\n    }\n    \n    // input for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns):\");\n    scanf(\"%d %d\", &rowB, &colB);\n    getchar();\n\n    if (rowB > MAXROW || colB > MAXCOL)\n    {\n        printf(\"Invalid number of rows and/or columns entered (maximum size: 10x10).\\n\");\n        return 0;       // return error flag\n    }\n\n    printf(\"Enter elements for Matrix B:\\n\");\n    for (int i = 0; i < rowB; i++)\n    {\n        for (int j = 0; j < colB; j++)\n        {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrixB[i][j]);\n        }\n    }\n    return 1;\n}\n\n// function to display desired matrix\nvoid displaymatrices ( int matrixDisplay[MAXROW][MAXCOL], int rows, int cols)\n{\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\"%d \", matrixDisplay[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// function to add Matrix A and B\nvoid addmatrices ()\n{\n    if (rowA != rowB || colA != colB)\n    {\n        printf(\"Matrices of different orders cannot be added!\\n\");\n        return;\n    }\n    \n    for (int i = 0; i < rowA; i++)\n    {\n        for (int j = 0; j < colA; j++)\n        {\n            matrixSum[i][j] = matrixA[i][j] + matrixB[i][j];\n        }\n    }\n    \n    printf(\"Result of Matrix A + Matrix B:\\n\");\n    displaymatrices(matrixSum, rowA, colA);\n}\n\n// function to subtract Matrix A and B\nvoid subtractmatrices ()\n{\n    if (rowA != rowB || colA != colB)\n    {\n        printf(\"Matrices of different orders cannot be subtracted!\\n\");\n        return;\n    }\n    \n    for (int i = 0; i < rowA; i++)\n    {\n        for (int j = 0; j < colA; j++)\n        {\n            matrixDiff[i][j] = matrixA[i][j] - matrixB[i][j];\n        }\n    }\n    \n    printf(\"Result of Matrix A - Matrix B:\\n\");\n    displaymatrices(matrixDiff, rowA, colA);\n}\n\n// function to tranpose Matrix\nvoid transposeMatrix ( int targetMatrix [MAXROW][MAXCOL], char matrixLetter)\n{\n    // check which matrix user wants to transpose\n    if (matrixLetter == 'A')\n    {\n        for (int i = 0; i < rowA; i++)\n        {\n            for (int j = 0; j < colA; j++)\n            {\n                matrixTemp[j][i] = targetMatrix[i][j];\n            }\n        }\n        \n        printf(\"Transpose of Matrix %c:\\n\", matrixLetter);\n        displaymatrices(matrixTemp, colA, rowA);\n    }\n    else\n    {\n        for (int i = 0; i < rowB; i++)\n        {\n            for (int j = 0; j < colB; j++)\n            {\n                matrixTemp[j][i] = targetMatrix[i][j];\n            }\n        }\n        \n        printf(\"Transpose of Matrix %c:\\n\", matrixLetter);\n        displaymatrices(matrixTemp, colB, rowB);\n    }\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAXLIST 100\n\n// struct declarations\ntypedef struct \n{\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n} Grocery_item;\n\ntypedef struct\n{\n    bool in_stock;\n    bool outof_stock;\n} Availability_status;\n\ntypedef struct\n{\n    Grocery_item item[MAXLIST];\n    Availability_status status[MAXLIST];\n    int total;\n} Grocery_inventory;\nGrocery_inventory inventory;\n\n// function prototype declarations\nvoid addItem ();\nvoid displayItems ();\nvoid updatequantity ();\nvoid removeitem ();\n\nint main ()\n{\n    while (1)\n    {\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n\n        int choice;\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();\n        switch (choice)\n        {\n        case 1:\n            addItem();\n            break;\n        case 2:\n            displayItems();\n            break;\n        case 3:\n            updatequantity();\n            break;\n        case 4:\n            removeitem();\n            break;\n        case 5:\n            printf(\"Exiting...\\n\");\n            exit(0);\n        default:\n            printf(\"Enter a proper choice.\\n\");\n            break;\n        }\n    }\n    return 0;\n}\n\n// function to insert user input of grocery item into struct\nvoid addItem ()\n{\n    if (inventory.total < MAXLIST)\n    {\n        // user input\n        printf(\"Enter Item Name: \");\n        fgets(inventory.item[inventory.total].name, sizeof(inventory.item[inventory.total].name), stdin);\n        inventory.item[inventory.total].name [strcspn(inventory.item[inventory.total].name, \"\\n\")] = 0;\n\n        printf(\"Enter Category: \");\n        fgets(inventory.item[inventory.total].category, sizeof(inventory.item[inventory.total].category), stdin);\n        inventory.item[inventory.total].category [strcspn(inventory.item[inventory.total].category, \"\\n\")] = 0;\n\n        printf(\"Enter Quantity: \");\n        scanf(\"%d\", &inventory.item[inventory.total].quantity);\n        getchar();\n\n        printf(\"Enter Price: \");\n        scanf(\"%f\", &inventory.item[inventory.total].price);\n        getchar();\n\n        // do not save grocery item into system if user enter a -ve amount for either quantity/price\n        if (inventory.item[inventory.total].quantity < 0 || inventory.item[inventory.total].price < 0)\n        {\n            printf(\"Quantity/Price of grocery item must be more than 0!\\n\");\n            return;\n        }\n\n        // check if quantity is set to 0, if yes, outof_stock will be set to true \n        // otherwise in_stock will be set to true\n        if (inventory.item[inventory.total].quantity == 0)\n        {\n            inventory.status[inventory.total].outof_stock = true;\n        }\n        else\n        {\n            inventory.status[inventory.total].in_stock = true;\n        }\n\n        // increment array index of grocery item\n        inventory.total += 1;\n        printf(\"Grocery item added successfully!\\n\");\n    }\n    else\n    {\n        printf(\"Grocery inventory is full. No more items can be added.\\n\");\n    }\n}\n\n// function to display all grocery items in grocery inventory\nvoid displayItems ()\n{\n    if (inventory.total == 0)\n    {\n        printf(\"No grocery items in the inventory.\\n\");\n    }\n    else\n    {\n        for (int i = 0; i < inventory.total; i++)\n        {\n            // check if item in any specific array index has been removed,\n            // i.e. that array index's grocery item is empty\n            // if it is empty (removed) dont display anything, skip to next item\n            printf(\"\\nName: %s\\n\", inventory.item[i].name);\n            printf(\"Category: %s\\n\", inventory.item[i].category);\n            printf(\"Quantity: %d\\n\", inventory.item[i].quantity);\n            printf(\"Price: %.2f\\n\", inventory.item[i].price);\n\n            if (inventory.status[i].in_stock == true)\n            {\n                printf(\"Status: In Stock\\n\");\n            }\n            else if (inventory.status[i].outof_stock == true)\n            {\n                printf(\"Status: Out of Stock\\n\");\n            }\n            else\n            {\n                printf(\"Status: Error!\\n\");\n            }   \n        }\n    }\n}\n\n// function to update quantity of selected grocery item\nvoid updatequantity ()\n{\n    char choice_name[100];\n    printf(\"Enter name of grocery item to update quantity: \");\n    fgets(choice_name, 100, stdin);\n    choice_name[strcspn(choice_name, \"\\n\")] = 0;\n\n    for (int i = 0; i < inventory.total; i++)\n    {\n        if ( strcmp(inventory.item[i].name, choice_name) == 0 )\n        {\n            printf(\"Enter new quantity for %s: \", inventory.item[i].name);\n            scanf(\"%d\", &inventory.item[i].quantity);\n            getchar();\n            \n            // check if new quantity is 0, if yes update boolean value of outof_stock to true and in_stock to false\n            // and vice versa\n            if (inventory.item[i].quantity == 0)\n            {\n                inventory.status[i].in_stock = false;\n                inventory.status[i].outof_stock = true;\n            }\n            else\n            {\n                inventory.status[i].in_stock = true;\n                inventory.status[i].outof_stock = false;\n            }\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Grocery item not found.\\n\");\n}\n\n// function to remove grocery item from grocery item array\nvoid removeitem ()\n{\n    char choice_name[100];\n    printf(\"Enter name of grocery item to remove: \");\n    fgets(choice_name, 100, stdin);\n    choice_name[strcspn(choice_name, \"\\n\")] = 0;\n\n    // this for loop is to loop through all array elements\n    for (int i = 0; i < inventory.total; i++)\n    {\n        // if statement to check if user's targeted grocery is in array list or not\n        if ( strcmp(inventory.item[i].name, choice_name) == 0 )\n        {\n            // if yes, this for loop will continue from main for loop's counter\n            // to replace targeted grocery item's array index with the grocery item in the next array index\n            // effectively removing the targeted grocery item and shifting every other item on the RHS to the left\n            for (int j = i; j < inventory.total; j++)\n            {\n                /* bruh\n                strcpy(inventory.item[j].name, inventory.item[j + 1].name);\n                strcpy(inventory.item[j].category, inventory.item[j + 1].category);\n                inventory.item[j].quantity = inventory.item[j + 1].quantity;\n                inventory.item[j].price = inventory.item[j + 1].price;\n                inventory.status[j].in_stock = inventory.status[j + 1].in_stock;\n                inventory.status[j].outof_stock = inventory.status[j + 1].outof_stock;\n                */\n                inventory.item[j] = inventory.item[j + 1];\n                inventory.status[j] = inventory.status[j + 1];\n            }\n            inventory.total -= 1;\n            printf(\"Grocery item '%s' removed successfully!\\n\", choice_name);\n            return;\n        }\n    }\n    printf(\"Grocery item not found.\\n\");\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXLIST 10\n\n// global variable declaration\nint counter_linkedlist;\n\n// Structure for Student\ntypedef struct Student \n{\n    char name[100];\n    int id;\n    float grade;\n    struct Student *next;\n} Student;\nStudent *head = NULL;\nStudent *list[MAXLIST];\n\n// function prototype declaration\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid freeMemory();\nvoid sortStudents();\nvoid merge_sort_divide(int left_index, int right_index);\nvoid merge_sort_combine(int left_index, int middle_index, int right_index);\n\n// Main function to drive the program\nint main() \n{\n    int choice, id;\n    char name[100];\n    float grade;\n    \n    // set Student *list[MAXLIST] pointers to NULL\n    memset(list, 0, sizeof(list));\n\n    do \n    {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();      // To consume the newline character\n\n        switch (choice) \n        {\n        case 1:\n            if (counter_linkedlist >= MAXLIST)\n            {\n                printf(\"Maximum number of student records reached!\\n\");\n                break;\n            }\n            \n            printf(\"Enter Name: \");\n            fgets(name, sizeof(name), stdin);\n            strtok(name, \"\\n\");     // To consume the newline character\n\n            printf(\"Enter ID: \");\n            scanf(\"%d\", &id);\n\n            // checker to prevent user from entering duplciate student IDs\n            int n = 0;\n            for (int i = 0; i < counter_linkedlist; i++)\n            {\n                if (id == list[i]->id)\n                {\n                    n = 1;      // set the duplicate flag\n                    printf(\"Student ID already in use!\\n\");\n                    break;      // this break only breaks the for loop, not the switch case\n                }\n            }\n\n            if (n == 1)\n            {\n                break;          // break from switch case if duplicate flag is set\n            }\n            \n            printf(\"Enter Grade: \");\n            scanf(\"%f\", &grade);\n\n            // if user enters grade lesser than 0 or more than 100, break from switch case\n            if (grade < 0 || grade > 100)\n            {\n                printf(\"Grade must be between 0 and 100 inclusive.\\n\");\n                break;\n            }\n\n            insertStudent(name, id, grade);\n            break;\n        case 2:\n            displayStudents();\n            break;\n        case 3:\n            printf(\"Records sorted by grade using Merge Sort.\\n\");\n            sortStudents();\n            break;\n        case 4:\n            printf(\"Enter ID to search: \");\n            scanf(\"%d\", &id);\n            Student* found = searchStudentByID(id);\n            \n            if (found) \n            {\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n            } \n            else \n            {\n                printf(\"Student not found.\\n\");\n            }\n            \n            break;\n        case 5:\n            deleteList();\n            printf(\"List deleted.\\n\");\n            break;\n        case 6:\n            freeMemory();\n            printf(\"Exiting...\\n\");\n            break;\n        default:\n            printf(\"Invalid choice! Please try again.\\n\");\n            break;\n        }\n    } \n    while (choice != 6);\n\n    return 0;\n}\n\n// Function to creates a new student node and return a pointer to it\nStudent* createStudent(const char* name, int id, float grade) \n{\n    // Write your code (1 mark)\n    // allocate memory for new student node\n    list[counter_linkedlist] = malloc(sizeof(Student));\n\n    // copy user input values \n    strcpy(list[counter_linkedlist]->name, name);\n    list[counter_linkedlist]->id = id;\n    list[counter_linkedlist]->grade = grade;\n\n    return list[counter_linkedlist];\n}\n\n// Function to insert a new student record into the linked list\nvoid insertStudent(const char* name, int id, float grade) \n{\n    // Write your code (1 mark)\n    \n    // this commented out old code is to set the first user input to be the head node\n    // the head node will point to the second input in the list\n    // then the 2nd input will point to 3rd etc.\n    /*\n    if (head == NULL && counter_linkedlist == 0)\n    {\n        head = createStudent(name, id, grade);\n        counter_linkedlist++;\n    }\n    else\n    {\n        list[counter_linkedlist] = createStudent(name, id, grade);\n        counter_linkedlist++;\n    }\n    */\n\n    // a new head node is set after every user input according to sample output\n    Student *new_head = NULL;\n    new_head = createStudent(name, id, grade);\n\n    // set current input's next pointer to point to prev input's address\n    // and prev input's next pointer to NULL\n    if (counter_linkedlist > 0)\n    {\n        // for any subsequent user inputs, those inputs will point to the old head node\n        list[counter_linkedlist]->next = head;\n        head = new_head;\n    }\n    else\n    {\n        // this else statement will only run once at the start when user inputs the first student record\n        list[counter_linkedlist]->next = NULL;\n        head = new_head;\n    }\n\n    counter_linkedlist++;\n}\n\n// Function to display all student records\nvoid displayStudents() \n{\n    // Write your code (1 mark)\n    if (counter_linkedlist == 0)\n    {\n        printf(\"No student records saved.\\n\");\n    }\n    \n    // reinitialise *current to point to next node every iteration\n    Student *current = head;\n    while(current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student record by student ID \n// and return a pointer to the corresponding student node.\nStudent *searchStudentByID(int id) \n{\n    // Write your code (1 mark)\n    // loop through struct list to find identical id\n    for (int i = 0; i < counter_linkedlist; i++)\n    {\n        if (id == list[i]->id)\n        {\n            return list[i];\n        }\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() \n{\n    // ensure that after list has been deleted, user can still enter up to MAXLIST number of inputs before reaching limit\n    counter_linkedlist = 0;\n\n    Student *current = head;\n    Student *next;\n    while (current != NULL) \n    {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n\n    for (int i = 0; i < counter_linkedlist; i++)\n    {\n        free(list[i]);\n    }\n} \n\n// called when exiting to just delete everything\nvoid freeMemory() \n{\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() \n{\n    // Write your code (1 mark)\n    // Merge Sort is my choice of sorting algorithm \n    // because it has a consistent time complexity of O(n log n)\n    // which is very efficient for large sets of data such as student records.\n    // e.g. UoNM's 2024 Y01 School of Computer Science already has 180+ undergrads like\n    merge_sort_divide(0, counter_linkedlist - 1);\n}\n\n// Merge Sort algorithm function to split array into 2 subarrays recursively\nvoid merge_sort_divide (int left_index, int right_index) \n{\n    // after continuous splitting, the middle index will be equal to the left index\n    // e.g. left = 0, right = 1, hence middle = 0\n    // when middle index is passed on to merge_sort_divide as right index for further splitting,\n    // this if condition will make the function return back to the previous subarray\n    if (left_index < right_index) \n    { \n        int middle_index = left_index + (right_index - left_index)/2;\n\n        //further divide left side half into 2 halves\n        merge_sort_divide(left_index, middle_index);\n\n        //further divide right side half into 2 halves\n        merge_sort_divide(middle_index + 1, right_index);\n\n        //combine 2 elements together, gradually into an array\n        merge_sort_combine(left_index, middle_index, right_index);\n    }\n}\n\n// Merge Sort algorithm function to combine 2 subarrays\nvoid merge_sort_combine(int left_index, int middle_index, int right_index) \n{\n    int leftside_length = middle_index - left_index + 1;\n    int rightside_length = right_index - middle_index;\n\n    // temp left&right pointer arrays\n    Student *left_arrayPTR[leftside_length];\n    Student *right_arrayPTR[rightside_length];\n\n    for (int i = 0; i < leftside_length; i++) \n    {\n        left_arrayPTR[i] = list[left_index + i];\n    }\n\n    for (int j = 0; j < rightside_length; j++) \n    {\n        right_arrayPTR[j] = list[middle_index + 1 + j];\n    }\n\n    int i, j, k;\n    Student temp;\n    Student *current = &temp;\n\n    // DO NOT SET NEW HEAD NODE BEFORE SORTING IN FOR LOOP\n    // THIS WILL REQUIRE THE i AND j COUNTER VALUES TO ALTER, SETTING i = 1, j = 1 DOES NOT WORK\n    // FIND AND SET THE HEAD NODE AFTER SORTING FOR LOOP\n    /*\n    if ( i < leftside_length && ( j >= rightside_length || left_arrayPTR[i]->grade <= right_arrayPTR[j]->grade ) )\n    {\n        head = left_arrayPTR[i];\n    }\n    else \n    {\n        head = right_arrayPTR[j];\n    }\n    */\n\n    // in this for loop, current.next will point to the list[i] being assessed\n    // then current will be set to \"become\" list[i]\n    // in the next iteration, current will still be the prev list[i],\n    // which the program will set the prev list[i] to point to the current list[i] being assessed\n    for ( (i = 0, j = 0, k = left_index); k <= right_index; k++)\n    {\n        if ( i < leftside_length && ( j >= rightside_length || left_arrayPTR[i]->grade <= right_arrayPTR[j]->grade ) )\n        {\n            current->next = left_arrayPTR[i];\n            current = current->next;\n            i++;\n        }\n        else \n        {\n            current->next = right_arrayPTR[j];\n            current = current->next;\n            j++;\n        }\n    }\n\n    // Hence, this means that the loop will end with the last list[i] that was assessed to be pointing to itself\n    // therefore, the list[last]'s, which is also \"current\", pointer will be set to NULL\n    // indicating that the list[last] is the \"tail\" with the highest grade value\n    current->next = NULL;\n    head = temp.next;\n    // prior to the for loop, *current = &temp, and then in the first iteration of the for loop, \n    // current.next (aka temp.next) = list[first], hence instead creating an if/else statement prior to the for loop,\n    // temp is used to hold list[first], so that i can implement:\n    // head = temp.next = list[first]\n\n    // after sorting, each list[i] will no longer point to list[i + 1],\n    // hence i used this for loop to make it so that the linked list indices are in order as well\n    current = head;\n    for (k = left_index; k <= right_index; k++) \n    {\n        list[k] = current;\n        current = current->next;\n    }\n}",
    "feedback": "q1-Meet requirement. \nq2-In the addItem function, the status of in_stock is not set if the quantity is greater than zero. It should explicitly set both in_stock and outof_stock based on the quantity.\nq3-The use of Merge Sort is advantageous due to its O(n log n) time complexity, making it efficient for larger datasets. The implementation appears well-structured, effectively dividing and combining the student records."
  },
  {
    "student_id": "20619473",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h> // Standard library for input/output\r\n\r\n#define MAX 10 // Defining\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]);\r\nvoid pMatrix(int rows, int cols, int matrix[MAX][MAX]);\r\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]);\r\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX];\r\n    int result[MAX][MAX];\r\n    int choice;\r\n\r\n    // Asking user to input the dimensions for Matrix A\r\n    printf(\"Enter dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // If dimensions exceed 10 (MAX)\r\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0) {\r\n        printf(\"Invalid dimensions for Matrix A. Dimensions must be between 1 and %d. Exiting...\\n\", MAX);\r\n        return 1;\r\n    }\r\n\r\n    // Asking user to input the elements for Matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, matrixA);\r\n\r\n    // Asking user to input the dimensions for Matrix B\r\n    printf(\"Enter dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // If dimensions exceed 10 (MAX)\r\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid dimensions for Matrix B. Dimensions must be between 1 and %d. Exiting.\\n\", MAX);\r\n        return 1;\r\n    }\r\n\r\n    // Asking user to input the elements for Matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, matrixB);\r\n\r\n    // Do while, switch case for menu\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    pMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Addition not possible. Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    pMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(rowsA, colsA, matrixA, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                pMatrix(colsA, rowsA, result);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(rowsB, colsB, matrixB, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                pMatrix(colsB, rowsB, result);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input a matrix (Prompt for input)\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid pMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Choice 1: Function to add two matrices\r\nvoid addMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Choice 2: Function to subtract two matrices\r\nvoid subtractMatrices(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Choice 3 and 4: Function to transpose a matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h> // Standard library for input/output\r\n#include <string.h> // String library\r\n\r\n#define MAX_ITEMS 100 // Defining\r\n\r\n// Struct for Grocery Items\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int inStock; \r\n} GroceryItem;\r\n\r\n// Function prototypes\r\nvoid addItem(GroceryItem inventory[], int *count);\r\nvoid listItems(const GroceryItem inventory[], int count);\r\nvoid updateQuantity(GroceryItem inventory[], int count);\r\nvoid removeItem(GroceryItem inventory[], int *count);\r\n\r\nint main() {\r\n    GroceryItem inventory[MAX_ITEMS];\r\n    int itemCount = 0;\r\n    int choice;\r\n\r\n    // Do while, switch case for choices\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(inventory, &itemCount);\r\n                break;\r\n            case 2:\r\n                listItems(inventory, itemCount);\r\n                break;\r\n            case 3:\r\n                updateQuantity(inventory, itemCount);\r\n                break;\r\n            case 4:\r\n                removeItem(inventory, &itemCount);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add\r\nvoid addItem(GroceryItem inventory[], int *count) {\r\n    if (*count >= MAX_ITEMS) {\r\n        printf(\"Inventory full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter Item Name: \");\r\n    getchar(); // Clear the input buffer\r\n    fgets(inventory[*count].name, sizeof(inventory[*count].name), stdin);\r\n    strtok(inventory[*count].name, \"\\n\"); // Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(inventory[*count].category, sizeof(inventory[*count].category), stdin);\r\n    strtok(inventory[*count].category, \"\\n\"); // Remove newline\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &inventory[*count].quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &inventory[*count].price);\r\n\r\n    inventory[*count].inStock = (inventory[*count].quantity > 0) ? 1 : 0;\r\n\r\n    (*count)++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list\r\nvoid listItems(const GroceryItem inventory[], int count) {\r\n    if (count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < count; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update quantity\r\nvoid updateQuantity(GroceryItem inventory[], int count) {\r\n    char name[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar(); // Clear the input buffer\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\"); // Remove newline\r\n\r\n    for (int i = 0; i < count; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &newQuantity);\r\n            inventory[i].quantity = newQuantity;\r\n            inventory[i].inStock = (newQuantity > 0) ? 1 : 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item '%s' not found in inventory.\\n\", name);\r\n}\r\n\r\n// Function to remove an item\r\nvoid removeItem(GroceryItem inventory[], int *count) {\r\n    char name[100];\r\n\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    getchar(); // Clear the input buffer\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\"); // Remove newline\r\n\r\n    for (int i = 0; i < *count; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            for (int j = i; j < *count - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            (*count)--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item '%s' not found in inventory.\\n\", name);\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h> // Standard library for input/output\n#include <stdlib.h> // Library for free() and malloc()\n#include <string.h> // Library for string\n \n// Structure for Student \ntypedef struct Student { \n    char name[100]; \n    int id; \n    float grade; \n    struct Student* next; \n} Student; \n \nStudent* head = NULL; \n \n// Function to create a new student node \nStudent* createStudent(const char* name, int id, float grade) { \n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        return NULL;\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n \n// Function to insert a new student record \nvoid insertStudent(const char* name, int id, float grade) { \n    Student* newStudent = createStudent(name, id, grade);\n    if (!newStudent) return;\n\n    if (!head || head->grade > grade) {\n        newStudent->next = head;\n        head = newStudent;\n    } else {\n        Student* current = head;\n        while (current->next && current->next->grade <= grade) {\n            current = current->next;\n        }\n        newStudent->next = current->next;\n        current->next = newStudent;\n    }\n    printf(\"Student record inserted successfully.\\n\");\n}\n\n// Function to display all student records \nvoid displayStudents() { \n    if (!head) {\n        printf(\"No student records found.\\n\");\n        return;\n    }\n    Student* current = head;\n    while (current) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n \n// Function to search for a student by ID \nStudent* searchStudentByID(int id) { \n    Student* current = head;\n    while (current) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n \n// Function to delete the entire list \nvoid deleteList() { \n    Student* current = head; \n    Student* next; \n \n    while (current != NULL) { \n        next = current->next; \n        free(current); \n        current = next; \n    } \n    head = NULL; \n} \n \nvoid freeMemory() { \n    deleteList(); \n} \n \n// Sort function to sort the student records by grade based on an algorithm of your choice (Bubble Sort)\nvoid sortStudents() { \n    if (!head || !head->next) return;\n\n    int swapped;\n    Student* ptr1;\n    Student* lptr = NULL;\n\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                float tempGrade = ptr1->grade;\n                int tempID = ptr1->id;\n                char tempName[100];\n\n                strcpy(tempName, ptr1->name);\n                ptr1->grade = ptr1->next->grade;\n                ptr1->id = ptr1->next->id;\n                strcpy(ptr1->name, ptr1->next->name);\n\n                ptr1->next->grade = tempGrade;\n                ptr1->next->id = tempID;\n                strcpy(ptr1->next->name, tempName);\n\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n \n// Main function to drive the program \nint main() { \n \n    int choice, id; \n    char name[100]; \n    float grade; \n \n    do { \n        printf(\"\\n1. Insert Student Record\\n\"); \n        printf(\"2. Display Student Records\\n\"); \n        printf(\"3. Sort Records\\n\"); \n        printf(\"4. Search Record by ID\\n\"); \n        printf(\"5. Delete List\\n\"); \n        printf(\"6. Exit\\n\"); \n        printf(\"Enter your choice: \"); \n        scanf(\"%d\", &choice); \n        getchar(); // To consume the newline character \n \n        switch (choice) { \n            case 1: \n                printf(\"Enter Name: \"); \n                fgets(name, sizeof(name), stdin); \n                strtok(name, \"\\n\"); \n                printf(\"Enter ID: \"); \n                scanf(\"%d\", &id); \n                printf(\"Enter Grade: \"); \n                scanf(\"%f\", &grade); \n                insertStudent(name, id, grade); \n                break; \n            case 2: \n                displayStudents(); \n                break; \n            case 3: \n                sortStudents();                 \n                break; \n            case 4: \n                printf(\"Enter ID to search: \"); \n                scanf(\"%d\", &id); \n                Student* found = searchStudentByID(id); \n                if (found) { \n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \n                } else { \n                    printf(\"Student not found.\\n\"); \n                } \n                break; \n            case 5: \n                deleteList(); \n                printf(\"List deleted.\\n\"); \n                break; \n            case 6: \n                freeMemory(); \n                printf(\"Exiting...\\n\"); \n                break; \n            default: \n                printf(\"Invalid choice! Please try again.\\n\"); \n        } \n    } while (choice != 6); \n \n    return 0; \n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly to sort student records by grade in ascending order. While it is simple and effective for small datasets, it has a time complexity of O(n?), which can be inefficient for larger datasets. For larger lists, consider using more efficient sorting algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20715999",
    "code": "\n/* --- lab assesment 3/lab assesment 3/Q1.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_SIZE 10\n\n// FUNCTION PROTOTYPES\n// Main functions\nvoid transpose(int[][MAX_SIZE], char, int[]); \nvoid add_matrices(int[][MAX_SIZE], int[], int[][MAX_SIZE], int[]);\nvoid substract_matrices(int[][MAX_SIZE], int[], int[][MAX_SIZE], int[]);\nvoid print_matrix(int matrix[][MAX_SIZE], int dimensions[]);\n\n//INPUT FUNCTIONS + VALIDATION \nvoid standard_input(char[], size_t); // Primary way to get input, size_t is size of array.\nvoid clear_buffer(void); // Flush buffer\nvoid matrix_input(int[][MAX_SIZE], char, int[]); // Get matrix\nint is_digit(char[]); // Return 1 if string only contain digits, else return 0\nint is_empty(char[]); // Return 1 if string is empty, else return 0\nint is_zero(char[]); // Return 1 if input is 01, 03, 0XX, else return 0\n\nint main (void) {\n    int matrix_A[MAX_SIZE][MAX_SIZE] = {0};\n    int matrix_B[MAX_SIZE][MAX_SIZE] = {0};\n    char a = 'A';\n    char b = 'B';\n    int dimensions_A[2] = {0};\n    int dimensions_B[2] = {0};\n    char input[10] = \"\\0\";\n    int choice = -1;\n\n    while (1) {\n        puts(\"==== MATRIX OPERATIONS MENU ====\");\n        puts(\"Enter 1 to Add Matrices\");\n        puts(\"Enter 2 to Substract Matrices\");\n        puts(\"Enter 3 to Transpose Matrix A\");\n        puts(\"Enter 4 to Transpose Matrix B\");\n        puts(\"Enter 5 to exit program\");\n        printf(\"Choice: \");\n            standard_input(input, sizeof(input));\n            if (is_empty(input)) continue; // Get input again if is empty\n            if (!is_digit(input)) continue; // Get input again if non digit\n            if (is_zero(input)) continue; // Get input again if input is 01, 02, 0XX\n            choice = atoi(input); // Convert input to int\n            if (choice == 5) {\n                puts(\"Exiting program\");\n                break;\n            }\n\n        switch (choice) {\n            default:\n                puts(\"Invalid input. Please enter a number (1-5)\");\n                break;\n            case 1:\n                // Get matrix\n                matrix_input(matrix_A, a, dimensions_A);\n                matrix_input(matrix_B, b, dimensions_B);\n                add_matrices(matrix_A, dimensions_A, matrix_B, dimensions_B);\n                break;\n            case 2:\n                // Get matrix\n                matrix_input(matrix_A, a, dimensions_A);\n                matrix_input(matrix_B, b, dimensions_B);\n                substract_matrices(matrix_A, dimensions_A, matrix_B, dimensions_B);\n                break;\n            case 3:\n                // Get matrix\n                matrix_input(matrix_A, a, dimensions_A);\n                transpose(matrix_A, a, dimensions_A);\n                break;\n            case 4:\n                // Get matrix\n                matrix_input(matrix_B, b, dimensions_B);\n                transpose(matrix_B, b, dimensions_B);\n                break;\n        }\n    }\n    return 0;\n}\n\n\n// Main functions\nvoid transpose(int matrix[][MAX_SIZE], char choice, int dimensions[]) {\n    int rows = dimensions[0];\n    int columns = dimensions[1];\n    int transposed_matrix[MAX_SIZE][MAX_SIZE]; // Columns and rows swapped\n\n    // Transpose\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            transposed_matrix[j][i] = matrix[i][j];\n        }\n    }\n\n    // Print transposed matrix\n    print_matrix(transposed_matrix, dimensions);\n}\n\nvoid add_matrices(int matrix_A[][MAX_SIZE], int dimensions_A[], int matrix_B[][MAX_SIZE], int dimensions_B[]) {\n    int rows = dimensions_A[0];\n    int columns = dimensions_A[1];\n    int matrix_result[MAX_SIZE][MAX_SIZE]; // Columns and rows swapped\n    // Check if Matrix A and Matrix B has same dimensions\n    if (dimensions_A[0] != dimensions_B[0] || dimensions_A[1] != dimensions_B[1]) {\n        puts(\"Invalid addition of matrices\");\n        puts(\"Matrix A and Matrix B must have same dimensions\");\n        return;\n    }\n    \n    // Do addition \n    puts(\"Matrix A + Matrix B\");\n    for (int i = 0; i < dimensions_A[0]; i++) {\n        for (int j = 0; j < dimensions_A[1]; j++) {\n            matrix_result[i][j] = matrix_A[i][j] + matrix_B[i][j];\n        }\n    }\n\n    // Print result\n    print_matrix(matrix_result, dimensions_A);\n\n}\n\nvoid substract_matrices(int matrix_A[][MAX_SIZE], int dimensions_A[], int matrix_B[][MAX_SIZE], int dimensions_B[]) {\n    int rows = dimensions_A[0];\n    int columns = dimensions_A[1];\n    int matrix_result[MAX_SIZE][MAX_SIZE]; // Columns and rows swapped\n    // Check if Matrix A and Matrix B has same dimensions\n    if (dimensions_A[0] != dimensions_B[0] || dimensions_A[1] != dimensions_B[1]) {\n        puts(\"Invalid substraction of matrices\");\n        puts(\"Matrix A and Matrix B must have same dimensions\");\n        return;\n    }\n    \n    // Do substraction\n    puts(\"Matrix A - Matrix B\");\n    for (int i = 0; i < dimensions_A[0]; i++) {\n        for (int j = 0; j < dimensions_A[1]; j++) {\n            matrix_result[i][j] = matrix_A[i][j] - matrix_B[i][j];\n        }\n    }\n\n    // Print result\n    print_matrix(matrix_result, dimensions_A);\n}\n\nvoid print_matrix(int matrix[][MAX_SIZE], int dimensions[]) {\n    for (int i = 0; i < dimensions[0]; i++) {\n        for (int j = 0; j < dimensions[1]; j++) {\n            printf(\"%-5d\", matrix[i][j]);\n        }\n        printf(\"\\n\\n\");\n    }\n}\n\n\n//INPUT FUNCTIONS + VALIDATION \nvoid clear_buffer(void){\n    while(getchar() != '\\n');\n}\n\nvoid standard_input(char input[], size_t size) {\n    fgets(input, size, stdin); // Directly read into the passed array\n    if (!strchr(input, '\\n')) { // Check if the newline was not present (overflow occurred)\n        clear_buffer(); // Clear the buffer\n    } \n    else {\n        input[strcspn(input, \"\\n\")] = '\\0'; // Remove newline character if present\n    }\n}\n\nvoid matrix_input(int matrix[][MAX_SIZE], char choice, int dimensions[]) {\n    char input[5] = \"\\0\";\n    printf(\"Enter dimensions of matrix %c\\n\", choice);\n    while(1) {\n        printf(\"Enter rows: \");\n        standard_input(input, sizeof(input));\n        if (is_empty(input)) continue; // Get input again if is empty\n        if (!is_digit(input)) continue; // Get input again if non digit\n        if (is_zero(input)) continue; // Get input again if input is 01, 02, 0XX\n        if (atoi(input) == 0) {\n            puts(\"Invalid input. Rows can not be 0\");\n            continue; // Get input again\n        }\n        if (atoi(input) > MAX_SIZE) {\n            puts(\"Invalid input. Maximum number rows is 10\");\n            continue; // Get input again if rows more than 10\n        }\n        dimensions[0] = atoi(input); // Convert input to int\n        break;\n    }\n    while(1) {\n        printf(\"Enter columns: \");\n        standard_input(input, sizeof(input));\n        if (is_empty(input)) continue; // Get input again if is empty\n        if (!is_digit(input)) continue; // Get input again if non digit\n        if (is_zero(input)) continue; // Get input again if input is 01, 02, 0XX\n        if (atoi(input) == 0) {\n            puts(\"Invalid input. Columns can not be 0\");\n            continue; // Get input again\n        }\n        if (atoi(input) > MAX_SIZE) {\n            puts(\"Invalid input. Maximum number of columns is 10\");\n            continue; // Get input again if columns more than 10\n        }\n        dimensions[1] = atoi(input); // Convert input to int\n        break;\n    }\n\n    for (int i = 0; i < dimensions[0]; i ++) {\n        for (int j = 0; j < dimensions[1]; j++) {\n            while(1) {\n            printf(\"Element[%d][%d]: \", i + 1, j + 1);\n            standard_input(input, sizeof(input));\n            if (is_empty(input)) continue; // Get input again if is empty\n            if (!is_digit(input)) continue; // Get input again if non digit\n            if (is_zero(input)) continue; // Get input again if input is 01, 02, 0XX\n            matrix[i][j] = atoi(input); // Convert input to int\n            break;\n            }\n        }\n    }\n}\n\nint is_digit(char input[]){\n    if(!isdigit(input[0]) && input[0] != '-') { // Allow first character to be negative\n        puts(\"Invalid input. Input must only contain digits.\");\n        return 0;\n    }\n    for(int i = 1; i < strlen(input); i++){\n        if(!isdigit(input[i])) {\n            puts(\"Invalid input. Input must only contain digits.\");\n            return 0; // Test failed\n        }\n    }\n    return 1; // Test pass\n}\n\nint is_empty(char input[]){\n    if (strlen(input) == 0) {\n        puts(\"Invalid input. Input can not be empty.\");\n        return 1; // Empty, return 1\n    }\n    return 0; // Not empty, return 0\n}\n\nint is_zero(char input[]) {\n    if (input[0] == '0' && input[1] != '\\0') {\n        printf(\"0 can not have following numbers after it.\\n\"); \n        return 1;\n    }\n    return 0;\n}\n/* --- lab assesment 3/lab assesment 3/Q2.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>  // Include for bool, true, and false\n\nstruct Grocery_item {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    bool stock;\n};\n\nstruct Grocery_inventory {\n    struct Grocery_item Grocery_items[100];\n    int total_items;\n};\n\nstruct Grocery_inventory inventory = {{0}, 0};  // Declaring and initializing the inventory\n\n// FUNCTION PROTOTYPES\nvoid add_grocery_item(void);\nvoid list_all_grocery_items(void);\nvoid update_quantity(void);\nvoid remove_grocery_item(void);\n\n// INPUT FUNCTIONS\nvoid standard_input(char[], size_t); // Primary way to get input, size_t is size of array.\nvoid clear_buffer(void); // Flush buffer\n\nint main (void) {\n    char input[50] = \"\\0\";\n    int choice = -1;\n\n    while (1) {\n        puts(\"\\nGrocery Inventory Management System\\n\");\n        puts(\"Enter 1 to Add Grocery Item\");\n        puts(\"Enter 2 to List All Grocery Items\");\n        puts(\"Enter 3 to Update Quantity\");\n        puts(\"Enter 4 to Remove Grocery Item\");\n        puts(\"Enter 5 to exit program\");\n        printf(\"Choice: \");\n        standard_input(input, sizeof(input));\n        choice = atoi(input); // Convert input to int\n    \n        if (choice == 5) {\n            puts(\"Exiting program\");\n            break;\n        }\n\n        switch (choice) {\n            default:\n                puts(\"Invalid input. Please enter a number (1-5)\");\n                break;\n            case 1:\n                add_grocery_item();\n                break;\n            case 2:\n                list_all_grocery_items();\n                break;\n            case 3:\n                update_quantity();\n                break;\n            case 4:\n                remove_grocery_item();\n                break;\n        }\n    }\n    return 0;\n}\n\n\n// MAIN FUNCTIONS\nvoid add_grocery_item(void){\n    char input[100] = \"\\0\";\n    struct Grocery_item new_item;\n    if (inventory.total_items < 100) {\n        printf(\"Enter item name: \");\n        standard_input(inventory.Grocery_items[inventory.total_items].name, 100);\n        \n        printf(\"Enter item category: \");\n        standard_input(inventory.Grocery_items[inventory.total_items].category, 50);\n\n        printf(\"Enter item quantity: \");\n        while (scanf(\"%d\", &inventory.Grocery_items[inventory.total_items].quantity) != 1 || inventory.Grocery_items[inventory.total_items].quantity < 0) {\n            clear_buffer();\n            printf(\"Invalid quantity, please enter a non-negative number: \");\n        }\n\n        printf(\"Enter item price: \");\n        while (scanf(\"%f\", &inventory.Grocery_items[inventory.total_items].price) != 1 || inventory.Grocery_items[inventory.total_items].price <= 0) {\n            clear_buffer();\n            printf(\"Invalid price, please enter a positive number: \");\n        }\n\n        printf(\"Is the item in stock (1 for Yes, 0 for No): \");\n        while (scanf(\"%d\", (int *)&inventory.Grocery_items[inventory.total_items].stock) != 1 || (inventory.Grocery_items[inventory.total_items].stock != 0 && inventory.Grocery_items[inventory.total_items].stock != 1)) {\n            clear_buffer();\n            printf(\"Invalid input, enter 1 for Yes, 0 for No: \");\n        } \n\n        puts(\"Grocery item added succesfully\");\n\n        inventory.total_items++; // Add one item\n    }\n    else puts(\"Inventory is full. Can not add more items\"); \n}\n\nvoid list_all_grocery_items(void) {\n    printf(\"Total items: %d\\n\", inventory.total_items);\n    for (int i = 0; i < inventory.total_items; i++) {\n        printf(\"Item %d: %s, Category: %s, Quantity: %d, Price: %.2f, Stock: %s\\n\",\n        i + 1, inventory.Grocery_items[i].name, \n        inventory.Grocery_items[i].category,\n        inventory.Grocery_items[i].quantity, \n        inventory.Grocery_items[i].price,\n        inventory.Grocery_items[i].stock? \"In Stock\":\"Out of Stock\");\n    }\n}\n\nvoid update_quantity(void) {\n    char name[100];\n    int update_quantity;\n    int found = 0;\n    printf(\"Enter name of grocery item to update quantity: \");\n    standard_input(name, sizeof(name));\n    for (int i = 0; i < inventory.total_items; i++) {\n        if (strcmp(name, inventory.Grocery_items[i].name) == 0) {\n            printf(\"Enter new quantity for %s: \", inventory.Grocery_items[i].name);\n            scanf(\"%d\", &inventory.Grocery_items[i].quantity);\n            clear_buffer();\n            puts(\"Quantity updated succesfully\");\n            found++; // Mark as found\n        }\n    }\n    if (found == 0) printf(\"%s is not in grocery inventory list\\n\", name);\n}\n\n\nvoid remove_grocery_item(void) {\n    char name[100];\n    int found = 0;\n    printf(\"Enter name of grocery item to remove: \");\n    standard_input(name, sizeof(name));\n    for (int i = 0; i < inventory.total_items; i++) {\n        if (strcmp(name, inventory.Grocery_items[i].name) == 0) {\n            found++; // Mark as found\n            inventory.total_items--; // Remove an item\n            // Shift items in grocery inventory to the left after removing an item\n            for (int j = i; j < inventory.total_items; j++) {\n                    inventory.Grocery_items[j] = inventory.Grocery_items[j + 1];\n            }\n            // Clear the last item in the array \n            memset(&inventory.Grocery_items[inventory.total_items], 0, sizeof(struct Grocery_item));\n            printf(\"Grocery item %s removed successfully.\\n\", name);\n        }\n    }\n\n    if (found == 0) {\n        printf(\"%s is not in grocery inventory list\\n\", name);\n    }\n}\n\n//INPUT FUNCTIONS\nvoid clear_buffer(void){\n    while(getchar() != '\\n');\n}\n\nvoid standard_input(char input[], size_t size) {\n    fgets(input, size, stdin); // Directly read into the passed array\n    if (!strchr(input, '\\n')) { // Check if the newline was not present (overflow occurred)\n        clear_buffer(); // Clear the buffer\n    } \n    else {\n        input[strcspn(input, \"\\n\")] = '\\0'; // Remove newline character if present\n    }\n}\n\n\n\n/* --- lab assesment 3/lab assesment 3/Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\nchar name[100];\nint id;\nfloat grade;\nstruct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for the new node\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL; // Next pointer is NULL as it is the last node\n    return newStudent;\n}\n\n// Function to insert a new student record\n// Creates a new student node and inserts it at the end of the list.\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n\n    if (head == NULL) { // First student in list if list is empty\n        head = newStudent; \n    } \n    else {\n        Student* temp = head; // Temporary pointer to move through link list\n        while (temp->next != NULL) { // Determine last node\n            temp = temp->next;\n        }\n        temp->next = newStudent; // Move to next node\n    }\n}\n\n// Function to display all student records\nvoid displayStudents(void) {\n    if (head == NULL) {\n        puts(\"No student records found\");\n        return;\n    }\n\n    Student* temp = head; // Temporary pointer to move through link list\n    puts(\"Student Records:\");\n    // Display each node\n    while (temp != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head; // Temporary pointer to move through link list\n    while (temp != NULL) {\n        if (temp->id == id) {\n            return temp; // Student found\n        }\n        temp = temp->next; // Move to next node\n    }\n    return NULL; // Student not found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;  // Pointer to move through link list\n    Student* next;  // Pointer to hold the next node\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next; // Move to next node\n    }\n    head = NULL; // Set the head pointer to NULL after deleting every node\n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an algorithm of your choice\nvoid sortStudents() {\n    if (head == NULL) {\n        puts(\"No student records to sort\");\n        return;\n    }\n    int swapped;\n    Student* ptr1;\n    Student* ptr2 = NULL;\n\n    // Bubble sort\n    // Number of passes needed\n    for (ptr1 = head; ptr1 != NULL; ptr1 = ptr1->next) {\n        // Swap each element in struct Student\n        for (Student* ptr2 = head; ptr2->next != NULL; ptr2 = ptr2->next) {\n            if (ptr2->grade > ptr2->next->grade) {  // If the current student's grade is greater than the next student's grade\n                // Swap the student records\n                char tempName[100];  // Temporary variable to store the name during the swap\n                int tempID;  // Temporary variable to store the ID during the swap\n                float tempGrade;  // Temporary variable to store the grade during the swap\n\n                strcpy(tempName, ptr2->name);  // Swap names\n                strcpy(ptr2->name, ptr2->next->name);\n                strcpy(ptr2->next->name, tempName);\n\n                tempID = ptr2->id;  // Swap ID\n                ptr2->id = ptr2->next->id;\n                ptr2->next->id = tempID;\n\n                tempGrade = ptr2->grade;  // Swap grades\n                ptr2->grade = ptr2->next->grade;\n                ptr2->next->grade = tempGrade;\n            }\n        }\n    }\n\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (choose sorting method)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } \n                else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                puts(\"List deleted\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n            }\n    } while (choice != 6);\n    return 0;\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation effectively sorts student records by grade. While bubble sort is straightforward and easy to implement, its time complexity of O(n?) can lead to inefficiency with larger datasets. For better performance, consider using more efficient sorting algorithms, such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20724220",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX_SIZE 10 // Define maximum size of the matrix\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int *rows, int *columns, char name);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int columns);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int columns);\r\nvoid subMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int columns);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int columns, char name);\r\n\r\nint main() {\r\n\tint rowsA, columnsA, rowsB, columnsB;\r\n\tint matrixA[MAX_SIZE][MAX_SIZE] = {0};\r\n\tint matrixB[MAX_SIZE][MAX_SIZE] = {0};\r\n\tint choice;\r\n\t\r\n\tinputMatrix(matrixA, &rowsA, &columnsA, 'A'); // input Matrix A\r\n\tinputMatrix(matrixB, &rowsB, &columnsB, 'B'); // input Matrix B\r\n\r\n\t// Main menu\r\n\tdo {\r\n\t\tprintf(\"\\nMatrix Operations Menu:\\n\");\r\n\t\tprintf(\"1. Add Matrices\\n\");\r\n\t\tprintf(\"2. Subtract Matrices\\n\");\r\n\t\tprintf(\"3. Transpose Matrix A\\n\");\r\n\t\tprintf(\"4. Transpose Matrix B\\n\");\r\n\t\tprintf(\"5. Exit\\n\");\r\n        printf(\"\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n\t\t// handle user choice using switch case\r\n\t\tswitch (choice) {\r\n\t\tcase 1:\r\n\t\t\t// add matrices if they have the same dimension\r\n\t\t\tif (rowsA == rowsB && columnsA == columnsB) { \r\n\t\t\t\taddMatrices(matrixA, matrixB, rowsA, columnsA);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprintf(\"Matrices must have the same dimension to be added.\\n\");\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\t// subtract matrices if they have the same dimension\r\n\t\t\tif (rowsA == rowsB && columnsA == columnsB) {\r\n\t\t\t\tsubMatrices(matrixA, matrixB, rowsA, columnsA);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprintf(\"Matrices must have the same dimension to be subtracted.\\n\");\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\ttransposeMatrix(matrixA, rowsA, columnsA, 'A'); // transpose Matrix A\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\ttransposeMatrix(matrixB, rowsB, columnsB, 'B'); // transpose Matrix B\r\n\t\t\tbreak;\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\t\tdefault:\r\n\t\t\tprintf(\"Invalid choice. Please enter again.\\n\");\r\n\t\t} \r\n\r\n\t} while (choice != 5);\r\n\r\n\treturn 0;\r\n}\r\n\r\n// Function to input a matrix\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int *rows, int *columns, char name){\r\n\t// Prompt the user to enter dimension of matrix\r\n\tdo {\r\n\t\tprintf(\"Enter dimensions for Matrix %c (rows and columns): \", name);\r\n\t\tscanf(\"%d %d\", rows, columns);\r\n\r\n\t\t// Check if the matrix size exceed the maximum size allowed\r\n\t\tif (*rows > MAX_SIZE || *columns > MAX_SIZE) {\r\n\t\t\tprintf(\"Matrix size exceeds the maximum size (%dx%d).\\n\", MAX_SIZE, MAX_SIZE);\r\n\t\t\tprintf(\"Please enter again.\\n\");\r\n\t\t}\r\n\t} while (*rows > MAX_SIZE || *columns > MAX_SIZE);\r\n\r\n\t// Prompt the user to enter elements for the matrix\r\n\tprintf(\"Enter elements for Matrix %c:\\n\", name);\r\n\tfor (int i = 0; i < *rows; i++) { // outer loop control rows\r\n\t\tfor (int j = 0; j < *columns; j++) { // inner loop control columns\r\n\t\t\tprintf(\"Elements [%d][%d]: \", i+1, j+1);\r\n\t\t\tscanf(\"%d\", &matrix[i][j]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Function to print matrices\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int columns) {\r\n\tfor (int i = 0; i < rows; i++) {\r\n\t\tfor (int j = 0; j < columns; j++) {\r\n\t\t\tprintf(\"%-3d\", matrix[i][j]);\r\n\t\t}\r\n        printf(\"\\n\");\r\n\t} \r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int columns) {\r\n\tint result[MAX_SIZE][MAX_SIZE];\r\n\tfor (int i = 0; i < rows; i++) {\r\n\t\tfor (int j = 0; j < columns; j++) {\r\n\t\t\tresult[i][j] = matrixA[i][j] + matrixB[i][j];\r\n\t\t}\r\n\t}\r\n\tprintf(\"Result of Matrix A + Matrix B:\\n\");\r\n\tprintMatrix(result, rows, columns);\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rows, int columns) {\r\n\tint result[MAX_SIZE][MAX_SIZE];\r\n\tfor (int i = 0; i < rows; i++) {\r\n\t\tfor (int j = 0; j < columns; j++) {\r\n\t\t\tresult[i][j] = matrixA[i][j] - matrixB[i][j];\r\n\t\t}\r\n\t}\r\n\tprintf(\"Result of Matrix A - Matrix B:\\n\");\r\n\tprintMatrix(result, rows, columns);\r\n}\r\n\r\n// Function to transpose matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int columns, char name) {\r\n\tint result[MAX_SIZE][MAX_SIZE];\r\n\tfor (int i = 0; i < rows; i++) {\r\n\t\tfor (int j = 0; j < columns; j++) {\r\n\t\t\tresult[j][i] = matrix[i][j]; // swap rows and columns\r\n\t\t}\r\n\t}\r\n\tprintf(\"Transpose of Matrix %c:\\n\", name);\r\n\tprintMatrix(result, columns, rows); \r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n#define MAX_ITEMS 100 // define maximum number of grocery items\r\n#define MAX_NAME_LEN 100 // define max length for item name\r\n#define MAX_CAT_LEN 50 // define max length for item category\r\n\r\n// define a structure to store individual grocery item details\r\ntypedef struct{\r\n    char name [MAX_NAME_LEN];\r\n    char category[MAX_CAT_LEN];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// define a structure to store grocery items' availability status\r\ntypedef struct{\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// define a structure to represent the entire grocery inventory\r\ntypedef struct{\r\n    GroceryItem grocery[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// function prototypes\r\nvoid removeNewLine(char *str);\r\nvoid addGrocery(GroceryInventory *inventory);\r\nvoid listGrocery(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGrocery(GroceryInventory *inventory);\r\n\r\nint main(){\r\n    GroceryInventory inventory = { .count = 0 }; // initialise the inventory\r\n    int choice;\r\n\r\n    do {\r\n        // Main Menu\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Items\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Items\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // clear newline from input buffer\r\n\r\n        // handle user choice using switch case\r\n        switch (choice){\r\n            case 1:\r\n                addGrocery(&inventory); // add new grocery items\r\n                break;\r\n            case 2:\r\n                listGrocery(&inventory); // list all grocery items\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory); // update quantity of an item\r\n                break;\r\n            case 4:\r\n                removeGrocery(&inventory); // remove grocery items\r\n                break;\r\n            case 5:\r\n                printf(\"Exited.\\n\"); // exit the application\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please enter again.\\n\");\r\n        }\r\n    \r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n\r\n}\r\n\r\n// function to remove newline character\r\nvoid removeNewLine(char *str) \r\n{\r\n\tstr[strcspn(str, \"\\n\")] = 0;\r\n}\r\n\r\n// function to add grocery items to the inventory\r\nvoid addGrocery(GroceryInventory *inventory){\r\n\r\n    // check if inventory is full\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->grocery[inventory->count]; // pointer to new item\r\n    AvailabilityStatus *availability = &inventory->status[inventory->count]; // pointer to status\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(item->name, MAX_NAME_LEN, stdin);\r\n    removeNewLine(item->name);\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item->category, MAX_CAT_LEN, stdin);\r\n    removeNewLine(item->category);\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item->price);\r\n    while (getchar() != '\\n'); // clear input buffer\r\n\r\n    // update availability status based on quantity of the item\r\n    availability->inStock = (item->quantity > 0);\r\n    availability->outOfStock = (item->quantity == 0);\r\n\r\n    inventory->count++; // increment inventory count\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// function to list all grocery items\r\nvoid listGrocery(GroceryInventory *inventory){\r\n\r\n    // check if there are items in the inventory\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // display each items details\r\n    for (int i = 0; i < inventory->count; i++){\r\n        const GroceryItem *item = &inventory->grocery[i]; \r\n        const AvailabilityStatus *availability = &inventory->status[i]; \r\n\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n\r\n        if (availability->inStock){\r\n            printf(\"Status: %s\\n\", \"In Stock\");\r\n        }\r\n        else {\r\n            printf(\"Status: %s\\n\", \"Out of Stock\");\r\n        }\r\n    }\r\n}\r\n\r\n// function to update grocery item quantity\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n\r\n    // Check if there are items in the inventory\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LEN]; // name of the item to update\r\n    int itemFound = 0; // flag to track if the item is found\r\n\r\n    do {\r\n        printf(\"Enter name of the grocery item to update quantity: \");\r\n        fgets(name, MAX_NAME_LEN, stdin);\r\n        removeNewLine(name);\r\n\r\n        for (int i = 0; i < inventory->count; i++) {\r\n            GroceryItem *item = &inventory->grocery[i];\r\n            AvailabilityStatus *availability = &inventory->status[i];\r\n\r\n            if (strcmp(item->name, name) == 0) {\r\n                printf(\"Enter new quantity for %s: \", name);\r\n                scanf(\"%d\", &item->quantity);\r\n                getchar(); // clear newline character from input buffer\r\n\r\n                // update availability status\r\n                availability->inStock = (item->quantity > 0);\r\n                availability->outOfStock = (item->quantity == 0);\r\n\r\n                printf(\"Quantity updated successfully!\\n\");\r\n                itemFound = 1; // mark the item as found\r\n                break; // exit the loop since the item is found\r\n            }\r\n        }\r\n\r\n        if (!itemFound) {\r\n            printf(\"Item not found. Please try again.\\n\");\r\n        }\r\n\r\n    } while (!itemFound);\r\n}\r\n\r\n// function to remove grocery items\r\nvoid removeGrocery(GroceryInventory *inventory){\r\n\r\n    // Check if there are items in the inventory\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LEN];\r\n    int itemFound = 0; // flag to track if the item is found\r\n\r\n    do {\r\n        printf(\"Enter name of the grocery item to remove: \");\r\n        fgets(name, MAX_NAME_LEN, stdin);\r\n        removeNewLine(name);\r\n\r\n        for (int i = 0; i < inventory->count; i++) {\r\n            GroceryItem *item = &inventory->grocery[i];\r\n            AvailabilityStatus *availability = &inventory->status[i];\r\n\r\n            // check if the name matches\r\n            if (strcmp(item->name, name) == 0) {\r\n\r\n                // shift all elements left to fill the gap\r\n                for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->grocery[j] = inventory->grocery[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n                }\r\n\r\n                inventory->count--;\r\n                printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n                itemFound = 1; // mark the item as found\r\n                break; // exit the loop since the item is found\r\n            }\r\n        }\r\n\r\n        if (!itemFound) {\r\n            printf(\"Item not found. Please try again.\\n\");\r\n        }\r\n\r\n    } while (!itemFound);\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#define MAX_NAME_LEN 100 // define max length for student name\r\n\r\n// define a structure to store individual student details\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next; // pointer to next student in the linked list\r\n} Student; \r\n\r\nStudent *head = NULL; // head of the linked list\r\n\r\n// function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(Student* head, int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\nvoid sortStudents(); \r\nStudent* mergeSort(Student* head);\r\nStudent* split(Student* head);\r\nStudent* merge(Student* left, Student* right);\r\n\r\n// Main function to drive the program\r\nint main() {\r\n\r\n    int choice, id;\r\n    char name[100];\r\n    float grade; \r\n\r\n    do {\r\n        // Main Menu\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        // handle user choice using switch case\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // remove trailing newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade); // insert student record into linked list\r\n                break;\r\n            case 2:\r\n                displayStudents(); // display all current student records\r\n                break;\r\n            case 3:\r\n                sortStudents(); // sort student records by grade\r\n                printf(\"Records sorted by grade using merge sort.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(head, id); // search for student record by ID\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList(); // delete all student records\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\"); // exit the application\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n\r\n    // allocate memory for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n\r\n    if (!newStudent) {\r\n        // handle memory allocation failure\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    // initialise the new student record\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n\r\n    Student *newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n\r\n    // check if there are student records\r\n    if (!head) {\r\n        printf(\"No existing student records.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student *current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(Student* head, int id) {\r\n\r\n    Student *current = head;\r\n    while (current) {\r\n        if (current->id == id) { // check if the current student ID matches the search ID\r\n            return current; // student found\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL; // No matching student found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    // free each node and move to the next\r\n    while (current != NULL) { \r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to free all allocated memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using merge sort\r\nvoid sortStudents() {\r\n\r\n    /* Merge sort is used because\r\n        - it guarantees a time complexity of O(n log n) in the average, best, and worst cases\r\n        - it is a stable sorting algorithm\r\n        - it fits well with linked List because it traverses items in sequential manner, avoid random access\r\n    */\r\n\r\n    if (!head || !head->next) return; // No need to sort if list has 0 or 1 node\r\n    head = mergeSort(head);\r\n\r\n} \r\n\r\n// Function to do merge sort\r\nStudent* mergeSort(Student* head) {\r\n\r\n    // Base case: if the list is empty or has only one node, it's already sorted\r\n    if (head == NULL || head->next == NULL) return head;\r\n\r\n    // split the list into two havles\r\n    Student *middle = split(head);\r\n    Student *left = head;\r\n    Student *right = middle;\r\n\r\n    // recursively sort each half\r\n    left = mergeSort(left);\r\n    right = mergeSort(right);\r\n\r\n    // merge the two sorted havles\r\n    return merge(left, right);\r\n\r\n}\r\n\r\n// Function to split the linked list into havles\r\nStudent* split(Student* head) {\r\n\r\n    Student* fast = head;\r\n    Student* slow = head;\r\n\r\n    // Move fast pointer two steps and slow pointer one step to find the middle\r\n    while (fast->next && fast->next->next) {\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n    }\r\n\r\n    // split the list into two havles\r\n    Student* middle = slow->next;\r\n    slow->next = NULL; // terminate the first half\r\n    return middle;\r\n\r\n}\r\n\r\n// function to merge two sorted linked lists\r\nStudent* merge(Student* left, Student* right) {\r\n\r\n    // If either list is empty, return the other list\r\n    if (left == NULL) return right;\r\n    if (right == NULL) return left;\r\n\r\n    // Compare grade and merge the lists\r\n    if (left->grade < right->grade) {\r\n        left->next = merge(left->next, right);\r\n        return left;\r\n    } else {\r\n        right->next = merge(left, right->next);\r\n        return right;\r\n    }\r\n\r\n}",
    "feedback": "q1-Meet requirement\nq2-The AvailabilityStatus struct is defined but not necessary. You can determine if an item is in stock based solely on the quantity. You can simplify the code by removing this struct and using a boolean derived from the quantity in the GroceryItem struct or use a union. In the removeGrocery function, after shifting the items left, the last item in the array is left unchanged. This could lead to accessing outdated or invalid data if the last item was previously removed.\nq3-    The merge sort implementation is well-suited for linked lists, as it operates in O(n log n) time complexity, which is efficient compared to bubble sort. It is stable and works well with the sequential nature of linked lists."
  },
  {
    "student_id": "20607094",
    "code": "",
    "feedback": "q1-The displayMatrix function is called in the addMatrices and subtractMatrices functions after calculating results, but the result matrix is not initialized or declared in the right scope.\nq2-Meet requirement. \nq3-The program uses Bubble Sort to sort student records by grade. While functional, Bubble Sort has a time complexity of O(n?), which can be inefficient for larger datasets. For enhanced efficiency, consider implementing more advanced sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20718606",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10\n\n//  functions for working with matrices\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char name); //get user input\nvoid displayMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]); //print\nvoid addMatrices(int rows, int cols, int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]); //add\nvoid subtractMatrices(int rows, int cols, int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]); //subtract\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]); //transpose\n\nint main() { \n    // Initialize variables\n    int rowsA, colsA, rowsB, colsB;\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\n    int result[MAX_SIZE][MAX_SIZE];\n    int choice;\n\n    // Get dimensions for Matrix A\n    printf(\"Matrix A dimensions (rows cols): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE) {\n        printf(\"Max size is %dx%d.\\n\", MAX_SIZE, MAX_SIZE);\n        return 1;\n    }\n\n    inputMatrix(rowsA, colsA, matrixA, 'A');\n\n    // Get dimensions for Matrix B\n    printf(\"Matrix B dimensions (rows cols): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    if (rowsB > MAX_SIZE || colsB > MAX_SIZE) {\n        printf(\"Max size is %dx%d.\\n\", MAX_SIZE, MAX_SIZE);\n        return 1;\n    }\n\n    inputMatrix(rowsB, colsB, matrixB, 'B');\n\n    // Keep asking user what they want to do\n    do {\n        printf(\"\\nMatrix operations menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1: //if choice is 1\n                if (rowsA == rowsB && colsA == colsB) { //check if rows and cols are the same\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\n                    printf(\"Sum is:\\n\");\n                    displayMatrix(rowsA, colsA, result);\n                } else { //if rows and cols are not the same\n                    printf(\"Addition needs matrices of the same size.\\n\"); \n                }\n                break;\n\n            case 2: //if choice is 2\n                if (rowsA == rowsB && colsA == colsB) { //check if rows and cols are the same\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\n                    printf(\"Difference is:\\n\");\n                    displayMatrix(rowsA, colsA, result);\n                } else { //if rows and cols are not the same\n                    printf(\"Subtraction needs matrices of the same size.\\n\");\n                }\n                break;\n\n            case 3: //if choice is 3\n                transposeMatrix(rowsA, colsA, matrixA, result);\n                printf(\"Matrix A Transposed:\\n\");\n                displayMatrix(colsA, rowsA, result);\n                break;\n\n            case 4: //if choice is 4\n                transposeMatrix(rowsB, colsB, matrixB, result);\n                printf(\"Matrix B Transposed:\\n\");\n                displayMatrix(colsB, rowsB, result);\n                break;\n\n            case 5: //if choice is 5\n                printf(\"Bye!\\n\");\n                break;\n\n            default:\n                printf(\"Not a valid choice. Try again.\\n\");\n        }\n\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Get user input for a matrix\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], char name) {\n    printf(\"Fill in Matrix %c:\\n\", name); \n    for (int i = 0; i < rows; i++) { //loop to get number of rows\n        for (int j = 0; j < cols; j++) { //nested loop to get number of columns\n            printf(\"%c[%d][%d]: \", name, i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Add two matrices\nvoid addMatrices(int rows, int cols, int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) { //get each element\n            result[i][j] = matrixA[i][j] + matrixB[i][j]; //matrices are added by adding corresponding elements\n        }\n    }\n}\n\n// Subtract two matrices\nvoid subtractMatrices(int rows, int cols, int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) { //get each element\n            result[i][j] = matrixA[i][j] - matrixB[i][j]; //matrices are subtracted by subtracting corresponding elements\n        }\n    }\n}\n\n// Transpose a matrix\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) { //to transpose a matrix is to switch rows and columns\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) { //get each element\n            result[j][i] = matrix[i][j]; //switch rows and columns\n        }\n    }\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n#define NAME_LEN 100\n#define CATEGORY_LEN 50\n\n// Struct to store item details\ntypedef struct {\n    char name[NAME_LEN]; // Item name, max 100 characters\n    char category[CATEGORY_LEN]; // Category of the item, max 50 characters\n    int quantity; // Quantity available\n    float price; // Price per item\n} GroceryItem;\n\n// Struct to store availability status\ntypedef struct {\n    bool inStock; // True if item is in stock\n    bool outOfStock; // True if item is out of stock\n} AvailabilityStatus;\n\n// Struct to manage the entire inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS]; // Array to hold grocery items\n    AvailabilityStatus status[MAX_ITEMS]; // Array to hold availability status\n    int count; // Number of items currently in inventory\n} GroceryInventory;\n\n// Function to add a new grocery item to the inventory\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) { // -> is a pointer operator. In this case it points to the memory address of the count variable.\n        printf(\"Inventory is full. Cannot add more items.\\n\"); \n        return;\n    }\n\n    GroceryItem newItem; // Temporary variable to hold the new item\n    printf(\"Enter item name: \");\n    fgets(newItem.name, NAME_LEN, stdin);\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0; // Remove newline character\n\n    printf(\"Enter category: \");\n    fgets(newItem.category, CATEGORY_LEN, stdin);\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0; // Remove newline character\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &newItem.quantity); // Read the quantity\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &newItem.price); // Read the price\n    getchar(); // Clear the newline left by scanf\n\n    // Add the new item to the inventory\n    inventory->items[inventory->count] = newItem;\n\n    AvailabilityStatus newStatus;\n    if (newItem.quantity > 0) {\n        newStatus.inStock = true; // Item is available\n        newStatus.outOfStock = false;\n    } else {\n        newStatus.inStock = false; // Item is not available\n        newStatus.outOfStock = true;\n    }\n\n    inventory->status[inventory->count] = newStatus; // Update status\n    inventory->count++; // Increment item count\n\n    printf(\"Item added successfully!\\n\");\n}\n\n// Function to list all grocery items in the inventory\nvoid listGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\nInventory List:\\n\");\n    for (int i = 0; i < inventory->count; i++) { // Loop through all items\n        printf(\"Item %d:\\n\", i + 1); \n        printf(\"  Name: %s\\n\", inventory->items[i].name);\n        printf(\"  Category: %s\\n\", inventory->items[i].category);\n        printf(\"  Quantity: %d\\n\", inventory->items[i].quantity);\n        printf(\"  Price: %.2f\\n\", inventory->items[i].price);\n        printf(\"  Availability: %s\\n\", inventory->status[i].inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of an existing item\nvoid updateQuantity(GroceryInventory *inventory) {\n    char itemName[NAME_LEN];\n    printf(\"Enter the name of the item to update quantity: \");\n    fgets(itemName, NAME_LEN, stdin); // Read the item name from user input\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline character\n\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) { // Check if the item name matches\n            printf(\"Enter new quantity: \"); \n            scanf(\"%d\", &inventory->items[i].quantity); // Read the new quantity\n            getchar(); // Clear the newline left by scanf\n\n            // Update availability status using boolean conditions to check\n            if (inventory->items[i].quantity > 0) {\n                inventory->status[i].inStock = true; \n                inventory->status[i].outOfStock = false;\n            } else {\n                inventory->status[i].inStock = false;\n                inventory->status[i].outOfStock = true;\n            }\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory.\\n\");\n}\n\n// Function to remove an item from the inventory\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    char itemName[NAME_LEN];\n    printf(\"Enter the name of the item to remove: \");\n    fgets(itemName, NAME_LEN, stdin);\n    itemName[strcspn(itemName, \"\\n\")] = 0; // Remove newline character\n\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            // Shift items down to remove the specified item\n            for (int j = i; j < inventory->count - 1; j++) { // Shift items down\n                inventory->items[j] = inventory->items[j + 1]; // Copy the next item\n                inventory->status[j] = inventory->status[j + 1]; // Copy the next availability status\n            }\n\n            inventory->count--; // Decrease the count\n            printf(\"Item removed successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory.\\n\");\n}\n\nint main() {\n    GroceryInventory inventory = { .count = 0 }; // Initialize inventory\n    int choice;\n\n    do {\n        // Display menu\n        printf(\"\\nGrocery Inventory Management:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice); // Read user choice\n        getchar(); // Clear the newline left by scanf\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory); // Add new item\n                break;\n            case 2:\n                listGroceryItems(&inventory); // List all items\n                break;\n            case 3:\n                updateQuantity(&inventory); // Update quantity of an item\n                break;\n            case 4:\n                removeGroceryItem(&inventory); // Remove an item\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\"); // Exit the program\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\"); // Handle invalid input\n        }\n    } while (choice != 5); // Loop until user chooses to exit\n\n    return 0;\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\n    newStudent->name[sizeof(newStudent->name) - 1] = '\\0'; // Ensure null termination\n    newStudent->id = id; // Set the ID\n    newStudent->grade = grade; // Set the grade\n    newStudent->next = NULL; // Set the next pointer to NULL\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    if (head == NULL) {\n        head = newStudent;\n        return;\n    }\n    Student* current = head;\n    while (current->next != NULL) { // Find the last node\n        current = current->next; // Move to the next node\n    } \n    current->next = newStudent; // Insert the new node\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n    printf(\"Student Records (sorted alphabetically):\\n\");\n    Student* current = head;\n    while (current != NULL) { // Loop through all nodes\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head; \n    while (current != NULL) {\n        Student* next = current->next; // Save the next node\n        free(current); // Free the current node\n        current = next; // Move to the next node\n    }\n    head = NULL;\n}\n\n// Function to free memory\nvoid freeMemory() {\n    deleteList();\n}\n\n// Function to sort the records alphabetically by name\n// Using bubble sort:\nvoid sortRecords() {\n    if (head == NULL || head->next == NULL) {\n        // List is empty or has only one element, no need to sort\n        return;\n    }\n\n    Student* ptr1 = head; // Pointer to traverse the list\n    Student* ptr2 = head->next; \n\n    while (ptr1 != NULL) { // Loop through the list\n        ptr2 = ptr1->next; \n        while (ptr2 != NULL) {\n            if (strcmp(ptr1->name, ptr2->name) > 0) { // If the current name is greater than the next name\n                // Swap the names \n                char tempName[100]; // Temporary variable to hold the name\n                strncpy(tempName, ptr1->name, sizeof(tempName) - 1); // Copy the name\n                tempName[sizeof(tempName) - 1] = '\\0'; // Ensure null termination\n\n                strncpy(ptr1->name, ptr2->name, sizeof(ptr1->name) - 1); \n                ptr1->name[sizeof(ptr1->name) - 1] = '\\0'; \n\n                strncpy(ptr2->name, tempName, sizeof(ptr2->name) - 1);\n                ptr2->name[sizeof(ptr2->name) - 1] = '\\0'; \n\n                // Swap the IDs\n                int tempID = ptr1->id;\n                ptr1->id = ptr2->id;\n                ptr2->id = tempID;\n\n                // Swap the grades\n                float tempGrade = ptr1->grade;\n                ptr1->grade = ptr2->grade;\n                ptr2->grade = tempGrade;\n            }\n            ptr2 = ptr2->next;\n        }\n        ptr1 = ptr1->next;\n    }\n    // List is now sorted, display the sorted records\n    displayStudents();\n}\n\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (Alphabetical by Name)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortRecords();\n                // printf(\"Records sorted alphabetically by name.\\n\");\n                break;\n\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\n                           found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20590948",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10  // Define the maximum size for the matrix\n\n// Function declarations for matrix operations\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];  // Matrices A and B\n    int rowsA, colsA, rowsB, colsB;  // Dimensions of matrices\n    int choice;  // User's choice for the operation\n\n    // Input the size and elements of Matrix A\n    printf(\"Enter the number of rows and columns for Matrix A: \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE) {\n        printf(\"Error: Dimensions of Matrix A exceed the allowed limit.\\n\");\n        return 1;  // Exit the program if dimensions are invalid\n    }\n\n    printf(\"Enter the elements of Matrix A:\\n\");\n    inputMatrix(A, rowsA, colsA);\n\n    // Input the size and elements of Matrix B\n    printf(\"Enter the number of rows and columns for Matrix B: \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n\n    if (rowsB > MAX_SIZE || colsB > MAX_SIZE) {\n        printf(\"Error: Dimensions of Matrix B exceed the allowed limit.\\n\");\n        return 1;  // Exit the program if dimensions are invalid\n    }\n\n    printf(\"Enter the elements of Matrix B:\\n\");\n    inputMatrix(B, rowsB, colsB);\n\n    // Display a menu for matrix operations\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Choose an option: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                // Perform matrix addition\n                if (rowsA == rowsB && colsA == colsB) {\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    addMatrices(A, B, rowsA, colsA);\n                } else {\n                    printf(\"Error: Matrices must have the same dimensions for addition.\\n\");\n                }\n                break;\n\n            case 2:\n                // Perform matrix subtraction\n                if (rowsA == rowsB && colsA == colsB) {\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    subtractMatrices(A, B, rowsA, colsA);\n                } else {\n                    printf(\"Error: Matrices must have the same dimensions for subtraction.\\n\");\n                }\n                break;\n\n            case 3:\n                // Transpose Matrix A\n                printf(\"Transpose of Matrix A:\\n\");\n                transposeMatrix(A, rowsA, colsA);\n                break;\n\n            case 4:\n                // Transpose Matrix B\n                printf(\"Transpose of Matrix B:\\n\");\n                transposeMatrix(B, rowsB, colsB);\n                break;\n\n            case 5:\n                // Exit the program\n                printf(\"Exiting the program. Goodbye!\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice. Please select a valid option from the menu.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to input matrix elements\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Enter element at position [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to display a matrix\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");  // Move to the next row\n    }\n}\n\n// Function to add two matrices and display the result\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int result[MAX_SIZE][MAX_SIZE];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];  // Perform element-wise addition\n        }\n    }\n    printMatrix(result, rows, cols);\n}\n\n// Function to subtract one matrix from another and display the result\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int result[MAX_SIZE][MAX_SIZE];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];  // Perform element-wise subtraction\n        }\n    }\n    printMatrix(result, rows, cols);\n}\n\n// Function to calculate and display the transpose of a matrix\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int result[MAX_SIZE][MAX_SIZE];\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < rows; j++) {\n            result[i][j] = matrix[j][i];  // Swap rows and columns\n        }\n    }\n    printMatrix(result, cols, rows);\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100       // Maximum number of grocery items allowed in inventory\n#define MAX_NAME_LEN 100    // Maximum length for item names\n#define MAX_CATEGORY_LEN 50 // Maximum length for item categories\n\n// Structure to store details of a grocery item\ntypedef struct {\n    char name[MAX_NAME_LEN];       // Name of the grocery item\n    char category[MAX_CATEGORY_LEN]; // Category to which the item belongs\n    int quantity;                 // Number of items available\n    float price;                  // Price per unit of the item\n} GroceryItem;\n\n// Structure to manage item availability status\ntypedef struct {\n    bool inStock;                 // Indicates if the item is in stock\n    bool outOfStock;              // Indicates if the item is out of stock\n} AvailabilityStatus;\n\n// Structure to maintain the inventory, including items and their statuses\ntypedef struct {\n    GroceryItem items[MAX_ITEMS]; // Array of grocery items\n    AvailabilityStatus status[MAX_ITEMS]; // Array of item availability statuses\n    int count;                    // Number of items currently in inventory\n} GroceryInventory;\n\n// Function declarations for inventory operations\nvoid addItem(GroceryInventory* inventory);     // Function to add a new item to the inventory\nvoid listItems(GroceryInventory* inventory);   // Function to list all items in the inventory\nvoid updateQuantity(GroceryInventory* inventory); // Function to update the quantity of an item\nvoid removeItem(GroceryInventory* inventory);  // Function to remove an item from the inventory\n\nint main() {\n    GroceryInventory inventory = {.count = 0}; // Initialize inventory with no items\n    int choice; // Variable to store user's menu selection\n\n    // Menu-driven program for inventory management\n    do {\n        printf(\"\\nGrocery Inventory Management System:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Clear input buffer to prevent issues with fgets\n\n        switch (choice) {\n            case 1:\n                addItem(&inventory); // Add a new item to the inventory\n                break;\n            case 2:\n                listItems(&inventory); // Display all items in the inventory\n                break;\n            case 3:\n                updateQuantity(&inventory); // Update the quantity of an existing item\n                break;\n            case 4:\n                removeItem(&inventory); // Remove an item from the inventory\n                break;\n            case 5:\n                printf(\"Exiting the program. Goodbye!\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please select a valid option.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Add a new grocery item to the inventory\nvoid addItem(GroceryInventory* inventory) {\n    if (inventory->count >= MAX_ITEMS) { // Check if the inventory is full\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem* item = &inventory->items[inventory->count]; // Get pointer to the new item\n    AvailabilityStatus* status = &inventory->status[inventory->count]; // Get pointer to the new item's status\n\n    // Input details for the new item\n    printf(\"Enter item name: \");\n    fgets(item->name, MAX_NAME_LEN, stdin);\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // Remove newline character from input\n\n    printf(\"Enter category: \");\n    fgets(item->category, MAX_CATEGORY_LEN, stdin);\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &item->quantity);\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &item->price);\n\n    // Update availability status based on quantity\n    status->inStock = item->quantity > 0;\n    status->outOfStock = !status->inStock;\n\n    inventory->count++; // Increment the count of items in inventory\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Display all grocery items in the inventory\nvoid listItems(GroceryInventory* inventory) {\n    if (inventory->count == 0) { // Check if inventory is empty\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    // Iterate through the inventory and display item details\n    for (int i = 0; i < inventory->count; i++) {\n        GroceryItem* item = &inventory->items[i];\n        AvailabilityStatus* status = &inventory->status[i];\n\n        printf(\"\\nItem %d:\\n\", i + 1);\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Update the quantity of a specific grocery item\nvoid updateQuantity(GroceryInventory* inventory) {\n    if (inventory->count == 0) { // Check if inventory is empty\n        printf(\"No items in inventory to update.\\n\");\n        return;\n    }\n\n    char name[MAX_NAME_LEN]; // Variable to store item name for search\n    printf(\"Enter the name of the grocery item to update quantity: \");\n    fgets(name, MAX_NAME_LEN, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0';\n\n    // Search for the item by name\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            printf(\"Enter new quantity for %s: \", name);\n            scanf(\"%d\", &inventory->items[i].quantity);\n\n            // Update availability status based on new quantity\n            inventory->status[i].inStock = inventory->items[i].quantity > 0;\n            inventory->status[i].outOfStock = !inventory->status[i].inStock;\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory.\\n\");\n}\n\n// Remove a grocery item from the inventory\nvoid removeItem(GroceryInventory* inventory) {\n    if (inventory->count == 0) { // Check if inventory is empty\n        printf(\"No items in inventory to remove.\\n\");\n        return;\n    }\n\n    char name[MAX_NAME_LEN]; // Variable to store item name for removal\n    printf(\"Enter the name of the grocery item to remove: \");\n    fgets(name, MAX_NAME_LEN, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0';\n\n    // Search for the item by name\n    for (int i = 0; i < inventory->count; i++) {\n        if (strcmp(inventory->items[i].name, name) == 0) {\n            // Shift items to remove the specified item\n            for (int j = i; j < inventory->count - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n                inventory->status[j] = inventory->status[j + 1];\n            }\n\n            inventory->count--; // Decrease item count\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory.\\n\");\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;  \n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (newStudent == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        return NULL;\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    if (newStudent == NULL) return;\n\n    newStudent->next = head;\n    head = newStudent;\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n\n    Student* temp = head;\n    \n    while (temp != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp != NULL) {\n        if (temp->id == id) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\n// Free all memory used by the program\nvoid freeMemory() {\n    deleteList();\n\n}\n\n// Swap function to swap two student nodes\nvoid swap(Student* a, Student* b) {\n    char tempName[100];\n    int tempID;\n    float tempGrade;\n\n    // Swap the data of two students\n    strcpy(tempName, a->name);\n    tempID = a->id;\n    tempGrade = a->grade;\n\n    strcpy(a->name, b->name);\n    a->id = b->id;\n    a->grade = b->grade;\n\n    strcpy(b->name, tempName);\n    b->id = tempID;\n    b->grade = tempGrade;\n}\n\n// Function to sort the student records by grade using Bubble Sort\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        return;  // No need to sort if the list has 0 or 1 element\n    }\n\n    int swapped;\n    Student *ptr1;\n    Student *ptr2 = NULL;\n\n    // Sorting the list by grades using Bubble Sort\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != ptr2) {\n            if (ptr1->grade > ptr1->next->grade) {\n                swap(ptr1, ptr1->next);\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        ptr2 = ptr1;\n    } while (swapped);\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        // Display menu options\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); \n\n        switch (choice) {\n            case 1:\n                // Insert student record\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");  \n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                // Display all student records\n                displayStudents();\n                break;\n            case 3:\n                // Sort student records by grade\n                sortStudents();\n                break;\n            case 4:\n                // Search for student record by ID\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                // Delete all student records\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                // Exit the program\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is simple and works well for small lists. Its time complexity of O(n?) can lead to inefficiencies with larger datasets. For improved performance, consider implementing more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20612400",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10\r\n\r\nvoid createMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    printf(\"Enter the elements of the matrix (%d x %d):\\n\", rows, cols);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid add(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtract(int rows, int cols, int a[MAX][MAX], int b[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transpose(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int a[10][10], b[10][10], result[10][10];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    printf(\"Enter dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsA > 10 || colsA > 10 || rowsB > 10 || colsB > 10 || rowsA <= 0 || colsA <= 0 || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Dimension not accepted.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    printf(\"Matrix A:\\n\");\r\n    createMatrix(rowsA, colsA, a);\r\n    printf(\"Matrix B:\\n\");\r\n    createMatrix(rowsB, colsB, b);\r\n\r\n    do {\r\n        printf(\"\\nChoose operation:\\n\");\r\n        printf(\"1. Add\\n2. Subtract\\n3. Transpose A\\n4. Transpose B\\n5. Exit\\n\");\r\n        printf(\"Enter choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    add(rowsA, colsA, a, b, result);\r\n                    printf(\"Result:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Unable to add Matrices\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtract(rowsA, colsA, a, b, result);\r\n                    printf(\"Result:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Unable to subtract Matrices\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transpose(rowsA, colsA, a, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n\r\n            case 4:\r\n                transpose(rowsB, colsB, b, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice!\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX 100\r\n#define BUFFER_SIZE 100\r\n\r\ntypedef struct {\r\n    char name[BUFFER_SIZE];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int inStock; \r\n} Item;\r\n\r\nItem inventory[MAX];\r\nint itemCount = 0;\r\n\r\nvoid addItem();\r\nvoid displayItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Item\\n\");\r\n        printf(\"2. List Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                displayItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addItem() {\r\n    if (itemCount >= MAX) {\r\n        printf(\"Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    Item newItem;\r\n    printf(\"Enter item name: \");\r\n\r\n    getchar();\r\n\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\"); \r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\"); \r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    newItem.inStock = (newItem.quantity > 0) ? 1 : 0;\r\n\r\n    inventory[itemCount++] = newItem;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\nvoid displayItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nInventory:\\n\");\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"%d. Name: %s, Category: %s, Quantity: %d, Price: %.2f, Status: %s\\n\",\r\n               i + 1, inventory[i].name, inventory[i].category, inventory[i].quantity,\r\n               inventory[i].price, inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\"); \r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n\r\n            inventory[i].inStock = (inventory[i].quantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n\r\n    getchar(); \r\n\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\"); \r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n\r\n            itemCount--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            \r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\nvoid sortStudents();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                Student* found = searchStudentByID(id);\r\n\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted.\\n\");\r\n}\r\n\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    \r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        return; \r\n    }\r\n\r\n    Student* i;\r\n    Student* j;\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempID;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The sorting method effectively sorts student records based on grades. However, the nested loop structure resembles a bubble sort, which has a time complexity of O(n?). For larger datasets, consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20612781",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define SIZE 10\n\n//Input element fuction\nvoid matrix (int matrix[SIZE][SIZE], int row, int col, char character) {\n    printf(\"Enter elements for Matrix %c: \\n\" ,character);\n    for(int i=0; i<row; i++) {\n        for(int j=0; j<col; j++) {\n            printf(\"Element [%d][%d]: \", i+1, j+1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n//Addition of matrices function\nvoid add (int A[SIZE][SIZE], int B[SIZE][SIZE], int row, int col) {\n    printf(\"Result of matrix A + Matrix B:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d \", A[i][j] + B[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n//Subtraction of matrices function\nvoid subtract (int A[SIZE][SIZE], int B[SIZE][SIZE], int row, int col) {\n    printf(\"Result of matrix A - Matrix B:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d \", A[i][j] - B[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n//Transpose matrix function\nvoid transpose(int matrix[SIZE][SIZE], int row, int col) {\n    printf(\"Transpose of the Matrix:\\n\");\n    for (int i = 0; i < col; i++) {\n        for (int j = 0; j < row; j++) {\n            printf(\"%d \", matrix[j][i]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main()\n{\n    //Initialize variable\n    int rowA, colA, rowB, colB;\n    int matrixA[SIZE][SIZE];\n    int matrixB[SIZE][SIZE];\n    int choice;\n    \n    //Input details of matrix A, if not in condition need to input again\n    do {\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\n        scanf(\"%d %d\", &rowA, &colA);\n        \n        if (rowA>SIZE || colA>SIZE) {\n            printf(\"The maximum of rows and columns of matrix is 10x10. Plaese try again\\n\");\n        }\n        \n        if (rowA<=0 || colA<=0){\n            printf(\"Number of rows and columns must be greater than 0. Please try again\\n\");\n        }\n    } while(rowA>SIZE || colA>SIZE || rowA<=0 || colA<=0);\n    \n    //Pass data to input element function\n    matrix(matrixA, rowA, colA, 'A');\n    \n    //Input details of matrix B, if not in condition need to input again\n    do {\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\n        scanf(\"%d %d\", &rowB, &colB);\n        \n        if (rowB>SIZE || colB>SIZE) {\n            printf(\"The maximum of rows and columns of matrix is 10x10. Plaese try again\\n\");\n        }\n        \n        if (rowB<=0 || colB<=0){\n            printf(\"Number of rows and columns must be greater than 0. Please try again\\n\");\n        }\n    } while(rowB>SIZE || colB>SIZE || rowB<=0 || colB<=0);\n    \n    //Pass data to input element function\n    matrix(matrixB, rowB, colB, 'B');\n    \n    //Ask user to choose from menu, loop until 5 is choosen\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");    \n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        \n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            \n            //Addition\n            case 1:\n                if(rowA==rowB && colA==colB) {\n                    add(matrixA, matrixB, rowA, colA);\n                }\n                \n                else{\n                    printf(\"Error: Dimension of both matrices must be same.\\n\");\n                }\n                \n                break;\n            \n            //Subtraction    \n            case 2:\n                if(rowA==rowB && colA==colB) {\n                    subtract(matrixA, matrixB, rowA, colA);\n                }\n                \n                else{\n                    printf(\"Error: Dimension of both matrices must be same.\\n\");\n                }\n                \n                break;\n            \n            //Transpose matix A    \n            case 3:\n                transpose(matrixA, rowA, colA);\n                break;\n            \n            //Transpose matix B    \n            case 4:\n                transpose(matrixB, rowB, colB);\n                break;\n            \n            //Exit    \n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            \n            //Invalip option   \n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n                \n        }\n    } while(choice != 5);\n\n    return 0;\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#define MAX 100\n\nstruct Grocery {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    bool stock;\n};\n\nstruct Grocery inventory[MAX];\nint count = 0;\n\nvoid addItem() {\n    struct Grocery item;\n    \n    if (count >= MAX) {\n        printf(\"Inventory is full. Failed to add item.\\n\");\n        return;\n    }\n    \n    getchar();\n    printf(\"Enter Item Name: \");\n    fgets(item.name, sizeof(item.name), stdin);\n    item.name[strcspn(item.name, \"\\n\")] = '\\0';\n    \n    printf(\"Enter Category: \");\n    fgets(item.category, sizeof(item.category), stdin);\n    item.category[strcspn(item.category, \"\\n\")] = '\\0';\n\n    \n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &item.quantity);\n    \n    printf(\"Enter Price: \");\n    scanf(\"%f\", &item.price);\n    \n    item.stock = (item.quantity > 0);\n    \n    inventory[count++] = item;\n    \n    printf(\"Grocery item added successfully!\\n\\n\");\n    \n}\n\nvoid listItem () {\n    if (count==0) {\n        printf(\"\\nNo grocery items in the inventory.\\n\\n\");\n        return;\n    }\n    \n    for(int i=0; i<count; i++) {\n        printf(\"Name: %s\\n\", inventory[i].name);\n        printf(\"Category: %s\\n\", inventory[i].category);\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\n        printf(\"Price: %.2f\\n\", inventory[i].price);\n        printf(\"Status: %s\\n\\n\", inventory[i].stock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\nvoid updateQuantity() {\n    if (count == 0) {\n        printf(\"\\nNo grocery items in the inventory.\\n\\n\");\n        return;\n    }\n\n    getchar();\n    char name[100];\n    printf(\"Enter the name of the grocery item to update quantity: \");\n    fgets(name, sizeof(name), stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove the trailing newline\n\n    for (int i = 0; i < count; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            printf(\"Enter new quantity for %s: \", name);\n            scanf(\"%d\", &inventory[i].quantity);\n            inventory[i].stock = (inventory[i].quantity > 0); // Update stock status\n            printf(\"Quantity updated successfully!\\n\\n\");\n            return;\n        }\n    }\n    printf(\"Item not found in the inventory.\\n\\n\");\n}\n\nvoid removeItem() {\n    if (count == 0) {\n        printf(\"\\nNo grocery items in the inventory.\\n\\n\");\n        return;\n    }\n\n    getchar(); // Clear input buffer\n    char name[100];\n    printf(\"Enter the name of the grocery item to remove: \");\n    fgets(name, sizeof(name), stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; \n\n    for (int i = 0; i < count; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            for (int j = i; j < count - 1; j++) {\n                inventory[j] = inventory[j + 1]; \n            }\n            count--;\n            printf(\"Grocery item '%s' removed successfully!\\n\\n\", name);\n            return;\n        }\n    }\n    printf(\"Item not found in the inventory.\\n\\n\");\n}\n\nint main()\n{\n    int choice;\n    \n    do {\n        printf(\"Grocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        \n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        \n        switch (choice) {\n            case 1:\n                addItem();\n                break;\n            \n            case 2:\n                listItem();\n                break;\n              \n            case 3:\n                updateQuantity();\n                break;\n                \n            case 4:\n                removeItem();\n                break;\n                \n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n                \n            default:\n                printf(\"Invalid choice! Please try again.\");\n        }\n    }while(choice!=5);\n}\n\n\n\n/* --- Q3.c --- */\n#include <stdio.h> \n#include <stdlib.h> \n#include <string.h> \n \n// Structure for Student \ntypedef struct Student { \n    char name[100]; \n    int id; \n    float grade; \n    struct Student* next; \n} Student; \n \nStudent* head = NULL; \n \n// Function to create a new student node \nStudent* createStudent(const char* name, int id, float grade) { \n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if(newStudent == NULL) {\n    \tprintf(\"Memory not allocated.\\n\");  \n    }\n    \n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n \n} \n \n// Function to insert a new student record \nvoid insertStudent(const char* name, int id, float grade) { \n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n} \n \n// Function to display all student records \nvoid displayStudents() { \n    if(head == NULL) {\n        printf(\"No student records available.\\n\");\n        return;\n    }\n    \n    Student* current = head;\n    while (current) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n} \n \n// Function to search for a student by ID \nStudent* searchStudentByID(int id) { \n    Student* current = head;\n    while (current) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n} \n \n// Function to delete the entire list \nvoid deleteList() { \n    Student* current = head; \n    Student* next; \n \n    while (current != NULL) { \n        next = current->next; \n        free(current); \n        current = next; \n    } \n    head = NULL; \n} \n\n \n \nvoid freeMemory() { \n    deleteList(); \n} \n \n// Sort function to sort the student records by Bubble Sort \n/**Reason: If the list is already sorted or nearly sorted, \nit can terminate early if no swaps are made during a pass**/\nvoid sortStudents() { \n    if (head == NULL || head->next == NULL) {\n        printf(\"No need to sort. The list has zero or one student.\\n\");\n        return;\n    }\n\n    Student* current;\n    Student* prev = NULL;\n    int swapped;\n\n    do {\n        swapped = 0;\n        current = head;\n\n        while (current->next != prev) {\n            if (current->grade > current->next->grade) {\n                // Swap the contents of current and next node\n                char temp[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(temp, current->name);\n                tempID = current->id;\n                tempGrade = current->grade;\n\n                strcpy(current->name, current->next->name);\n                current->id = current->next->id;\n                current->grade = current->next->grade;\n\n                strcpy(current->next->name, temp);\n                current->next->id = tempID;\n                current->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            current = current->next;\n        }\n        prev = current; \n    } while (swapped);\n\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n} \n \n// Main function to drive the program \nint main() { \n \n    int choice, id; \n    char name[100]; \n    float grade; \n \n    do { \n        printf(\"\\n1. Insert Student Record\\n\"); \n        printf(\"2. Display Student Records\\n\"); \n        printf(\"3. Sort Records (Bubble Sort)\\n\"); \n        printf(\"4. Search Record by ID\\n\"); \n        printf(\"5. Delete List\\n\"); \n        printf(\"6. Exit\\n\"); \n        printf(\"Enter your choice: \"); \n        scanf(\"%d\", &choice); \n        getchar(); \n        \n        switch (choice) { \n            case 1: \n                printf(\"Enter Name: \"); \n                fgets(name, sizeof(name), stdin); \n                strtok(name, \"\\n\"); \n                printf(\"Enter ID: \"); \n                scanf(\"%d\", &id); \n                printf(\"Enter Grade: \"); \n                scanf(\"%f\", &grade); \n                insertStudent(name, id, grade); \n                break; \n                \n            case 2: \n                displayStudents(); \n                break; \n                \n            case 3: \n                sortStudents();                 \n                break; \n                \n            case 4: \n                printf(\"Enter ID to search: \"); \n                scanf(\"%d\", &id); \n                Student* found = searchStudentByID(id); \n \n                if (found) { \n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \n                } else { \n                    printf(\"Student not found.\\n\"); \n                } \n                break; \n                \n            case 5: \n                deleteList(); \n                printf(\"List deleted.\\n\"); \n                break; \n                \n            case 6: \n                freeMemory(); \n                printf(\"Exiting...\\n\"); \n                break; \n                \n            default: \n                printf(\"Invalid choice! Please try again.\\n\"); \n        } \n    } while (choice != 6); \n \n    return 0; \n} ",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to sort the student records by grade. This algorithm is simple and works well for small lists, but it has a time complexity of O(n?), which may not be efficient for larger datasets. Consider using a more efficient sorting algorithm like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20618300",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\n// Show the menu options\r\nvoid displayMenu() \r\n{\r\n    printf(\"\\nMatrix Operations Menu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Validation when user input the rows and columns for the matrix A, B.\r\n// Must one decimal then space then only the second decimal\r\nint isValidDimensions(char *input, int *rows, int *cols) \r\n{\r\n    int r, c;\r\n    // sscanf extract the value of the eg. r = 2, c = 2 from the input\r\n    if (sscanf(input, \"%d %d\", &r, &c) == 2 && r > 0 && r <= 10 && c > 0 && c <= 10) \r\n    {\r\n        *rows = r;\r\n        *cols = c;\r\n        return 1; // Valid dimensions\r\n    }\r\n    return 0; // Invalid dimensions\r\n}\r\n\r\n// Used to get valid dimensions\r\nvoid getDimensions(char *question, int *rows, int *cols) \r\n{\r\n    char input[100]; // variable to store the user input\r\n    do \r\n    {\r\n        printf(\"%s\", question); // print the message: \"Enter dimensions for Matrix A (rows and columns): \"\r\n        fgets(input, sizeof(input), stdin); // get the user input\r\n        // check if the input position is [0, 1, 2]\r\n        if (!isValidDimensions(input, rows, cols)) \r\n        { \r\n            printf(\"Invalid input! Please enter two integers between 1 and 10 separated by a space.\\n\");\r\n        }\r\n    } while (!isValidDimensions(input, rows, cols));\r\n}\r\n\r\nvoid inputMatrix(int rows, int cols, int matrix[10][10]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            // used to check if the value stored in the matrix[i][j] is decimal or not\r\n            // scanf will return 1 when input is valid integer\r\n            while (scanf(\"%d\", &matrix[i][j]) != 1) \r\n            {\r\n                printf(\"Invalid input! Enter a valid integer: \");\r\n                // Clear the input buffer\r\n                while (getchar() != '\\n'); \r\n            }\r\n        }\r\n    }\r\n    // Clear buffer after matrix input\r\n    while (getchar() != '\\n'); \r\n}\r\n\r\nvoid printMatrix(int rows, int cols, int matrix[10][10]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrix(int rows, int cols, int addMatrixA[10][10], int addMatrixB[10][10], int result[10][10]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[i][j] = addMatrixA[i][j] + addMatrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrix(int rows, int cols, int subtractMatrixA[10][10], int sutractbMatrixB[10][10], int result[10][10]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[i][j] = subtractMatrixA[i][j] - sutractbMatrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int rows, int cols, int matrix[10][10], int result[10][10]) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    int inputMatrixA[10][10], inputMatrixB[10][10], result[10][10];\r\n    int inputRowsA, inputColsA, inputRowsB, inputColsB;\r\n    int userChoice;\r\n\r\n    // Input rows, columns, and values for Matrix A\r\n    getDimensions(\"Enter dimensions for Matrix A (rows and columns): \", &inputRowsA, &inputColsA);\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(inputRowsA, inputColsA, inputMatrixA);\r\n\r\n    // Input rows, columns, and values for Matrix B\r\n    getDimensions(\"Enter dimensions for Matrix B (rows and columns): \", &inputRowsB, &inputColsB);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(inputRowsB, inputColsB, inputMatrixB);\r\n\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n\r\n        // when scanf doesn't gets valid integer, it will return 0 (False)\r\n        if(scanf(\"%d\", &userChoice) != 1)\r\n        {\r\n            printf(\"Invalid choice. Please choose a valid choice\\n\");\r\n            // clear the input buffer\r\n            while (getchar() != '\\n');\r\n            continue;\r\n        }\r\n\r\n        switch (userChoice) \r\n        {\r\n            case 1:\r\n                // check if the dimensions of Matrix A and Matrix B is same or not\r\n                if (inputRowsA == inputRowsB && inputColsA == inputColsB) \r\n                {\r\n                    addMatrix(inputRowsA, inputColsA, inputMatrixA, inputMatrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(inputRowsA, inputColsA, result);\r\n                } \r\n                else \r\n                {\r\n                    printf(\"Addition is not possible. Both dimensions must same.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (inputRowsA == inputRowsB && inputColsA == inputColsB) \r\n                {\r\n                    subtractMatrix(inputRowsA, inputColsA, inputMatrixA, inputMatrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(inputRowsA, inputColsA, result);\r\n                } \r\n                else \r\n                {\r\n                    printf(\"Subtraction is not possible. Both dimensions must same.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(inputRowsA, inputColsA, inputMatrixA, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(inputColsA, inputRowsA, result);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(inputRowsB, inputColsB, inputMatrixB, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(inputColsB, inputRowsB, result);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Have a nice daay!\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (userChoice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int isInStock;\r\n} Grocery;\r\n\r\nGrocery inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n// show menu\r\nvoid displayMenu() \r\n{\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// add item\r\nvoid addGrocery() \r\n{\r\n    if (itemCount >= MAX_ITEMS) \r\n    {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    Grocery item;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item.name, sizeof(item.name), stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = '\\0'; \r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, sizeof(item.category), stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = '\\0'; \r\n\r\n    printf(\"Enter Quantity: \");\r\n    // make sure the data input by user is decimal\r\n    while (scanf(\"%d\", &item.quantity) != 1) \r\n    {\r\n        printf(\"Invalid input! Please enter an integer: \");\r\n        // clear the input buffer\r\n        while (getchar() != '\\n');\r\n    }\r\n\r\n    printf(\"Enter Price: RM\");\r\n    while (scanf(\"%f\", &item.price) != 1) \r\n    {\r\n        printf(\"Invalid input! Please enter a valid price: \");\r\n        while (getchar() != '\\n');\r\n    }\r\n    while (getchar() != '\\n');\r\n\r\n    // Ternary Operator\r\n    item.isInStock = (item.quantity > 0) ? 1 : 0;\r\n\r\n    inventory[itemCount++] = item;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGrocery() \r\n{\r\n    if (itemCount == 0) \r\n    {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        // \\033[ = starts the escape sequence\r\n        // 0;32m = 32 is green color\r\n        // \\033[0m = resets all formatting text to default\r\n        printf(\"\\033[0;32mCategory: %s\\033[0m\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: RM%.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].isInStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid updateGroceryQuantity() \r\n{\r\n    char name[100];\r\n    int newQuantity;\r\n\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        if (strcmp(inventory[i].name, name) == 0) \r\n        {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            while (scanf(\"%d\", &newQuantity) != 1) \r\n            {\r\n                printf(\"Invalid input! Please enter an integer: \");\r\n                while (getchar() != '\\n');\r\n            }\r\n\r\n            inventory[i].quantity = newQuantity;\r\n            inventory[i].isInStock = (newQuantity > 0) ? 1 : 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found...\\n\");\r\n}\r\n\r\nvoid removeGrocery() \r\n{\r\n    char name[100];\r\n\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    // remove trailing newline\r\n    name[strcspn(name, \"\\n\")] = '\\0'; \r\n\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        if (strcmp(inventory[i].name, name) == 0) \r\n        {\r\n            // overwrite items by changing inventory[0] to inventory[1] as example\r\n            for (int j = i; j < itemCount - 1; j++) \r\n            {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n\r\n            // so the duplicate last item will be remove\r\n            // original inventory[2] is cola for example, overwrite by 100 plus(inventory[j] = inventory[j + 1];)\r\n            // inventory[2] = 100 plus \r\n            // inventory[3] = 100 plus\r\n            // itemCount = 3 - 1 = 2\r\n            // right now the last dduplicate item is clear\r\n            itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found...\\n\");\r\n}\r\n\r\nint main() \r\n{\r\n    int choice;\r\n\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n\r\n        // validation of the input \r\n        if (scanf(\"%d\", &choice) != 1) \r\n        {\r\n            printf(\"Invalid choice! Please choose again!\\n \");\r\n            while (getchar() != '\\n');\r\n            continue;\r\n        }\r\n\r\n        switch (choice) \r\n        {\r\n            case 1:\r\n                // ensure the last input buffer is not newline which would cause bug\r\n                // then it will execute the addGrocery() function\r\n                while (getchar() != '\\n'); \r\n                addGrocery();\r\n                break;\r\n            case 2:\r\n                listGrocery();\r\n                break;\r\n            case 3:\r\n                while (getchar() != '\\n'); \r\n                updateGroceryQuantity();\r\n                break;\r\n            case 4:\r\n                while (getchar() != '\\n'); \r\n                removeGrocery();\r\n                break;\r\n            case 5:\r\n                printf(\"Have a nice day!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// act like a checkpoint to check if the list is empty or not\r\nStudent* head = NULL;\r\n\r\nvoid displayMenu()\r\n{\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n}\r\n\r\n// Creates a new student node and returns a pointer to it.\r\nStudent* createStudent(const char* name, int id, float grade) \r\n{\r\n    // create new node for student\r\n    Student* newNode = (Student*)malloc(sizeof(Student));\r\n    if (newNode == NULL) \r\n    {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    strcpy(newNode->name, name);\r\n    newNode->id = id;\r\n    newNode->grade = grade;\r\n    newNode->next = NULL; // as a signal show that this node is the last node in the list\r\n    return newNode; // return the pointer to the newly created newStudent node\r\n}\r\n\r\n// Inserts a new student record into the linked list\r\nvoid insertStudent(const char* name, int id, float grade) \r\n{\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    // if head is NULL, means the list is empty\r\n    // then newStudent is assigned to head, making it the first node in the list\r\n    if (head == NULL) \r\n    {\r\n        head = newStudent;\r\n    } \r\n    else \r\n    {\r\n        // need to find the last nodes of the list which next will be NULL\r\n        Student* temp = head;\r\n        while (temp->next != NULL) \r\n        {\r\n            temp = temp->next;\r\n        }\r\n        // when find the last nodes of the list, \r\n        // store the latest created node which is address of newStudent into it\r\n        temp->next = newStudent;\r\n    }\r\n    printf(\"Student inserted successfully!\\n\");\r\n}\r\n\r\n// Displays all current student records in the linked list\r\nvoid displayStudents() \r\n{\r\n    // no need to sort empty list or list with one student\r\n    if (head == NULL) \r\n    {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;\r\n    while (temp != NULL) \r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        // repeat displaying the student records by moving the next into temp\r\n        // when temp is NULL, which is last nodes, then break out the loop\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Searches for a student record by student ID and returns a pointer to the corresponding student node\r\nStudent* searchStudentByID(int id) \r\n{\r\n    Student* temp = head;\r\n    // here will keep looping until the last node to find the id\r\n    while (temp != NULL) \r\n    {\r\n        if (temp->id == id) \r\n        {\r\n            return temp;// passess the address of the found node back to the calling function\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL; // tell the calling function the search is unsuccessful\r\n}\r\n\r\n// Deletes the entire linked list and frees the allocated memory\r\nvoid deleteList() \r\n{\r\n    Student* current = head; // stored current to the first node\r\n    Student* next; // pointer that will temporarily store the address of the next node in the list\r\n\r\n    while (current != NULL) \r\n    {\r\n        next = current->next; // store next to the next of first node which is the address of second node\r\n        free(current); // memory occupied by the current node is released\r\n        current = next; // after the current is clear, then store the next to current and repeat until current is NULL\r\n    }\r\n    head = NULL;\r\n    printf(\"List deleted.\\n\");\r\n}\r\n\r\n// Sort the student records by grade according to a sorting algorithm of your choice\r\nvoid sortStudents() \r\n{\r\n    // Check if the list is empty or has only one node\r\n    if (head == NULL || head->next == NULL) \r\n    {\r\n        printf(\"No need to sort. Not enough students.\\n\");\r\n        return; \r\n    }\r\n\r\n    // flag to track if a swap occurred in the current pass\r\n    int sort;\r\n    // pointer for traversal and tracking the last sorted node\r\n    Student *currentNode, *lastSortedNode = NULL;  \r\n\r\n    do {\r\n        sort = 0; // reset the swap flag at the start of each pass\r\n        currentNode = head;// start traversal from the head of the list\r\n\r\n        // traverse the list until the last sorted node\r\n        while (currentNode->next != lastSortedNode) \r\n        {\r\n            // compare the grade of the current node and the next node\r\n            // if the current node grade is greater, swap their data\r\n            if (currentNode->grade > currentNode->next->grade) \r\n            {\r\n                // temporary variables to store the data of the current node\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                // copy current node data into temporary variables\r\n                strcpy(tempName, currentNode->name);\r\n                tempID = currentNode->id;\r\n                tempGrade = currentNode->grade;\r\n\r\n                // copy the next node data into the current node\r\n                strcpy(currentNode->name, currentNode->next->name);\r\n                currentNode->id = currentNode->next->id;\r\n                currentNode->grade = currentNode->next->grade;\r\n\r\n                // copy the temporary data into the next node\r\n                strcpy(currentNode->next->name, tempName);\r\n                currentNode->next->id = tempID;\r\n                currentNode->next->grade = tempGrade;\r\n\r\n                sort = 1;  // set the flag to show the swap is occurred\r\n            }\r\n            currentNode = currentNode->next;\r\n        }\r\n\r\n        // mark the last node in this pass as sorted\r\n        lastSortedNode = currentNode;  \r\n    } while (sort); \r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// A utility function to ensure that all memory is freed when the program exits\r\nvoid freeMemory()\r\n{\r\n    deleteList();\r\n}\r\n\r\nint main() \r\n{\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        displayMenu();\r\n\r\n        // Validate menu choice\r\n        printf(\"Enter your choice: \");\r\n        while (scanf(\"%d\", &choice) != 1) \r\n        {\r\n            printf(\"Invalid choice! Please re-enter: \");\r\n            while (getchar() != '\\n'); // Clear the buffer\r\n        }\r\n        getchar(); // Clear leftover newline character\r\n\r\n        switch (choice) \r\n        {\r\n            case 1:\r\n                // Validate name\r\n                printf(\"Enter Name: \");\r\n                while (1) \r\n                {\r\n                    if (fgets(name, sizeof(name), stdin)) \r\n                    {\r\n                        name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline\r\n                        if (strlen(name) > 0) break;\r\n                    }\r\n                    printf(\"Invalid input! Please enter a valid name: \");\r\n                }\r\n\r\n                // validate ID\r\n                printf(\"Enter ID: \");\r\n                while (scanf(\"%d\", &id) != 1 || id <= 0) \r\n                {\r\n                    printf(\"Invalid input! Please enter a positive integer for ID: \");\r\n                    while (getchar() != '\\n'); // Clear the buffer\r\n                }\r\n\r\n                // validate grade\r\n                printf(\"Enter Grade: \");\r\n                while (scanf(\"%f\", &grade) != 1 || grade < 0.0 || grade > 100.0) \r\n                {\r\n                    printf(\"Invalid input! Please enter a grade between 0 and 100: \");\r\n                    while (getchar() != '\\n'); \r\n                }\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                while (scanf(\"%d\", &id) != 1 || id <= 0) \r\n                {\r\n                    printf(\"Invalid input! Please enter a valid positive integer for ID: \");\r\n                    while (getchar() != '\\n'); \r\n                }\r\n\r\n                Student* found = searchStudentByID(id);\r\n                // means found != NULL print the details\r\n                if (found) \r\n                {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } \r\n                // when found = NULL means no such ID\r\n                else \r\n                {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Have a nice day!\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is a straightforward choice for sorting small datasets. However, it has a time complexity of O(n?), which may not be efficient for larger datasets. Consider using more efficient algorithms like Quick Sort or Merge Sort for better performance on larger lists."
  },
  {
    "student_id": "20609983",
    "code": "\n/* --- Question 1.c --- */\n/******************************************************************************\n\nWelcome to GDB Online.\n  GDB online is an online compiler and debugger tool for C, C++, Python, PHP, Ruby, \n  C#, OCaml, VB, Perl, Swift, Prolog, Javascript, Pascal, COBOL, HTML, CSS, JS\n  Code, Compile, Run and Debug online from anywhere in world.\n\n*******************************************************************************/\n#include <stdio.h>\n#define MAX_SIZE 10 // Defines the maximum size for the matrices\n\n// Function prototypes for matrix operations\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name); // Reads a matrix from user input\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols); // Prints a matrix\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols); // Adds two matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols); // Subtracts one matrix from another\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols); // Transposes a matrix\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE]; // Matrices A and B in integer\n    int rowsA, colsA, rowsB, colsB; // row and collumn of matrices A and B in integer\n    int choice; // User's menu choice\n\n    // dimensions and elements for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \"); // prompt for dimensions of Matrix A\n    scanf(\"%d %d\", &rowsA, &colsA); // check if dimensions of matrix A is valid\n    while (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsA <= 0 || colsA <= 0) {\n        printf(\"Invalid dimensions. Please enter again: \");\n        scanf(\"%d %d\", &rowsA, &colsA);\n    }\n    inputMatrix(A, rowsA, colsA, 'A');\n\n    // dimensions and elements for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \"); // prompt for dimensions of Matrix B\n    scanf(\"%d %d\", &rowsB, &colsB); // check if dimensions of matrix A is valid\n    while (rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsB <= 0 || colsB <= 0) {\n        printf(\"Invalid dimensions. Please enter again: \");\n        scanf(\"%d %d\", &rowsB, &colsB);\n    }\n    inputMatrix(B, rowsB, colsB, 'B');\n\n    // menu loop for matrix operations\n    do {\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n\t\t// check if matrixes have the same dimension\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(A, B, rowsA, colsA); // use function for adding matrices from below\n                } else {\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\"); \n                }\n                break;\n            case 2:\n\t\t// check if matrixes have the same dimension\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(A, B, rowsA, colsA); // use function for subtracting matrices from below\n                } else {\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\n                }\n                break;\n            case 3:\n                transposeMatrix(A, rowsA, colsA); // use function for transposing Matrix A\n                break;\n            case 4:\n                transposeMatrix(B, rowsB, colsB); // use function for transposing Matrix B\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0; //terminate program\n}\n\n// function for inputting matrix\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\n    printf(\"Enter elements for Matrix %c:\\n\", name);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// function for printing matrix\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// function for adding matrices\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int result[MAX_SIZE][MAX_SIZE]; // Resultant matrix\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j]; // Element-wise addition\n        }\n    }\n    printf(\"Result of Matrix A + Matrix B:\\n\");\n    printMatrix(result, rows, cols); // Prints the resulting matrix\n}\n\n// function for subtracting matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int result[MAX_SIZE][MAX_SIZE]; // Resultant matrix\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j]; // Element-wise subtraction\n        }\n    }\n    printf(\"Result of Matrix A - Matrix B:\\n\");\n    printMatrix(result, rows, cols); // Prints the resulting matrix\n}\n\n// function for tranosing matrices\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    int result[MAX_SIZE][MAX_SIZE]; // Transposed matrix\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j]; // Swaps rows and columns\n        }\n    }\n    printf(\"Transpose of the Matrix:\\n\");\n    printMatrix(result, cols, rows); // Prints the transposed matrix\n}\n/* --- Question 2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n\n// use structure to hold info\ntypedef struct {\n    char name[100]; // grocery item name\n    char category[50]; // category name\n    int quantity; // number of stock quantity in interger\n    float price; // make price per unit decimal\n} GroceryItem;\n\n// use structure to hold availability status\ntypedef struct {\n    bool inStock; // Boolean to indicate if the item is in stock\n} AvailabilityStatus;\n\n// use structure for grocery inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS]; // Array of grocery items\n    AvailabilityStatus statuses[MAX_ITEMS]; // Array of availability statuses according to each item\n    int itemCount; // number of items in the inventory\n} GroceryInventory;\n\nvoid addGroceryItem(GroceryInventory *inventory); // Add a new item to the inventory\nvoid listAllGroceryItems(const GroceryInventory *inventory); // Display all items in the inventory\nvoid updateQuantity(GroceryInventory *inventory); // Update the quantity of a specific item\nvoid removeGroceryItem(GroceryInventory *inventory); // Remove an item from the inventory\n\nint main() {\n    GroceryInventory inventory = {.itemCount = 0}; // Initialize inventory with no items\n    int choice;\n\n    do {\n        // Display menu options\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory); // Call function to add a new item\n                break;\n            case 2:\n                listAllGroceryItems(&inventory); // Call function to list all items\n                break;\n            case 3:\n                updateQuantity(&inventory); // Call function to update item quantity\n                break;\n            case 4:\n                removeGroceryItem(&inventory); // Call function to remove an item\n                break;\n            case 5:\n                printf(\"Exiting the program.\\n\"); // Exit message\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\"); // Handle invalid input\n        }\n    } while (choice != 5); // Repeat until the user chooses to exit\n\n    return 0;\n}\n\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->itemCount >= MAX_ITEMS) { // Check if the inventory is full\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n    printf(\"Enter Item Name: \");\n    getchar(); // Consume the newline character left by scanf\n    fgets(newItem.name, sizeof(newItem.name), stdin); // Read the name of the item\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0; // Remove trailing newline\n\n    printf(\"Enter Category: \");\n    fgets(newItem.category, sizeof(newItem.category), stdin); // Read the category of the item\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0; // Remove trailing newline\n\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &newItem.quantity); // Read the quantity\n\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &newItem.price); // Read the price\n\n    inventory->items[inventory->itemCount] = newItem; // Add item to inventory\n    inventory->statuses[inventory->itemCount].inStock = newItem.quantity > 0; // Update availability status\n    inventory->itemCount++; // Increment item count\n\n    printf(\"Grocery item added successfully!\\n\");\n}\n\nvoid listAllGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->itemCount == 0) { // Check if the inventory is empty\n        printf(\"No items in the inventory.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < inventory->itemCount; i++) { // Loop through all items\n        const GroceryItem *item = &inventory->items[i]; // Get the current item\n        const AvailabilityStatus *status = &inventory->statuses[i]; // Get the availability status\n\n        // Display item details\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\n        printf(\"-----------------------------\\n\");\n    }\n}\n\nvoid updateQuantity(GroceryInventory *inventory) {\n    char name[100];\n    printf(\"Enter the name of the item to update: \");\n    getchar(); // Consume the newline character left by scanf\n    fgets(name, sizeof(name), stdin); // Read the name of the item\n    name[strcspn(name, \"\\n\")] = 0; // Remove trailing newline\n\n    for (int i = 0; i < inventory->itemCount; i++) { // Search for the item\n        if (strcmp(inventory->items[i].name, name) == 0) { // Match found\n            int newQuantity;\n            printf(\"Enter new quantity: \");\n            scanf(\"%d\", &newQuantity); // Read the new quantity\n\n            inventory->items[i].quantity = newQuantity; // Update quantity\n            inventory->statuses[i].inStock = newQuantity > 0; // Update availability status\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\"); // Item not found\n}\n\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    char name[100];\n    printf(\"Enter the name of the item to remove: \");\n    getchar(); // Consume the newline character left by scanf\n    fgets(name, sizeof(name), stdin); // Read the name of the item\n    name[strcspn(name, \"\\n\")] = 0; // Remove trailing newline\n\n    for (int i = 0; i < inventory->itemCount; i++) { // Search for the item\n        if (strcmp(inventory->items[i].name, name) == 0) { // Match found\n            for (int j = i; j < inventory->itemCount - 1; j++) { // Shift items to fill the gap\n                inventory->items[j] = inventory->items[j + 1];\n                inventory->statuses[j] = inventory->statuses[j + 1];\n            }\n\n            inventory->itemCount--; // Decrement item count\n            printf(\"Item removed successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\"); // Item not found\n}\n\n/* --- Question 3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define the structure for a student node\ntypedef struct Student {\n    char name[100]; // Name of the student\n    int id;         // ID of the student\n    float grade;    // Grade of the student\n    struct Student* next; // Pointer to the next student in the list\n} Student;\n\n// Head pointer for the linked list\nStudent* head = NULL;\n\n// Function prototypes\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid sortStudents();\n\n// Utility function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    // Allocate memory for the new node\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    // Copy data into the new node\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record into the linked list\nvoid insertStudent(const char* name, int id, float grade) {\n    // Create a new student node\n    Student* newStudent = createStudent(name, id, grade);\n    // Insert at the beginning of the list\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted successfully.\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n    Student* current = head;\n    printf(\"\\nStudent Records:\\n\");\n    while (current != NULL) {\n        // Print details of the current student\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student record by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        // Check if current student matches the ID\n        if (current->id == id) {\n            return current; // Found the student\n        }\n        current = current->next;\n    }\n    return NULL; // Student not found\n}\n\n// Function to delete the entire linked list and free memory\nvoid deleteList() {\n    Student* current = head;\n    while (current != NULL) {\n        // Save the current node to free later\n        Student* temp = current;\n        current = current->next;\n        free(temp); // Free each node\n    }\n    head = NULL;\n    printf(\"All student records deleted successfully.\\n\");\n}\n\n// Function to sort student records by grade (using Bubble Sort for simplicity)\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        // No need to sort if the list is empty or has one element\n        return;\n    }\n    int swapped;\n    do {\n        swapped = 0;\n        Student* current = head;\n        while (current->next != NULL) {\n            // Compare grades of adjacent nodes\n            if (current->grade > current->next->grade) {\n                // Swap the data of current node and next node\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, current->name);\n                tempID = current->id;\n                tempGrade = current->grade;\n\n                strcpy(current->name, current->next->name);\n                current->id = current->next->id;\n                current->grade = current->next->grade;\n\n                strcpy(current->next->name, tempName);\n                current->next->id = tempID;\n                current->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            current = current->next;\n        }\n    } while (swapped);\n    printf(\"Student records sorted by grade successfully.\\n\");\n}\n\nint main() {\n    int choice;\n    char name[100];\n    int id;\n    float grade;\n\n    do {\n        // Display menu options\n        printf(\"\\nStudent Record Management System\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete All Records\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                // Insert new student\n                printf(\"Enter name: \");\n                getchar(); // Consume newline character\n                fgets(name, sizeof(name), stdin);\n                name[strcspn(name, \"\\n\")] = 0; // Remove trailing newline\n\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n\n                printf(\"Enter grade: \");\n                scanf(\"%f\", &grade);\n\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                // Display all records\n                displayStudents();\n                break;\n\n            case 3:\n                // Sort records by grade\n                sortStudents();\n                break;\n\n            case 4:\n                // Search for a student by ID\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* student = searchStudentByID(id);\n                if (student) {\n                    printf(\"Student found: Name: %s, ID: %d, Grade: %.2f\\n\", student->name, student->id, student->grade);\n                } else {\n                    printf(\"Student with ID %d not found.\\n\", id);\n                }\n                break;\n\n            case 5:\n                // Delete all records\n                deleteList();\n                break;\n\n            case 6:\n                // Exit program\n                printf(\"Exiting the program.\\n\");\n                deleteList(); // Ensure memory is freed before exit\n                break;\n\n            default:\n                // Handle invalid choice\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to sort student records by grade. While it effectively sorts the list, Bubble Sort has a time complexity of O(n?) and is not the most efficient choice for larger datasets. Consider using more efficient algorithms, like Merge Sort or Quick Sort, for better performance."
  },
  {
    "student_id": "20713555",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10\n\n// Function prototypes\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions for Matrix A\n    do {\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\n        if (scanf(\"%d %d\", &rowsA, &colsA) != 2 || rowsA <= 0 || colsA <= 0 || rowsA > MAX_SIZE || colsA > MAX_SIZE) {\n            printf(\"Invalid dimensions! Please enter values between 1 and %d.\\n\", MAX_SIZE);\n            while(getchar() != '\\n'); // Clear invalid input\n        }\n    } while (rowsA <= 0 || colsA <= 0 || rowsA > MAX_SIZE || colsA > MAX_SIZE);\n\n    // Input elements for Matrix A\n    printf(\"Enter elements of Matrix A:\\n\");\n    inputMatrix(A, rowsA, colsA);\n\n    // Input dimensions for Matrix B\n    do {\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\n        if (scanf(\"%d %d\", &rowsB, &colsB) != 2 || rowsB <= 0 || colsB <= 0 || rowsB > MAX_SIZE || colsB > MAX_SIZE) {\n            printf(\"Invalid dimensions! Please enter values between 1 and %d.\\n\", MAX_SIZE);\n            while(getchar() != '\\n'); // Clear invalid input\n        }\n    } while (rowsB <= 0 || colsB <= 0 || rowsB > MAX_SIZE || colsB > MAX_SIZE);\n\n    // Input elements for Matrix B\n    printf(\"Enter elements of Matrix B:\\n\");\n    inputMatrix(B, rowsB, colsB);\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        \n        if (scanf(\"%d\", &choice) != 1) {\n            printf(\"Invalid choice! Please enter a number between 1 and 5.\\n\");\n            while(getchar() != '\\n'); // Clear invalid input\n            continue; // Skip to next iteration of the loop\n        }\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(A, B, result, rowsA, colsA);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    displayMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"Matrices must have the same dimensions for addition!\\n\");\n                }\n                break;\n\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(A, B, result, rowsA, colsA);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    displayMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"Matrices must have the same dimensions for subtraction!\\n\");\n                }\n                break;\n\n            case 3:\n                transposeMatrix(A, result, rowsA, colsA);\n                printf(\"Transpose of Matrix A:\\n\");\n                displayMatrix(result, colsA, rowsA); // Note: Rows and columns are swapped\n                break;\n\n            case 4:\n                transposeMatrix(B, result, rowsB, colsB);\n                printf(\"Transpose of Matrix B:\\n\");\n                displayMatrix(result, colsB, rowsB); // Note: Rows and columns are swapped\n                break;\n\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice! Please enter a number between 1 and 5.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to input a matrix\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to display a matrix\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to add two matrices\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <ctype.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LENGTH 100\n#define MAX_CATEGORY_LENGTH 50\n\n// Define the structure for a grocery item\ntypedef struct {\n    char name[MAX_NAME_LENGTH];\n    char category[MAX_CATEGORY_LENGTH];\n    int quantity;\n    float price;\n} GroceryItem;\n\n// Define the structure for availability status\ntypedef struct {\n    bool inStock;\n    bool outOfStock;\n} AvailabilityStatus;\n\n// Define the structure for grocery inventory\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    AvailabilityStatus availability[MAX_ITEMS];\n    int count;\n} GroceryInventory;\n\n// Function prototypes\nvoid addGroceryItem(GroceryInventory *inventory);\nvoid listGroceryItems(GroceryInventory *inventory);\nvoid updateGroceryItemQuantity(GroceryInventory *inventory);\nvoid removeGroceryItem(GroceryInventory *inventory);\nvoid displayMenu();\nint findItemByName(GroceryInventory *inventory, const char *name);\nbool isValidName(const char *name);\nbool isValidCategory(const char *category);\n\nint main() {\n    GroceryInventory inventory = { .count = 0 };\n    int choice;\n\n    while (1) {\n        displayMenu();\n        printf(\"Enter your choice: \");\n        if (scanf(\"%d\", &choice) != 1) { // Check if input is valid\n            printf(\"Invalid input. Please enter a number.\\n\");\n            while (getchar() != '\\n'); // Clear invalid input from buffer\n            continue; // Restart loop\n        }\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory);\n                break;\n            case 2:\n                listGroceryItems(&inventory);\n                break;\n            case 3:\n                updateGroceryItemQuantity(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting the program.\\n\");\n                exit(0);\n            default:\n                printf(\"Invalid choice. Please enter a number between 1 to 5 only.\\n\");\n        }\n    }\n\n    return 0;\n}\n\nvoid displayMenu() {\n    printf(\"\\n--- Grocery Inventory Management ---\\n\");\n    printf(\"1. Add Grocery Item\\n\");\n    printf(\"2. List All Grocery Items\\n\");\n    printf(\"3. Update Quantity by Item Name\\n\");\n    printf(\"4. Remove Grocery Item\\n\");\n    printf(\"5. Exit\\n\");\n}\n\n\n// Function to validate category (only alphabetic characters and spaces)\nbool isValidCategory(const char *category) {\n    for (int i = 0; category[i] != '\\0'; i++) {\n        if (!isalpha(category[i]) && !isspace(category[i])) {\n            return false; // Invalid character found\n        }\n    }\n    return true; // Valid category\n}\n\n// Function to add a grocery item\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->count >= MAX_ITEMS) {\n        printf(\"Inventory is full! Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n\n    printf(\"Enter item name: \");\n    scanf(\" %[^\\n]\", newItem.name); // Read string with spaces\n\n    printf(\"Enter category: \");\n    scanf(\" %[^\\n]\", newItem.category);\n\n    // Validate category\n    if (!isValidCategory(newItem.category)) {\n        printf(\"Invalid category! Only alphabetic characters are allowed.\\n\");\n        return;\n    }\n\n    printf(\"Enter quantity: \");\n    while (scanf(\"%d\", &newItem.quantity) != 1 || newItem.quantity < 0) { \n        // Validate integer input and ensure quantity is non-negative\n        printf(\"Invalid input. Please enter a valid non-negative quantity: \");\n        while (getchar() != '\\n'); // Clear invalid input from buffer\n    }\n\n    printf(\"Enter price: \");\n    while (scanf(\"%f\", &newItem.price) != 1 || newItem.price < 0.0f) { \n        // Validate float input and ensure price is non-negative\n        printf(\"Invalid input. Please enter a valid non-negative price: \");\n        while (getchar() != '\\n'); // Clear invalid input from buffer\n    }\n\n    inventory->items[inventory->count] = newItem;\n\n    // Set availability status based on quantity\n    inventory->availability[inventory->count].inStock = (newItem.quantity > 0);\n    inventory->availability[inventory->count].outOfStock = (newItem.quantity == 0);\n\n    inventory->count++;\n\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items with their availability\nvoid listGroceryItems(GroceryInventory *inventory) {\n    if (inventory->count == 0) {\n        printf(\"No grocery items in inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\n--- Grocery Items ---\\n\");\n\n    for (int i = 0; i < inventory->count; i++) {\n        GroceryItem item = inventory->items[i];\n        AvailabilityStatus status = inventory->availability[i];\n\n        printf(\"Item %d:\\n\", i + 1);\n        printf(\"Name: %s\\n\", item.name);\n        printf(\"Category: %s\\n\", item.category);\n        printf(\"Quantity: %d\\n\", item.quantity);\n        printf(\"Price: %.2f\\n\", item.price);\n        printf(\"Availability: %s\\n\", status.inStock ? \"In Stock\" : \"Out of Stock\");\n        printf(\"-----------------------\\n\");\n    }\n}\n\n// Function to find an item by name, returns index or -1 if not found\nint findItemByName(GroceryInventory *inventory, const char *name) {\n   for (int i = 0; i < inventory->count; i++) {\n       if (strcmp(inventory->items[i].name, name) == 0) { // Case-sensitive comparison\n           return i; // Return index of found item\n       }\n   }\n   return -1; // Return -1 if not found\n}\n\n// Function to update the quantity of a grocery item by name\nvoid updateGroceryItemQuantity(GroceryInventory *inventory) {\n   if (inventory->count == 0) {\n       printf(\"No grocery items in inventory.\\n\");\n       return;\n   }\n\n   char name[MAX_NAME_LENGTH];\n\n   // Prompt for item name\n   printf(\"Enter the name of the item to update: \");\n   scanf(\" %[^\\n]\", name); // Read string with spaces\n\n   int index = findItemByName(inventory, name); // Find index of the item by name\n\n   if (index == -1) { // If not found, notify user\n       printf(\"Item '%s' not found in inventory.\\n\", name);\n       return;\n   }\n\n   int newQuantity;\n\n   // Loop until a valid quantity is provided\n   do {\n       printf(\"Enter new quantity for '%s' (must be >= 0): \", inventory->items[index].name);\n       while (scanf(\"%d\", &newQuantity) != 1 || newQuantity < 0) { \n           // Validate integer input and ensure quantity is non-negative\n           printf(\"Invalid input. Please enter a valid non-negative quantity: \");\n           while (getchar() != '\\n'); // Clear invalid input from buffer\n       }\n   } while (newQuantity < 0); // Repeat until valid input\n\n   // Update quantity and availability status\n   inventory->items[index].quantity = newQuantity;\n   inventory->availability[index].inStock = (newQuantity > 0);\n   inventory->availability[index].outOfStock = (newQuantity == 0);\n\n   printf(\"Quantity updated successfully!\\n\");\n}\n\n// Function to remove a grocery item from the inventory by name\nvoid removeGroceryItem(GroceryInventory *inventory) {\n   if (inventory->count == 0) {\n       printf(\"No grocery items in inventory.\\n\");\n       return;\n   }\n\n   char name[MAX_NAME_LENGTH];\n\n   // Prompt for item name\n   printf(\"Enter the name of the item to remove: \");\n   scanf(\" %[^\\n]\", name); // Read string with spaces\n\n   int index = findItemByName(inventory, name); // Find index of the item by name\n\n   if (index == -1) { // If not found, notify user\n       printf(\"Item '%s' not found in inventory.\\n\", name);\n       return;\n   }\n\n   // Shift items to fill the gap\n   for (int i = index; i < inventory->count - 1; i++) {\n       inventory->items[i] = inventory->items[i + 1];\n       inventory->availability[i] = inventory->availability[i + 1];\n   }\n\n   // Decrease the count of items in the inventory\n   inventory->count--;\n\n   printf(\"Grocery item '%s' removed successfully!\\n\", name);\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next; // Pointer to the next student in the list\n} Student;\n\nStudent* head = NULL; // Head of the linked list\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\n    if (!newStudent) {\n        fprintf(stderr, \"Memory allocation failed!\\n\");\n        exit(EXIT_FAILURE); // Exit if memory allocation fails\n    }\n    strcpy(newStudent->name, name); // Copy name\n    newStudent->id = id;             // Set ID\n    newStudent->grade = grade;       // Set grade\n    newStudent->next = NULL;         // Initialize next pointer to NULL\n    return newStudent;                // Return the new student node\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade); // Create a new student node\n    newStudent->next = head; // Insert at the beginning of the list\n    head = newStudent;       // Update head to point to the new student\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) { // Check if the list is empty\n        printf(\"No student records available.\\n\");\n        return;\n    }\n    \n    Student* current = head; // Start from the head of the list\n    printf(\"\\n--- Student Records ---\\n\");\n    \n    while (current != NULL) { // Traverse the list\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next; // Move to the next student\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head; // Start from the head of the list\n\n    while (current != NULL) { // Traverse the list\n        if (current->id == id) { // Check if ID matches\n            return current; // Return pointer to found student\n        }\n        current = current->next; // Move to the next student\n    }\n    \n    return NULL; // Return NULL if not found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n\n    while (current != NULL) { // Traverse and free each node\n        next = current->next;  // Store next node\n        free(current);         // Free current node\n        current = next;       // Move to next node\n    }\n\n    head = NULL; // Reset head to NULL after deletion\n}\n\n// Function to free all memory when exiting the program\nvoid freeMemory() {\n    deleteList(); // Ensure all memory is freed before exit\n}\n\n// Sort function to sort the student records by grade using Bubble Sort algorithm of your choice\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        return; // No need to sort if list is empty or has one element\n    }\n\n    int swapped;\n    Student *ptr1;\n    Student *lptr = NULL;\n\n    do {\n        swapped = 0;\n        ptr1 = head;\n\n        while (ptr1->next != lptr) { // Traverse the list until last sorted element\n            if (ptr1->grade > ptr1->next->grade) { // Compare grades for sorting\n                // Swap data instead of nodes for simplicity and efficiency.\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, ptr1->name);\n                tempID = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempID;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1; // Set swapped flag to true as we made a swap.\n            }\n            ptr1 = ptr1->next; // Move to next node.\n        }\n        lptr = ptr1; // Last sorted element.\n    } while (swapped); // Repeat until no swaps are made.\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n--- Student Records Management ---\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (Ascending order)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");  // Remove newline character from input string.\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);  // Insert new student record.\n                break;\n            case 2:\n                displayStudents();  // Display all records.\n                break;\n            case 3:\n                sortStudents();  // Sort records by grade.\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id); \n\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\n                           found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();  // Delete all records.\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();  // Free memory before exiting.\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n        \n    } while (choice != 6);  // Continue until user chooses to exit.\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation effectively sorts the student records by grade. However, bubble sort has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider implementing more efficient sorting algorithms, such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20511126",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define MAX_SIZE 5\r\n\r\n// function for inputting matrix elements\r\nint inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE])\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// function for adding matrices\r\nvoid addMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE])\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to subtract two matrices\r\nvoid subtractMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE])\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to transpose a matrix\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE])\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to print a matrix\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE])\r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    // intitializing variables\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    // dimensions for Matrix A\r\n    printf(\"Enter dimensions for matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    if (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE)\r\n    {\r\n        printf(\"Invalid dimensions for Matrix A. Please restart the program.\\n\"); // error funtion if rows or columns arent between MAX_SIZE\r\n        return 1;\r\n    }\r\n\r\n    // inputting elements into the matrix A\r\n    printf(\"Enter elements for matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, matrixA);\r\n\r\n    // dimensions for Matrix B\r\n    printf(\"Enter dimensions for matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    if (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE)\r\n    {\r\n        printf(\"Invalid dimensions for Matrix B. Please restart the program.\\n\"); // error funtion if rows or columns arent between MAX_SIZE\r\n        return 1;\r\n    }\r\n\r\n    // inputting elements into the matrix B\r\n    printf(\"Enter elements for matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, matrixB);\r\n\r\n    do\r\n    {\r\n        // display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // switch case for input of the user\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            if (rowsA == rowsB && colsA == colsB) // checking if the dimensions are same for addition\r\n            {\r\n                addMatrices(rowsA, colsA, matrixA, matrixB, result); // using function addMatrices to add the matrices\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(rowsA, colsA, result); // displaying the matrix by printMatrix function\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrices dimensions do not match for addition.\\n\"); // error if the dimensions dont match\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            if (rowsA == rowsB && colsA == colsB) // checking if the dimensions are same for addition\r\n            {\r\n                subtractMatrices(rowsA, colsA, matrixA, matrixB, result); // using function subtractMatrices to subtract the matrices\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                printMatrix(rowsA, colsA, result); // displaying the matrix by printMatrix function\r\n            }\r\n            else\r\n            {\r\n                printf(\"Matrices dimensions do not match for subtraction.\\n\"); // error if the dimensions dont match\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            transposeMatrix(rowsA, colsA, matrixA, result); // function to make transpose of a matrix\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(colsA, rowsA, result); // displaying the transposed matrix\r\n            break;\r\n\r\n        case 4:\r\n            transposeMatrix(rowsB, colsB, matrixB, result); // function to make transpose of a matrix\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(colsB, rowsB, result); // displaying the transposed matrix\r\n            break;\r\n\r\n        case 5:\r\n            printf(\"Exiting program.\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n// defining the Grocery struct\r\ntypedef struct\r\n{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} Grocery;\r\n\r\n// defining the AvailabilityStatus struct\r\ntypedef struct\r\n{\r\n    bool instock;    // true if the item is in stock\r\n    bool notinstock; // opposite of instock\r\n} AvailabilityStatus;\r\n\r\n// defining the GroceryInventory struct\r\ntypedef struct\r\n{\r\n    Grocery items[100];                   // array of grocery items\r\n    AvailabilityStatus availability[100]; // array of availability statuses\r\n    int itemCount;                        // count of total grocery items\r\n} GroceryInventory;\r\n\r\n// function declarations\r\nvoid addItem(GroceryInventory *inventory);\r\nvoid listItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeItem(GroceryInventory *inventory);\r\n\r\nint main()\r\n{\r\n    GroceryInventory inventory = {.itemCount = 0};\r\n    int choice;\r\n\r\n    do\r\n    {\r\n        printf(\"\\nGrocery Inventory Management System:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove a Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // remove newline left by scanf\r\n\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            addItem(&inventory);\r\n            break;\r\n        case 2:\r\n            listItems(&inventory);\r\n            break;\r\n        case 3:\r\n            updateQuantity(&inventory);\r\n            break;\r\n        case 4:\r\n            removeItem(&inventory);\r\n            break;\r\n        case 5:\r\n            printf(\"Exiting the program.\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// function to add a grocery item to the inventory\r\nvoid addItem(GroceryInventory *inventory)\r\n{\r\n    if (inventory->itemCount > 100)\r\n    {\r\n        printf(\"Inventory is full, cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    Grocery *item = &inventory->items[inventory->itemCount];\r\n    AvailabilityStatus *status = &inventory->availability[inventory->itemCount];\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0'; // remove trailing newline\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0'; // remove trailing newline\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    getchar(); // remove newline\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n    getchar(); // remove newline\r\n\r\n    // uppdate availability\r\n    status->instock = (item->quantity > 0);\r\n    status->notinstock = !status->instock;\r\n\r\n    inventory->itemCount++;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// function to list all grocery items in the inventory\r\nvoid listItems(const GroceryInventory *inventory)\r\n{\r\n    if (inventory->itemCount == 0)\r\n    {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n    printf(\"\\n\");\r\n    for (int i = 0; i < inventory->itemCount; i++) // for loop to print all items pointed by inventory\r\n    {\r\n        const Grocery *item = &inventory->items[i];\r\n        const AvailabilityStatus *status = &inventory->availability[i];\r\n\r\n        printf(\"  Name: %s\\n\", item->name);\r\n        printf(\"  Category: %s\\n\", item->category);\r\n        printf(\"  Quantity: %d\\n\", item->quantity);\r\n        printf(\"  Price: $%.2f\\n\", item->price);\r\n        printf(\"  Status: %s\\n\", status->instock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory)\r\n{\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // remove trailing newline\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++)\r\n    {\r\n        if (strcmp(inventory->items[i].name, name) == 0) // if the item name pointed at my inventory is the same as user input, ask for new quantity\r\n        {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory->items[i].quantity); // assign new quantity to the item\r\n            getchar();                                  // remove newline\r\n\r\n            // update availability status\r\n            inventory->availability[i].instock = (inventory->items[i].quantity > 0);\r\n            inventory->availability[i].notinstock = !inventory->availability[i].instock;\r\n\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in the inventory.\\n\"); // error if item is not found in the array\r\n}\r\n\r\n// function to remove a grocery item from the inventory\r\nvoid removeItem(GroceryInventory *inventory)\r\n{\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // remove trailing newline\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++)\r\n    {\r\n        if (strcmp(inventory->items[i].name, name) == 0)\r\n        {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) // shift all items after the removed item one step forward\r\n            {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->itemCount--; // decrease itemCount\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student\r\n{\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student;\r\n\r\nStudent *head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent *createStudent(const char *name, int id, float grade)\r\n{\r\n    Student *NewStudent = (Student *)malloc(sizeof(Student)); // NewStudent is the pointer that points to the first node of the linked list\r\n    strcpy(NewStudent->name, name);\r\n    NewStudent->id = id;\r\n    NewStudent->grade = grade;\r\n    NewStudent->next = NULL; // pointer that points to the next part of the linked list declared to NULL\r\n    return NewStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char *name, int id, float grade)\r\n{\r\n    Student *NewStudent = createStudent(name, id, grade);\r\n    if (!head) // if head pointer is empty, NewStudent becomes the first node in the list\r\n    {\r\n        head = NewStudent;\r\n    }\r\n    else // if its not empty, we find the last node in the list to make it NewStudent\r\n    {\r\n        Student *temp = head;\r\n        while (temp->next)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = NewStudent; // by the end of the loop, temp points to the last node in the list\r\n    }\r\n    printf(\"Student record added.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents()\r\n{\r\n    if (!head)\r\n    {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student *temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp)\r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next; // iterate through the nodes, printing them all out until the last node is reached\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent *searchStudentByID(int id)\r\n{\r\n    Student *temp = head;\r\n    while (temp)\r\n    {\r\n        if (temp->id == id)\r\n        {\r\n            return temp; // iterate through the nodes, if one of the nodes are the same as id, return temp\r\n        }\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList()\r\n{\r\n    Student *current = head;\r\n    Student *next;\r\n    while (current != NULL)\r\n    {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory()\r\n{\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an\r\n// algorithm of your choice\r\nvoid sortStudents()\r\n{\r\n    // using bubble sort\r\n    Student *i, *j;\r\n    for (i = head; i != NULL; i = i->next) // outer loop that iterates through the nodes\r\n    {\r\n        for (j = i->next; j != NULL; j = j->next) // inner loop that iterates through the nodes after i\r\n        {\r\n            if (i->grade < j->grade)\r\n            {\r\n                // swap the contents of the two nodes\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempID;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Student records sorted by grade in descending order.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main()\r\n{\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do\r\n    {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\");\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n        case 3:\r\n            sortStudents();\r\n            break;\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student *found = searchStudentByID(id);\r\n            if (found)\r\n            {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                       found->name, found->id, found->grade);\r\n            }\r\n            else\r\n            {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in descending order. While Bubble Sort is straightforward, its time complexity of O(n?) can be inefficient for larger datasets. For better performance, consider using more efficient algorithms such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20701571",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    //intialization\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n\r\n    do{ \r\n    // input dimensions\r\n    printf(\"Enter the demensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    if (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE) { // this if statement ensures that the row size or column size for matrix A is not exceeded past 10 or is below or equal to 0 by using the logical OR.\r\n        printf(\"Invalid dimensions for Matrix A. Try again!\\n\");\r\n        \r\n    }\r\n    } while (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE); // the program loops backs to enter the dimensions again because the maximum size has been exceeded. \r\n    \r\n    inputMatrix(A, rowsA, colsA, 'A'); // input elements of Matrix A\r\n    \r\n    do{\r\n    printf(\"\\nEnter the demensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    if (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE) { // this if statement ensures that the row size or column size for matrix B is not exceeded past 10 or is below or equal to 0 by using the logical OR.   \r\n        printf(\"Invalid dimensions for Matrix B. Try again!\\n\");\r\n\r\n    }\r\n    }while(rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE);\r\n\r\n    inputMatrix(B, rowsB, colsB, 'B'); //input elements of Matrix B\r\n    \r\n    do{\r\n    if (rowsA != rowsB || colsA != colsB) {\r\n        printf(\"Matrix operations (add/subtract) require matching dimensions. Exiting...\\n\");  \r\n    }\r\n    }while (rowsA != rowsB || colsA != colsB);\r\n    \r\n    // Matrix Menu loop\r\n    do { // use of do-while loop so the program displays the menu first time and then again after the user has performed a operation once and wishes to do it again the loop will allow the user to do either the same operation or a different one.\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n                addMatrices(A, B, rowsA, colsA);\r\n                break;\r\n            case 2:\r\n                printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n                subtractMatrices(A, B, rowsA, colsA);\r\n                break;\r\n            case 3:\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                transposeMatrix(A, rowsA, colsA);\r\n                break;\r\n            case 4:\r\n                printf(\"\\nTranspose of Matrix B:\\n\");\r\n                transposeMatrix(B, rowsB, colsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid option. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n    \r\n    return 0;\r\n}\r\n\r\n// Function to input a matrix\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    printf(\"Enter elements of Matrix %c (%dx%d) (each number in a element should be different):\\n\", name, rows, cols);\r\n    for (int i = 0; i < rows; i++) {// Loop through each row of the matrix\r\n        for (int j = 0; j < cols; j++) {// Loop through each column of the matrix\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1); // Allows the user to enter the value for the current matrix element\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// The display a matrix function is designed to print the elements of a given matrix row by row in a readable format \r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { // Iterate over each row of the matrix\r\n        for (int j = 0; j < cols; j++) {  // Iterate over each column in the current row\r\n            printf(\"%d \", matrix[i][j]); // Print the current matrix element followed by a space\r\n        }\r\n        printf(\"\\n\"); // skips a line to display a matrix \r\n    }\r\n}\r\n\r\n// Function to add matrices\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n    displayMatrix(result, rows, cols);\r\n}\r\n\r\n// Function to subtract matrices\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    // Iterate over the rows of the original matrix\r\n    for (int i = 0; i < rows; i++) { \r\n        for (int j = 0; j < cols; j++) { // Iterate over the columns of the original matrix\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n    displayMatrix(result, rows, cols); //The dimensions of the transposed matrix are swapped.\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    int result[MAX_SIZE][MAX_SIZE]; // Define a temporary result matrix to store the transposed values\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];// Assign the value at position [i][j] in the original matrix \r\n            // to position [j][i] in the transposed matrix\r\n        }\r\n    }\r\n    displayMatrix(result, cols, rows); //The dimensions of the transposed matrix are swapped.\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int inStock;\r\n} GroceryItem;\r\n\r\nGroceryItem inventory[MAX_ITEMS];\r\nint Numitems = 0; //initialize number of items to 0\r\n\r\nvoid addItem() {\r\n    if (Numitems >= MAX_ITEMS) { //if statement to ensure the user doesnt exceed the maximum number of items defined previously\r\n        printf(\"Inventory is full.\\n\");\r\n    }\r\n\r\n    GroceryItem item; // declares a variable item of type GroceryItem\r\n    printf(\"Enter item name: \"); //item.name is the destination where the entered string is stored, so the string entered will be stored in the array \"name\" in the struct GroceryItem\r\n    scanf(\" %[^\\n]s\", item.name);// %[^\\n] is a format specifier used with scanf to read an entire line\r\n    printf(\"Enter category: \"); \r\n    scanf(\" %[^\\n]s\", item.category); //The category field of the item struct will store the input string.\r\n    printf(\"Enter quantity: \"); // we use the ampersand (&) for quantity and not in \"name\" and \"category\" fields because they are arrays and the name of an array is a pointer to the first element of the array.\r\n    scanf(\"%d\", &item.quantity); // the quantity inputted by the user should be an integer so %d is used. \"&item.quantity\" passes the address of the quantity field to scanf.\r\n    printf(\"Enter price: \");// we use the ampersand for price as well as it does not have an array rather it is a float.\r\n    scanf(\"%f\", &item.price);// for price we have to use floating point format specifier.\r\n    item.inStock = item.quantity > 0; // item is in stock if quantity of the item is greater than 0.\r\n\r\n    inventory[Numitems++] = item;\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\nvoid listItems() {\r\n    if (Numitems == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\nprintf(\"Inventory List:\\n\"); \r\n    for (int i = 0; i < Numitems; i++) { // Loop through all items in the inventory\r\n        printf(\"Name: %s\\n, Category: %s\\n, Quantity: %d\\n, Price: %.2f\\n, Status: %s\\n\",\r\n               inventory[i].name,         // Print the item's name\r\n               inventory[i].category,     // Print the item's category\r\n               inventory[i].quantity,     // Print the item's quantity\r\n               inventory[i].price,        // Print the item's price to 2 decimal places\r\n               inventory[i].inStock ? \"In Stock\" : \"Out of Stock\"); // Print stock status based on quantity, using ternary operator\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char name[100]; // Buffer to store the name of the item to be updated\r\n    printf(\"Enter item name to update: \"); // Prompt the user for the item's name\r\n    scanf(\" %[^\\n]s\", name); // Read the item name, allowing spaces\r\n\r\n    for (int i = 0; i < Numitems; i++) { // Loop through the inventory\r\n        if (strcmp(inventory[i].name, name) == 0) { // Check if the current item's name matches the input\r\n            printf(\"Enter new quantity: \"); // Prompt for the new quantity\r\n            scanf(\"%d\", &inventory[i].quantity); // Read the new quantity\r\n            inventory[i].inStock = inventory[i].quantity > 0; // Update stock status based on the new quantity\r\n            printf(\"Quantity updated successfully.\\n\"); \r\n            return; // Exit the function after updating.\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\"); // Inform the user if the item was not found in the inventory\r\n}\r\n\r\nvoid removeItem() {\r\n    char name[100]; // Buffer to store the name of the item to be removed\r\n    printf(\"Enter item name to remove: \"); // Prompt the user for the item's name\r\n    scanf(\" %[^\\n]s\", name); // Read the item name, allowing spaces\r\n\r\n    for (int i = 0; i < Numitems; i++) { // Loop through the inventory.\r\n        if (strcmp(inventory[i].name, name) == 0) { // Check if the current item's name matches the input\r\n            for (int j = i; j < Numitems - 1; j++) { // Shift subsequent items to fill the gap\r\n                inventory[j] = inventory[j + 1]; // Overwrite the current item with the next one\r\n            }\r\n            Numitems--; // Decrement the item count after removal\r\n            printf(\"Item removed successfully.\\n\"); \r\n            return; // Exit the function after removing\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\"); // Inform the user if the item was not found in the inventory\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    do { // do while loop so it allows the program to keep looping the Menu until the user enters 5 and exits the program\r\n        printf(\"\\nMenu:\\n1. Add Item\\n2. List Items\\n3. Update Quantity\\n4. Remove Item\\n5. Exit\\nEnter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next; // this is the pointer to the next student in the linked list\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\nvoid insertStudent(const char* name, int id, float grade); // Inserts a new student record into the linked list.\r\nvoid displayStudents(); // Displays all current student records in the linked list.\r\nStudent* searchStudentByID(int id); // Searches for a student record by student ID and returns a pointer to the corresponding studentnode.\r\nvoid deleteList(); // Deletes the entire linked list and frees the allocated memory.\r\nvoid freeMemory(); // A utility function to ensure that all memory is freed when the program exits.\r\nStudent* createStudent(const char* name, int id, float grade); //Creates a new student node and returns a pointer to it.\r\nvoid sortStudents(); // Sort the student records by grade according to a sorting algorithm of your choice. \r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for the new student\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name); // Copy the name\r\n    newStudent->id = id;           // Assign the ID\r\n    newStudent->grade = grade;     // Assign the grade\r\n    newStudent->next = NULL;       // Initialize the next pointer\r\n    return newStudent;             // Return the new student\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade); // Create a new student node\r\n    if (!newStudent) return;\r\n\r\n    if (head == NULL) { // If the list is empty, make the new student the head\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head; // Temporary pointer to traverse the list\r\n        while (temp->next != NULL) { // Goes through to the end of the list\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent; // Add the new student to the end of the list\r\n    }\r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) { // This checks whether the list is empty or not\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"Student Records:\\n\");\r\n    while (temp != NULL) { // Goes through the list and display each student's details\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* StudentID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) { // If the ID matches, return the student\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL; // Return NULL if no student is found\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    // To view the sorted version first press 2 to display all the records in the unsorted manner then press 3 to sort all the records and view again by pressing 2\r\n    if (head == NULL || head->next == NULL) { \r\n        printf(\"No sorting needed. List is empty or has only one student.\\n\");\r\n        return; // No need to sort if the list is empty or contains only one node\r\n    }\r\n\r\n    Student* i;\r\n    Student* j;\r\n    for (i = head; i->next != NULL; i = i->next) { // Outer loop to traverse the list\r\n        for (j = head; j->next != NULL; j = j->next) { // Inner loop for pairwise comparisons\r\n            if (j->grade > j->next->grade) { // Compare grades\r\n                // Swap the data (name, ID, and grade) between adjacent nodes\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, j->name); //swaps the names\r\n                tempID = j->id; // swaps the ID's\r\n                tempGrade = j->grade; // swaps the grades\r\n\r\n                strcpy(j->name, j->next->name);\r\n                j->id = j->next->id;\r\n                j->grade = j->next->grade;\r\n\r\n                strcpy(j->next->name, tempName);\r\n                j->next->id = tempID;\r\n                j->next->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n printf(\"Student records have been sorted by grade in ascending order, using bubble sort (press 2 to view the sorted order).\\n\");\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n Student* current = head; // Pointer to the current node\r\n Student* next; // Pointer to the next node\r\n\r\n while (current != NULL) { // Goes through the list\r\n    next = current->next; // Save the pointer to the next node\r\n    free(current); // Frees up the memory for the current node\r\n    current = next; // Moves to the next node\r\n }\r\n head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n deleteList(); // Call deleteList to free the entire list\r\n} \r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n int choice, ID_NO;\r\n char name[100];\r\n float grade;\r\n do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\"); //using bubble sort, because it is simpliest to implement and can be used for sorting records easily\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To remove the newline character\r\n\r\n\r\n switch (choice) {\r\n    case 1:\r\n        printf(\"Enter Name: \");\r\n        fgets(name, sizeof(name), stdin);\r\n        strtok(name, \"\\n\");\r\n        printf(\"Enter ID: \");\r\n        scanf(\"%d\", &ID_NO);\r\n        printf(\"Enter Grade: \");\r\n        scanf(\"%f\", &grade);\r\n        insertStudent(name, ID_NO, grade);\r\n    break;\r\n    case 2:\r\n    displayStudents();\r\n    break;\r\n    case 3:\r\n    sortStudents();\r\n    break;\r\n    case 4:\r\nprintf(\"Enter ID to search: \");\r\nscanf(\"%d\", &ID_NO);\r\n\r\nStudent* found = StudentID(ID_NO); \r\nif (found) {\r\n        printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n }\r\n    else {\r\nprintf(\"Student not found.\\n\");\r\n}\r\n    break;\r\n    case 5:\r\n        deleteList();\r\n        printf(\"List deleted.\\n\");\r\n    break;\r\n    case 6:\r\n        freeMemory();\r\n        printf(\"Exiting...\\n\");\r\n    break;\r\n    default:\r\n        printf(\"Invalid choice! Please try again.\\n\"); }\r\n}   while (choice != 6);\r\n\r\nreturn 0;\r\n} \r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20677103",
    "code": "\n/* --- qstn 1.c --- */\n#include <stdio.h>\r\n\r\n// Defining the maximum size for the matrices\r\n#define MAX_SIZE 10\r\n\r\n// Declarations of functions: The functions will be defined afterwards\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    // Declare matrices and result arrays\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int transposedA[MAX_SIZE][MAX_SIZE], transposedB[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB; // Variables for the number of rows and columns of each matrix\r\n    int choice; // To store the user's menu choice\r\n\r\n    // Input matrix A's dimensions and elements\r\n    printf(\"Enter the number of rows and columns for Matrix A (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);  // Taking input for rows and columns\r\n    printf(\"Enter the elements of Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);  // Function to input the elements of Matrix A\r\n\r\n    // Input matrix B's dimensions and elements\r\n    printf(\"Enter the number of rows and columns for Matrix B (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);  // Taking input for rows and columns\r\n    printf(\"Enter the elements of Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);  // Function to input the elements of Matrix B\r\n\r\n    // Loop to display the menu and ask the user for an operation until the exit condition\r\n    do {\r\n        // Display matrix operations menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); // Get user choice for operation\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Add matrices A and B if their dimensions match\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);  // Call function to add matrices\r\n                    printf(\"Matrix A + Matrix B =\\n\");\r\n                    displayMatrix(result, rowsA, colsA);  // Display the result of the addition\r\n                } else {\r\n                    printf(\"Matrix dimensions must match for addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                // Subtract matrices A and B if their dimensions match\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA); // Call function to subtract matrices\r\n                    printf(\"Matrix A - Matrix B =\\n\");\r\n                    displayMatrix(result, rowsA, colsA);  // Display the result of the subtraction\r\n                } else {\r\n                    printf(\"Matrix dimensions must match for subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                // Transpose matrix A\r\n                transposeMatrix(matrixA, transposedA, rowsA, colsA);  // Call function to transpose Matrix A\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(transposedA, colsA, rowsA);  // Display the transposed matrix (rows and cols swapped)\r\n                break;\r\n\r\n            case 4:\r\n                // Transpose matrix B\r\n                transposeMatrix(matrixB, transposedB, rowsB, colsB);  // Call function to transpose Matrix B\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(transposedB, colsB, rowsB);  // Display the transposed matrix (rows and cols swapped)\r\n                break;\r\n\r\n            case 5:\r\n                // Quit the program\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                // If the user entered an invalid choice, prompt them to try again\r\n                printf(\"Invalid choice, please try again.\\n\");\r\n        }\r\n    } while (choice != 5);  // Repeat the loop until the user chooses to exit\r\n\r\n    return 0;  // Terminates the program\r\n}\r\n\r\n// Input function for the elements of the matrix\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    // Loop to take input for each element of the matrix\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);  // Display a prompt for the user to enter the element\r\n            scanf(\"%d\", &matrix[i][j]);  // Store the element in the matrix\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    // Loop to display the elements of the matrix in a formatted way\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);  // Print each element followed by a space\r\n        }\r\n        printf(\"\\n\");  // Print a new line after each row\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    // Loop through each element of the matrices and add corresponding elements\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];  // Add corresponding elements of A and B\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    // Loop through each element of the matrices and subtract corresponding elements\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];  // Subtract corresponding elements of A and B\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    // Loop through each element and assign it to the transposed position\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];  // Swap the row and column indices\r\n        }\r\n    }\r\n}\r\n\n/* --- qstn 2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Define a structure to represent a grocery item\r\ntypedef struct {\r\n    char name[100];       // Name of the item\r\n    char category[50];    // Category of the item\r\n    int quantity;         // Quantity of the item\r\n    float price;          // Price of the item\r\n} groceryItem;\r\n\r\n// Define a union to represent the availability status of an item\r\ntypedef union {\r\n    bool inStock;         // Indicates if the item is in stock\r\n    bool noStock;         // Indicates if the item is out of stock\r\n} availabilityStatus;\r\n\r\n// Define a structure to represent the grocery inventory\r\ntypedef struct {\r\n    groceryItem item[100];         // Array of grocery items\r\n    availabilityStatus status[100]; // Array of availability statuses\r\n    int inventoryCount;            // Number of items in the inventory\r\n} groceryInventory;\r\n\r\n// Declare a global pointer to the grocery inventory\r\ngroceryInventory* inventory;\r\n\r\n// Function to add a new grocery item to the inventory\r\nvoid addItem() {\r\n    // Point to the next available slot in the item array\r\n    groceryItem* addedItem = &inventory->item[inventory->inventoryCount]; \r\n\r\n    // Prompt user to enter item name\r\n    printf(\"Enter Item name:\\n\");\r\n    fgets(addedItem->name, sizeof(addedItem->name), stdin);  // Read the item name from standard input\r\n    strtok(addedItem->name, \"\\n\");  // Remove the newline character from the name\r\n\r\n    // Prompt user to enter category\r\n    printf(\"Enter category:\\n\");\r\n    fgets(addedItem->category, sizeof(addedItem->category), stdin);  // Read the category from standard input\r\n    strtok(addedItem->category, \"\\n\");  // Remove the newline character from the category\r\n\r\n    // Prompt user to enter quantity\r\n    printf(\"Enter quantity:\\n\");\r\n    scanf(\"%d\", &addedItem->quantity);  // Read the quantity from standard input\r\n    getchar();  // Consume the newline character left by scanf\r\n\r\n    // Prompt user to enter price\r\n    printf(\"Enter price:\\n\");\r\n    scanf(\"%f\", &addedItem->price);  // Read the price from standard input\r\n    getchar();  // Consume the newline character left by scanf\r\n\r\n    // Update the availability status based on the quantity\r\n    inventory->status[inventory->inventoryCount].inStock = (addedItem->quantity > 0);\r\n\r\n    // Increment the inventory count\r\n    inventory->inventoryCount++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items in the inventory\r\nvoid listItems() {\r\n    // Check if inventory is empty\r\n    if (inventory->inventoryCount == 0) {\r\n        printf(\"No grocery items in the inventory\\n\");\r\n    } else {\r\n        // Loop through all items in the inventory and display their details\r\n        for (int i = 0; i < inventory->inventoryCount; i++) {\r\n            groceryItem* item = &inventory->item[i];  // Point to the current item in the array\r\n            printf(\"Name: %s\\nCategory: %s\\nQuantity: %d\\nPrice: $%.2f\\nStatus: %s\\n\\n\",\r\n                   item->name, item->category, item->quantity, item->price,\r\n                   inventory->status[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a specific grocery item\r\nvoid updateQuantity() {\r\n    char itemName[100];\r\n    // Prompt user to enter the name of the item to update\r\n    printf(\"Enter name of the grocery item to update quantity:\\n\");\r\n    fgets(itemName, sizeof(itemName), stdin);  // Read the item name from standard input\r\n    strtok(itemName, \"\\n\");  // Remove the newline character from the item name\r\n\r\n    // Loop through the inventory to find the item\r\n    for (int i = 0; i < inventory->inventoryCount; i++) {\r\n        if (strcmp(inventory->item[i].name, itemName) == 0) {\r\n            int addedQuantity;\r\n\r\n            // Prompt user to enter the new quantity\r\n            printf(\"Enter new quantity for %s:\\n\", itemName);\r\n            scanf(\"%d\", &addedQuantity);  // Read the new quantity from standard input\r\n            getchar();  // Consume the newline character left by scanf\r\n\r\n            // Update the item's quantity and availability status\r\n            inventory->item[i].quantity = addedQuantity;\r\n            inventory->status[i].inStock = (addedQuantity > 0);\r\n            printf(\"Quantity updated successfully\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory\\n\");\r\n}\r\n\r\n// Function to remove a specific grocery item from the inventory\r\nvoid removeItems() {\r\n    char itemName[100];\r\n    // Prompt user to enter the name of the item to remove\r\n    printf(\"Enter name of grocery item to remove:\\n\");\r\n    fgets(itemName, sizeof(itemName), stdin);  // Read the item name from standard input\r\n    strtok(itemName, \"\\n\");  // Remove the newline character from the item name\r\n\r\n    // Loop through the inventory to find the item\r\n    for (int i = 0; i < inventory->inventoryCount; i++) {\r\n        if (strcmp(inventory->item[i].name, itemName) == 0) {\r\n            // Shift all subsequent items one position to the left\r\n            for (int j = i; j < inventory->inventoryCount - 1; j++) {\r\n                inventory->item[j] = inventory->item[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            // Decrement the inventory count\r\n            inventory->inventoryCount--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    // Allocate memory for the inventory\r\n    inventory = (groceryInventory*)malloc(sizeof(groceryInventory));  \r\n    if (!inventory) {  // Check if memory allocation was successful\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return 1;\r\n    }\r\n    // Initialize the inventory count to 0\r\n    inventory->inventoryCount = 0;  \r\n\r\n    int choice = 0;\r\n    while (choice != 5) {\r\n        // Display the menu options\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add grocery item\\n\");\r\n        printf(\"2. List all grocery items\\n\");\r\n        printf(\"3. Update quantity\\n\");\r\n        printf(\"4. Remove grocery item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  // Consume the newline character\r\n\r\n        // Handle the user's choice\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItems();\r\n                break;\r\n            case 5:\r\n                printf(\"Exited\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    // Free the allocated memory for the inventory\r\n    free(inventory);\r\n    return 0;\r\n}\r\n\n/* --- qstn 3 p.c --- */\n\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n// Structure for Student \r\ntypedef struct Student { \r\n char name[100]; \r\n int id; \r\n float grade; \r\n struct Student* next; \r\n} Student; \r\nStudent* head = NULL; \r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    // Write your code (1 mark)  \r\n    Student* addedStudent= (Student*) calloc(1, sizeof(Student)); // the addedStudent is a created pointer that points to block of the calloc memory block where the calloc is casted by the student* type making it be part of the student struct. The calloc creates sapce for one new student to be added having enough space for one students data/ structure. i used calloc as i find it safer to use as all memory is initialized to 0 so to avoind rubbish value.\r\n    strcpy(addedStudent->name, name);//  this copies the name that was inputted from the user and stores it in the name area under the addedStudent .\r\n    addedStudent->id=id; // this makes the id entered by the user be assigned to be in the id of the added Student.\r\n    addedStudent->grade=grade; \r\n    addedStudent-> next=NULL; //this initialializes the next pointeer to Null\r\n    return addedStudent;\r\n} \r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    // Write your code (1 mark) \r\n    Student* addedStudent=createStudent(name, id, grade); //this asigns the information of the new added student to the addedStudent list under the student structure.\r\n    addedStudent-> next= head;// this assigns the head to now be stored in the next member of the struct instead of Null as it was before.\r\n    head=addedStudent; //now the head pointer points to the addedStudent information\r\n} \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n // Write your code (1 mark) \r\n    printf(\"   students data    \\n\");\r\n    for(Student* top= head; top!= NULL; top= top-> next){\r\n        printf(\" name: %s, ID: %d, grade: %.2f\\n\", top-> name, top-> id, top -> grade);\r\n    } // this for loop first initialozes the top pointer to point to the head which os the top of the list and then after each iteration it points to the next node which is the next students data, it iterates until it reaches the Null as then this will be the ned of the list. \r\n\r\n\r\n} \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n // Write your code (1 mark) \r\n    for(Student* top=head; top!= NULL; top->next){\r\n        if(top->id==id){\r\n            return top;\r\n        }\r\n    }\r\n    return NULL;\r\n} \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n head = NULL; \r\n} \r\n\r\nvoid freeMemory() { \r\n deleteList(); \r\n} \r\n// Sort function to sort the student records by grade based on bubble sort because it uses a simpler logic and easy to implementand use. also since we are dealing with small amount of data it is easier to use and better. \r\n\r\nvoid sortStudents() { \r\n// Write your code (1 mark) \r\n   int sorted; // this will show that the list has been sorted.\r\n   Student* start; // pointer that points to the head of the list.\r\n   Student* end=NULL; // the pointer that points to the end of the list will be NULL to mark the end.\r\n\r\n   do { // a do while loop is done so the sorting of students is done atleast one.\r\n\r\n    sorted=0; \r\n    start=head;\r\n\r\n    while( start-> next!=end){ //this makes it loop until it reaches the end which has a null.\r\n        if(start->grade > start->next->grade){ // compares grades of 2 consecutive students and determines wheather they need to be sorted or not.\r\n            char name2[100]; // creates temporary variables to accomodate swapping and avoid overwriting.\r\n            int id2;\r\n            float grade2;\r\n\r\n            strcpy(name2, start->name); // copies information of one student to the temporary variables\r\n            id2=start->id;\r\n            grade2=start->grade;\r\n\r\n            \r\n\r\n            strcpy(start->name, start->next->name); //swapping\r\n            start->id=start->next->id;\r\n            start->grade=start->next->grade;\r\n\r\n            strcpy(start->next->name, name2);\r\n            start->next->id=id2;\r\n            start->next->grade=grade2;\r\n\r\n            sorted=1;// this states if a part has been sorted then return true. it is like a mark for a part being sorted.\r\n\r\n\r\n        }\r\n        start=start->next; //this moves the pointer to the next node.\r\n    }\r\n    end=start; // this shows where the sorting has reached\r\n\r\n\r\n}while(sorted);\r\nprintf(\"students data and records sorted by grades\");\r\n}\r\n\r\n\r\n\r\n// Main function to drive the program \r\nint main() { \r\n int choice, id; \r\n char name[100]; \r\n float grade; \r\n do { \r\n printf(\"\\n1. Insert Student Record\\n\"); \r\n printf(\"2. Display Student Records\\n\"); \r\n printf(\"3. Sort Records (choose sorting method)\\n\"); \r\n printf(\"4. Search Record by ID\\n\"); \r\n printf(\"5. Delete List\\n\"); \r\n printf(\"6. Exit\\n\"); \r\n printf(\"Enter your choice: \"); \r\n scanf(\"%d\", &choice); \r\n getchar(); // To consume the newline character \r\n switch (choice) { \r\n case 1: \r\n printf(\"Enter Name: \"); \r\n fgets(name, sizeof(name), stdin); \r\n strtok(name, \"\\n\"); \r\n printf(\"Enter ID: \"); \r\n scanf(\"%d\", &id); \r\n printf(\"Enter Grade: \"); \r\n scanf(\"%f\", &grade); \r\n insertStudent(name, id, grade); \r\n break; \r\n case 2: \r\n displayStudents(); \r\n break; \r\n case 3: \r\n sortStudents(); \r\n break; \r\n case 4: \r\n printf(\"Enter ID to search: \"); \r\n scanf(\"%d\", &id); \r\n Student* found = searchStudentByID(id); \r\n\r\nif(found) { \r\n    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",found->name, found->id, found->grade); \r\n } else { \r\n    printf(\"Student not found.\\n\");\r\n } \r\n break; \r\n case 5: \r\n deleteList(); \r\n printf(\"List deleted.\\n\"); \r\n break; \r\n case 6: \r\n freeMemory(); \r\n printf(\"Exiting...\\n\"); \r\n break; \r\n default: \r\n printf(\"Invalid choice! Please try again.\\n\"); \r\n } \r\n } while (choice != 6); \r\n return 0; \r\n} \r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly to sort student records by grade. While Bubble Sort is simple and effective for small datasets, it has a time complexity of O(n?), which may be inefficient for larger datasets. For larger lists, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20599269",
    "code": "\n/* --- Omair Ahmad Ibrahim- 20599269/Omair Ahmad Ibrahim- 20599269/Task 2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Defining the structures\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus availability[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .count = 0 };\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->count];\r\n    AvailabilityStatus *status = &inventory->availability[inventory->count];\r\n\r\n    printf(\"Enter name: \");\r\n    scanf(\" %[^\\n]\", item->name);  \r\n    printf(\"Enter category: \");\r\n    scanf(\" %[^\\n]\", item->category);  \r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n\r\n    status->inStock = item->quantity > 0;\r\n\r\n    inventory->count++;\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems(const GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Items:\\n\");\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        const AvailabilityStatus *status = &inventory->availability[i];\r\n        printf(\"%d. Name: %s, Category: %s, Quantity: %d, Price: %.2f, %s\\n\",\r\n               i + 1, item->name, item->category, item->quantity, item->price,\r\n               status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    int index;\r\n    printf(\"Enter the item number to update quantity: \");\r\n    scanf(\"%d\", &index);\r\n\r\n    if (index < 1 || index > inventory->count) {\r\n        printf(\"Invalid item number.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[index - 1];\r\n    AvailabilityStatus *status = &inventory->availability[index - 1];\r\n\r\n    printf(\"Enter new quantity for %s: \", item->name);\r\n    scanf(\"%d\", &item->quantity);\r\n\r\n    status->inStock = item->quantity > 0;\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    int index;\r\n    printf(\"Enter the item number to remove: \");\r\n    scanf(\"%d\", &index);\r\n\r\n    if (index < 1 || index > inventory->count) {\r\n        printf(\"Invalid item number.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = index - 1; i < inventory->count - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->availability[i] = inventory->availability[i + 1];\r\n    }\r\n\r\n    inventory->count--;\r\n    printf(\"Item removed successfully!\\n\");\r\n}\r\n\n/* --- Omair Ahmad Ibrahim- 20599269/Omair Ahmad Ibrahim- 20599269/Task 3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n\r\n    if (!head) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"All student records deleted successfully.\\n\");\r\n}\r\n\r\n// Function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort the student records by grade\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n    // Using Bubble Sort for simplicity\r\n    for (Student* i = head; i; i = i->next) {\r\n        for (Student* j = i->next; j; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap the contents\r\n                char tempName[100];\r\n                int tempId = i->id;\r\n                float tempGrade = i->grade;\r\n\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n\r\n                i->id = j->id;\r\n                j->id = tempId;\r\n\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1: {\r\n                char name[100];\r\n                int id;\r\n                float grade;\r\n\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            }\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4: {\r\n                int id;\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            }\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Omair Ahmad Ibrahim- 20599269/Omair Ahmad Ibrahim- 20599269/Task1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB, choice;\r\n\r\n    // Input dimensions for matrices\r\n    printf(\"Enter the number of rows and columns for Matrix A (max 10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter the number of rows and columns for Matrix B (max 10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Validate dimensions\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX) {\r\n        printf(\"Matrix size exceeds the maximum allowed (10x10).\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input matrices\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    // Menu-driven operations\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible. Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function definitions\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The choice of Bubble Sort is appropriate for simplicity, especially for small datasets. However, it has a time complexity of O(n?), which may not be efficient for larger datasets. Consider implementing more efficient sorting algorithms like Quick Sort or Merge Sort for scalability."
  },
  {
    "student_id": "20722371",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <math.h>\r\n\r\nint main() {\r\n    int rows, columns, a[10][10], b[10][10], i, j, choice;\r\n    int sum[10][10], diff[10][10], transposeda[10][10], transposedb[10][10];\r\n\r\n    printf(\"Enter dimensions for Matrix A (rows and columns) : \");\r\n    scanf(\"%d %d\", &rows, &columns);\r\n\r\n    // Input values for Matrix A\r\n    printf(\"Enter elements for Matrix A : \\n\");\r\n    for (i = 0; i < rows; ++i)\r\n        for (j = 0;j<rows; ++j){\r\n            printf(\"[%d][%d] : \", i + 1, j + 1);\r\n            scanf(\"%d\", &a[i][j]);\r\n        }\r\n\r\n    // Input values for Matrix B\r\n    printf(\"Enter elements for Matrix B : \\n\");\r\n    for (i = 0; i < rows; ++i)\r\n        for (j = 0; j < rows; ++j){\r\n            printf(\"[%d][%d] : \", i + 1, j + 1);\r\n            scanf(\"%d\", &b[i][j]);\r\n        }\r\n\r\n    // Display Matrix A and Matrix B\r\n    printf(\"\\nMatrix A : \\n\");\r\n    for (i = 0; i < rows; ++i){\r\n        for (j = 0; j < columns; ++j){\r\n            printf(\"%d  \", a[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    printf(\"\\nMatrix B : \\n\");\r\n    for (i = 0; i < rows; ++i){\r\n        for (j = 0; j < columns; ++j){\r\n            printf(\"%d  \", b[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n    // Main menu loop\r\n    do{ \r\n        printf(\"\\nMatrix Operations Menu : \\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice : \");\r\n    \r\n        if(scanf(\"%d\",&choice) != 1 || choice < 1 || choice > 5){\r\n            printf(\"Invalid choice. Please enter a number between 1 to 5.\\n\");\r\n            continue;\r\n        }\r\n\r\n    // Processes\r\n        // 1. Sum of two matrices\r\n        for (i = 0; i < rows ; ++i){\r\n            for(j = 0; j < columns ; ++j){\r\n                sum[i][j] = a[i][j] + b[i][j];\r\n            }\r\n        }\r\n\r\n        // 2. Difference of two matrices\r\n        for (i = 0; i < rows ; ++i){\r\n            for(j = 0; j < columns ; ++j){\r\n                diff[i][j] = a[i][j] - b[i][j];\r\n            }\r\n        }\r\n\r\n        // 3. Transposing Matrix A\r\n        for (i = 0; i < rows ; ++i){\r\n            for (j = 0 ; j < columns ; ++j){\r\n                transposeda[j][i] = a[i][j]; // rows and columns are swapped \r\n            }\r\n        }\r\n    \r\n        // 4. Transposing Matrix B\r\n        for (i = 0; i < rows ; ++i){\r\n            for (j = 0 ; j < columns ; ++j){\r\n                transposedb[j][i] = b[i][j]; // rows and columns are swapped \r\n            }\r\n        }\r\n\r\n        switch (choice){\r\n            case 1: \r\n            // 1. Add Matrices\r\n                printf(\"Result of Matrix A + Matrix B : \\n\");\r\n                for (i = 0; i < rows ; ++i){    \r\n                    for (j = 0 ; j < columns ; ++j){\r\n                        printf(\"%d  \", sum[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            break;\r\n\r\n            case 2:\r\n            // 2. Subtract Matrices\r\n                printf(\"Result of Matrix A - Matrix B : \\n\");\r\n                for (i = 0; i < rows ; ++i){\r\n                    for (j = 0 ; j < columns ; ++j){\r\n                        printf(\"%d  \", diff[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            break;\r\n\r\n            case 3:\r\n            // 3. Transpose Matrix A\r\n                printf(\"Transpose of Matrix A : \\n\");\r\n                for (i = 0; i < rows ; ++i){\r\n                    for (j = 0 ; j < columns ; ++j){\r\n                        printf(\"%d  \", transposeda[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n            break;\r\n\r\n            case 4:\r\n            // 4. Transpose Matrix B\r\n                printf(\"Transpose of Matrix B : \\n\");\r\n                for (i = 0; i < rows ; ++i){\r\n                    for (j = 0 ; j < columns ; ++j){\r\n                        printf(\"%d  \", transposedb[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                } \r\n            break;\r\n\r\n            case 5:\r\n            // 5. Exit\r\n                printf(\"\\nExiting...\");\r\n                return 0;\r\n            break;\r\n        }\r\n    }\r\n    while (choice != 5); // menu loops until user exits\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n#define SIZE 25\r\n\r\ntypedef struct{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    double price;\r\n} groceryitems;\r\n\r\ntypedef struct{\r\n    bool instock;\r\n    bool outofstock;\r\n} availabilitystatus;\r\n\r\ntypedef struct{\r\n    groceryitems items[100];\r\n    availabilitystatus availability[100];\r\n    int count;\r\n} groceryinventory;\r\n\r\nint main() {\r\n    int choice;\r\n    char name[100];\r\n    \r\n    groceryinventory inventory;\r\n    inventory.count = 0;\r\n\r\n    do {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        if (scanf(\"%d\", &choice) != 1 || choice < 1 || choice > 5) {\r\n            printf(\"Invalid choice. Please enter a number between 1 to 5.\\n\");\r\n            while (getchar() != '\\n'); // clear the input buffer\r\n            continue;\r\n        }\r\n\r\n        while (getchar() != '\\n'); //clear any leftover newline character from previous input\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // 1. Add Grocery Item\r\n                groceryitems newitem;\r\n               \r\n                printf(\"Enter Item Name: \");\r\n                fgets(newitem.name, sizeof(newitem.name), stdin);\r\n                newitem.name[strcspn(newitem.name, \"\\n\")] = '\\0'; // remove newline character from name\r\n\r\n                printf(\"Enter Category: \");\r\n                fgets(newitem.category, sizeof(newitem.category), stdin);\r\n                newitem.category[strcspn(newitem.category, \"\\n\")] = '\\0'; // remove newline character from category\r\n\r\n                printf(\"Enter Quantity: \");\r\n                scanf(\"%d\", &newitem.quantity);\r\n\r\n                printf(\"Enter Price: \");\r\n                scanf(\"%lf\", &newitem.price);\r\n\r\n                inventory.items[inventory.count++] = newitem;\r\n                printf(\"Grocery item added successfully!\\n\");\r\n                break;\r\n\r\n            case 2:\r\n                // 2. List All Grocery Items\r\n                if (inventory.count == 0) {\r\n                    printf(\"No grocery items in the inventory.\\n\");\r\n                    break;\r\n                }\r\n                \r\n                for (int i = 0; i < inventory.count; i++) {\r\n                    groceryitems *item = &inventory.items[i];\r\n\r\n                    printf(\"Name: %s\\n\", item->name);\r\n                    printf(\"Category: %s\\n\", item->category);\r\n                    printf(\"Price: %.2f\\n\", item->price);\r\n                    printf(\"Status: %s\\n\", item->quantity > 0 ? \"In Stock\" : \"Out of Stock\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                // 3. Update Quantity\r\n                printf(\"Enter the name of the grocery item to update quantity: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0'; // remove newline character from name input\r\n\r\n                int found = 0;\r\n                for (int i = 0; i < inventory.count; i++) {\r\n                    if (strcmp(inventory.items[i].name, name) == 0) {\r\n                        printf(\"Enter new quantity: \");\r\n                        scanf(\"%d\", &inventory.items[i].quantity);\r\n                        printf(\"Quantity updated successfully!\\n\");\r\n                        found = 1;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    printf(\"Item not found in inventory.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 4:\r\n                // 4. Remove Grocery Item\r\n                printf(\"Enter the name of the grocery item to remove: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = '\\0'; // remove newline character from name input\r\n\r\n                found = 0;\r\n                for (int i = 0; i < inventory.count; i++) {\r\n                    if (strcmp(inventory.items[i].name, name) == 0) {\r\n                        // shift the items to remove the current item\r\n                        for (int j = i; j < inventory.count - 1; j++) {\r\n                            inventory.items[j] = inventory.items[j + 1];\r\n                        }\r\n                        inventory.count--;\r\n                        printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n                        found = 1;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    printf(\"Item not found in inventory.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                // 5. Exit\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n                break;\r\n        }\r\n    } while (choice != 5); // menu loops until user exits\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a student\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) return;\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all students\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No records to be displayed.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nvoid searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            printf(\"Found! Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n            return;\r\n        }\r\n        current = current->next;\r\n    }\r\n    printf(\"Student with ID %d not found. Please ensure the correct ID is entered.\\n\", id);\r\n}\r\n\r\n// Function to sort students by grade\r\nvoid sortStudents() {\r\n    for (Student* i = head; i && i->next; i = i->next) {\r\n        Student* min = i;\r\n        for (Student* j = i->next; j; j = j->next) {\r\n            if (j->grade < min->grade) min = j;\r\n        }\r\n        if (min != i) {\r\n            // swapping student data\r\n            char tempName[100];\r\n            int tempID = i->id;\r\n            float tempGrade = i->grade;\r\n\r\n            strcpy(tempName, i->name);\r\n            strcpy(i->name, min->name);\r\n            strcpy(min->name, tempName);\r\n\r\n            i->id = min->id;\r\n            i->grade = min->grade;\r\n\r\n            min->id = tempID;\r\n            min->grade = tempGrade;\r\n        }\r\n    }\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n    printf(\"All records deleted.\\n\");\r\n}\r\n\r\n// Main function\r\nint main() {\r\n    int choice, id;\r\n    float grade;\r\n    char name[100];\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        if (scanf(\"%d\", &choice) != 1 || choice < 1 || choice > 6) { // to ensure valid user input\r\n            printf(\"Invalid choice. Please enter a number between 1 to 6.\\n\");\r\n            while (getchar() != '\\n'); // clear input buffer\r\n            continue;\r\n        }\r\n\r\n        switch (choice) {\r\n            case 1:\r\n            // 1. Insert Student Record\r\n                printf(\"Enter name: \");\r\n                while (getchar() != '\\n');\r\n                scanf(\"%[^\\n]\", name);\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n            // 2. Display Student Records\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n            //3. Sort Records\r\n                sortStudents();\r\n                printf(\"Records sorted by grade.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n            //4. Search Record by ID\r\n                printf(\"Enter student ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                searchStudentByID(id);\r\n                break;\r\n\r\n            case 5:\r\n            //5. Delete List\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n            //6. Exit\r\n                deleteList();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 6); //menu loops until user exits\r\n    \r\n    return 0;\r\n}\r\n",
    "feedback": "q1-The inner loop for reading matrix B should use columns instead of rows for the second dimension.\nq2-Meet requirement. \nq3-The sortStudents function uses a selection sort method to sort students by grade. This method is appropriate for small datasets but has a time complexity of O(n?), which may not be efficient for larger datasets. For improved performance, consider using algorithms such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20573337",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid readMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int currentRow, int currentCol);\r\n\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int currentRow, int currentCol);\r\n\r\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE],\r\n                 int result[MAX_SIZE][MAX_SIZE]);\r\n\r\nvoid subtractMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE],\r\n                      int result[MAX_SIZE][MAX_SIZE]);\r\n\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int currentRow,\r\n                     int currentCol);\r\n\r\nint validDimension(int dimension);\r\n\r\n//Main loop , pretty  important can't do anything without it\r\nint main() {\r\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n    //using do while loops to make sure the body of code executes at least once\r\n    //not sure if doing so many do while loops was the best way to implement this but it works\r\n    do {\r\n        printf(\"Enter number of rows for Matrix A (1-10): \");\r\n        scanf(\"%d\", &rowsA);\r\n    } while (!validDimension(rowsA));\r\n\r\n    do {\r\n        printf(\"Enter number of columns for Matrix A (1-10): \");\r\n        scanf(\"%d\", &colsA);\r\n    } while (!validDimension(colsA));\r\n\r\n    do {\r\n        printf(\"Enter number of rows for Matrix B (1-10): \");\r\n        scanf(\"%d\", &rowsB);\r\n    } while (!validDimension(rowsB));\r\n\r\n    do {\r\n        printf(\"Enter number of columns for Matrix B (1-10): \");\r\n        scanf(\"%d\", &colsB);\r\n    } while (!validDimension(colsB));\r\n\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    readMatrix(rowsA, colsA, A, 0, 0);\r\n\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    readMatrix(rowsB, colsB, B, 0, 0);\r\n\r\n    do {\r\n        // Print the menu\r\n        printf(\"Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        int result[MAX_SIZE][MAX_SIZE];\r\n        //Using switch as it's faster than if-else and also more easier to debug\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(rowsA, colsA, result, 0, 0);\r\n                } else {\r\n                    printf(\"Matrices dimensions do not match for addition.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Subtraction (A - B):\\n\");\r\n                    printMatrix(rowsA, colsA, result, 0, 0);\r\n                } else {\r\n                    printf(\"Matrices dimensions do not match for subtraction.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(rowsA, colsA, A, result, 0, 0);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result, 0, 0);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(rowsB, colsB, B, result, 0, 0);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result, 0, 0);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nint validDimension(int dimension) {\r\n    return (dimension >= 1 && dimension <= MAX_SIZE) ? 1 : 0;\r\n}\r\n\r\n// Coding the Function Logic\r\nvoid readMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int currentRow, int currentCol) {\r\n    if (currentRow == rows) return;\r\n    if (currentCol == cols) {\r\n        readMatrix(rows, cols, matrix, currentRow + 1, 0);\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter element [%d][%d]: \", currentRow, currentCol);\r\n    scanf(\"%d\", &matrix[currentRow][currentCol]);\r\n    readMatrix(rows, cols, matrix, currentRow, currentCol + 1);\r\n}\r\n\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int currentRow, int currentCol) {\r\n    if (currentRow == rows) return;\r\n    if (currentCol == 0) printf(\"[ \");\r\n    printf(\"%d \", matrix[currentRow][currentCol]);\r\n    currentCol == cols - 1\r\n        ? (printf(\"]\\n\"), printMatrix(rows, cols, matrix, currentRow + 1, 0))\r\n        : printMatrix(rows, cols, matrix, currentRow, currentCol + 1);\r\n}\r\n\r\nvoid addMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE],\r\n                 int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++)\r\n        for (int j = 0; j < cols; j++)\r\n            result[i][j] = A[i][j] + B[i][j];\r\n}\r\n\r\nvoid subtractMatrices(int rows, int cols, int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE],\r\n                      int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++)\r\n        for (int j = 0; j < cols; j++)\r\n            result[i][j] = A[i][j] - B[i][j];\r\n}\r\n\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int currentRow,\r\n                     int currentCol) {\r\n    if (currentRow == rows) return;\r\n    if (currentCol == cols) {\r\n        transposeMatrix(rows, cols, matrix, result, currentRow + 1, 0);\r\n        return;\r\n    }\r\n    result[currentCol][currentRow] = matrix[currentRow][currentCol];\r\n    transposeMatrix(rows, cols, matrix, result, currentRow, currentCol + 1);\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\n// Define max sizes\r\n#define MAX_GROCERY_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Define a boolean type for clarity\r\ntypedef enum { false, true } bool;\r\n\r\n// Structure for Grocery Item\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];\r\n    char category[MAX_CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Availability Status structure\r\ntypedef struct {\r\n    bool inStock;\r\n} AvailabilityStatus;\r\n\r\n// Grocery Inventory structure\r\ntypedef struct {\r\n    GroceryItem items[MAX_GROCERY_ITEMS];\r\n    AvailabilityStatus availability[MAX_GROCERY_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\n\r\nvoid listGroceryItems(GroceryInventory *inventory, int index);\r\n\r\nvoid updateItemQuantity(GroceryInventory *inventory);\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.count = 0;\r\n\r\n    int choice;\r\n    //using do while loops to make sure the body of code executes at least once\r\n    do {\r\n        printf(\"\\nGrocery Inventory Menu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Item Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // consume newline\r\n        //Using switch as it's faster than if-else and also more easier to debug\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                if (inventory.count == 0) {\r\n                    printf(\"No items in inventory.\\n\");\r\n                } else {\r\n                    printf(\"Listing all items:\\n\");\r\n                    listGroceryItems(&inventory, 0); // recursive list, more recursion yay!!!\r\n                }\r\n                break;\r\n            case 3:\r\n                updateItemQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_GROCERY_ITEMS) {\r\n        printf(\"Inventory is full.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n    printf(\"Enter Name: \");\r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\");\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\");\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    getchar();\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n    getchar();\r\n\r\n    // Determine availability\r\n    AvailabilityStatus newStatus;\r\n    newStatus.inStock = newItem.quantity > 0 ? true : false;\r\n\r\n    // Insert into inventory\r\n    inventory->items[inventory->count] = newItem;\r\n    inventory->availability[inventory->count] = newStatus;\r\n    inventory->count++;\r\n\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// Recursive function to list all grocery items\r\nvoid listGroceryItems(GroceryInventory *inventory, int index) {\r\n    if (index >= inventory->count) {\r\n        return; // base case\r\n    }\r\n    GroceryItem *current = &inventory->items[index];\r\n    AvailabilityStatus *stat = &inventory->availability[index];\r\n\r\n    printf(\"Item %d:\\n\", index + 1);\r\n    printf(\"Name: %s\\n\", current->name);\r\n    printf(\"Category: %s\\n\", current->category);\r\n    printf(\"Quantity: %d\\n\", current->quantity);\r\n    printf(\"Price: %.2f\\n\", current->price);\r\n    printf(\"Availability: %s\\n\", stat->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    printf(\"\\n\");\r\n\r\n    // Recursively list next item\r\n    listGroceryItems(inventory, index + 1);\r\n}\r\n\r\n// Function to update item quantity\r\nvoid updateItemQuantity(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    int foundIndex = -1;\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            foundIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    foundIndex == -1\r\n        ? printf(\"Item not found.\\n\")\r\n        : (printf(\"Enter new quantity: \"),\r\n           scanf(\"%d\", &inventory->items[foundIndex].quantity),\r\n           getchar(),\r\n           inventory->availability[foundIndex].inStock = inventory->items[foundIndex].quantity > 0 ? true : false,\r\n           printf(\"Quantity updated.\\n\"));\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    strtok(itemName, \"\\n\");\r\n\r\n    int foundIndex = -1;\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            foundIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (foundIndex == -1) {\r\n        printf(\"Item not found.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift all items after foundIndex one step left\r\n    for (int j = foundIndex; j < inventory->count - 1; j++) {\r\n        inventory->items[j] = inventory->items[j + 1];\r\n        inventory->availability[j] = inventory->availability[j + 1];\r\n    }\r\n\r\n    inventory->count--;\r\n    printf(\"Item removed successfully.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student;\r\n\r\n//intialise the start to null\r\nStudent *head = NULL;\r\n\r\n// Function prototypes\r\nStudent *createStudent(const char *name, int id, float grade);\r\n\r\nvoid insertStudent(const char *name, int id, float grade);\r\n\r\nvoid displayStudents();\r\n\r\nStudent *searchStudentByID(int id);\r\n\r\nvoid deleteList();\r\n\r\nvoid freeMemory();\r\n\r\nvoid sortStudents();\r\n\r\nvoid recursiveBubbleSort(Student **headRef, int length);\r\n\r\nint getListLength(Student *head);\r\n\r\n// Create a new student node\r\nStudent *createStudent(const char *name, int id, float grade) {\r\n    Student *newStudent = (Student *) malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Insert a new student record\r\nvoid insertStudent(const char *name, int id, float grade) {\r\n    Student *newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student *temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n    printf(\"Student record inserted.\\n\");\r\n}\r\n\r\n// Display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student *temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Search for a student by ID\r\nStudent *searchStudentByID(int id) {\r\n    // Using ternary operator for concise code\r\n    Student *temp = head ? head : NULL;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Delete the entire list\r\nvoid deleteList() {\r\n    Student *current = head;\r\n    Student *next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Free all allocated memory (just calls deleteList here)\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// We will use a recursive bubble sort approach for sorting by grade.\r\n// Reason for choosing bubble sort: Easy to implement recursively.\r\nvoid sortStudents() {\r\n    int length = getListLength(head);\r\n    if (length < 2) {\r\n        printf(\"No need to sort.\\n\");\r\n        return;\r\n    }\r\n    recursiveBubbleSort(&head, length);\r\n    printf(\"Records sorted by grade in ascending order.\\n\");\r\n}\r\n\r\n// Get the length of the list\r\nint getListLength(Student *head) {\r\n    int count = 0;\r\n    Student *temp = head;\r\n    while (temp != NULL) {\r\n        count++;\r\n        temp = temp->next;\r\n    }\r\n    return count;\r\n}\r\n\r\n// Recursive Bubble Sort: Recursively passes through the list and bubbles up the largest element in each pass.\r\n//What is recursion but fancier iteration\r\nvoid recursiveBubbleSort(Student **headRef, int length) {\r\n    // Base case\r\n    if (length == 1) return;\r\n\r\n    Student *current = *headRef;\r\n    Student *nextNode = current->next;\r\n    Student *prev = NULL;\r\n\r\n    for (int i = 0; i < length - 1; i++) {\r\n        if (current->grade > nextNode->grade) {\r\n            // Swap nodes\r\n            if (prev == NULL) {\r\n                // swapping first two nodes\r\n                current->next = nextNode->next;\r\n                nextNode->next = current;\r\n                *headRef = nextNode;\r\n                prev = nextNode;\r\n            } else {\r\n                prev->next = nextNode;\r\n                current->next = nextNode->next;\r\n                nextNode->next = current;\r\n                prev = nextNode;\r\n            }\r\n        } else {\r\n            prev = current;\r\n            current = current->next;\r\n        }\r\n        nextNode = current->next;\r\n        if (nextNode == NULL) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Recur for the sublist of length-1\r\n    recursiveBubbleSort(headRef, length - 1);\r\n}\r\n\r\n// Main program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    //using do while loops to make sure the body of code executes at least once\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // consume newline\r\n        //Using switch as it's faster than if-else and also more easier to debug\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4: {\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student *found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            }\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The recursive implementation of Bubble Sort is correctly utilized to sort student records by grade in ascending order. While Bubble Sort is simple and easy to understand, it has a time complexity of O(n?), which can be inefficient for larger datasets. For larger lists, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20612945",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// Function prototypes\r\nvoid inputMatrix(int rows, int cols, int matrix[10][10]);\r\nvoid printMatrix(int rows, int cols, int matrix[10][10]);\r\nvoid addMatrices(int rows, int cols, int A[10][10], int B[10][10], int result[10][10]);\r\nvoid subtractMatrices(int rows, int cols, int A[10][10], int B[10][10], int result[10][10]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[10][10], int result[10][10]);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[10][10], matrixB[10][10];\r\n    int result[10][10];\r\n    int choice;\r\n\r\n    //input matrix a\r\n    printf(\"Enter dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    if (rowsA <= 0 || rowsA > 10 || colsA <= 0 || colsA > 10) {\r\n        printf(\"Invalid dimensions\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //input matrix a element\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(rowsA, colsA, matrixA);\r\n\r\n    //input matrix b\r\n    printf(\"Enter dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    if (rowsB <= 0 || rowsB > 10 || colsB <= 0 || colsB > 10) {\r\n        printf(\"Invalid dimensions\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //input matrix b element\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(rowsB, colsB, matrixB);\r\n\r\n    //main menu\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            //addition case\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Both matrices must have the same dimensions in order to perform addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            //substraction case\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(rowsA, colsA, matrixA, matrixB, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Both matrices must have the same dimensions in order to perform substraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            //transpose a case\r\n            case 3:\r\n                transposeMatrix(rowsA, colsA, matrixA, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(colsA, rowsA, result);\r\n                break;\r\n\r\n            //transpose b case\r\n            case 4:\r\n                transposeMatrix(rowsB, colsB, matrixB, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(colsB, rowsB, result);\r\n                break;\r\n\r\n            //exit\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid input.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n//input function\r\nvoid inputMatrix(int rows, int cols, int matrix[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//print function\r\nvoid printMatrix(int rows, int cols, int matrix[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//addition \r\nvoid addMatrices(int rows, int cols, int A[10][10], int B[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//substraction\r\nvoid subtractMatrices(int rows, int cols, int A[10][10], int B[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//transpose\r\nvoid transposeMatrix(int rows, int cols, int matrix[10][10], int result[10][10]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LEN 100\r\n#define MAX_CATEGORY_LEN 50\r\n\r\n// Struct for grocery item\r\ntypedef struct {\r\n    char name[MAX_NAME_LEN];\r\n    char category[MAX_CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Struct for availability status\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Struct for grocery inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\n//main function\r\nint main() {\r\n    GroceryInventory inventory = { .itemCount = 0 };\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character after input\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n    return 0;\r\n}\r\n\r\n//add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *newItem = &inventory->items[inventory->itemCount];\r\n    AvailabilityStatus *newStatus = &inventory->status[inventory->itemCount];\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(newItem->name, MAX_NAME_LEN, stdin);\r\n    newItem->name[strcspn(newItem->name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem->category, MAX_CATEGORY_LEN, stdin);\r\n    newItem->category[strcspn(newItem->category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem->quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem->price);\r\n    getchar();\r\n\r\n    // Update availability status\r\n    newStatus->inStock = (newItem->quantity > 0);\r\n    newStatus->outOfStock = (newItem->quantity <= 0);\r\n\r\n    inventory->itemCount++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n//list all grocery items\r\nvoid listGroceryItems(const GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Items:\\n\");\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        const AvailabilityStatus *status = &inventory->status[i];\r\n\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: $%.2f\\n\", item->price);\r\n        printf(\"Availability: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n//update quantity\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(name, MAX_NAME_LEN, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            getchar();\r\n\r\n            // Update availability status\r\n            inventory->status[i].inStock = (inventory->items[i].quantity > 0);\r\n            inventory->status[i].outOfStock = (inventory->items[i].quantity <= 0);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n//remove a grocery item\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char name[MAX_NAME_LEN];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(name, MAX_NAME_LEN, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Shift items to remove the selected item\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully.\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    printf(\"-------------------------------\\n\");\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n    Student* i;\r\n    Student* j;\r\n    int swapped;\r\n    for (i = head; i != NULL; i = i->next) {\r\n        swapped = 0;\r\n        for (j = head; j->next != NULL; j = j->next) {\r\n            if (j->grade > j->next->grade) {\r\n                // Swap student data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, j->name);\r\n                tempID = j->id;\r\n                tempGrade = j->grade;\r\n\r\n                strcpy(j->name, j->next->name);\r\n                j->id = j->next->id;\r\n                j->grade = j->next->grade;\r\n\r\n                strcpy(j->next->name, tempName);\r\n                j->next->id = tempID;\r\n                j->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n        }\r\n        if (!swapped) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n//main function\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation uses Bubble Sort to sort student records by grade. While it works correctly, Bubble Sort has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20621408",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// FUNCTIONS:\r\n//      Get User Input before going into Main Menu Loop\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int row, int col, char name)\r\n{\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//      Display Matrix\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int row, int col)\r\n{\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//      Addition\r\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int row, int col)\r\n{\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//      Subtraction\r\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int row, int col)\r\n{\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//      Transposition\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int row, int col)\r\n{\r\n    for (int i = 0; i < row; i++)\r\n    {\r\n        for (int j = 0; j < col; j++)\r\n        {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// MAIN PROGRAM ----------------------------------------------------------------------------------------------------------------------\r\nint main()\r\n{\r\n    int rowA, colA;\r\n    int rowB, colB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE];\r\n    int matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    // Get User Input for Matrices A\r\n    do\r\n    {\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowA, &colA);\r\n    } while (rowA <= 0 || rowA > MAX_SIZE || colA <= 0 || colA > MAX_SIZE);\r\n\r\n    inputMatrix(matrixA, rowA, colA, 'A');\r\n\r\n    // Get User Input for Matrices B\r\n    do\r\n    {\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowB, &colB);\r\n    } while (rowB <= 0 || rowB > MAX_SIZE || colB <= 0 || colB > MAX_SIZE);\r\n\r\n    inputMatrix(matrixB, rowB, colB, 'B');\r\n\r\n    // Main Menu Loop\r\n    while(1)\r\n    {\r\n        puts(\"\");\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice)\r\n        {\r\n            case 1:\r\n                if (rowA == rowB && colA == colB)\r\n                {\r\n                    addMatrices(matrixA, matrixB, result, rowA, colA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowA, colA);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Matrices must need to be the same dimensions in order to do Addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowA == rowB && colA == colB)\r\n                {\r\n                    subtractMatrices(matrixA, matrixB, result, rowA, colA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowA, colA);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Matrices must need to be the same dimensions in order to do Subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(matrixA, result, rowA, colA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colA, rowA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(matrixB, result, rowB, colB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colB, rowB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"INVALID... Try again.\\n\");\r\n        }\r\n\r\n        if (choice == 5)\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Define Color Codes\r\n#define RESET_COLOR \"\\x1b[0m\"\r\n#define GREEN_COLOR \"\\x1b[32m\"\r\n\r\n// STRUCTURES:\r\n//      Item\r\ntypedef struct\r\n{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n//      Status\r\ntypedef struct\r\n{\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n//      Inventory\r\ntypedef struct\r\n{\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// FUNCTIONS:\r\n//      Add Items\r\nvoid addGroceryItem(GroceryInventory *inventory)\r\n{\r\n    if (inventory->count >= MAX_ITEMS)\r\n    {\r\n        printf(\"Inventory full. Can't add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item.name, 100, stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = '\\0';             // Remove newline character (\\n) that will be automatically added when using \"fgets\"\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, 50, stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = '\\0';     // Remove newline character (\\n) that will be automatically added when using \"fgets\"\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n    getchar();                                              // Clear newline character (\\n)\r\n\r\n    inventory->items[inventory->count] = item;\r\n    inventory->status[inventory->count].inStock = item.quantity > 0;\r\n    inventory->status[inventory->count].outOfStock = item.quantity == 0;\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n//      Display All Items\r\nvoid listAllGroceryItems(const GroceryInventory *inventory)\r\n{\r\n    if (inventory->count == 0)\r\n    {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->count; i++)\r\n    {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(GREEN_COLOR \"Category: %s\\n\" RESET_COLOR, inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\\n\", \r\n               inventory->status[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n//      Update Item Quantity\r\nvoid updateQuantity(GroceryInventory *inventory)\r\n{\r\n    if (inventory->count == 0)\r\n    {\r\n        printf(\"No grocery items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++)\r\n    {\r\n        if (strcmp(inventory->items[i].name, name) == 0)\r\n        {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            getchar();                                              // Clear newline character (\\n)\r\n\r\n            inventory->status[i].inStock = inventory->items[i].quantity > 0;\r\n            inventory->status[i].outOfStock = inventory->items[i].quantity == 0;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found in the inventory.\\n\", name);\r\n}\r\n\r\n//      Remove Item\r\nvoid removeGroceryItem(GroceryInventory *inventory)\r\n{\r\n    if (inventory->count == 0)\r\n    {\r\n        printf(\"No grocery items in the inventory to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    for (int i = 0; i < inventory->count; i++)\r\n    {\r\n        if (strcmp(inventory->items[i].name, name) == 0)\r\n        {\r\n            for (int j = i; j < inventory->count - 1; j++)\r\n            {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->status[j] = inventory->status[j + 1];\r\n            }\r\n            inventory->count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found in the inventory.\\n\", name);\r\n}\r\n\r\n// MAIN PROGRAM ----------------------------------------------------------------------------------------------------------------------\r\nint main()\r\n{\r\n    GroceryInventory inventory = {.count = 0};\r\n    int choice;\r\n\r\n    // Main Menu Loop\r\n    while(1)\r\n    {\r\n        puts(\"\");\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Items\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();                                              // Clear newline character (\\n)\r\n\r\n        switch (choice)\r\n        {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n\r\n            case 2:\r\n                listAllGroceryItems(&inventory);\r\n                break;\r\n\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"INVALID. Try again.\\n\");\r\n        }\r\n\r\n        if (choice == 5)\r\n        {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// STRUCTURE\r\n//      Student\r\n//      Structure for Student\r\ntypedef struct Student\r\n{\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// FUNCTIONS:\r\n//      Create Student\r\n//      Function to create a new student node\r\n//      Creates a new student node and returns a pointer to it.\r\nStudent* createStudent(const char* name, int id, float grade)\r\n{\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n\r\n    if (!newStudent)\r\n    {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n//      Insert Student\r\n//      Function to insert a new student record\r\n//      Inserts a new student record into the linked list.\r\nvoid insertStudent(const char* name, int id, float grade)\r\n{\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n//      Display Student\r\n//      Function to display all student records\r\n//      Displays all current student records in the linked list.\r\nvoid displayStudents()\r\n{\r\n    if (!head)\r\n    {\r\n        printf(\"No student records currently.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n\r\n    while (current)\r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n//      Search Student\r\n//      Function to search for a student by ID\r\n//      Searches for a student record by student ID and returns a pointer to the corresponding student node.\r\nStudent* searchStudentByID(int id)\r\n{\r\n    Student* current = head;\r\n\r\n    while (current)\r\n    {\r\n        if (current->id == id)\r\n        {\r\n            return current;\r\n        }\r\n\r\n        current = current->next;\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n//      Delete Student List\r\n//      Function to delete the entire list\r\n//      Deletes the entire linked list and frees the allocated memory.\r\nvoid deleteList()\r\n{\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current)\r\n    {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n\r\n    head = NULL;\r\n}\r\n\r\n//      Same as Delete Student List\r\n//      A utility function to ensure that all memory is freed when the program exits.\r\nvoid freeMemory()\r\n{\r\n    deleteList();\r\n}\r\n\r\n//      Sort Students\r\n//      Sort function to sort the student records by grade based on an algorithm of your choice\r\n//      Sort the student records by grade according to a sorting algorithm of your choice.\r\nvoid sortStudents()\r\n{\r\n    if (!head || !head->next)\r\n    {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current;\r\n    Student* next;\r\n    int swapped;\r\n\r\n    // Bubble Sort\r\n    do\r\n    {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next)\r\n        {\r\n            next = current->next;\r\n            if (current->grade > next->grade)\r\n            {\r\n                // Swap\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, current->name);\r\n                tempID = current->id;\r\n                tempGrade = current->grade;\r\n\r\n                strcpy(current->name, next->name);\r\n                current->id = next->id;\r\n                current->grade = next->grade;\r\n\r\n                strcpy(next->name, tempName);\r\n                next->id = tempID;\r\n                next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n\r\n            current = current->next;\r\n        }\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// MAIN PROGRAM ----------------------------------------------------------------------------------------------------------------------\r\n//      Main function to drive the program\r\nint main()\r\n{\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    // Main Menu Loop\r\n    do\r\n    {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();                                              // To consume the newline character (\\n)\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");                             // Remove trailing newline character (\\n)\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n\r\n                if (found)\r\n                {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. While this algorithm is easy to implement and understand, it has a time complexity of O(n?), making it inefficient for large datasets. Consider using a more efficient sorting algorithm, such as Merge Sort or Quick Sort, for better performance."
  },
  {
    "student_id": "20697931",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\r\n#define MAXROW 10\r\n#define MAXCOL 10\r\n\r\n\r\nvoid PrintMatrix(int row, int column,int matrix[row][column]){\r\n    \r\n    for (int i =0; i<row; i++){\r\n        for (int j=0; j<column;j++){\r\n    \r\n            printf(\"%d \",matrix[i][j]);\r\n        }\r\n        \r\n        printf(\"\\n\");\r\n    \r\n    }\r\n}\r\n\r\nint  Add_Matrices(int matrixA[10][10],int matrixB[10][10],int row,int column){\r\n        int sum=0;\r\n        int add_matrix[row][column];\r\n\r\n    \r\n        for (int i=0;i<row;i++){\r\n            for(int j=0;j<column;j++){\r\n                sum =matrixA[i][j] + matrixB[i][j];\r\n                add_matrix[i][j]=sum;\r\n            }\r\n        }\r\n        PrintMatrix(row, column,add_matrix);\r\n        \r\n    }\r\n    \r\nint  Sub_Matrices(int matrixA[10][10],int matrixB[10][10],int row,int column){\r\n        int sum=0;\r\n        int add_matrix[row][column];\r\n\r\n    \r\n        for (int i=0;i<row;i++){\r\n            for(int j=0;j<column;j++){\r\n                sum =matrixA[i][j] + matrixB[i][j];\r\n                add_matrix[i][j]=sum;\r\n            }\r\n        }\r\n        PrintMatrix(row, column,add_matrix);\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n\r\n\r\n\r\n\r\n\r\nvoid Transpose(int matrix[10][10],int row,int column){\r\n    int transpose_matrix[row][column] ;\r\n    for (int i =0; i< column;i++){\r\n        for (int j=0; j < row; j++){\r\n            transpose_matrix[j][i]=matrix[i][j];\r\n        }   \r\n    }\r\n    PrintMatrix(row, column,transpose_matrix);\r\n\r\n}\r\n\r\n\r\n\r\nvoid main(){\r\n    int rowA=0;\r\n    int columnA=0;\r\n    int rowB=0;\r\n    int columnB=0;\r\n    int matrixA[10][10]={0,0};\r\n    int matrixB[10][10]={0,0};\r\n    printf(\"\\nEnter dimensions for Matrix A(rows and columns):\");\r\n    scanf(\"%d %d\",&rowA,&columnA);\r\n\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i=0;i<rowA;i++){\r\n        for (int j=0;j<columnA;j++){\r\n            printf(\"Element [%d][%d]:\",i+1,j+1);\r\n            scanf(\"%d\",&matrixA[i][j]);\r\n        \r\n        }\r\n    }\r\n\r\n    printf(\"Enter dimensions for Matrix B(rows and columns):\");\r\n    scanf(\"%d %d\",&rowB,&columnB);\r\n\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i=0;i<rowB;i++){\r\n        for (int j=0;j<columnB;j++){\r\n            printf(\"Element [%d][%d]:\",i+1,j+1);\r\n            scanf(\"%d\",&matrixB[i][j]);\r\n        \r\n        }\r\n    }\r\n\r\n    int choice=0;\r\n\r\n    while(1){\r\n        printf(\"\\nMatrix Operations Menu:\");\r\n        printf(\"1.Add Matrices\\n\");\r\n        printf(\"2.Subtract Matrices\\n\");\r\n        printf(\"3.Transpose Matrix A\\n\");\r\n        printf(\"4.Transpose Matrix B\\n\");\r\n        printf(\"5.Exit\\n\");\r\n        printf(\"Enter your choice:\");\r\n        scanf(\"%d\",&choice);\r\n        \r\n        //validation\r\n        while(choice <1 || choice >5){\r\n            printf(\"\\nInvalid choice\");\r\n            printf(\"\\nEnter your choice:\");\r\n            scanf(\"%d\",&choice);\r\n        }\r\n\r\n        //exit\r\n        if (choice == 5){\r\n            break;\r\n        }\r\n\r\n        switch (choice)\r\n        {\r\n        //Addition\r\n        case 1:\r\n            printf(\"Result of Matrix A + Matrix B:\\n\");\r\n            if ((rowA == rowB) && (columnA == columnB)){\r\n                Sub_Matrices(matrixA,matrixB,rowA,columnA);\r\n                \r\n            }\r\n            else{\r\n                printf(\"\\nAddition cant be done\");\r\n\r\n            }\r\n            \r\n            \r\n            break;\r\n        //Subtraction\r\n        case 2:\r\n            printf(\"Result of Matrix A - Matrix B:\\n\");\r\n            if ((rowA == rowB) && (columnA == columnB)){\r\n                Sub_Matrices(matrixA,matrixB,rowA,columnA);\r\n        \r\n            }\r\n            else{\r\n                printf(\"\\nSubtraction cant be done\");\r\n\r\n            }\r\n            \r\n            \r\n            break;\r\n\r\n\r\n        //Transpose A\r\n        case 3:\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            Transpose(matrixA,rowA,columnA);\r\n            break;\r\n        \r\n        //Transpose B\r\n        case 4:\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            Transpose(matrixB,rowB,columnB);\r\n            break;\r\n        \r\n\r\n        \r\n        }\r\n\r\n    }\r\n    \r\n\r\n\r\n}\r\n\n/* --- q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n#define MAXSIZE 100\r\n\r\nstruct grocery_item{\r\n    char name[100];\r\n    char category[100];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\nstruct availability_status{\r\n    bool instock;\r\n};\r\n\r\nstruct grocery_inventory{\r\n    struct grocery_item items_array[1000];\r\n    struct availability_status available_array[100];\r\n    int total_items_num;\r\n};\r\n\r\n\r\n\r\n\r\nvoid Add_GroceryItem(struct grocery_inventory* groceryaddress){\r\n\r\n    if (groceryaddress->total_items_num == 1000){\r\n        printf(\"inventory is full\");\r\n        printf(\"Not successful\");\r\n    }\r\n    else{\r\n        int index=groceryaddress->total_items_num;\r\n       \r\n        \r\n        printf(\"Enter Item Name:\");\r\n        getchar();\r\n        \r\n        fgets(groceryaddress->items_array[index].name,sizeof(groceryaddress->items_array[index].name),stdin);\r\n        groceryaddress->items_array[index].name[strcspn(groceryaddress->items_array[index].name, \"\\n\")] = '\\0'; // Remove newline\r\n        \r\n        \r\n        printf(\"Enter Item category:\");\r\n        fgets(groceryaddress->items_array[index].category,sizeof(groceryaddress->items_array[index].category),stdin);\r\n        groceryaddress->items_array[index].category[strcspn(groceryaddress->items_array[index].category, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n        int item_quantity=0;\r\n        printf(\"Enter Quantity:\");\r\n        scanf(\"%d\",&item_quantity);\r\n        groceryaddress->items_array[index].quantity=item_quantity;\r\n        if( item_quantity ==0){\r\n            groceryaddress->available_array[index].instock=false;\r\n        }\r\n\r\n        \r\n\r\n        float item_price=0.0;\r\n        printf(\"Enter price:\");\r\n        scanf(\"%f\",&item_price);\r\n        groceryaddress->items_array[index].price=item_price;\r\n\r\n        groceryaddress->total_items_num++;\r\n\r\n        printf(\"Grocery item added succesfully\\n\");\r\n       \r\n    \r\n    }\r\n\r\n}\r\n\r\n\r\nvoid List_GroceryItems(struct grocery_inventory* groceryaddress){\r\n    for (int i=0;i<groceryaddress->total_items_num;i++){\r\n        printf(\"Name:%s\\n\",groceryaddress->items_array[i].name);\r\n        printf(\"Category:%s\\n\",groceryaddress->items_array[i].category);\r\n        printf(\"Quantity:%d\\n\",groceryaddress->items_array[i].quantity);\r\n        printf(\"Price:%.2f\\n\",groceryaddress->items_array[i].price);\r\n\r\n        \r\n        if (groceryaddress->available_array[i].instock == true){\r\n            printf(\"Status:In Stock\\n\");\r\n        }\r\n        else{\r\n            printf(\"Status:Out of Stock\\n\");\r\n    \r\n        }\r\n        \r\n\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nvoid Update_GroceryItem(struct grocery_inventory* groceryaddress,char item_name[100]){\r\n    int found=0;\r\n    for (int i=0; i < groceryaddress->total_items_num;i++){\r\n        if (strcmp(groceryaddress->items_array[i].name,item_name) == 0){\r\n            printf(\"Enter a new quantity:\");\r\n            scanf(\"%d\",&groceryaddress->items_array[i].quantity);\r\n            if(groceryaddress->items_array[i].quantity == 0){\r\n                groceryaddress->available_array[i].instock = false;\r\n            }\r\n            found=1;\r\n            printf(\"Updated successfully\\n\");\r\n            break;\r\n        }\r\n    }\r\n    if (found == 0){\r\n        printf(\"Grocery item not found\\n\");\r\n    }\r\n\r\n}\r\n\r\nvoid Remove_GroceryItem(struct grocery_inventory* groceryaddress,char item_name[100]){\r\n    int found=0;\r\n    for (int i=0; i < groceryaddress->total_items_num;i++){\r\n        if (strcmp(groceryaddress->items_array[i].name,item_name) == 0 ){\r\n            strcpy(groceryaddress->items_array[i].name,\"\");\r\n            strcpy(groceryaddress->items_array[i].category,\"\");\r\n            groceryaddress->items_array[i].quantity=0;\r\n            groceryaddress->items_array[i].price=0.0;\r\n            found=1;\r\n            groceryaddress->total_items_num --;\r\n            printf(\" Grocery item deleted successfully\\n\");\r\n\r\n            break;\r\n        }\r\n    }\r\n    if (found == 0){\r\n        printf(\"Grocery item not found\\n\");\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvoid main(){\r\n\r\n    struct grocery_inventory grocery;\r\n    struct grocery_inventory* groceryptr=&grocery;\r\n    \r\n    \r\n    grocery.total_items_num=0;\r\n\r\n    int choice=0;\r\n\r\n    while(1){\r\n        printf(\"Menu:\\n\");\r\n        printf(\"1.Add Grocery Item\\n\");\r\n        printf(\"2.List All Grocery Items\\n\");\r\n        printf(\"3.Update Quantity\\n\");\r\n        printf(\"4.Remove Grocery Item\\n\");\r\n        printf(\"5.Exit\\n\");\r\n        printf(\"Enter your choice:\");\r\n        scanf(\"%d\",&choice);\r\n        \r\n        //Validation\r\n        while(choice < 1|| choice >5){\r\n            printf(\"Invalid\");\r\n            printf(\"Enter your choice:\");\r\n            scanf(\"%d\",&choice);\r\n\r\n        }\r\n        \r\n        //Exit\r\n        if (choice == 5){\r\n            break;\r\n        }\r\n\r\n        switch (choice){\r\n\r\n        //Add the grocery item\r\n        case 1:\r\n           Add_GroceryItem(groceryptr);\r\n           break;\r\n        \r\n        //display \r\n        case 2:\r\n            List_GroceryItems(groceryptr);\r\n            break;\r\n        \r\n        //update\r\n        case 3:\r\n            char update_item[100];\r\n            printf(\"Enter the name of item to update:\");\r\n            getchar();\r\n            fgets(update_item,sizeof(update_item),stdin);\r\n            update_item[strcspn(update_item, \"\\n\")] = '\\0';\r\n            \r\n           \r\n            Update_GroceryItem(groceryptr,update_item);\r\n            break;\r\n\r\n        //delete\r\n        case 4:\r\n            char delete_item[100];\r\n             printf(\"Enter the name of item to delete:\");\r\n            getchar();\r\n            fgets(delete_item,sizeof(delete_item),stdin);\r\n            update_item[strcspn(delete_item, \"\\n\")] = '\\0';\r\n            \r\n            Remove_GroceryItem(groceryptr,delete_item);\r\n\r\n            break;\r\n        \r\n\r\n        \r\n        }\r\n\r\n    }\r\n    \r\n}\n/* --- q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    struct Student* student = (struct Student*)malloc(sizeof(struct Student));\r\n    if (student == NULL) {\r\n        printf(\"Memory allocation error\");\r\n        return NULL;\r\n    }\r\n    strcpy(student->name,name);\r\n    student->id= id;\r\n    student->grade=grade;\r\n    student->next=NULL;\r\n    return student;\r\n    \r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    struct Student* insert_student=createStudent(name,id,grade);\r\n    if (insert_student == NULL){\r\n        printf(\"Unsuccessful\");\r\n        return;\r\n\r\n    }\r\n    if (head == NULL){//if head is null then the new student is the head\r\n        head= insert_student;\r\n    }\r\n    else{              //traverse until end of the linked list to connect the new student\r\n        struct Student* current= head;\r\n        struct Student* previous= NULL;\r\n        while (current!= NULL){\r\n            previous=current;\r\n            current= current->next;\r\n        }\r\n        \r\n        (*previous).next=insert_student;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL){//if no students in linked list\r\n        printf(\"No students to display\");\r\n    }\r\n    else{\r\n        struct Student* current=head;\r\n        while( current != NULL){\r\n            printf(\"Name:%s, ID:%d , Grade:%.2f\\n\",current->name,current->id,current->grade);\r\n            current=current->next;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n     if (head == NULL){//if no students then nothing to display \r\n        printf(\"No students to display\");\r\n        return NULL;\r\n    }\r\n    else{\r\n        struct Student* current=head;\r\n        int found=0;\r\n        while( current != NULL && found==0){\r\n            if (current->id == id ){\r\n                found=1;\r\n                return current;\r\n            } \r\n            current=current->next;\r\n        }\r\n        printf(\"Not found\");\r\n        return NULL;\r\n\r\n    }\r\n\r\n    \r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n     if (head == NULL){\r\n        printf(\"No students to sort\\n\");\r\n     }\r\n    else{\r\n         \r\n    int swapped;  //flagged to check if swap occured\r\n    Student *current;\r\n\r\n    char temp_name[50];\r\n    int temp_id = 0;\r\n    float temp_grade = 0.0;\r\n\r\n  do {\r\n    swapped = 0;\r\n    current = head;\r\n\r\n    while (current->next != NULL) {\r\n        if (current->grade > current->next->grade) {\r\n            // Swap names using strcpy\r\n             \r\n            strcpy(temp_name, current->name);\r\n            strcpy(current->name, (current->next)->name);\r\n            strcpy((current->next)->name, temp_name);\r\n\r\n            // Swap IDs\r\n            temp_id = current->id;\r\n            current->id = (current->next)->id;\r\n            (current->next)->id = temp_id;\r\n\r\n            // Swap grades\r\n            temp_grade = current->grade;\r\n            current->grade = (current->next)->grade;\r\n            (current->next)->grade = temp_grade;\r\n\r\n            swapped = 1;\r\n        }\r\n        current = current->next;\r\n    }\r\n    \r\n} while (swapped);\r\n\r\n\r\n}\r\n       \r\n    \r\n    }\r\n    \r\n\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n\r\n                if (found != NULL ) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-The function signature for main should return an int, not void. It should be defined as int main().     The Sub_Matrices function is incorrectly performing addition instead of subtraction. It should be using the matrixA[i][j] - matrixB[i][j] operation.     The Add_Matrices and Sub_Matrices functions do not return a value, even though they are declared to return an int. You should change their return type to void if they are not meant to return anything.\n    The program lacks validation for matrix dimensions, which could lead to issues if the user inputs invalid dimensions (greater than 10 or non-positive values).\nq2-    In Add_GroceryItem, the check for inventory capacity uses total_items_num == 1000, but the inventory is defined with a maximum of 1000 items. The message should reflect that the inventory is full.\n    In Remove_GroceryItem, the method of removing an item by clearing its fields does not correctly shift the remaining items in the array. As a result, the last item will not be removed from the inventory effectively.\nq3-In the insertStudent function, if the linked list is empty, the new student should be added as the head. However, if the list is not empty, the insertion logic does not correctly handle the case where the list is traversed but no addition happens at the end. Although it doesn't cause a crash, it may lead to incorrect behavior if there is an attempt to insert a duplicate ID."
  },
  {
    "student_id": "20712314",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <ctype.h>\r\n\r\n//Import libraries and write up function prototypes\r\n\r\nvoid Print(int rows,int columns,int dimensions[rows][columns]);\r\nvoid Addition(int rowsA,int columnsA,int rowsB,int columnsB,int dimensionsA[rowsA][columnsA],int dimensionsB[rowsB][columnsB]);\r\nvoid Subtraction(int rowsA,int columnsA,int rowsB,int columnsB,int dimensionsA[rowsA][columnsA],int dimensionsB[rowsB][columnsB]);\r\nvoid Transpose(int rows,int columns,int dimensions[rows][columns],int choice);\r\nvoid Operations(int choice,int rowsA,int columnsA,int rowsB,int columnsB,int dimensionsA[rowsA][columnsA],int dimensionsB[rowsB][columnsB]);\r\n\r\n//Only one function is needed since all the functions are nested in one another\r\n\r\nint main(){\r\n\r\n    int rowsA,columnsA,rowsB,columnsB,choice;                          //Declaring variables\r\n    do{                                                               //Repeating the matrix dimension defining process until the input is valid(non zero rows or columns)\r\n        printf(\"\\nEnter dimensions for Matrix A(rows and columns):\");\r\n        scanf(\"%d %d\",&rowsA,&columnsA);                              \r\n        while(getchar()!='\\n');                                       //Clearing buffer in case user enters  non-digit values\r\n        if(rowsA<1||columnsA<1||rowsA>10||columnsA>10){               //Letting user know the limitation\r\n            printf(\"\\nThe range is from 1 till 10(maximum 10 x 10)\\n\");\r\n        }\r\n    }while(rowsA<1||columnsA<1||rowsA>10||columnsA>10);\r\n    int dimensionsA[rowsA][columnsA];                                 //Once the input is valid,create a array big enough to place the matrix\r\n    printf(\"\\nEnter elements for Matrix A:\\n\");                       //Receiving matrix entries\r\n        for(int i=0;i<rowsA;i++){\r\n            for(int j=0;j<columnsA;j++){\r\n                printf(\"\\nElement[%d][%d]:\",i+1,j+1);\r\n                scanf(\"%d\",&dimensionsA[i][j]);   \r\n            }\r\n        }\r\n        \r\n    do{                                                                //Same process as matrix A for matrix B\r\n        printf(\"\\nEnter dimensions for Matrix B(rows and columns):\");\r\n        scanf(\"%d %d\",&rowsB,&columnsB);\r\n        while(getchar()!='\\n');\r\n        if(rowsB<1||columnsB<1||rowsB>10||columnsB>10){\r\n            printf(\"\\nThe range is from 1 till 10(maximum 10 x 10)\\n\");\r\n        }\r\n    }while(rowsB<1||columnsB<1||rowsB>10||columnsB>10);\r\n    int dimensionsB[rowsB][columnsB];\r\n    printf(\"\\nEnter elements for Matrix B:\\n\");\r\n    for(int x=0;x<rowsB;x++){\r\n        for(int y=0;y<columnsB;y++){\r\n            printf(\"\\nElement[%d][%d]:\",x+1,y+1);\r\n            scanf(\"%d\",&dimensionsB[x][y]);     \r\n        }\r\n    }   \r\n\r\n    Operations(choice,rowsA,columnsA,rowsB,columnsB,dimensionsA,dimensionsB); //Placing the Operations function inside the Matrix function\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n//Defining functions\r\n\r\n    \r\n\r\nvoid Print(int rows,int columns,int dimensions[rows][columns]){               //A printing function for matrices so the matrix can look as proper as how we would handwrite it\r\n    for(int z=0;z<rows;z++){\r\n        for(int k=0;k<columns;k++){\r\n            printf(\"%d\\t\",dimensions[z][k]);                                   //Putting a horizontal tab between entries so they can have enough space between each other\r\n        }\r\n        printf(\"\\n\");                                                          //So the rows can be seperated properly\r\n    }\r\n}\r\n\r\nvoid Addition(int rowsA,int columnsA,int rowsB,int columnsB,int dimensionsA[rowsA][columnsA],int dimensionsB[rowsB][columnsB]){     //Addition function\r\n    int rowsC=rowsA;                                                    //Declaring a local array big enough to hold the result of addition\r\n    int columnsC=columnsA;\r\n    int dimensionsC[rowsC][columnsC];\r\n    for(int z=0;z<rowsB;z++){               \r\n        for(int k=0;k<columnsB;k++){\r\n            dimensionsC[z][k]=dimensionsA[z][k]+dimensionsB[z][k];      //Performing addition between entries then placing the values in the \"result\" matrix\r\n        }\r\n    }\r\n    printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n    Print(rowsC,columnsC,dimensionsC);                                  //Printing the answer using the matrix printing function\r\n}\r\n\r\nvoid Subtraction(int rowsA,int columnsA,int rowsB,int columnsB,int dimensionsA[rowsA][columnsA],int dimensionsB[rowsB][columnsB]){      //Subtraction function\r\n    int rowsC=rowsA;                                                    //Declaring a local array big enough to hold the result of subtraction\r\n    int columnsC=columnsA;\r\n    int dimensionsC[rowsC][columnsC];\r\n    for(int z=0;z<rowsB;z++){\r\n        for(int k=0;k<columnsB;k++){\r\n            dimensionsC[z][k]=dimensionsA[z][k]-dimensionsB[z][k];      //Performing subtraction between entries then placing the values in the \"result\" matrix\r\n        }\r\n    }\r\n    printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n    Print(rowsC,columnsC,dimensionsC);                                   //Printing the answer using the matrix printing function\r\n}\r\n\r\nvoid Transpose(int rows,int columns,int dimensions[rows][columns],int choice){        //Transpose function\r\n    int rowsC=columns;                              //Declaring a local array big enough to hold the result of the Transposed matrix\r\n    int columnsC=rows;\r\n    int dimensionsC[rowsC][columnsC];               //The transposed matrix will have the row size of the original matrix's column size,and a column size of the ori's row size\r\n    for(int z=0;z<rowsC;z++){\r\n        for(int k=0;k<columnsC;k++){\r\n            dimensionsC[z][k]=dimensions[k][z];     //Eg: The entry on the third row second column of the original matrix will become the entry on the second row third column of the \"result\" matrix\r\n        }\r\n    }\r\n    if(choice==3){                                  //There are only two possible values of choices,when the value of choice is 3,it's meant for transpose of A,when it's 4(in this case \"not 3\"),it's for transpose of B\r\n        printf(\"\\nTranspose of Matrix A:\\n\");\r\n        Print(rowsC,columnsC,dimensionsC);\r\n    }\r\n        else{\r\n            printf(\"\\nTranspose of Matrix B:\\n\");\r\n            Print(rowsC,columnsC,dimensionsC);\r\n        }\r\n    \r\n}\r\n\r\nvoid Operations(int choice,int rowsA,int columnsA,int rowsB,int columnsB,int dimensionsA[rowsA][columnsA],int dimensionsB[rowsB][columnsB]){    //The function for the collective available operations on matrices\r\n    while(choice!=5){                                                                               //While the user doesn't choose to exit the menu,we will keep repeating the pop up for the operations menu\r\n    printf(\"\\n\\nMatrix Operations Menu:\\n\");                                                        //Printing the operations menu \r\n    printf(\"1.Add Matrices\\n\");\r\n    printf(\"2.Subtract Matrices\\n\");\r\n    printf(\"3.Transpose Matrix A\\n\");\r\n    printf(\"4.Transpose Matrix B\\n\");\r\n    printf(\"5.Exit\\n\");\r\n    printf(\"Enter your choice:\");\r\n    scanf(\"%d\",&choice);                                                                             //Receiving the value for the user's choice\r\n    if((choice==1 || choice==2) && (rowsA!=rowsB || columnsA!=columnsB)){                            //To validate whether the two matrices are available for addition or subtraction if the user chooses one of these two options\r\n        printf(\"\\nMatrices must be of same size in order to perform addition or subtraction\");\r\n        continue;                                                                                    //To ensure that the operations menu will still pop up after this message,i cannot just \"stop\" the while loop\r\n    }\r\n            else{\r\n                switch (choice){                                                                     //Using the appropriate functions depending on the user's choice of operation\r\n                    case 1:                                                                           \r\n                        Addition(rowsA,columnsA,rowsB,columnsB,dimensionsA,dimensionsB);             //Entering the necessary parameters for the addition function\r\n                        break;                                                                       //Breaking after each case so the program won't perform matrix operations the user didn't choose\r\n                    case 2:\r\n                        Subtraction(rowsA,columnsA,rowsB,columnsB,dimensionsA,dimensionsB);          //Entering the necessary parameters for the subtraction function\r\n                        break;\r\n                    case 3:\r\n                        Transpose(rowsA,columnsA,dimensionsA,choice);                                //Entering the necessary parameters of matrix  A for the transpose function\r\n                        break;     \r\n                    case 4:\r\n                        Transpose(rowsB,columnsB,dimensionsB,choice);                                //Entering the necessary parameters of matrix  B for the transpose function\r\n                        break;\r\n                    case 5:\r\n                        printf(\"\\nExiting...\\n\");\r\n                        return;\r\n                    default:\r\n                        printf(\"\\nYou have not entered a valid choice\\n\");                             //The case where the user has entered a choice that's not one of the 5 available ones                \r\n                        break;\r\n                }\r\n            }\r\n    }\r\n}\r\n    \n/* --- Q2.c --- */\n//Import libraries \r\n#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n\r\n\r\n\r\nint i=0;                                                //Declaring global variable to for the indexing of struct variables(eg:if i is 5,it means there are 5 grocery items in the list,from index 0 till 4)\r\n\r\ntypedef struct Groceries                                //Creating struct for storing data\r\n{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n}groceries;\r\n\r\ntypedef union  Grocery_verification                     //Creating union for some verification and copying purposes later\r\n{\r\n    char Name[100];\r\n}verification;\r\n\r\n//Write up function prototypes\r\nvoid Add(verification verify,groceries grocery[]);\r\nvoid List(groceries grocery[]);\r\nvoid Update(verification verify,groceries grocery[]);\r\nvoid Remove(verification verify,groceries grocery[]);\r\nint Availability();\r\n\r\n\r\n\r\nint main(){\r\n\r\n    //Initializing variables\r\n    verification verify;\r\n    groceries grocery[100];\r\n    int choice=0;\r\n\r\n    while(choice!=5){                                       //Repeating the pop up of the management system until the user chooses to exit\r\n        printf(\"\\nGrocery Inventory Management System\");    //Menu\r\n        printf(\"\\n1.Add Grocery Item\");\r\n        printf(\"\\n2.List All Grocery Items\");\r\n        printf(\"\\n3.Update Quantity\");\r\n        printf(\"\\n4.Remove Grocery Item\");\r\n        printf(\"\\n5.Exit\");\r\n        printf(\"\\nEnter your choice:\");\r\n        scanf(\"%d\",&choice);                                \r\n        while (getchar() != '\\n');                             //Clearing up buffer in case it stores the new line character\r\n        switch(choice){\r\n            case 1:\r\n                Add(verify,grocery);                           //Entering the necessary parameters for the Add function\r\n                break;\r\n        \r\n            case 2:\r\n                List(grocery);                                  //Entering the necessary parameters for the list function\r\n                break;\r\n\r\n            case 3:\r\n                Update(verify,grocery);                         //Entering the necessary parameters for the update function\r\n                break;\r\n\r\n            case 4:\r\n                Remove(verify,grocery);                         //Entering the necessary parameters for the remove function\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"\\nExiting...\");                         \r\n                return 0;\r\n\r\n            default:\r\n                printf(\"\\nYou have not entered a valid choice\");  //When user chooses some choice that's not listed\r\n                break;   \r\n        }\r\n    }\r\n    \r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\nvoid Add(verification verify,groceries grocery[]){\r\n    int u=i;                                                //Declaring local variable for indexing in later steps of this function\r\n    if(i<100){                                              //index 99 is the 100th item,hence i<100\r\n        printf(\"\\nEnter Item Name:\");\r\n        fgets(verify.Name,100,stdin);                       //Store user input in union variable so we can make verification later\r\n        verify.Name[strcspn(verify.Name, \"\\n\")] = '\\0';     //Remove new line character and replace with NULL character\r\n        for(int j=0;j<i;j++){                               //Loop until every existing struct variable has been looped through\r\n            if(strcmp(grocery[j].name,verify.Name)==0){     //When the user's input is something that already exists in the grocery list,we just inform and stop the function there\r\n                printf(\"\\nItem is already in list!\");\r\n                return;                                       \r\n            }\r\n        }\r\n    //Copying the user's input just now to the respective struct variable and getting new inputs for the item's related info,since the latest index is i-1,by making u=i,we can ensure that we're expanding the list\r\n        strcpy(grocery[u].name,verify.Name);\r\n        printf(\"\\nEnter Category:\");\r\n        fgets(grocery[u].category,50,stdin);\r\n        grocery[u].category[strcspn(grocery[u].category,\"\\n\")]=0;\r\n        printf(\"\\nEnter Quantity:\");\r\n        scanf(\"%d\",&grocery[i].quantity);\r\n        while (getchar() != '\\n');\r\n        printf(\"\\nEnter Price:\");\r\n        scanf(\"%f\",&grocery[i].price);\r\n        while (getchar() != '\\n');\r\n        printf(\"\\nGrocery item added successfully!\\n\");\r\n        i++;                                                            //When we add an item,the global variable should be updated so when we wanna access the struct later,we can use the newest index count \r\n        return;\r\n    }\r\n        else{\r\n            printf(\"Item list has reached max capacity\");           //Because the max capacity for grocery item entries is 100\r\n            return;\r\n        }\r\n}\r\n\r\nvoid List(groceries grocery[]){\r\n    if(i==0){                                                   //When the global variable for indexing has the value of 0,it means there are no items in the list\r\n        printf(\"No grocery items in the inventory.\");\r\n    }\r\n        else{\r\n            for(int z=0;z<i;z++){                               //Looping through every single variable from index 0 till the last one available so nothing is missed in the list\r\n                printf(\"\\nName:%s\",grocery[z].name);\r\n                printf(\"\\nCategory:%s\",grocery[z].category);\r\n                printf(\"\\nQuantity:%d\",grocery[z].quantity);\r\n                printf(\"\\nPrice:$%.2f\",grocery[z].price);\r\n                Availability(grocery[z].name,grocery);          //Calling the availability function \r\n            }\r\n        }\r\n}\r\n\r\nvoid Update(verification verify,groceries grocery[]){                   \r\n    printf(\"\\nEnter name of the grocery item to update quantity:\");\r\n    fgets(verify.Name,100,stdin);                                       //Receives user input\r\n    verify.Name[strcspn(verify.Name, \"\\n\")] = '\\0';\r\n    for(int y=0;y<i;y++){                                               //For loop to find the respective struct variable that matches the user's input\r\n        if (strcmp(grocery[y].name,verify.Name)==0){                    //Only allow updating when there exists a string that matches the user's input\r\n            printf(\"\\nEnter new quantity for %s:\",grocery[y].name);\r\n            scanf(\"%d\",&grocery[y].quantity);                           //Receiving input for updating then stroring it in the quantity variable of the match case(eg: if grocery2.name is a match,we'll change for grocery2.quantity)\r\n            while (getchar() != '\\n');\r\n            printf(\"\\nQuantity updated successfully!\\n\");\r\n        }\r\n            else{\r\n                printf(\"\\nNo such item in inventory\\n\");                //When there isn't an item on the list that matches the user's input\r\n            }\r\n    }\r\n}\r\n\r\nvoid Remove(verification verify,groceries grocery[]){\r\n    printf(\"\\nEnter name of the grocery item to remove:\");\r\n    fgets(verify.Name,100,stdin);                                               //Receiving user's input for items to remove\r\n    verify.Name[strcspn(verify.Name, \"\\n\")] = '\\0';\r\n    for(int w=0;w<i;w++){                                                       //For loop to find the struct name variable(grocery item) that matches the user's input\r\n        if(strcmp(grocery[w].name,verify.Name)==0){\r\n            for(int l=w;l<i-1;l++){\r\n                grocery[l]=grocery[l+1];                                        //Assigning the values of the item to the one the match case,essentially removing the match case's value\r\n            }\r\n            i--;                                                                //The global variable for indexing the grocery list should decrease in size when one of it's items is removed\r\n            printf(\"\\nGrocery item %s removed successfully!\\n\",verify.Name);\r\n        }\r\n            else{\r\n                printf(\"\\nNo such item in inventory.\\n\");                       //When nothing in the list matches the user's input\r\n            }\r\n    }\r\n}\r\n\r\nint Availability(char target[],groceries grocery[]){        //Target is the item that we wish to check for it's availability\r\n    for(int o=0;o<i;o++){                                   //Looping through the list to find the item that is to be checked for\r\n        if (strcmp(grocery[o].name,target)==0){             //Case where we find the item in the list\r\n            if(grocery[o].quantity<1){                      //When quantity<1,it means there's no stock or there's stock loss,both result in the out of stock status\r\n                printf(\"\\nOut of Stock\\n\");\r\n                return 1;                                   //Stop function if we already generated a result\r\n            }\r\n                else {\r\n                    printf(\"\\nIn Stock\\n\");                 //When quantity>=1,it means we have stock\r\n                    return 0;                               //Stop function if we already generated a result\r\n                }\r\n        }\r\n    }\r\n    printf(\"\\nNo such item in inventory.\\n\");               //Not really necessary when this function is only called in this program when we already know the \"target\" variable is something existing in the list,but in case we need to use it for items that aren't next time,we put this else statement\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function prototypes\r\n\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\nvoid sortStudents();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove trailing newline\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* temp = head;\r\n    if (temp == NULL) {\r\n        printf(\"No student records to display\\n\");\r\n        return;\r\n    }\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student *ptr1;\r\n    Student *lptr = NULL;\r\n\r\n    // Bubble Sort implementation\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the grades\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                // Swap the ids\r\n                int tempId = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempId;\r\n\r\n                // Swap the names\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n}\r\n",
    "feedback": "q1-The addition and subtraction functions use dimensionsB for looping instead of dimensionsA for the result matrix. This can lead to incorrect results if the dimensions of the two matrices differ.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is correctly implemented and sorts the student records by grade in ascending order. While Bubble Sort is easy to understand and implement, it has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20701305",
    "code": "",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. However, it has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort for better performance."
  },
  {
    "student_id": "20619091",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX 10 // Max size for matrices (10x10)\r\n\r\n// Function to let the user fill in a matrix\r\nvoid userMatrixInput(int rows, int columns, int matrice[MAX][MAX], char name) {\r\n    printf(\"Fill in the MAtrix PLease %c (%dx%d):\\n\", name, rows, columns);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"Enter value for [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrice[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print out a matrix\r\nvoid displayMatrix(int rows, int columns, int matrice[MAX][MAX]) {\r\n    printf(\"Here is the matrix:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"%d \", matrice[i][j]); // Print each value\r\n        }\r\n        printf(\"\\n\"); // Move to the next row\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid additionOfMatrices(int rows, int columns, int MatrixA[MAX][MAX], int MatrixB[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = MatrixA[i][j] + MatrixB[i][j]; // Add corresponding values\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract Matrix B from Matrix A\r\nvoid minusOfMatrices(int rows, int columns, int MatrixA[MAX][MAX], int MatrixB[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = MatrixA[i][j] - MatrixB[i][j]; // Subtract corresponding values\r\n        }\r\n    }\r\n}\r\n\r\n// Function to calculate the transpose of a matrix\r\nvoid transposeMatrix(int rows, int columns, int matrix[MAX][MAX], int transpose[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            transpose[j][i] = matrix[i][j]; // Flip rows and columns\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int MatrixA[MAX][MAX], MatrixB[MAX][MAX], result[MAX][MAX]; // The two input matrices and the result matrix\r\n    int row1, column1, row2, column2; // Sizes for both matrices\r\n    int choice; // What the user wants to do\r\n\r\n    // Ask the user for the size of Matrix A\r\n    printf(\"Enter the number of rows for Matrix A: \");\r\n    scanf(\"%d\", &row1);\r\n    printf(\"Enter the number of columns for Matrix A: \");\r\n    scanf(\"%d\", &column1);\r\n\r\n    // Ask the user for the size of Matrix B\r\n    printf(\"Enter the number of rows for Matrix B: \");\r\n    scanf(\"%d\", &row2);\r\n    printf(\"Enter the number of columns for Matrix B: \");\r\n    scanf(\"%d\", &column2);\r\n\r\n    // Make sure the sizes are valid (not too big or small)\r\n    if (row1 <= 0 || row1 > MAX || column1 <= 0 || column1 > MAX ||\r\n        row2 <= 0 || row2 > MAX || column2 <= 0 || column2 > MAX) {\r\n        printf(\"Oops! Matrix size must be between 1 and %d.\\n\", MAX);\r\n        return 1; // Stop the program if sizes are invalid\r\n    }\r\n\r\n    // Get the values for both matrices\r\n    userMatrixInput(row1, column1, MatrixA, 'A');\r\n    userMatrixInput(row2, column2, MatrixB, 'B');\r\n\r\n    // Show the menu\r\n    do {\r\n        printf(\"\\nWhat do you want to do?\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: // Add matrices\r\n                if (row1 == row2 && column1 == column2) {\r\n                    additionOfMatrices(row1, column1, MatrixA, MatrixB, result);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    displayMatrix(row1, column1, result);\r\n                } else {\r\n                    printf(\"Can't add matrices with different sizes.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2: // Subtract matrices\r\n                if (row1 == row2 && column1 == column2) {\r\n                    minusOfMatrices(row1, column1, MatrixA, MatrixB, result);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    displayMatrix(row1, column1, result);\r\n                } else {\r\n                    printf(\"Can't subtract matrices with different sizes.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3: // Transpose Matrix A\r\n                transposeMatrix(row1, column1, MatrixA, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(column1, row1, result);\r\n                break;\r\n\r\n            case 4: // Transpose Matrix B\r\n                transposeMatrix(row2, column2, MatrixB, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(column2, row2, result);\r\n                break;\r\n\r\n            case 5: // Exit the program\r\n                printf(\"Thanks for using the program! Bye!!\\n\");\r\n                break;\r\n\r\n            default: // If the user enters something invalid\r\n                printf(\"Invalid choice! Please pick a valid option.\\n\");\r\n        }\r\n    } while (choice != 5); // Keep showing the menu until the user wants to exit\r\n\r\n    return 0; // End the program\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Max sizes to avoid overflowing the memory\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n#define MAX_INVENTORY_SIZE 100\r\n\r\n// A structure to represent a grocery item\r\nstruct GroceryItem {\r\n    char name[MAX_NAME_LENGTH];      // Name of the item (like \"Apple\")\r\n    char category[MAX_CATEGORY_LENGTH];  // Category of the item (like \"Fruit\")\r\n    int quantity;                    // How many items are in stock\r\n    float price;                     // Price of one item\r\n};\r\n\r\n// Enum to represent if an item is in stock or out of stock\r\nenum AvailabilityAmount { IN_STOCK, OUT_OF_STOCK };\r\n\r\n// A structure to represent the inventory of all grocery items\r\nstruct GroceryInventory {\r\n    struct GroceryItem items[MAX_INVENTORY_SIZE];  // List of grocery items\r\n    enum AvailabilityAmount availability[MAX_INVENTORY_SIZE];  // Available amount of each item\r\n    int itemCount;  // The current number of items in the inventory\r\n};\r\n\r\n// Function prototypes (these are like \"shortcuts\" for the functions that come later)\r\nvoid addGroceryItem(struct GroceryInventory *inventory);\r\nvoid listGroceryItems(struct GroceryInventory *inventory);\r\nvoid updateQuantity(struct GroceryInventory *inventory);\r\nvoid removeGroceryItem(struct GroceryInventory *inventory);\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    struct GroceryInventory inventory = {{}, {}, 0};  // Start with an empty inventory\r\n    int choice;\r\n\r\n    // Keep showing the menu until the user decides to exit\r\n    while (1) {\r\n        displayMenu();  // Display options\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);  // Get user's choice\r\n\r\n        // Perform the action based on the user's choice\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);  // Add a new item\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);  // Show all items\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);  // Update quantity of an item\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);  // Remove an item\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n                return 0;  // Exit the program\r\n            default:\r\n                printf(\"Invalid choice! Try again.\\n\");  // Invalid option\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n// Display the menu with options\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Add a new grocery item to the inventory\r\nvoid addGroceryItem(struct GroceryInventory *inventory) {\r\n    // Check if there's space for new items\r\n    if (inventory->itemCount >= MAX_INVENTORY_SIZE) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    struct GroceryItem newItem;\r\n\r\n    // Get the item's name\r\n    printf(\"Enter the name of the grocery item: \");\r\n    getchar();  // Clear the leftover newline\r\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0;  // Remove the newline character at the end\r\n\r\n    // Get the item's category\r\n    printf(\"Enter the category of the grocery item: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0;  // Remove newline\r\n\r\n    // Get the item's quantity\r\n    printf(\"Enter the quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    // Get the item's price\r\n    printf(\"Enter the price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Set the item's availability (In stock if quantity > 0)\r\n    enum AvailabilityAmount Amount = (newItem.quantity > 0) ? IN_STOCK : OUT_OF_STOCK;\r\n\r\n    // Add the new item to the inventory\r\n    inventory->items[inventory->itemCount] = newItem;\r\n    inventory->availability[inventory->itemCount] = Amount;\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// List all items in the inventory\r\nvoid listGroceryItems(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Inventory:\\n\");\r\n    // Go through each item and print its details\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        struct GroceryItem item = inventory->items[i];\r\n        enum AvailabilityAmount Amount = inventory->availability[i];\r\n        printf(\"Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\", (Amount == IN_STOCK) ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"--------------------------\\n\");\r\n    }\r\n}\r\n\r\n// Update the quantity of an existing item\r\nvoid updateQuantity(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items in the inventory to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to update quentity: \");\r\n    getchar();  // Clear the newline\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  // Remove the newline\r\n\r\n    // Search for the item in the inventory\r\n    int found = 0;\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            found = 1;\r\n            printf(\"Enter the new quantity for %s: \", itemName);\r\n            int newQuantity;\r\n            scanf(\"%d\", &newQuantity);\r\n            inventory->items[i].quantity = newQuantity;\r\n            inventory->availability[i] = (newQuantity > 0) ? IN_STOCK : OUT_OF_STOCK;\r\n            printf(\"Quantity updated successfully!!\\n\");\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found in inventory.\\n\");\r\n    }\r\n}\r\n\r\n// Remove an item from the inventory\r\nvoid removeGroceryItem(struct GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No items to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[MAX_NAME_LENGTH];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar();  // Clear the newline\r\n    fgets(itemName, MAX_NAME_LENGTH, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = 0;  // Remove newline\r\n\r\n    // Search for the item and remove it\r\n    int found = 0;\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            found = 1;\r\n            // Shift the items to remove the one at index i\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Item '%s' has been removed succefully!.\\n\", itemName);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"No item.\\n\");\r\n    }\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Struct to hold student info\r\ntypedef struct Student {\r\n    char name[100];  // Student's name\r\n    int id;          // Student's ID\r\n    float grade;     // Student's grade\r\n    struct Student* next;  // Pointer to the next student in the list\r\n} Student;\r\n\r\n// The start of our list (points to the first student)\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student (adding a new record)\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Create memory space for a new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"memory allocation failed.\\n\");\r\n        return NULL;  // Return NULL if we couldn't create a student\r\n    }\r\n\r\n    // Copy the student's details into the new record\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;  // No next student for now\r\n\r\n    return newStudent;  // Send back the new student\r\n}\r\n\r\n// Function to add a new student to the end of the list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create the new student\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) {\r\n        return;  // If something went wrong, just return\r\n    }\r\n\r\n    // If the list is empty, make this the first student\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        // Traverse to the end of the list and add the new student there\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;  // Link the new student to the last one\r\n    }\r\n}\r\n\r\n// Function to print out all the students in the list\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records yet.\\n\");\r\n        return;  // If the list is empty, just show a message and return\r\n    }\r\n\r\n    // Go through each student in the list and print their details\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;  // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by their ID\r\nStudent* searchStudentByID(int id) {\r\n    // Look through the list for a student with the given ID\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;  // Found the student, return their info\r\n        }\r\n        temp = temp->next;  // Move to the next student\r\n    }\r\n    return NULL;  // No student found with that ID\r\n}\r\n\r\n// Function to delete all students and clear the list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    // Go through the list and free each student one by one\r\n    while (current != NULL) {\r\n        next = current->next;  // Save the next student\r\n        free(current);  // Free the current student from memory\r\n        current = next;  // Move to the next student\r\n    }\r\n    head = NULL;  // The list is now empty, so set head to NULL\r\n}\r\n\r\n// Sort the students by grade (bubble sort because its easier)\r\nvoid sortStudents() {\r\n    // If there's no student or just one, no need to sort\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* temp;\r\n    do {\r\n        swapped = 0;  // Start with no swaps\r\n        temp = head;\r\n\r\n        // Go through the list and swap students if their grades are out of order\r\n        while (temp != NULL && temp->next != NULL) {\r\n            if (temp->grade > temp->next->grade) {\r\n                // Swap their data (name, id, and grade)\r\n                float tempGrade = temp->grade;\r\n                int tempID = temp->id;\r\n                char tempName[100];\r\n                strcpy(tempName, temp->name);\r\n\r\n                // Swap the students\r\n                temp->grade = temp->next->grade;\r\n                temp->id = temp->next->id;\r\n                strcpy(temp->name, temp->next->name);\r\n\r\n                temp->next->grade = tempGrade;\r\n                temp->next->id = tempID;\r\n                strcpy(temp->next->name, tempName);\r\n\r\n                swapped = 1;  // Mark that we made a swap\r\n            }\r\n            temp = temp->next;  // Move to the next student\r\n        }\r\n    } while (swapped);  // Keep sorting until no more swaps are needed\r\n}\r\n\r\n// Function to clean up memory when we're done\r\nvoid freeMemory() {\r\n    deleteList();  // Delete all student records\r\n}\r\n\r\n// Main function\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Show the menu options\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Students REcords\\n\");\r\n        printf(\"3. Sort Students Record\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // This gets rid of the newline character left by scanf\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Add a new student\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);  // Get the name from the user\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);  // Add the student to the list\r\n                break;\r\n\r\n            case 2:\r\n                // Show all students\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                // Sort students by Record\r\n                sortStudents();\r\n                printf(\"Students sorted by grade using Bubble sort.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n                // Search for a student by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                // Delete all student records\r\n                deleteList();\r\n                printf(\"All records deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                // Exit the program\r\n                freeMemory();\r\n                printf(\"Goodbye!\\n\");\r\n                break;\r\n\r\n            default:\r\n                // If the user enters an invalid option\r\n                printf(\"Oops! That's not a valid choice. Try again.\\n\");\r\n        }\r\n    } while (choice != 6);  // Keep running the menu until the user chooses to exit\r\n\r\n    return 0;  // All done, exit the program\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-While Bubble Sort is simple and works for small datasets, it has a time complexity of O(n?), making it inefficient for larger lists. If performance is a concern, more efficient algorithms (like Quick Sort or Merge Sort) could be considered for future implementations."
  },
  {
    "student_id": "20722250",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// function prototypes\r\nvoid inputMtx(int matrix[MAX_SIZE][MAX_SIZE], char name, int *rows, int *cols);\r\nvoid addMtx(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMtx(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMtx(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid displayMtx(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid displayMenu();\r\n\r\nint main() \r\n{\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA;\r\n    int rowsB, colsB;\r\n    int choice;\r\n\r\n    // input dimensions and elements for matrices A and B\r\n    inputMtx(matrixA, 'A', &rowsA, &colsA);\r\n    inputMtx(matrixB, 'B', &rowsB, &colsB);\r\n\r\n    // display menu and execute the selected operation\r\n    do \r\n    {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // consume newline character\r\n\r\n        switch (choice) \r\n        {\r\n            case 1: // add matrices A and B\r\n                if (rowsA == rowsB && colsA == colsB) \r\n                {\r\n                    addMtx(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMtx(result, rowsA, colsA);\r\n                } \r\n                else \r\n                {\r\n                    printf(\"Error: Matrices must have the same dimensions to perform addition.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2: // subtract matrices A and B\r\n                if (rowsA == rowsB && colsA == colsB) \r\n                {\r\n                    subtractMtx(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMtx(result, rowsA, colsA);\r\n                } \r\n                else \r\n                {\r\n                    printf(\"Error: Matrices must have the same dimensions to perform subtraction.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3: // transpose matrix A\r\n                transposeMtx(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMtx(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4: // transpose matrix B\r\n                transposeMtx(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMtx(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5: // exit\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// function to get matrix dimensions and elements from user input\r\nvoid inputMtx(int matrix[MAX_SIZE][MAX_SIZE], char name, int *rows, int *cols) \r\n{\r\n    // input dimensions\r\n    do \r\n    {\r\n        printf(\"Enter dimensions for Matrix %c (rows and columns): \", name);\r\n        scanf(\"%d %d\", rows, cols);\r\n        \r\n        if (*rows <= 0 || *rows > MAX_SIZE || *cols <= 0 || *cols > MAX_SIZE) \r\n        {\r\n            printf(\"Invalid dimensions. Please enter dimensions between 1 and 10.\\n\\n\");\r\n        }\r\n    } while (*rows <= 0 || *rows > MAX_SIZE || *cols <= 0 || *cols > MAX_SIZE);\r\n\r\n    // input elements\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < *rows; i++) \r\n    {\r\n        for (int j = 0; j < *cols; j++) \r\n        {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// function to add two matrices\r\nvoid addMtx(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to subtract two matrices\r\nvoid subtractMtx(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to transpose a matrix\r\nvoid transposeMtx(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// function to display matrix\r\nvoid displayMtx(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// function to display menu\r\nvoid displayMenu() \r\n{\r\n    printf(\"\\nMatrix Operations Menu\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include <ctype.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus statuses[MAX_ITEMS];\r\n    int totalItems;\r\n} GroceryInventory;\r\n\r\n// function prototypes\r\nvoid addItem(GroceryInventory *inventory);\r\nvoid listItems(const GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeItem(GroceryInventory *inventory);\r\nvoid displayMenu();\r\nvoid capitaliseStr(char *str);\r\n\r\nint main() \r\n{\r\n    int choice;\r\n    GroceryInventory inventory = {.totalItems = 0};\r\n\r\n    do \r\n    {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // consume newline character\r\n\r\n        switch (choice) \r\n        {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// function to add a grocery item to the inventory\r\nvoid addItem(GroceryInventory *inventory) \r\n{\r\n    if (inventory->totalItems >= MAX_ITEMS) \r\n    {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->totalItems];\r\n    AvailabilityStatus *status = &inventory->statuses[inventory->totalItems];\r\n    \r\n    printf(\"Enter item name: \");\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    strtok(item->name, \"\\n\"); // remove newline character\r\n    capitaliseStr(item->name); // capitalise first letter of each word in item name\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    strtok(item->category, \"\\n\");\r\n    capitaliseStr(item->category); // capitalise first letter of each word in item category\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    getchar();\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item->price);\r\n    getchar();\r\n\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = !status->inStock;\r\n\r\n    inventory->totalItems++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// function to display a list of all grocery items in the inventory\r\nvoid listItems(const GroceryInventory *inventory) \r\n{\r\n    if (inventory->totalItems == 0) \r\n    {\r\n        printf(\"No grocery items available in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) \r\n    {\r\n        const GroceryItem *item = &inventory->items[i];\r\n        const AvailabilityStatus *status = &inventory->statuses[i];\r\n\r\n        printf(\"\\n-Grocery Item #%d-\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// function to update the quantity of a grocery item in the inventory\r\nvoid updateQuantity(GroceryInventory *inventory) \r\n{\r\n    if (inventory->totalItems == 0) \r\n    {\r\n        printf(\"No grocery items available to update.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n    capitaliseStr(name); // capitalise before comparison\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) \r\n    {\r\n        GroceryItem *item = &inventory->items[i];\r\n        AvailabilityStatus *status = &inventory->statuses[i];\r\n\r\n        if (strcmp(item->name, name) == 0) // compare the name of current item with the entered name to find a match\r\n        {\r\n            // if found, update quantity of current item\r\n            printf(\"Enter new quantity for %s: \", item->name);\r\n            scanf(\"%d\", &item->quantity);\r\n            getchar();\r\n\r\n            status->inStock = item->quantity > 0;\r\n            status->outOfStock = !status->inStock;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    // if not found\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\r\n\r\n// function to remove a grocery item from the inventory\r\nvoid removeItem(GroceryInventory *inventory) \r\n{\r\n    if (inventory->totalItems == 0) \r\n    {\r\n        printf(\"No grocery items available to remove.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\");\r\n    capitaliseStr(name); // capitalise before comparison\r\n\r\n    for (int i = 0; i < inventory->totalItems; i++) \r\n    {\r\n        if (strcmp(inventory->items[i].name, name) == 0) // compare the name of current item with the entered name to find a match\r\n        {\r\n            // if found, remove current item (by shifting items and statuses to the left to fill the current item's spot)\r\n            for (int j = i; j < inventory->totalItems - 1; j++) \r\n            {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->statuses[j] = inventory->statuses[j + 1];\r\n            }\r\n\r\n            inventory->totalItems--; // decrement total number of items by 1 after removal\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n    // if not found\r\n    printf(\"Grocery item not found in the inventory.\\n\");\r\n}\r\n\r\n// function to display menu\r\nvoid displayMenu() \r\n{\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// function to capitalise the first letter of each word in a string\r\nvoid capitaliseStr(char *str) \r\n{\r\n    int isWordStart = 1; // tracks if the current character is the start of a word\r\n\r\n    for (int i = 0; str[i] != '\\0'; i++) \r\n    {\r\n        if (isWordStart && isalpha(str[i])) \r\n        {\r\n            str[i] = toupper(str[i]); // capitalize the first letter of the word\r\n            isWordStart = 0;\r\n        } \r\n        else \r\n        {\r\n            str[i] = tolower(str[i]); // convert the remaining letters in the word to lowercase\r\n        }\r\n\r\n        if (isblank(str[i])) \r\n        {\r\n            isWordStart = 1; // reset for the next word after a space\r\n        }\r\n    }\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nvoid sortStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\nvoid displayMenu();\r\n\r\nint main() \r\n{\r\n    int choice;\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n\r\n    do \r\n    {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // consume newline character\r\n\r\n        switch (choice) \r\n        {\r\n            case 1: // insert student record\r\n                printf(\"Enter name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2: // display student records\r\n                if (head == NULL) // if list empty\r\n                {\r\n                    printf(\"No student records available to display.\\n\");\r\n                }\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3: // sort student records\r\n                if (head == NULL)\r\n                {\r\n                    printf(\"No student records available to sort.\\n\");\r\n                }\r\n                else\r\n                {\r\n                    sortStudents();\r\n                    printf(\"Student records sorted by grade successfully using Selection Sort.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 4: // search student record by id\r\n                if (head == NULL)\r\n                {\r\n                    printf(\"No student records available to search.\\n\");\r\n                }\r\n                else\r\n                {\r\n                    printf(\"Enter ID to search: \");\r\n                    scanf(\"%d\", &id);\r\n                    Student* found = searchStudentByID(id);\r\n                    if (found) \r\n                    {\r\n                        printf(\"Student record found:\\n\");\r\n                        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                    } \r\n                    else \r\n                    {\r\n                        printf(\"Student record not found.\\n\");\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case 5: // delete list\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6: // exit\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n// function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) \r\n{\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) \r\n    {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    \r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n// function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) \r\n{\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// function to display all student records\r\nvoid displayStudents() \r\n{\r\n    Student* current = head;\r\n    \r\n    while (current != NULL) \r\n    {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// function to sort the student records by grade using selection sort algorithm\r\nvoid sortStudents() \r\n{\r\n    Student* current = head;\r\n    Student* min;\r\n    Student* next;\r\n\r\n    while (current != NULL) \r\n    {\r\n        min = current;\r\n        next = current->next;\r\n\r\n        while (next != NULL) \r\n        {\r\n            if (next->grade < min->grade) \r\n            {\r\n                min = next;\r\n            }\r\n            next = next->next;\r\n        }\r\n\r\n        if (min != current) \r\n        {\r\n            char tempName[100];\r\n            int tempID;\r\n            float tempGrade;\r\n\r\n            // swap name            \r\n            strcpy(tempName, current->name);\r\n            strcpy(current->name, min->name);\r\n            strcpy(min->name, tempName);\r\n\r\n            // swap id\r\n            tempID = current->id;\r\n            current->id = min->id;\r\n            min->id = tempID;\r\n            \r\n            // swap grade\r\n            tempGrade = current->grade;\r\n            current->grade = min->grade;\r\n            min->grade = tempGrade;\r\n        }\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// function to search for a student record by ID\r\nStudent* searchStudentByID(int id) \r\n{\r\n    Student* current = head;\r\n\r\n    while (current != NULL) \r\n    {\r\n        if (current->id == id) // if match found, return current\r\n        {\r\n            return current;\r\n        }\r\n        current = current->next; // else, move to the next node\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// function to delete the entire list\r\nvoid deleteList() \r\n{\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) \r\n    {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// function to free all allocated memory\r\nvoid freeMemory() \r\n{\r\n    deleteList();\r\n}\r\n\r\n// function to display menu\r\nvoid displayMenu()\r\n{\r\n    printf(\"\\nStudent Record Management System\\n\");\r\n    printf(\"1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Student Records\\n\");\r\n    printf(\"4. Search Student Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-All required functions are correctly implemented"
  },
  {
    "student_id": "20698118",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX_SIZE 10\r\n\r\n//function prototypes\r\nvoid matrixInput(int row, int column, int matrix[row][column]);\r\nvoid addMatrix(int row, int column, int MatrixA[row][column], int MatrixB[row][column], int result[row][column]);\r\nvoid subtractMatrix(int row, int column, int MatrixA[row][column], int MatrixB[row][column], int result[row][column]);\r\nvoid displayMatrix(int row, int column, int matrix[row][column]);\r\nvoid transposeMatrix(int row, int column, int matrix[row][column], int result[column][row]);\r\n\r\nint main(){\r\n    //variable declarations\r\n    int rowA, columnA, rowB, columnB;\r\n    int choice = 0;\r\n\r\n    //while loop to ensure proper dimensions are inputted\r\n    while(1){\r\n    printf(\"Enter the number of rows in Matrix A: \");\r\n    scanf(\"%d\", &rowA);\r\n    printf(\"Enter the number of columns in Matrix A: \");\r\n    scanf(\"%d\", &columnA);\r\n\r\n    if (rowA > MAX_SIZE || columnA > MAX_SIZE) { //checking the dimensions\r\n        printf(\"The maximum size for the matrices is %dx%d!\\n\", MAX_SIZE, MAX_SIZE);\r\n    }else{\r\n        break;\r\n    }\r\n    }\r\n    int MatrixA[rowA][columnA]; //initialising matrix\r\n\r\n    //while loop to ensure proper dimensions are inputted\r\n    while(1){\r\n    printf(\"Enter the number of rows in Matrix B: \");\r\n    scanf(\"%d\", &rowB);\r\n    printf(\"Enter the number of columns in Matrix B: \");\r\n    scanf(\"%d\", &columnB);\r\n\r\n    if (rowB > MAX_SIZE || columnB > MAX_SIZE) {//checking the dimensions\r\n        printf(\"The maximum size for the matrices is %dx%d!\\n\", MAX_SIZE, MAX_SIZE);\r\n    }else{\r\n        break;\r\n    }\r\n    }\r\n    int MatrixB[rowB][columnB]; //initialising matrix\r\n\r\n    printf(\"Enter the values for Matrix A\\n\"); //getting the values of the matrices\r\n    matrixInput(rowA, columnA, MatrixA); //calling functions\r\n\r\n    printf(\"Enter the values for Matrix B\\n\");\r\n    matrixInput(rowB, columnB, MatrixB);\r\n\r\n    int loop = 1;\r\n    while(loop){ //loop infinitely to allow user to do multiple operations before exiting\r\n        printf(\"===========================================\\n\");\r\n        printf(\"\\tMATRIX OPERATION MENU\\n\");\r\n        printf(\"===========================================\\n\");\r\n        printf(\"1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix A\\n4. Transpose Matrix B\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \"); //user inputs\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch(choice){\r\n            case 1:\r\n            if(rowA != rowB || columnA != columnB){\r\n                printf(\"Matrices must have same size to be added\\n\"); //checking if matrix dimensions are equal\r\n                break;\r\n            }else{\r\n                int resultMatrix[rowA][columnA]; //calculating the addition of matrix A and B\r\n                addMatrix(rowA, columnA, MatrixA, MatrixB, resultMatrix);\r\n                displayMatrix(rowA, columnA, resultMatrix); //output\r\n            break;\r\n            }\r\n\r\n            case 2:\r\n            if(rowA != rowB || columnA != columnB){\r\n                printf(\"Matrices must have same size to be subtracted\\n\"); //checking if matrices have same dimensions\r\n                break;\r\n            }else{\r\n                int resultMatrix[rowA][columnA]; //calculating the difference between matrix A and B\r\n                subtractMatrix(rowA, columnA, MatrixA, MatrixB, resultMatrix);\r\n                displayMatrix(rowA, columnA, resultMatrix); //output\r\n                break;\r\n            }\r\n\r\n            case 3: {\r\n            int resultMatrix[columnA][rowA]; //transposing matrix A\r\n            transposeMatrix(rowA, columnA, MatrixA, resultMatrix);\r\n            printf(\"Transpose of Matrix A: \\n\");\r\n            displayMatrix(columnA, rowA, resultMatrix);\r\n            break;\r\n            }\r\n\r\n            case 4: {\r\n            int resultMatrix[columnB][rowB]; //transposing matrix B\r\n            transposeMatrix(rowB, columnB, MatrixB, resultMatrix);\r\n            printf(\"Transpose of Matrix B: \\n\");\r\n            displayMatrix(columnB, rowB, resultMatrix);\r\n            break;\r\n            }\r\n\r\n            case 5: //exit\r\n            printf(\"Exiting...\");\r\n            loop = 0;\r\n            break;\r\n\r\n            default: //in case user enters unsupported values\r\n            printf(\"Please enter a valid input.\");\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n//function for matrix input\r\nvoid matrixInput(int row, int column, int matrix[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traverses through row and column\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1); //getting user input\r\n            scanf(\"%d\", &matrix[i][j]); //saving user input into matrix\r\n        }\r\n    }\r\n}\r\n\r\n//function to add matrix A and B\r\nvoid addMatrix(int row, int column, int MatrixA[row][column], int MatrixB[row][column], int result[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            result[i][j] = MatrixA[i][j] + MatrixB[i][j]; //finding the result of addition and putting it into the corresponding row and column for the result matrix\r\n        }\r\n    }\r\n}\r\n\r\n//function to subract 2 matrices\r\nvoid subtractMatrix(int row, int column, int MatrixA[row][column], int MatrixB[row][column], int result[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            result[i][j] = MatrixA[i][j] - MatrixB[i][j]; //finding the result of subtraction and putting it into the corresponding row and column for the result matrix\r\n        }\r\n    }\r\n}\r\n\r\n//function to display the matrix\r\nvoid displayMatrix(int row, int column, int matrix[row][column]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            printf(\"%d\\t\", matrix[i][j]); // printing element\r\n        }\r\n        printf(\"\\n\"); //to go to next line after a column is done\r\n    }\r\n}\r\n\r\n//function to transpose a matrix\r\nvoid transposeMatrix(int row, int column, int matrix[row][column], int result[column][row]){\r\n    for(int i = 0; i < row; i++){\r\n        for(int j = 0; j < column; j++){ //traversing through row and column\r\n            result[j][i] = matrix[i][j]; //changing i to j and j to i\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <ctype.h>\r\n\r\ntypedef struct{ //Grocery Item struct\r\n    char name[100];\r\n    char category[100];\r\n    int quantity;\r\n    float price;\r\n    char availability[100];\r\n}GroceryItem;\r\n\r\n//Function prototypes\r\nvoid add();\r\nvoid display();\r\nvoid update();\r\nvoid delete();\r\n\r\nint main(){\r\n    int choice = 0;\r\n    int loop = 1;\r\n\r\n    while(loop){\r\n        //menu display\r\n        printf(\"=======================\\n\");\r\n        printf(\"Grocery Inventory Manager\\n\");\r\n        printf(\"=======================\\n\");\r\n        printf(\"1. Add\\n2. Display\\n3. Update\\n4. Remove\\n5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); //user choice\r\n\r\n        switch(choice){\r\n\r\n            case 1:\r\n            add(); //adding item\r\n            break;\r\n\r\n            case 2:\r\n            display(); //displaying all items\r\n            break;\r\n\r\n            case 3:\r\n            update(); //updating quantities\r\n            break;\r\n\r\n            case 4:\r\n            delete(); //deleting items\r\n            break;\r\n\r\n            case 5:\r\n            printf(\"Exiting...\"); //exit\r\n            loop = 0;\r\n            break;\r\n\r\n            default:\r\n            printf(\"Please enter a valid input\"); //in case user enters a value thats not supported\r\n\r\n        }\r\n    }\r\n}\r\n\r\nvoid add(){//function to add items to the file\r\n    GroceryItem *item = malloc(sizeof(GroceryItem)); //allocating memory\r\n    FILE *filept = fopen(\"Inventory.csv\", \"a+\"); //opening csv file\r\n\r\n    //prompting user inputs\r\n    printf(\"Enter the name of the product: \");\r\n    scanf(\" %[^\\n]s\", item->name);\r\n    printf(\"Enter the category of the item: \");\r\n    scanf(\" %[^\\n]s\", item->category);\r\n\r\n    while(1){//infinite loop for error handling in case of a negative quantity input\r\n        printf(\"Enter the quantity of the item: \");\r\n        scanf(\" %d\", &item->quantity);\r\n\r\n        if(item->quantity < 0){\r\n            printf(\"The quantity of an item cannot be negative!\");\r\n        }else{\r\n            break;\r\n        }\r\n    }\r\n\r\n    printf(\"Enter the price of the item: RM \");\r\n    scanf(\" %f\", &item->price);\r\n\r\n    if(item->quantity > 0){ //determining whether item is in stock or not\r\n        strcpy(item->availability, \"In Stock\");\r\n    }else if(item->quantity == 0){\r\n        strcpy(item->availability, \"Out of Stock\");\r\n    }\r\n\r\n    //writing into the file\r\n    fprintf(filept, \"%s, %s, %d, %.2f, %s\\n\", item->name, item->category, item->quantity, item->price, item->availability);\r\n    fclose(filept); //closing file\r\n    free(item);\r\n}\r\n\r\n//function to display all the items\r\nvoid display(){\r\n    FILE *filept = fopen(\"Inventory.csv\", \"r\"); //opening the inventory in read\r\n    char line[1024]; //fetch the items\r\n    int i = 1; //counter\r\n    printf(\"Name, Category, Quantity, Price(RM), Availability\\n\");\r\n\r\n    while(fgets(line, sizeof(line), filept) != NULL){ //while fgets value is not null display the items\r\n        printf(\"%d. %s\\n\", i, line);\r\n        i++;\r\n    }\r\n\r\n    fclose(filept); //close the files\r\n}\r\n\r\n//function to update the quantity of the item\r\nvoid update() {\r\n    FILE *filept = fopen(\"Inventory.csv\", \"r\"); //open Inventory.csv in read mode\r\n    FILE *tempFile = fopen(\"Temp.csv\", \"w\"); //open a temp file to write into\r\n    char search[100], line[1024];\r\n    char name[100], category[100], availability[100];\r\n    int quantity;\r\n    float price;\r\n    int found = 0;\r\n\r\n    if (filept == NULL || tempFile == NULL) { //error handling\r\n        printf(\"Error: Could not open file.\\n\");\r\n        if (filept != NULL) fclose(filept);\r\n        if (tempFile != NULL) fclose(tempFile);\r\n        return;\r\n    }\r\n\r\n    getchar();  // clear \\n\r\n    printf(\"Which product would you like to update: \"); //prompting user input\r\n    fgets(search, sizeof(search), stdin);\r\n    search[strcspn(search, \"\\n\")] = 0;  // remove trailing newline\r\n\r\n    while (fgets(line, sizeof(line), filept) != NULL) {\r\n        // traverse the current line\r\n        int parsed = sscanf(line, \"%99[^,],%99[^,],%d,%f,%99[^\\n]\", name, category, &quantity, &price, availability);\r\n        if (parsed != 5) {\r\n            printf(\"Error traversing line: %s\", line);\r\n            continue;  // Skip malformed lines\r\n        }\r\n\r\n        if (strcmp(search, name) == 0) { //checking for exact name match\r\n            found = 1;\r\n            printf(\"Enter the new quantity: \");\r\n            while (scanf(\"%d\", &quantity) != 1 || quantity < 0) {\r\n                printf(\"Invalid input. Enter a non-negative quantity: \");\r\n                while (getchar() != '\\n');  // clear invalid input\r\n            }\r\n            while (getchar() != '\\n');  // clear input buffer\r\n\r\n            //updating availability\r\n            if (quantity > 0) {\r\n                strcpy(availability, \"In Stock\");\r\n            } else {\r\n                strcpy(availability, \"Out of Stock\");\r\n            }\r\n        }\r\n\r\n        // Write to temp file\r\n        fprintf(tempFile, \"%s,%s,%d,%.2f,%s\\n\", name, category, quantity, price, availability);\r\n    }\r\n\r\n    //close files and replace original file with updated file\r\n    fclose(filept);\r\n    fclose(tempFile);\r\n\r\n    if (found) {\r\n        //replacing temp to Inventory.csv and deleting the old Inventory.csv\r\n        remove(\"Inventory.csv\");\r\n        rename(\"Temp.csv\", \"Inventory.csv\");\r\n        printf(\"Quantity updated successfully.\\n\");\r\n    } else {\r\n        remove(\"Temp.csv\");\r\n        printf(\"Product not found.\\n\");\r\n    }\r\n}\r\n\r\n//function to delete items\r\nvoid delete() {\r\n    FILE *filept = fopen(\"Inventory.csv\", \"r\"); //open Inventory.csv in read mode\r\n    FILE *tempFile = fopen(\"Temp.csv\", \"w\"); //create Temp.csv to write updated list into\r\n    char search[100], line[1024];\r\n    char name[100], category[100], availability[100];\r\n    int quantity;\r\n    float price;\r\n    int found = 0;\r\n\r\n    if (filept == NULL || tempFile == NULL) {\r\n        printf(\"Error opening file.\\n\");\r\n        return;\r\n    }\r\n\r\n    getchar();  //clear leftover newline from previous input\r\n    printf(\"Which product would you like to delete: \"); //user input for search term\r\n    fgets(search, sizeof(search), stdin);\r\n    search[strcspn(search, \"\\n\")] = 0;  //remove '\\n'\r\n\r\n    while (fgets(line, sizeof(line), filept) != NULL) { //searching the file for search term\r\n        sscanf(line, \"%99[^,],%99[^,],%d,%f,%99[^\\n]\", name, category, &quantity, &price, availability);\r\n\r\n        if (strcmp(search, name) == 0) { \r\n            found = 1;\r\n            printf(\"Product '%s' deleted successfully.\\n\", name);\r\n            continue;  //skips writing this line to the temp file\r\n        }\r\n\r\n        //write other lines to the temp file\r\n        fprintf(tempFile, \"%s,%s,%d,%.2f,%s\\n\", name, category, quantity, price, availability);\r\n    }\r\n\r\n    fclose(filept); //closing files\r\n    fclose(tempFile);\r\n\r\n    if (found) { //renaming temp to Inventory.csv\r\n        remove(\"Inventory.csv\");\r\n        rename(\"Temp.csv\", \"Inventory.csv\");\r\n    } else {\r\n        printf(\"Product not found.\\n\");\r\n        remove(\"Temp.csv\");\r\n    }\r\n}\n/* --- Q3.c --- */\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} Student; \r\n \r\nStudent* head = NULL; \r\n \r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); //allocating memory\r\n\r\n    //copying data into the list\r\n    strcpy(newStudent->name, name); \r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n   int i = 1;\r\n    Student* temp = head; //Start at the head\r\n\r\n    if(temp == NULL){\r\n        printf(\"There are no students in the list\\n\"); //if list is empty\r\n        return;\r\n    }\r\n\r\n    while(temp != NULL){\r\n        printf(\"%d. Name: %s, ID: %d, Grade: %.2f\\n\", i++, temp->name, temp->id, temp->grade); //printing members of the list\r\n        temp = temp->next; // going to next node\r\n    }\r\n} \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n    Student* temp = head;\r\n    while(temp != NULL){\r\n        if(temp->id == id){\r\n        return temp;\r\n        }else{\r\n            temp = temp->next;\r\n        }\r\n    }\r\n    return NULL;\r\n} \r\n \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n    head = NULL; \r\n}\r\n \r\n \r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\n// Function to split the linked list into two halves\r\nStudent* splitList(Student* head) {\r\n    Student* Left = head;\r\n    Student* Right = head->next;\r\n\r\n    while (Right != NULL && Right->next != NULL) {\r\n        Left = Left->next;\r\n        Right = Right->next->next;\r\n    }\r\n\r\n    Student* secondHalf = Left->next;\r\n    Left->next = NULL; // Split the list\r\n    return secondHalf;\r\n}\r\n\r\n// Function to merge two sorted lists\r\nStudent* mergeLists(Student* list1, Student* list2) {\r\n    if (list1 == NULL) return list2;\r\n    if (list2 == NULL) return list1;\r\n\r\n    Student* merged = NULL;\r\n\r\n    if (list1->grade <= list2->grade) {\r\n        merged = list1;\r\n        merged->next = mergeLists(list1->next, list2);\r\n    } else {\r\n        merged = list2;\r\n        merged->next = mergeLists(list1, list2->next);\r\n    }\r\n\r\n    return merged;\r\n}\r\n\r\n// Recursive Merge Sort function\r\nStudent* mergeSort(Student* head) {\r\n    if (head == NULL || head->next == NULL) {\r\n        return head; // Base case: 0 or 1 node\r\n    }\r\n\r\n    Student* secondHalf = splitList(head); // Split the list into two halves\r\n    Student* sortedFirstHalf = mergeSort(head); // Sort the first half\r\n    Student* sortedSecondHalf = mergeSort(secondHalf); // Sort the second half\r\n\r\n    return mergeLists(sortedFirstHalf, sortedSecondHalf); // Merge sorted halves\r\n}\r\n\r\n// Sort function for your skeleton\r\nvoid sortStudents() {\r\n    head = mergeSort(head);\r\n    printf(\"Student records sorted by grade.\\n\");\r\n}\r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = createStudent(name, id, grade); // creating a new node\r\n    if (head == NULL) {\r\n        head = newStudent; //inserts to the head if head is empty\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    while (temp->next != NULL) { // traverses through the list to find the last node\r\n        temp = temp->next;\r\n    }\r\n    temp->next = newStudent; //enters student at end of the list\r\n\r\n} \r\n\r\n \r\n// Main function to drive the program \r\nint main() { \r\n \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records (Ascending Order)\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        getchar(); // To consume the newline character \r\n \r\n        switch (choice) { \r\n            case 1: \r\n                printf(\"Enter Name: \"); \r\n                fgets(name, sizeof(name), stdin); \r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id); \r\n                printf(\"Enter Grade: \"); \r\n                scanf(\"%f\", &grade); \r\n                insertStudent(name, id, grade); \r\n                break; \r\n            case 2: \r\n                displayStudents(); \r\n                break; \r\n            case 3: \r\n                sortStudents();                 \r\n                break; \r\n            case 4: \r\n                printf(\"Enter ID to search: \"); \r\n                scanf(\"%d\", &id); \r\n                Student* found = searchStudentByID(id); \r\n \r\n                if (found) { \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                    found->name, found->id, found->grade); \r\n                } else { \r\n                    printf(\"Student not found.\\n\"); \r\n                } \r\n                break; \r\n            case 5: \r\n                deleteList(); \r\n                printf(\"List deleted.\\n\"); \r\n                break; \r\n            case 6: \r\n                freeMemory(); \r\n                printf(\"Exiting...\\n\"); \r\n                break; \r\n            default: \r\n                printf(\"Invalid choice! Please try again.\\n\"); \r\n        } \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Merge Sort algorithm is implemented correctly to sort student records by grade in ascending order. This algorithm is efficient, with a time complexity of O(n log n), making it suitable for larger datasets compared to simpler algorithms like Bubble Sort."
  },
  {
    "student_id": "20610427",
    "code": "\n/* --- question1.c --- */\n#include <stdio.h>\r\n#define Rows_Size 10\r\n#define Colomns_Size 10\r\n\r\nint first[Rows_Size][Colomns_Size];\r\nint second[Rows_Size][Colomns_Size];\r\nint sum[Rows_Size][Colomns_Size];\r\nint substact[Rows_Size][Colomns_Size];\r\nint transposeA[Colomns_Size][Rows_Size];\r\nint transposeB[Colomns_Size][Rows_Size];\r\nint r, c, option;\r\n\r\nvoid Keyin();\r\nvoid Add_Matrices();\r\nvoid Substact_Matrices();\r\nvoid Transpose_Matrix_A();\r\nvoid Transpose_Matrix_B();\r\n\r\nint main() {\r\n    Keyin();\r\n    while (1) {\r\n        printf(\"\\nMatrix Operations Menu\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Substract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n\r\n        switch (option) {\r\n            case 1:\r\n                Add_Matrices();\r\n                break;\r\n            case 2:\r\n                Substact_Matrices();\r\n                break;\r\n            case 3:\r\n                Transpose_Matrix_A();\r\n                break;\r\n            case 4:\r\n                Transpose_Matrix_B();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice...\\n\");\r\n                break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid Keyin() {\r\n    int i, j;\r\n    printf(\"\\nEnter the dimensions of Matrix A (rows and columns): \\n\");\r\n    scanf(\"%d %d\", &r, &c);\r\n\r\n    printf(\"Enter the elements for Matrix A: \\n\");\r\n    for (i = 0; i < r; i++) {\r\n        for (j = 0; j < c; j++) {\r\n            printf(\"Element [%d][%d] :\", i + 1, j + 1);\r\n            scanf(\"%d\", &first[i][j]);\r\n        }\r\n    }\r\n\r\n    printf(\"Enter the elements for Matrix B: \\n\");\r\n    for (i = 0; i < r; i++) {\r\n        for (j = 0; j < c; j++) {\r\n            printf(\"Element [%d][%d] :\", i + 1, j + 1);\r\n            scanf(\"%d\", &second[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Add_Matrices() {\r\n    int i, j;\r\n    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n    for (i = 0; i < r; i++) {\r\n        for (j = 0; j < c; j++) {\r\n            sum[i][j] = first[i][j] + second[i][j];\r\n            printf(\"%d \", sum[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid Substact_Matrices() {\r\n    int i, j;\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    for (i = 0; i < r; i++) {\r\n        for (j = 0; j < c; j++) {\r\n            substact[i][j] = first[i][j] - second[i][j];\r\n            printf(\"%d \", substact[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid Transpose_Matrix_A() {\r\n    int i, j;\r\n    for (i = 0; i < r; i++) {\r\n        for (j = 0; j < c; j++) {\r\n            transposeA[j][i] = first[i][j];\r\n        }\r\n    }\r\n    printf(\"Transpose of Matrix A:\\n\");\r\n    for (i = 0; i < c; i++) {\r\n        for (j = 0; j < r; j++) {\r\n            printf(\"%d \", transposeA[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid Transpose_Matrix_B() {\r\n    int i, j;\r\n    for (i = 0; i < r; i++) {\r\n        for (j = 0; j < c; j++) {\r\n            transposeB[j][i] = second[i][j];\r\n        }\r\n    }\r\n    printf(\"Transpose of Matrix B:\\n\");\r\n    for (i = 0; i < c; i++) {\r\n        for (j = 0; j < r; j++) {\r\n            printf(\"%d \", transposeB[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n    \r\n\r\n\r\n \r\n\r\n\r\n\n/* --- question2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define Char_Name_Size 100\r\n#define Char_Category_Size 50\r\n\r\nint option, i = 0;\r\n\r\nstruct grocery {\r\n    char Name[Char_Name_Size];\r\n    char Category[Char_Category_Size];\r\n    int Quantity;\r\n    float Price;\r\n    bool InStock;\r\n};\r\n\r\nstruct grocery Grocery_Item[100];\r\n\r\nvoid Add_Grocery();\r\nvoid List_All_Grocery();\r\nvoid Update_Quantity();\r\nvoid Remove_Grocery();\r\nvoid Update_Stock_Status(struct grocery *item);\r\n\r\nint main() {\r\n    while (1) {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n        getchar(); // Clear newline from input buffer\r\n\r\n        switch (option) {\r\n            case 1:\r\n                Add_Grocery();\r\n                break;\r\n            case 2:\r\n                List_All_Grocery();\r\n                break;\r\n            case 3:\r\n                Update_Quantity();\r\n                break;\r\n            case 4:\r\n                Remove_Grocery();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid Option. Please try again.\\n\");\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nvoid Add_Grocery() {\r\n    printf(\"Enter Item Name: \");\r\n    fgets(Grocery_Item[i].Name, Char_Name_Size, stdin);\r\n    Grocery_Item[i].Name[strcspn(Grocery_Item[i].Name, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(Grocery_Item[i].Category, Char_Category_Size, stdin);\r\n    Grocery_Item[i].Category[strcspn(Grocery_Item[i].Category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &Grocery_Item[i].Quantity);\r\n    getchar();\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &Grocery_Item[i].Price);\r\n    getchar();\r\n\r\n    Update_Stock_Status(&Grocery_Item[i]);\r\n\r\n    i++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid List_All_Grocery() {\r\n    if (i == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int j = 0; j < i; ++j) {\r\n        printf(\"\\nName: %s\\n\", Grocery_Item[j].Name);\r\n        printf(\"Category: %s\\n\", Grocery_Item[j].Category);\r\n        printf(\"Quantity: %d\\n\", Grocery_Item[j].Quantity);\r\n        printf(\"Price: %.2f\\n\", Grocery_Item[j].Price);\r\n        printf(\"Status: %s\\n\", Grocery_Item[j].InStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid Update_Quantity() {\r\n    char Update_Item[Char_Name_Size];\r\n    printf(\"Enter the name of the grocery item to update the quantity: \");\r\n    fgets(Update_Item, Char_Name_Size, stdin);\r\n    Update_Item[strcspn(Update_Item, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    for (int j = 0; j < i; ++j) {\r\n        if (strcmp(Update_Item, Grocery_Item[j].Name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", Grocery_Item[j].Name);\r\n            scanf(\"%d\", &Grocery_Item[j].Quantity);\r\n            getchar();\r\n\r\n            Update_Stock_Status(&Grocery_Item[j]);\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item '%s' not found.\\n\", Update_Item);\r\n}\r\n\r\nvoid Remove_Grocery() {\r\n    char Remove_Item[Char_Name_Size];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    fgets(Remove_Item, Char_Name_Size, stdin);\r\n    Remove_Item[strcspn(Remove_Item, \"\\n\")] = '\\0'; // Remove newline\r\n\r\n    for (int j = 0; j < i; ++j) {\r\n        if (strcmp(Grocery_Item[j].Name, Remove_Item) == 0) {\r\n            for (int k = j; k < i - 1; ++k) {\r\n                Grocery_Item[k] = Grocery_Item[k + 1];\r\n            }\r\n            i--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", Remove_Item);\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Grocery item '%s' not found.\\n\", Remove_Item);\r\n}\r\n\r\nvoid Update_Stock_Status(struct grocery *item) {\r\n    item->InStock = (item->Quantity > 0);\r\n}\n/* --- question3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n//prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid sortStudents();\r\nvoid freeMemory();\r\n\r\n\r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (!head) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Function to sort student records by grade (Bubble Sort used for simplicity)\r\n// Bubble Sort is chosen due to its straightforward implementation for linked lists.\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the grades, names, and IDs\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                int tempID = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempID;\r\n\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                strcpy(ptr1->next->name, tempName);\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n//  Main function to drive the program \r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\nStudent Records Management System\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();  // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student with ID %d not found.\\n\", id);\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n\r\n    } while( choice != 6);\r\n    return 0;\r\n}\r\n\r\n\r\n",
    "feedback": "q1-Transpose Printing Order: In the Transpose_Matrix_A and Transpose_Matrix_B functions, the printing order should reference the transposed matrix correctly. The nested loops should iterate over the columns first and then the rows\nq2-The InStock status is not initialized when adding a new grocery item. Although the Update_Stock_Status function is called after setting the quantity, it should also be invoked when listing items to ensure that the status reflects the current quantity.\nq3-    The implementation of bubble sort is straightforward and works correctly for sorting student records by grade. However, bubble sort has a time complexity of O(n?), which can be inefficient for larger datasets. Consider using more efficient algorithms, such as Merge Sort or Quick Sort, for better performance in practice."
  },
  {
    "student_id": "20598255",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <ctype.h> //for vaildating if input is digit \r\n#include <stdlib.h> //for strtol\r\n#include <string.h.> //for string manipulation \r\n\r\n#define M_SIZE 10 //setting maximum size of 10\r\n\r\n//function to ensure matrix is numeric input \r\nint ValidateInput(){\r\n    char input[100]; //buffer to store user input\r\n    char *endptr; //pointer to track invalid parts of input \r\n    int value;\r\n\r\n    //loop until valid input is given\r\n    while(1){ \r\n        scanf(\"%s\", input); //read input as string\r\n        value =strtol(input, &endptr,10); //convert input to integer\r\n        \r\n        //check if conversion was successful \r\n        if (*endptr =='\\0'){ \r\n            return value; //read validated integer\r\n        }else{\r\n            printf(\"Invalid input! Please enter a numeric value:\"); //prompt user to input again\r\n        }\r\n    }\r\n}\r\n\r\n//function to inputMatrix \r\nvoid inputMatrix(int matrix[M_SIZE][M_SIZE],int rows, int cols){\r\n    //loop through rows\r\n    for (int i=0; i<rows; i++){\r\n        for (int j=0; j<cols; j++){ //loop through columns\r\n            printf(\"Enter element [%d][%d]:\", i+1, j+1); //prompt user to input elements\r\n            matrix[i][j] =ValidateInput(); //use validated input for each element\r\n            \r\n        }\r\n        \r\n    }\r\n}\r\n\r\n//function to display matrix \r\nvoid displayMatrix(int matrix[M_SIZE][M_SIZE], int rows, int cols){\r\n    for (int i=0; i<rows; i++){ //loop through rows\r\n        for(int j=0; j<cols;j++){ //loop through columns\r\n            printf(\"%d \", matrix[i][j]); //print matrix element\r\n\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// function to add two matrices \r\nvoid addMatrices(int matrixA[M_SIZE][M_SIZE], int matrixB[M_SIZE][M_SIZE],int result[M_SIZE][M_SIZE],int rows, int cols){\r\n    for (int i= 0; i<rows; i++){ //loop through rows\r\n        for (int j=0; j<cols; j++){ //loop through columns\r\n            result[i][j]= matrixA[i][j] +matrixB[i][j]; //add elements together and saved into results\r\n        }\r\n    }\r\n}\r\n\r\n//function to subtract two matrices\r\nvoid subtractMatrices(int matrixA[M_SIZE][M_SIZE], int matrixB[M_SIZE][M_SIZE],int result[M_SIZE][M_SIZE],int rows, int cols){\r\n    for (int i= 0; i<rows; i++){ //loop through rows\r\n        for (int j=0; j<cols; j++){ //loop through columns\r\n            result[i][j]= matrixA[i][j] - matrixB[i][j]; //subtract and save into result\r\n        }\r\n    }\r\n}\r\n\r\n//function to transpose matrix\r\nvoid transposeMatrix(int matrix[M_SIZE][M_SIZE],int transpose[M_SIZE][M_SIZE],int rows, int cols){\r\n    for (int i=0; i<rows; i++){ //loop through rows\r\n        for (int j=0; j<cols; j++){ //loop through columns\r\n            transpose[j][i]=matrix[i][j]; //transpose matrix\r\n        }\r\n    }\r\n}\r\n\r\nint main (){\r\n    int matrixA[M_SIZE][M_SIZE], matrixB[M_SIZE][M_SIZE]; //for matrices A and B\r\n    int result[M_SIZE][M_SIZE]; // result matrix for addition and subtraction\r\n    int rowsA,colsA,rowsB, colsB; //dimensions of matrices A and B \r\n    int choice; //variable to store user's menu choice\r\n    int transposeA[M_SIZE][M_SIZE], transposeB[M_SIZE][M_SIZE]; //transpose matrices for A and B\r\n\r\n    //prompt user for input for matrix A\r\n    printf(\"Enter the number of rows and columns for matrix A (MAX 10 ROWS AND 10 COLUMNS:)\");\r\n    //check if its digit\r\n    rowsA =ValidateInput();\r\n    colsA= ValidateInput();\r\n\r\n    //validate dimension for matrix A \r\n    if (rowsA> M_SIZE || colsA> M_SIZE|| rowsA <= 0|| colsA <=0){ //validation when input is smaller than 0, or bigger than 10 \r\n        printf(\"Invalid dimensions! Exiting program.\\n\");\r\n        return -1; \r\n    }\r\n\r\n    printf(\"Enter the elements of Matrix A : \\n\");\r\n    inputMatrix(matrixA,rowsA, colsA); //call function for inputting matrix\r\n\r\n    //prompt user for input for matrix B \r\n    printf(\"Enter the number of rows and columns for matrix B (MAX 10 ROWS AND 10 COLUMNS:)\");\r\n    //validate if its digit\r\n    rowsB= ValidateInput();\r\n    colsB= ValidateInput();\r\n\r\n    //validate dimensions \r\n    if (rowsB> M_SIZE || colsB> M_SIZE|| rowsB <= 0|| colsB <=0){ //validation when input is smaller than 0, or bigger than 10 \r\n        printf(\"Invalid dimensions! Exiting program.\\n\");\r\n        return -1; \r\n    }\r\n\r\n    //prompt user for input of elements in matrix B \r\n    printf(\"Enter the elements of Matrix B : \\n\");\r\n    inputMatrix(matrixB,rowsB,colsB); //call function to inputmatrix\r\n\r\n    //main loop \r\n    while (1){\r\n        //main menu \r\n        printf(\"\\n Menu \\n\");\r\n        printf(\"1. Add Matrices \\n \");\r\n        printf(\"2. Subtract Matrices \\n \");\r\n        printf(\"3. Transpose Matrice A \\n \");\r\n        printf(\"4. Transpose Matrice B \\n \");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice:\\n\"); //prompt user for input\r\n        scanf(\"%d\",&choice); //input saved into variable choice\r\n\r\n        //switch case \r\n        switch (choice){\r\n\r\n            //choice 1 - add matrices\r\n            case 1: \r\n                if (rowsA==rowsB && colsA==colsB){//both matrices need to have same number of rows and columns for addition to happen\r\n                    addMatrices(matrixA,matrixB,result,rowsA,colsB); //call function add matrice\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(result,rowsA,colsA); //call function displayMatrix to show results\r\n                } else{\r\n                    printf(\"Both matrix dimensions need to match for addition to happen.\\n\");\r\n                }\r\n                break;\r\n\r\n            //choice 2 - subtract matrices\r\n            case 2: \r\n                if (rowsA==rowsB && colsA==colsB){ //both matrices num of rows and columns need to be the same\r\n                    subtractMatrices(matrixA,matrixB,result,rowsA,colsA); // call function to subtract \r\n                    printf(\"Result of Matrix A- Matrix B:\\n\");\r\n                    displayMatrix(result,rowsA,colsA); //display result\r\n                } else{\r\n                    printf(\"Both matrix dimensions need to match for subtraction.\\n\"); //both matrices has different dimensions\r\n                }\r\n                break;\r\n\r\n            //choice 3- transpose matrix A \r\n            case 3:\r\n                transposeMatrix(matrixA,transposeA, rowsA, colsA); //call function to tranpose matrix\r\n                printf(\"Transpose of Matrix A:\\n\"); \r\n                displayMatrix(transposeA, colsA, rowsA); //print transposed matrix of A\r\n                break;\r\n\r\n            //choice 4- transpose matrix B \r\n            case 4: \r\n                transposeMatrix(matrixB, transposeB,rowsB,colsB); //call function to transpose matrix\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(transposeB,colsB,rowsB); //print transposed matrix of B\r\n                break;\r\n\r\n            //exit program \r\n            case 5:\r\n                printf(\"Exiting the program.\\n\");\r\n               \r\n                return 0;  //end program\r\n            \r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\"); //invalid choice input (not 1-5)\r\n        } \r\n\r\n       \r\n    } \r\n\r\n    \r\n    \r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n//define sizes\r\n#define MAX_ITEMS 100 //max number of items in inventory\r\n#define MAX_NAME_LENGTH 100 //max length of an item's name\r\n#define MAX_CATEGORY_LENGTH 50 //max length of an item's category\r\n\r\n//struct for grocery item \r\ntypedef struct{\r\n    char name[MAX_NAME_LENGTH];         //name of grocery item\r\n    char category[MAX_CATEGORY_LENGTH]; //category of grocery item\r\n    int quantity;                       //quanitity of grocery item\r\n    float price;                        //price of grocery item\r\n    bool in_stock;                      //boolean flag to indicate stock status\r\n} GroceryItem;\r\n\r\n//struct for entire inventory\r\ntypedef struct{\r\n    GroceryItem items[MAX_ITEMS]; //array of grocery items\r\n    int count;                    //no of items currently in inventory\r\n} GroceryInventory;\r\n\r\n//function to display menu \r\nvoid displayMenu(){\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List all grocery items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove grocery item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n\r\n}\r\n\r\n//function to add a grocery item \r\nvoid addItem(GroceryInventory *inventory){\r\n    //check if inventory is full\r\n    if(inventory->count >= MAX_ITEMS){\r\n        printf(\"Inventory is full. Cannot add more items.\\n\"); //display message if inventory is full\r\n        return;\r\n    }\r\n\r\n    //get the pointer to the next available slot in inventory\r\n    GroceryItem *item =&inventory-> items[inventory-> count];\r\n\r\n    //input details for new grocery item:\r\n    printf(\"Enter item name:\\n\");\r\n    scanf(\" %[^\\n]\", item->name); //read name, allowing spaces\r\n\r\n    printf(\"Enter category:\\n\");\r\n    scanf(\" %[^\\n]\", item->category);// read category, allowing spaces\r\n\r\n    printf(\"Enter quantity:\\n\");\r\n    scanf(\"%d\", &item->quantity); //read quantity as integer\r\n\r\n    while (getchar() != '\\n'); //clear input buffer\r\n\r\n    printf(\"Enter price:\\n\");\r\n    scanf(\"%f\", &item->price); //read price as float\r\n\r\n    while (getchar() != '\\n'); //clear input buffer\r\n\r\n    item->in_stock = item->quantity >0; //set in- stock status to instock if item quantity>0\r\n\r\n    inventory->count++; //incement inventory count\r\n    printf(\"Item added successfully!\\n\");\r\n\r\n}\r\n\r\n//function to list grocery items \r\nvoid listItems(const GroceryInventory *inventory){\r\n    //check if inventory is empty\r\n    if (inventory->count ==0){\r\n        printf(\"No items in inventory.\\n\"); //display message that inventory is empty\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nGrocery Inventory:\\n\");\r\n    //loop through all items and print thier detials\r\n    for (int i=0; i< inventory->count; i++){\r\n        const GroceryItem *item= &inventory->items[i];\r\n        printf(\"Item %d:\\n\", i+1);\r\n        printf(\"Name:%s\\n\", item->name);\r\n        printf(\"Category:%s\\n\", item->category);\r\n        printf(\"Quantity:%d\\n\", item->quantity);\r\n        printf(\"Price:$%.2f\\n\", item->price);\r\n        printf(\"Status:%s\\n\", item->in_stock?\"In stock\":\"Out of Stock\");\r\n    }\r\n}\r\n\r\n//function to update quantity of an item \r\nvoid updateQuantity(GroceryInventory *inventory){\r\n    //check if inventory is empty\r\n    if(inventory->count ==0){\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n\r\n\r\n    //prompt user for name of item that want quantity to be updates\r\n    printf(\"Enter name of the grocery item to update quantity:\");\r\n    while (getchar() != '\\n'); //clear input buffer \r\n    fgets(name,MAX_NAME_LENGTH,stdin); //read item name\r\n\r\n    //remove trailing newline character \r\n    size_t len=strlen(name);\r\n    if (len>0 && name[len-1]=='\\n'){\r\n        name[len-1]='\\0';\r\n    }\r\n\r\n    //search for the item in inventory\r\n    for (int i = 0; i<inventory->count;i++){\r\n        GroceryItem *item= &inventory->items[i];\r\n        //when have a match:\r\n        if (strcmp(item->name,name)==0){\r\n            printf(\"Enter new quantity:\"); //prompt user for new quantity\r\n            scanf(\"%d\", &item->quantity); // read new quantity of the item \r\n            //clear input buffer \r\n            while (getchar() != '\\n');\r\n            //update in stock status- instock if new quantity>0 \r\n            item->in_stock=item->quantity>0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory.\\n\"); //error message that item keyed in cant be found in inventory\r\n\r\n}\r\n\r\n//function to remove grocery item \r\nvoid removeItem(GroceryInventory *inventory){\r\n\r\n    //check if inventory is empty\r\n    if(inventory->count ==0){\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of item to be removed:\"); //prompt user for item name that want to be removed. \r\n    while (getchar() != '\\n'); //clear input buffer\r\n    scanf(\"%[^\\n]\", name); //read item name\r\n\r\n    //search for item to be removed using loop \r\n    for (int i=0; i< inventory-> count; i++){\r\n        \r\n        //when a match is found:\r\n        if (strcmp(inventory-> items[i].name, name)==0){\r\n            //shift all subsequent items to fill the gap \r\n            for (int j=i; j<inventory->count -1; j++){\r\n                inventory->items[j]= inventory->items[j+1];\r\n            }\r\n            inventory->count--; //decrease inventory count\r\n            printf(\"Item removed successfully!\\n\"); //display message that item is removed successfully\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found in inventory.\\n\"); //if item keyed in does not exist in inventory\r\n}\r\n\r\nint main(){\r\n    GroceryInventory inventory={.count =0}; //initialise an empty inventory\r\n    int choice; //variable to story user's menu choice\r\n    \r\n    while (1){ //main program loop\r\n        displayMenu(); //call function to display menu \r\n        printf(\"Enter your choice:\");//prompt user for inputting choice\r\n        scanf(\"%d\",&choice); //read user choice\r\n\r\n        //switch case \r\n        switch (choice){\r\n            \r\n            //choice 1: add item \r\n            case 1:\r\n                addItem(&inventory); //call function addItem\r\n                break;\r\n\r\n            //choice 2: list items\r\n            case 2:\r\n                listItems(&inventory); //call function listItems\r\n                break;\r\n\r\n            //chioce 3: update quantity\r\n            case 3:\r\n                updateQuantity(&inventory); //call function updateQuantity\r\n                break;\r\n\r\n            //Choice 4: remove item\r\n            case 4:\r\n                removeItem(&inventory); //call function to removeItem\r\n                break;\r\n\r\n            //Choice 5: exit program\r\n            case 5:\r\n                printf(\"Exiting program...\");\r\n                return 0; //exit program\r\n\r\n            //if choice other than 1-5\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");  //display error message.\r\n        }\r\n    \r\n    }\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for a Student\r\ntypedef struct Student {\r\n    char name[100];         //student name with a maximum size\r\n    int id;                 //student 's unique ID\r\n    float grade;            //student grade\r\n    struct Student* next;   //pointer to the next student in the list\r\n    } Student;\r\n\r\nStudent* head = NULL; //global head pointer for the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n// allocate memory for a new student:\r\n    Student *newStudent = (Student*)malloc(sizeof(Student));\r\n    \r\n    //check for memory allocation failure\r\n    if (newStudent ==NULL){\r\n        printf(\"Memory allocation failed \\n\"); //error message is failed\r\n        return NULL;\r\n    }\r\n    \r\n    //initialise the new student's data\r\n    strcpy(newStudent->name,name);  //copy the name\r\n    newStudent->id=id;              //set id\r\n    newStudent->grade =grade;       //set grade\r\n    newStudent->next =NULL;         //set the next pointer to NULL\r\n    return newStudent;              //return the new student node\r\n}\r\n\r\n// Function to insert a new student record at beginning of list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n// create a new student node\r\n    Student* newStudent= createStudent(name,id,grade);\r\n\r\n    //check if creation failed\r\n    if(newStudent ==NULL){\r\n        return;\r\n    }\r\n\r\n    //insert the new student at the head of list\r\n    newStudent->next=head;\r\n    head=newStudent;\r\n\r\n\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n // check if list is empty\r\n    if(head ==NULL){\r\n        printf(\"No student records found.\\n\"); //error message if list is empty\r\n        return;\r\n    }\r\n\r\n    //traverse the list and display each students details\r\n    Student* temp=head;\r\n    while(temp !=NULL){\r\n        printf(\"Name: %s, ID:%d, Grade: %.2f\\n\",temp->name, temp->id, temp->grade); //print all details\r\n        temp =temp->next; //move to next student\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n // traverse list to find student using the given ID\r\n    Student* temp=head;\r\n    while(temp !=NULL){\r\n        if (temp->id ==id){ //check if id matches\r\n            return temp; //return student if found\r\n        }\r\n        temp= temp->next; //not found then move to next student\r\n    }\r\n    return NULL; //return NULL if no student with the given ID is found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head; //start at the head of list\r\n    Student* next;\r\n\r\n    //free memory for each node in list\r\n    while (current != NULL) {\r\n    next = current->next;   //save the next node\r\n    free(current);          //free the current node\r\n    current = next;         //move to the next node\r\n    }\r\n    head = NULL; //set head pointer to NULL\r\n}\r\n\r\nvoid freeMemory() { //function to free all allocated memory\r\n deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n// check if list is empty\r\n    if(head ==NULL || head->next ==NULL){\r\n        return;//no need sort if list is empty or only have one element\r\n    }\r\n\r\n    //bubble sort implementation\r\n    Student* temp;\r\n    Student* i;\r\n    Student* j;\r\n    float tempGrade;    //temporary variable for swapping grades\r\n    char tempName[100];//temp varaible for swapping names\r\n    int tempID;         //temp variable for swapping IDs\r\n\r\n    //outer loop to iteerate through the list\r\n    for(i=head; i !=NULL; i=i->next){\r\n        //inner loop for comparisons\r\n        for(j=i->next; j!=NULL;j=j->next){\r\n            //compare grades and swap if out of order\r\n            if (i->grade > j->grade){\r\n                //swap student records\r\n                tempGrade= i->grade;\r\n                i->grade=j->grade;\r\n                j->grade=tempGrade;\r\n\r\n                //swap ids\r\n                tempID= i->id;\r\n                i->id=j->id;\r\n                j->id=tempID; \r\n\r\n                //swap names\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name,j->name);\r\n                strcpy(j->name,tempName);               \r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id; //variable for choice and ID\r\n    char name[100]; //buffer for student's name\r\n    float grade;//variable for student's grade\r\n\r\n    do { //main loop for menu\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");//prompt user for input of choice\r\n        scanf(\"%d\", &choice); //read user's choice\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n\r\n            //choice1- insert new student record\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin); //read name with spaces\r\n                strtok(name, \"\\n\"); //remove trailing newline\r\n                printf(\"Enter ID: \"); \r\n                scanf(\"%d\", &id);//read the ID\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade); //read Grade\r\n                insertStudent(name, id, grade); //call out function insertStudent \r\n                break;\r\n\r\n            //choice 2- display student records list\r\n            case 2:\r\n                displayStudents(); //call function to display all student records\r\n                break;\r\n\r\n            //choice3- sort students by grade\r\n            case 3:\r\n                sortStudents(); //call function sortStudents\r\n                break;\r\n\r\n            //choice 4- Search student by using ID\r\n            case 4:\r\n                printf(\"Enter ID to search: \"); //prompt user for ID\r\n                scanf(\"%d\", &id); //read ID\r\n                Student* found = searchStudentByID(id);  //call function searchStudentByID\r\n                if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                found->name, found->id, found->grade); //print student's details when match found\r\n                } else {\r\n                printf(\"Student not found.\\n\"); //error message when no student found \r\n                }\r\n                break;\r\n\r\n            //choice5- delete all student records\r\n            case 5:\r\n                deleteList(); //call function deleteList\r\n                printf(\"List deleted.\\n\");//display message that list has been deleted\r\n                break;\r\n\r\n            //choice 6- exit program\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            //handle invalid choice (not 1-6)\r\n            default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6); //repeat until user chooses to exit.\r\n    \r\n    return 0;\r\n} ",
    "feedback": "q1-the include directive for string manipulation should be #include <string.h> instead of #include <string.h.> \nq2-Meet requirement. \nq3-    The bubble sort implementation successfully sorts student records by grade. While bubble sort is easy to understand and implement, its time complexity of O(n?) can lead to inefficiency with larger datasets. For improved performance, consider using more efficient sorting algorithms, like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20720901",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_MATRIX 10\r\n\r\n// function prototype\r\nvoid printMenu();\r\nvoid matrixOperation(int rowsA, int columnsA, int matrixA[rowsA][columnsA], const int matrixB[rowsA][columnsA], const char operationType);\r\nvoid transposeMatrix(int rows, int columns, int matrix[rows][columns], const char matrixType);\r\n\r\n// print menu layout\r\nvoid printMenu()\r\n{\r\n  printf(\"Matrix Operations Menu: \\n\");\r\n  printf(\"1. Add Matrices\\n\");\r\n  printf(\"2. Subtract Matrices\\n\");\r\n  printf(\"3. Transpose Matrix A\\n\");\r\n  printf(\"4. Transpose Matrix B\\n\");\r\n  printf(\"5. Exit\\n\");\r\n}\r\n\r\n// add / subtract 2 matrix\r\nvoid matrixOperation(int rowsA, int columnsA, int matrixA[rowsA][columnsA], const int matrixB[rowsA][columnsA], const char operationType)\r\n{\r\n  // create a temp Matrix\r\n  int tempMatrix[rowsA][columnsA];\r\n\r\n  if (operationType == '+')\r\n  {\r\n    for (int i = 0; i < rowsA; i++)\r\n    {\r\n      for (int j = 0; j < columnsA; j++)\r\n      {\r\n        tempMatrix[i][j] = matrixA[i][j] + matrixB[i][j];\r\n      }\r\n    }\r\n  }\r\n  else if (operationType == '-')\r\n  {\r\n    for (int i = 0; i < rowsA; i++)\r\n    {\r\n      for (int j = 0; j < columnsA; j++)\r\n      {\r\n        tempMatrix[i][j] = matrixA[i][j] - matrixB[i][j];\r\n      }\r\n    }\r\n  }\r\n\r\n  printf(\"Result of Matrix A %c Matrix B: \\n\", operationType);\r\n  for (int i = 0; i < rowsA; i++)\r\n  {\r\n    for (int j = 0; j < columnsA; j++)\r\n    {\r\n      printf(\"%d \", tempMatrix[i][j]);\r\n    }\r\n    printf(\"\\n\");\r\n  }\r\n  printf(\"\\n\");\r\n}\r\n\r\n// transpose matrix\r\nvoid transposeMatrix(int rows, int columns, int matrix[rows][columns], const char matrixType)\r\n{\r\n  // Create a temporary matrix for the transpose\r\n  int tempMatrix[columns][rows];\r\n\r\n  // Compute the transpose\r\n  for (int i = 0; i < rows; i++)\r\n  {\r\n    for (int j = 0; j < columns; j++)\r\n    {\r\n      tempMatrix[j][i] = matrix[i][j];\r\n    }\r\n  }\r\n\r\n  // Print the transposed matrix\r\n  printf(\"Transpose of Matrix %c:\\n\", matrixType);\r\n  for (int i = 0; i < columns; i++)\r\n  {\r\n    for (int j = 0; j < rows; j++)\r\n    {\r\n      printf(\"%d \", tempMatrix[i][j]);\r\n    }\r\n    printf(\"\\n\");\r\n  }\r\n  printf(\"\\n\");\r\n}\r\n\r\n// allow user to input the size of the Matrix\r\nint rowsA = 0;\r\nint columnsA = 0;\r\nint rowsB = 0;\r\nint columnsB = 0;\r\n\r\nint main()\r\n{\r\n\r\n  while (1)\r\n  {\r\n    // first Matrix\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &columnsA);\r\n\r\n    // error handling for rowsA and columnsA(not more than 10)\r\n    if (rowsA > MAX_MATRIX && columnsA > MAX_MATRIX)\r\n    {\r\n      printf(\"Maximum matrix size is 10X10\\n\");\r\n      continue;\r\n    }\r\n\r\n    if (rowsA > MAX_MATRIX || columnsA > MAX_MATRIX)\r\n    {\r\n      printf(\"Maximum matrix row's size is 10\\n\");\r\n      continue;\r\n    }\r\n\r\n    if (rowsA < 1 || columnsA < 1)\r\n    {\r\n      printf(\"Minimum matrix row's size is 1\\n\");\r\n      continue;\r\n    }\r\n    // if size is within the range exit the loop\r\n    break;\r\n  }\r\n\r\n  int matrixA[rowsA][columnsA];\r\n  printf(\"Enter elements for Matrix A:\\n\");\r\n\r\n  for (int i = 0; i < rowsA; i++)\r\n  {\r\n    for (int j = 0; j < columnsA; j++)\r\n    {\r\n      printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n      scanf(\"%d\", &matrixA[i][j]);\r\n    }\r\n  }\r\n\r\n  while (1)\r\n  {\r\n    // first Matrix\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &columnsB);\r\n\r\n    // error handling for rowsA and columnsA(not more than 10)\r\n    if (rowsB > MAX_MATRIX && columnsB > MAX_MATRIX)\r\n    {\r\n      printf(\"Maximum matrix size is 10X10\\n\");\r\n      continue;\r\n    }\r\n\r\n    if (rowsA > MAX_MATRIX || columnsA > MAX_MATRIX)\r\n    {\r\n      printf(\"Maximum matrix row's size is 10\\n\");\r\n      continue;\r\n    }\r\n\r\n    if (rowsA < 1 || columnsA < 1)\r\n    {\r\n      printf(\"Minimum matrix row's size is 1\\n\");\r\n      continue;\r\n    }\r\n    // if size is within the range exit the loop\r\n    break;\r\n  }\r\n\r\n  int matrixB[rowsB][columnsB];\r\n  printf(\"Enter elements for Matrix B:\\n\");\r\n\r\n  for (int i = 0; i < rowsB; i++)\r\n  {\r\n    for (int j = 0; j < columnsB; j++)\r\n    {\r\n      printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n      scanf(\"%d\", &matrixB[i][j]);\r\n    }\r\n  }\r\n\r\n  while (1)\r\n  {\r\n    // operation menu\r\n    printMenu();\r\n\r\n    int choice;\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n\r\n    switch (choice)\r\n    {\r\n    case 1: // add\r\n      // see if two matrix size is same or not, if not then print error\r\n      if (rowsA != rowsB || columnsA != columnsB)\r\n      {\r\n        printf(\"Matrix's size is not compatible.\\n\\n\");\r\n        break;\r\n      }\r\n      matrixOperation(rowsA, columnsA, matrixA, matrixB, '+');\r\n      break;\r\n    case 2: // subtract\r\n      // see if two matrix size is same or not, if not then print error\r\n      if (rowsA != rowsB || columnsA != columnsB)\r\n      {\r\n        printf(\"Matrix's size is not compatible.\\n\\n\");\r\n        break;\r\n      }\r\n      matrixOperation(rowsA, columnsA, matrixA, matrixB, '-');\r\n      break;\r\n    case 3: // transpose Matrix A\r\n      transposeMatrix(rowsA, columnsA, matrixA, 'A');\r\n      break;\r\n    case 4: // transpose Matrix B\r\n      transposeMatrix(rowsB, columnsB, matrixB, 'B');\r\n      break;\r\n    case 5: // Exit\r\n      printf(\"Exiting...\");\r\n      exit(0); // exit with success code\r\n      break;\r\n    default:\r\n      printf(\"Invalid input...\\n\");\r\n      break;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\n/* --- q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct\r\n{\r\n  char name[101];\r\n  char category[51];\r\n  int quantity;\r\n  float price;\r\n} Item;\r\n\r\ntypedef union\r\n{\r\n  int InStock;\r\n  int OutOfStock;\r\n} Availability;\r\n\r\ntypedef struct\r\n{\r\n  Item itemArr[100];\r\n  Availability availArr[100];\r\n  int count; // total number of grocery items[index]\r\n} Inventory;\r\n\r\n// function prototype\r\nvoid printMenu();\r\nvoid addGrocery(Inventory *inventoryItem);\r\nvoid listAllItems(Inventory *inventoryItem);\r\nvoid updateQuantity(Inventory *inventoryItem);\r\nvoid removeGrocery(Inventory *inventoryItem);\r\n\r\nvoid printMenu()\r\n{\r\n  printf(\"Grocery Inventory Management System\\n\");\r\n  printf(\"1. Add Grocery Item\\n\");\r\n  printf(\"2. List All Grocery Items\\n\");\r\n  printf(\"3. Update Quantity\\n\");\r\n  printf(\"4. Remove Grocery Item\\n\");\r\n  printf(\"5. Exit\\n\");\r\n}\r\n\r\nvoid addGrocery(Inventory *inventoryItem)\r\n{\r\n  if (inventoryItem->count >= 100)\r\n  {\r\n    printf(\"Inventory full...\");\r\n    return;\r\n  }\r\n\r\n  char inputName[101];\r\n  char inputCategory[51];\r\n  int inputQuantity;\r\n  float inputPrice;\r\n\r\n  while (1)\r\n  {\r\n    printf(\"Enter Item Name: \");\r\n    fgets(inputName, 101, stdin);\r\n    inputName[strcspn(inputName, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(inputCategory, 51, stdin);\r\n    inputCategory[strcspn(inputCategory, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &inputQuantity);\r\n\r\n    if (inputQuantity < 0)\r\n    {\r\n      printf(\"quantity cannot less than 0.\\n\");\r\n      continue;\r\n    }\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &inputPrice);\r\n\r\n    if (inputPrice < 0)\r\n    {\r\n      printf(\"price cannot less than 0.\\n\");\r\n      continue;\r\n    }\r\n    break;\r\n  }\r\n\r\n  Item newItem;\r\n  strcpy(newItem.name, inputName);\r\n  strcpy(newItem.category, inputCategory);\r\n  newItem.quantity = inputQuantity;\r\n  newItem.price = inputPrice;\r\n\r\n  // check if quantity of product is more than 0\r\n  if (inputQuantity > 0)\r\n  {\r\n    inventoryItem->availArr[inventoryItem->count].InStock = 1;\r\n  }\r\n  else\r\n  {\r\n    inventoryItem->availArr[inventoryItem->count].OutOfStock = 1;\r\n  }\r\n\r\n  // add item into array\r\n  inventoryItem->itemArr[inventoryItem->count++] = newItem;\r\n\r\n  printf(\"Grocery Item added successfully!\\n\\n\");\r\n}\r\n\r\nvoid listAllItems(Inventory *inventoryItem)\r\n{\r\n  int index = inventoryItem->count;\r\n  if (index == 0)\r\n  {\r\n    printf(\"No grocery items in the inventory.\\n\\n\");\r\n    return;\r\n  }\r\n\r\n  for (int i = 0; i < index; i++)\r\n  {\r\n    printf(\"Name: %s\\n\", inventoryItem->itemArr[i].name);\r\n    printf(\"Category: %s\\n\", inventoryItem->itemArr[i].category);\r\n    printf(\"Quantity: %d\\n\", inventoryItem->itemArr[i].quantity);\r\n    printf(\"Price: %.2f\\n\", inventoryItem->itemArr[i].price);\r\n\r\n    if (inventoryItem->itemArr[i].quantity > 0)\r\n    {\r\n      printf(\"Status: %s\\n\", inventoryItem->availArr[i].InStock == 1 ? \"In Stock\\n\" : \"Error\\n\");\r\n    }\r\n    else\r\n    {\r\n      printf(\"Status: %s\\n\", inventoryItem->availArr[i].OutOfStock == 1 ? \"Out of Stock\\n\" : \"Error\\n\");\r\n    }\r\n  }\r\n}\r\n\r\nvoid updateQuantity(Inventory *inventoryItem)\r\n{\r\n  // ask for input\r\n  char inputName[101];\r\n  printf(\"Enter name of the grocery item to update quantity: \");\r\n  fgets(inputName, 101, stdin);\r\n  inputName[strcspn(inputName, \"\\n\")] = '\\0';\r\n\r\n  for (int i = 0; i < inventoryItem->count; i++)\r\n  {\r\n    // check if name and inputName is same or not\r\n    if (strcmp(inventoryItem->itemArr[i].name, inputName) == 0)\r\n    {\r\n      int inputQuantity;\r\n      printf(\"Enter new quantity for %s: \", inventoryItem->itemArr[i].name);\r\n      scanf(\"%d\", &inputQuantity);\r\n      getchar();\r\n\r\n      if (inputQuantity < 0)\r\n      {\r\n        printf(\"Quantity cannot less than 0.\\n\");\r\n        return;\r\n      }\r\n\r\n      // check if quantity of product is more than 0\r\n      if (inputQuantity > 0)\r\n      {\r\n        inventoryItem->availArr[i].InStock = 1;\r\n      }\r\n      else\r\n      {\r\n        inventoryItem->availArr[i].OutOfStock = 1;\r\n      }\r\n      inventoryItem->itemArr[i].quantity = inputQuantity;\r\n      printf(\"Quantity updated successfully!\\n\");\r\n      return;\r\n    }\r\n  }\r\n\r\n  printf(\"No Item Found...\\n\");\r\n}\r\n\r\nvoid removeGrocery(Inventory *inventoryItem)\r\n{\r\n  // ask for input\r\n  char inputName[101];\r\n  printf(\"Enter name of the grocery item to remove: \");\r\n  fgets(inputName, 101, stdin);\r\n  inputName[strcspn(inputName, \"\\n\")] = '\\0';\r\n\r\n  for (int i = 0; i < inventoryItem->count; i++)\r\n  {\r\n    // check if name and inputName is same or not\r\n    if (strcmp(inventoryItem->itemArr[i].name, inputName) == 0)\r\n    {\r\n      // shift following items\r\n      for (int j = i; j < inventoryItem->count; j++)\r\n      {\r\n        inventoryItem->itemArr[j] = inventoryItem->itemArr[j + 1];\r\n        inventoryItem->availArr[j] = inventoryItem->availArr[j + 1];\r\n      }\r\n      inventoryItem->count--;\r\n      printf(\"Grocery item '%s' removed successfully!\\n\", inputName);\r\n      return;\r\n    }\r\n  }\r\n  printf(\"No Item Found...\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n  Inventory inventoryItem;\r\n  // initialize total items to 0\r\n  inventoryItem.count = 0;\r\n\r\n  while (1)\r\n  {\r\n    printMenu();\r\n    int choice;\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar();\r\n\r\n    switch (choice)\r\n    {\r\n    case 1: // add\r\n      addGrocery(&inventoryItem);\r\n      break;\r\n    case 2: // list All\r\n      listAllItems(&inventoryItem);\r\n      break;\r\n    case 3: // update quantity\r\n      updateQuantity(&inventoryItem);\r\n      break;\r\n    case 4: // remove item\r\n      removeGrocery(&inventoryItem);\r\n      break;\r\n    case 5: // exit\r\n      printf(\"Exit...\");\r\n      exit(0);\r\n      break;\r\n    default:\r\n      printf(\"Invalid Input...\");\r\n      break;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\n/* --- q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student\r\n{\r\n  char name[100];\r\n  int id;\r\n  float grade;\r\n  struct Student *next;\r\n} Student;\r\nStudent *head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent *createStudent(const char *name, int id, float grade)\r\n{\r\n  // Write your code (1 mark)\r\n  Student *newStu = (Student *)malloc(sizeof(Student));\r\n  if (!newStu)\r\n  {\r\n    printf(\"Fail to allocate memory...\\n\");\r\n    return NULL;\r\n  }\r\n\r\n  strcpy(newStu->name, name);\r\n  newStu->id = id;\r\n  newStu->grade = grade;\r\n  newStu->next = NULL;\r\n\r\n  printf(\"\\n\");\r\n\r\n  return newStu;\r\n}\r\n// Function to insert a new student record\r\nvoid insertStudent(const char *name, int id, float grade)\r\n{\r\n  // Write your code (1 mark)\r\n  Student *newStu = createStudent(name, id, grade);\r\n  // if no Student return\r\n  if (!newStu)\r\n  {\r\n    printf(\"Error occurred when insert Student\");\r\n    return;\r\n  }\r\n\r\n  // no student in the list\r\n  if (head == NULL)\r\n  {\r\n    head = newStu;\r\n  }\r\n  else\r\n  {\r\n    Student *firstStu = head;\r\n    // loop until last node\r\n    while (firstStu->next != NULL)\r\n    {\r\n      firstStu = firstStu->next;\r\n    }\r\n    firstStu->next = newStu;\r\n  }\r\n}\r\n// Function to display all student records\r\nvoid displayStudents()\r\n{\r\n  // Write your code (1 mark)\r\n  Student *currentStu = head;\r\n  if (!currentStu)\r\n  {\r\n    printf(\"No student found\\n\");\r\n    return;\r\n  }\r\n\r\n  while (currentStu)\r\n  {\r\n    printf(\"Name: %s, ID: %li, Grade: %.2f\\n\", currentStu->name, currentStu->id, currentStu->grade);\r\n    currentStu = currentStu->next;\r\n  }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent *searchStudentByID(int id)\r\n{\r\n  // Write your code (1 mark)\r\n  Student *currentStu = head;\r\n  while (currentStu != NULL)\r\n  {\r\n    if (currentStu->id == id)\r\n    {\r\n      return currentStu;\r\n    }\r\n    currentStu = currentStu->next;\r\n  }\r\n\r\n  return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList()\r\n{\r\n  Student *current = head;\r\n  Student *next;\r\n  while (current != NULL)\r\n  {\r\n    next = current->next;\r\n    free(current);\r\n    current = next;\r\n  }\r\n  head = NULL;\r\n}\r\n\r\nvoid freeMemory()\r\n{\r\n  deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents()\r\n{\r\n  // Write your code (1 mark)\r\n  // store number of student in linked list\r\n  int length = 0;\r\n  Student *current = head;\r\n  while (current != NULL)\r\n  {\r\n    length++;\r\n    current = current->next;\r\n  }\r\n\r\n  int index = 0;\r\n  int flag;\r\n\r\n  while (index < length)\r\n  {\r\n    Student *nextNode = head;\r\n    Student *prevNode = head;\r\n    flag = 0;\r\n\r\n    while (nextNode->next != NULL)\r\n    {\r\n      Student *ptr = nextNode->next;\r\n      if (nextNode->grade > ptr->grade)\r\n      {\r\n        flag = 1;\r\n        // swap\r\n        if (nextNode == head)\r\n        {\r\n          nextNode->next = ptr->next;\r\n          ptr->next = nextNode;\r\n          prevNode = ptr;\r\n          head = prevNode;\r\n        }\r\n        else\r\n        {\r\n          nextNode->next = ptr->next;\r\n          ptr->next = nextNode;\r\n          prevNode->next = ptr;\r\n          prevNode = ptr;\r\n        }\r\n        continue;\r\n      }\r\n      prevNode = nextNode;\r\n      nextNode = nextNode->next;\r\n    }\r\n\r\n    // If no swap occurred, break the loop\r\n    if (!flag)\r\n    {\r\n      break;\r\n    }\r\n\r\n    ++index;\r\n  }\r\n  printf(\"Records sorted by grade using Bubble Sort.\\n\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main()\r\n{\r\n  int choice, id;\r\n  char name[100];\r\n  float grade;\r\n  do\r\n  {\r\n    printf(\"\\n1. Insert Student Record\\n\");\r\n    printf(\"2. Display Student Records\\n\");\r\n    printf(\"3. Sort Records (Bubble sort)\\n\");\r\n    printf(\"4. Search Record by ID\\n\");\r\n    printf(\"5. Delete List\\n\");\r\n    printf(\"6. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n    getchar(); // To consume the newline character\r\n    switch (choice)\r\n    {\r\n    case 1:\r\n      printf(\"Enter Name: \");\r\n      fgets(name, sizeof(name), stdin);\r\n      strtok(name, \"\\n\");\r\n      printf(\"Enter ID: \");\r\n      scanf(\"%d\", &id);\r\n      printf(\"Enter Grade: \");\r\n      scanf(\"%f\", &grade);\r\n      insertStudent(name, id, grade);\r\n      break;\r\n    case 2:\r\n      displayStudents();\r\n      break;\r\n    case 3:\r\n      sortStudents();\r\n      break;\r\n    case 4:\r\n      printf(\"Enter ID to search: \");\r\n      scanf(\"%d\", &id);\r\n      Student *found = searchStudentByID(id);\r\n      if (found)\r\n      {\r\n        printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n               found->name, found->id, found->grade);\r\n      }\r\n      else\r\n      {\r\n        printf(\"Student not found.\\n\");\r\n      }\r\n      break;\r\n    case 5:\r\n      deleteList();\r\n      printf(\"List deleted.\\n\");\r\n      break;\r\n    case 6:\r\n      freeMemory();\r\n      printf(\"Exiting...\\n\");\r\n      break;\r\n    default:\r\n      printf(\"Invalid choice! Please try again.\\n\");\r\n    }\r\n  } while (choice != 6);\r\n  return 0;\r\n}",
    "feedback": "q1-The condition for checking dimensions in the second matrix input is incorrect.  This should check rowsB and columnsB instead.\nq2-In the removeGrocery function, when shifting items after removal, the loop should run until inventoryItem->count - 1 to prevent accessing out of bounds.\nq3-    The program implements bubble sort to sort student records by grade. While the algorithm is effective for small datasets, its time complexity of O(n?) makes it inefficient for larger datasets. Consider implementing a more efficient sorting algorithm, such as Quick Sort or Merge Sort, for better performance."
  },
  {
    "student_id": "20615192",
    "code": "\n/* --- 20615192 Ang Shi Neng Lab3/20615192 Ang Shi Neng Lab3/Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid handleAddition(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rowsA, int colsA, int rowsB, int colsB);\r\nvoid handleSubtraction(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rowsA, int colsA, int rowsB, int colsB);\r\nvoid handleTranspose(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\n\r\nint main() {\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input dimensions and elements for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    while (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsA <= 0 || colsA <= 0) {\r\n        printf(\"Invalid dimensions. Please enter dimensions (1-10): \");\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n    }\r\n    inputMatrix(matrixA, rowsA, colsA, 'A');\r\n\r\n    // Input dimensions and elements for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    while (rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid dimensions. Please enter dimensions (1-10): \");\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n    }\r\n    inputMatrix(matrixB, rowsB, colsB, 'B');\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                handleAddition(matrixA, matrixB, rowsA, colsA, rowsB, colsB);\r\n                break;\r\n            case 2:\r\n                handleSubtraction(matrixA, matrixB, rowsA, colsA, rowsB, colsB);\r\n                break;\r\n            case 3:\r\n                handleTranspose(matrixA, rowsA, colsA, 'A');\r\n                break;\r\n            case 4:\r\n                handleTranspose(matrixB, rowsB, colsB, 'B');\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid handleAddition(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rowsA, int colsA, int rowsB, int colsB) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    if (rowsA == rowsB && colsA == colsB) {\r\n        addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n        printf(\"Result of Matrix A + Matrix B:\\n\");\r\n        printMatrix(result, rowsA, colsA);\r\n    } else {\r\n        printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n    }\r\n}\r\n\r\nvoid handleSubtraction(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int rowsA, int colsA, int rowsB, int colsB) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    if (rowsA == rowsB && colsA == colsB) {\r\n        subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n        printf(\"Result of Matrix A - Matrix B:\\n\");\r\n        printMatrix(result, rowsA, colsA);\r\n    } else {\r\n        printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n    }\r\n}\r\n\r\nvoid handleTranspose(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    transposeMatrix(matrix, result, rows, cols);\r\n    printf(\"Transpose of Matrix %c:\\n\", name);\r\n    printMatrix(result, cols, rows);\r\n}\r\n\n/* --- 20615192 Ang Shi Neng Lab3/20615192 Ang Shi Neng Lab3/Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define max_name_length 100\r\n#define max_category_length 50\r\n#define max_item 100\r\n\r\ntypedef struct {\r\n    char name[max_name_length];\r\n    char category[max_category_length];\r\n    int quantity;\r\n    float price;\r\n    int stock;\r\n} grocery_item;\r\n\r\ngrocery_item gI[max_item];\r\nint item_count = 0;\r\n\r\nvoid addItem() {\r\n    if (item_count >= max_item) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    grocery_item newItem;\r\n\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", newItem.name);\r\n    if (strlen(newItem.name) >= max_name_length) {\r\n        printf(\"Name too long. Please enter a shorter name.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", newItem.category);\r\n    if (strlen(newItem.category) >= max_category_length) {\r\n        printf(\"Category too long. Please enter a shorter category.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter Quantity: \");\r\n    if (scanf(\"%d\", &newItem.quantity) != 1) {\r\n        printf(\"Invalid input for quantity. Please enter an integer.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter Price: \");\r\n    if (scanf(\"%f\", &newItem.price) != 1) {\r\n        printf(\"Invalid input for price. Please enter a floating-point number.\\n\");\r\n        while (getchar() != '\\n'); // Clear input buffer\r\n        return;\r\n    }\r\n\r\n    newItem.stock = newItem.quantity > 0 ? 1 : 0;\r\n\r\n    gI[item_count] = newItem;\r\n    item_count++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listItems() {\r\n    if (item_count == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        grocery_item item = gI[i];\r\n        printf(\"Name: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Status: %s\\n\\n\", item.stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char name[max_name_length];\r\n    printf(\"Enter the name of the item to update: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(gI[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            if (scanf(\"%d\", &gI[i].quantity) != 1) {\r\n                printf(\"Invalid input for quantity. Please enter an integer.\\n\");\r\n                while (getchar() != '\\n'); // Clear input buffer\r\n                return;\r\n            }\r\n\r\n            gI[i].stock = gI[i].quantity > 0 ? 1 : 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nvoid removeItem() {\r\n    char name[max_name_length];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    scanf(\" %[^\\n]\", name);\r\n\r\n    for (int i = 0; i < item_count; i++) {\r\n        if (strcmp(gI[i].name, name) == 0) {\r\n            for (int j = i; j < item_count - 1; j++) {\r\n                gI[j] = gI[j + 1];\r\n            }\r\n\r\n            // Clear the last item's memory\r\n            memset(&gI[item_count - 1], 0, sizeof(grocery_item));\r\n\r\n            item_count--;\r\n            printf(\"Grocery item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n            while (getchar() != '\\n'); // Clear input buffer\r\n            continue;\r\n        }\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem();\r\n                break;\r\n            case 2:\r\n                listItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- 20615192 Ang Shi Neng Lab3/20615192 Ang Shi Neng Lab3/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Head pointer for the linked list\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = NULL;\r\n\r\n    do {\r\n        newStudent = (Student*)malloc(sizeof(Student));\r\n        if (!newStudent) {\r\n            printf(\"Memory allocation failed! Retrying...\\n\");\r\n        }\r\n    } while (!newStudent);\r\n\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\r\n    newStudent->name[sizeof(newStudent->name) - 1] = '\\0';  // Ensures null-termination\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n\r\n// Function to insert a new student at the beginning of the list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    for (Student* current = head; current != NULL; current = current->next) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    if (head == NULL) {\r\n        return NULL;\r\n    }\r\n\r\n    Student* current = head;\r\n    do {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    } while (current != NULL);\r\n\r\n    return NULL;\r\n}\r\n\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n    printf(\"All records have been deleted.\\n\");\r\n}\r\n\r\n// Bubble Sort function to sort students by grade\r\nvoid sortStudents() {\r\n    if (!head || !head->next) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* ptr2 = NULL;\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n        while (ptr1->next != ptr2) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                float tempGrade = ptr1->grade;\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                int tempID = ptr1->id;\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->next->id = tempID;\r\n\r\n                char tempName[100];\r\n                strncpy(tempName, ptr1->name, sizeof(tempName));\r\n                strncpy(ptr1->name, ptr1->next->name, sizeof(ptr1->name));\r\n                strncpy(ptr1->next->name, tempName, sizeof(ptr1->next->name));\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        ptr2 = ptr1;\r\n    } while (swapped);\r\n    printf(\"Records sorted by grade.\\n\");\r\n}\r\n\r\n// Main function to manage menu options\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    while (1) {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                name[strcspn(name, \"\\n\")] = 0; // Remove trailing newline\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting program.\\n\");\r\n                return 0;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to sort student records by grade. While this method is straightforward, it has a time complexity of O(n?), which can be inefficient for larger datasets. For improved performance, consider using more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20488702",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n#define ALLOCATE_MATRIX(rows, columns) (int**)malloc(rows * sizeof(int*) + rows * columns * sizeof(int))\r\n\r\n// Function prototypes\r\n\r\nvoid addMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid subtractMatrices(int rows, int cols, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]);\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\r\nvoid printMatrix(int rows, int cols, int matrix[MAX_SIZE][MAX_SIZE]);\r\n\r\n// Function to add \r\nvoid addMatrices(int rows, int columns, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract \r\nvoid subtractMatrices(int rows, int columns, int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose \r\nvoid transposeMatrix(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to input elements of a matrix\r\nvoid inputMatrix(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int rows, int columns, int matrix[MAX_SIZE][MAX_SIZE]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, columnsA, rowsB, columnsB;\r\n    int matrixA, matrixB;\r\n    int choice;\r\n\r\n    // Input for matrix A and B\r\n  printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n  scanf(\"%d %d\", &rowsA, &columnsA);\r\n  while (getchar() != '\\n'); //clear buffer\r\n\r\n  printf(\"Enter elements for Matrix A:\\n\");\r\n  inputMatrix(rowsA, columnsA, a);\r\n\r\n  printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\r\n  scanf(\"%d %d\", &rowsB, &columnsB);\r\n  while (getchar() != '\\n');\r\n\r\n  printf(\"Enter elements for Matrix B:\\n\");\r\n  inputMatrix(rowsB, columnsB, b);\r\n\r\n  //menu\r\n  do {\r\n    printf(\"\\nMatrix Operations Menu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    printf(\"Enter your choice: \");\r\n    scanf(\"%d\", &choice);\r\n\r\n    switch (choice) {\r\n      case 1:\r\n        if (rowsA == rowsB && columnsA == columnsB) {\r\n          addMatrices(rowsA, columnsA, a, b, result);\r\n          printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n          printMatrix(rowsA, columnsA, result);\r\n        } else {\r\n          printf(\"Error: Matrices must have same dimensions to add.\\n\");\r\n        }\r\n        break;\r\n\r\n      case 2:\r\n        if (rowsA == rowsB && columnsA == columnsB) {\r\n          subtractMatrices(rowsA, columnsA, a, b, result);\r\n          printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n          printMatrix(rowsA, columnsA, result);\r\n        } else {\r\n          printf(\"Error: Matrices must have same dimensions to subtract.\\n\");\r\n        }\r\n        break;\r\n\r\n      case 3:\r\n        transposeMatrix(rowsA, columnsA, a, result);\r\n        printf(\"\\nTranspose of Matrix A:\\n\");\r\n        printMatrix(columnsA, rowsA, result);\r\n        break;\r\n\r\n      case 4:\r\n        transposeMatrix(rowsB, columnsB, b, result);\r\n        printf(\"\\nTranspose of Matrix B:\\n\");\r\n        printMatrix(columnsB, rowsB, result);\r\n        break;\r\n\r\n      case 5:\r\n        printf(\"Exiting....\\n\");\r\n        break;\r\n\r\n      default:\r\n        printf(\"Invalid choice. Please try again.\\n\");\r\n    }\r\n  } while (choice != 5);\r\n\r\n  return 0;\r\n}\r\n\r\n//End of program\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// struct for grocery item\r\ntypedef struct {\r\n    char name[100], category[50];\r\n    int quantity;\r\n    float price;\r\n    int in_stock;  \r\n} GroceryItem;\r\n\r\n// struct for grocery inv\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int total_items;\r\n} GroceryInv;\r\n\r\n// fucntion for menu commmands\r\nvoid addGroceryItem(GroceryInv *inv);\r\nvoid listGroceryItems(const GroceryInv *inv);\r\nvoid updateQuantity(GroceryInv *inv);\r\nvoid displayMenu();\r\n\r\nint main() {\r\n    GroceryInv inv = {0};\r\n    int choice;\r\n\r\n    while (1) {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        if (choice == 1) addGroceryItem(&inv);\r\n        else if (choice == 2) listGroceryItems(&inv);\r\n        else if (choice == 3) updateQuantity(&inv);\r\n        else if (choice == 4) removeGroceryitem(&inv);\r\n        else if (choice == 5) break;\r\n        else printf(\"Invalid choice! Try again.\\n\");\r\n    }\r\n\r\n    printf(\"Exiting...\\n\");\r\n    return 0;\r\n}\r\n\r\n// menu\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    rpintf(\"Remove grocery Item\\n\");// it doesnt workkkkk\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Add a new grocery item\r\nvoid addGroceryItem(GroceryInv *inv) {\r\n    if (inv->total_items >= MAX_ITEMS) {\r\n        printf(\"Inventory full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", newItem.name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", newItem.category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    newItem.in_stock = (newItem.quantity > 0);  \r\n    inv->items[inv->total_items++] = newItem;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// List all grocery items\r\nvoid listGroceryItems(const GroceryInv *inv) {\r\n    if (!inv->total_items) {\r\n        printf(\"No items in inv.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inv->total_items; i++) {\r\n        GroceryItem item = inv->items[i];\r\n        printf(\"\\nName: %s\\nCategory: %s\\nQuantity: %d\\nPrice: %.2f\\nStatus: %s\\n\", \r\n               item.name, item.category, item.quantity, item.price, \r\n               item.in_stock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Update the quantity of gorcery items\r\nvoid updateQuantity(GroceryInv *inv) {\r\n    char itemName[100];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", itemName);\r\n\r\n    for (int i = 0; i < inv->total_items; i++) {\r\n        if (strcmp(inv->items[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity for %s: \", itemName);\r\n            scanf(\"%d\", &inv->items[i].quantity);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found!\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy((*newStudent).name, name);\r\n    (*newStudent).id = id;\r\n    (*newStudent).grade = grade;\r\n    (*newStudent).next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        (*newStudent).next = head;\r\n        head = newStudent;\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", (*current).name, (*current).id, (*current).grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if ((*current).id == id && (*current).grade >= 0) {\r\n            return current;\r\n        }\r\n        current = (*current).next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = (*current).next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using Insertion Sort\r\nvoid sortStudents() {\r\n    \r\n\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        while (getchar() != '\\n');\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", (*found).name, (*found).id, (*found).grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-In the displayMenu function, there is a typo: rpintf should be corrected to printf.The removeGroceryitem function is referenced in the main function but is not defined anywhere in the code, leading to a compilation error.\nq3-The sorting function is currently empty. Once implemented, Insertion Sort is a reasonable choice for sorting linked lists as it can efficiently handle small datasets and maintains a sorted list without requiring additional memory."
  },
  {
    "student_id": "20715043",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX_SIZE 10\r\n\r\n// Functions\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    // ask for the rows and columns of matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // ask for elements of matrix A\r\n    printf(\"Enter the elements of Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    // ask for the rows and columns of matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // ask for element of matrix B\r\n    printf(\"Enter the elements of Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    while (1) {\r\n        // Display menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {    //switch case\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error, not same dimension.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error, not same dimension.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"\\nInvalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {     //display function\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {    //addition function\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {   //substracting function\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {    //transpose function\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#define MAX_ITEMS 100\r\n\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus status[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Functions\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory = {.count = 0};\r\n    int choice;\r\n\r\n    while (1) {    //menu\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Emter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[inventory->count];\r\n    AvailabilityStatus *status = &inventory->status[inventory->count];\r\n\r\n    getchar();\r\n    printf(\"Enter item name: \");    //ask for item name\r\n    fgets(item->name, sizeof(item->name), stdin);   //store item name\r\n    item->name[strcspn(item->name, \"\\n\")] = '\\0';\r\n    printf(\"Enter category: \");     //ask for item category\r\n    fgets(item->category, sizeof(item->category), stdin);    //store item category\r\n    item->category[strcspn(item->category, \"\\n\")] = '\\0';\r\n    printf(\"Enter Quantity: \");     //ask for quantity\r\n    scanf(\"%d\", &item->quantity);    //store the quantity\r\n    printf(\"Enter price: \");         //ask for price\r\n    scanf(\"%f\", &item->price);        //store price\r\n\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = item->quantity == 0;\r\n\r\n    inventory->count++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems(GroceryInventory *inventory) {       //display list function\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        GroceryItem *item = &inventory->items[i];\r\n        AvailabilityStatus *status = &inventory->status[i];\r\n\r\n        printf(\"Name: %s\\n\", item->name);\r\n        printf(\"Category: %s\\n\", item->category);\r\n        printf(\"Quantity: %d\\n\", item->quantity);\r\n        printf(\"Price: %.2f\\n\", item->price);\r\n        printf(\"Status: %s\\n\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory *inventory) {    //update function\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[100];\r\n    getchar();\r\n    printf(\"Enter name of the grocery item to update quantity: \");   //ask for the name to update quantity\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    int itemIndex = -1;\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            itemIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    if (itemIndex == -1) {\r\n        printf(\"Item '%s' not found in inventory.\\n\", itemName);\r\n        return;\r\n    }\r\n\r\n    int newQuantity;\r\n    printf(\"Enter new quantity for %s: \", itemName);             //ask for new quantity\r\n    while (scanf(\"%d\", &newQuantity) != 1) {\r\n        printf(\"Invalid input. Please enter an integer for quantity: \");\r\n        while (getchar() != '\\n');\r\n    }\r\n\r\n    GroceryItem *item = &inventory->items[itemIndex];\r\n    AvailabilityStatus *status = &inventory->status[itemIndex];\r\n\r\n    item->quantity = newQuantity;\r\n    status->inStock = newQuantity > 0;\r\n    status->outOfStock = newQuantity == 0;\r\n\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory *inventory) {    //remove grocery item function\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemName[100];\r\n    getchar(); \r\n    printf(\"Enter name of the grocery item to remove: \");      //ask for name of grocery\r\n    fgets(itemName, sizeof(itemName), stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\r\n\r\n    int itemIndex = -1;\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\r\n            itemIndex = i;\r\n            break;\r\n        }\r\n    }\r\n    if (itemIndex == -1) {\r\n        printf(\"Item '%s' not found in inventory.\\n\", itemName);\r\n        return;\r\n    }\r\n    for (int i = itemIndex; i < inventory->count - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n        inventory->status[i] = inventory->status[i + 1];\r\n    }\r\n\r\n    inventory->count--;\r\n    printf(\"Grocery item '%s' removed successfully!\\n\", itemName);\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(1);\r\n    }\r\n    strncpy(newStudent->name, name, sizeof(newStudent->name) - 1);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Function to free all memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;  // No need to sort if the list is empty or has only one student\r\n    }\r\n\r\n    Student* i;\r\n    Student* j;\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                // Swap grades, IDs, and names\r\n                float tempGrade = i->grade;\r\n                int tempID = i->id;\r\n                char tempName[100];\r\n                strncpy(tempName, i->name, sizeof(tempName) - 1);\r\n\r\n                i->grade = j->grade;\r\n                i->id = j->id;\r\n                strncpy(i->name, j->name, sizeof(i->name) - 1);\r\n\r\n                j->grade = tempGrade;\r\n                j->id = tempID;\r\n                strncpy(j->name, tempName, sizeof(j->name) - 1);\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);  //To consume the newline character\r\n        getchar();\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While bubble sort is simple and effective for small datasets, it has a time complexity of O(n?), which can become inefficient as the number of records increases. For larger datasets, consider using more efficient algorithms such as Quick Sort or Merge Sort."
  },
  {
    "student_id": "20611657",
    "code": "\n/* --- question1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10 // Define the maximum size for the matrix as 10x10\r\n\r\n// Function to take input for a matrix\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { // Loop through each row\r\n        for (int j = 0; j < cols; j++) { // Loop through each column\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1); // Prompt user to enter matrix element\r\n            scanf(\"%d\", &matrix[i][j]); // Store the input in the matrix\r\n        }\r\n    }\r\n}\r\n\r\n// Function to print a matrix\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { // Loop through each row\r\n        for (int j = 0; j < cols; j++) { // Loop through each column\r\n            printf(\"%d \", matrix[i][j]); // Print the element at the current position\r\n        }\r\n        printf(\"\\n\"); // Move to the next line after each row\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int C[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { // Loop through each row\r\n        for (int j = 0; j < cols; j++) { // Loop through each column\r\n            C[i][j] = A[i][j] + B[i][j]; // Add corresponding elements of A and B\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract one matrix from another\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int C[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { // Loop through each row\r\n        for (int j = 0; j < cols; j++) { // Loop through each column\r\n            C[i][j] = A[i][j] - B[i][j]; // Subtract corresponding elements of B from A\r\n        }\r\n    }\r\n}\r\n\r\n// Function to compute the transpose of a matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int transposed[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) { // Loop through each row\r\n        for (int j = 0; j < cols; j++) { // Loop through each column\r\n            transposed[j][i] = matrix[i][j]; // Assign the element at (i, j) to (j, i)\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX]; // Declare matrices A, B, and result\r\n    int rowsA, colsA, rowsB, colsB; // Variables to store dimensions of A and B\r\n    int choice; // Variable to store user's menu choice\r\n\r\n    // Input dimensions of matrix A\r\n    printf(\"Enter rows and columns of matrix A (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Input dimensions of matrix B\r\n    printf(\"Enter rows and columns of matrix B (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Check if dimensions match for addition and subtraction\r\n    if (rowsA != rowsB || colsA != colsB) {\r\n        printf(\"Addition and subtraction require matrices of the same dimensions.\\n\");\r\n    }\r\n\r\n    // Input elements for matrix A\r\n    printf(\"Enter elements for matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // Input elements for matrix B\r\n    printf(\"Enter elements for matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    // Menu-driven program to perform matrix operations\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: // Add matrices\r\n                if (rowsA == rowsB && colsA == colsB) { // Ensure dimensions match\r\n                    addMatrices(A, B, result, rowsA, colsA); // Call addition function\r\n                    printf(\"Result of Addition:\\n\");\r\n                    printMatrix(result, rowsA, colsA); // Print the result\r\n                } else {\r\n                    printf(\"Cannot perform addition due to mismatched dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 2: // Subtract matrices\r\n                if (rowsA == rowsB && colsA == colsB) { // Ensure dimensions match\r\n                    subtractMatrices(A, B, result, rowsA, colsA); // Call subtraction function\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    printMatrix(result, rowsA, colsA); // Print the result\r\n                } else {\r\n                    printf(\"Cannot perform subtraction due to mismatched dimensions.\\n\");\r\n                }\r\n                break;\r\n            case 3: // Transpose matrix A\r\n                transposeMatrix(A, result, rowsA, colsA); // Call transpose function\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                printMatrix(result, colsA, rowsA); // Print the transposed matrix\r\n                break;\r\n            case 4: // Transpose matrix B\r\n                transposeMatrix(B, result, rowsB, colsB); // Call transpose function\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                printMatrix(result, colsB, rowsB); // Print the transposed matrix\r\n                break;\r\n            case 5: // Exit the program\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default: // Handle invalid menu choices\r\n                printf(\"Invalid choice!\\n\");\r\n        }\r\n    } while (choice != 5); // Repeat until the user chooses to exit\r\n\r\n    return 0; // Exit the program\r\n}\r\n\n/* --- question2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100 // Define the maximum number of items in the inventory\r\n\r\n// Define a structure to represent a grocery item\r\ntypedef struct {\r\n    char name[100];       // Name of the item\r\n    char category[50];    // Category of the item\r\n    int quantity;         // Quantity of the item in stock\r\n    float price;          // Price of the item\r\n    int inStock;          // Stock status (1 for in stock, 0 for out of stock)\r\n} GroceryItem;\r\n\r\n// Declare an array to hold the inventory items\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0; // Keep track of the number of items in the inventory\r\n\r\n// Function to add a new item to the inventory\r\nvoid addItem() {\r\n    if (itemCount >= MAX_ITEMS) { // Check if inventory is full\r\n        printf(\"Inventory full.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item; // Create a new item\r\n    printf(\"Enter item name: \");\r\n    scanf(\" %[^\\\"\\n]s\", item.name); // Read item name (handles spaces)\r\n    printf(\"Enter category: \");\r\n    scanf(\" %[^\\\"\\n]s\", item.category); // Read category\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &item.quantity); // Read quantity\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &item.price); // Read price\r\n    item.inStock = item.quantity > 0; // Update stock status based on quantity\r\n\r\n    inventory[itemCount++] = item; // Add the item to the inventory and increment count\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all items in the inventory\r\nvoid listItems() {\r\n    for (int i = 0; i < itemCount; i++) { // Loop through each item in the inventory\r\n        printf(\"%s (%s) - Quantity: %d, Price: %.2f, Status: %s\\n\",\r\n               inventory[i].name, inventory[i].category, inventory[i].quantity,\r\n               inventory[i].price, inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an item\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    printf(\"Enter item name to update quantity: \");\r\n    scanf(\" %[^\\\"\\n]s\", name); // Read item name (handles spaces)\r\n\r\n    for (int i = 0; i < itemCount; i++) { // Search for the item by name\r\n        if (strcmp(inventory[i].name, name) == 0) { // Check if names match\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity); // Update quantity\r\n            inventory[i].inStock = inventory[i].quantity > 0; // Update stock status\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\"); // If the item was not found\r\n}\r\n\r\n// Function to remove an item from the inventory\r\nvoid removeItem() {\r\n    char name[100];\r\n    printf(\"Enter item name to remove: \");\r\n    scanf(\" %[^\\\"\\n]s\", name); // Read item name (handles spaces)\r\n\r\n    for (int i = 0; i < itemCount; i++) { // Search for the item by name\r\n        if (strcmp(inventory[i].name, name) == 0) { // Check if names match\r\n            for (int j = i; j < itemCount - 1; j++) { // Shift items to fill the gap\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--; // Decrease the item count\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\"); // If the item was not found\r\n}\r\n\r\nint main() {\r\n    int choice; // Variable to store user's menu choice\r\n\r\n    // Menu-driven program for inventory management\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Item\\n\");\r\n        printf(\"2. List Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: // Add a new item\r\n                addItem();\r\n                break;\r\n            case 2: // List all items\r\n                listItems();\r\n                break;\r\n            case 3: // Update the quantity of an item\r\n                updateQuantity();\r\n                break;\r\n            case 4: // Remove an item\r\n                removeItem();\r\n                break;\r\n            case 5: // Exit the program\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default: // Handle invalid menu choices\r\n                printf(\"Invalid choice!\\n\");\r\n        }\r\n    } while (choice != 5); // Repeat until the user chooses to exit\r\n\r\n    return 0; // Exit the program\r\n}\r\n\n/* --- question3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Define a structure for student records in a linked list\r\ntypedef struct Student {\r\n    char name[100];         // Student's name\r\n    int id;                 // Student's ID\r\n    float grade;            // Student's grade\r\n    struct Student* next;   // Pointer to the next student in the list\r\n} Student;\r\n\r\n// Global pointer to the head of the linked list\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\r\n    strcpy(newStudent->name, name); // Copy the name to the student's record\r\n    newStudent->id = id;           // Set the student's ID\r\n    newStudent->grade = grade;     // Set the student's grade\r\n    newStudent->next = NULL;       // Initialize the next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record at the beginning of the list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade); // Create a new student node\r\n    newStudent->next = head;      // Set the new student's next pointer to the current head\r\n    head = newStudent;            // Update the head to the new student\r\n    printf(\"Student added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head; // Start from the head of the list\r\n    while (current != NULL) { // Traverse the list until the end\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next; // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to search for a student record by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head; // Start from the head of the list\r\n    while (current != NULL) { // Traverse the list until the end\r\n        if (current->id == id) { // Check if the current student's ID matches the given ID\r\n            return current; // Return the found student\r\n        }\r\n        current = current->next; // Move to the next student\r\n    }\r\n    return NULL; // Return NULL if the student is not found\r\n}\r\n\r\n// Function to delete the entire linked list\r\nvoid deleteList() {\r\n    Student* current = head; // Start from the head of the list\r\n    while (current != NULL) { // Traverse the list\r\n        Student* temp = current; // Store the current student\r\n        current = current->next; // Move to the next student\r\n        free(temp); // Free the memory of the current student\r\n    }\r\n    head = NULL; // Set the head to NULL\r\n    printf(\"List deleted successfully!\\n\");\r\n}\r\n\r\n// Function to sort the students by grade in ascending order\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) return; // If the list is empty or has one student, no need to sort\r\n\r\n    // Bubble sort implementation for linked list\r\n    for (Student* i = head; i != NULL; i = i->next) {\r\n        for (Student* j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) { // Compare grades and swap if necessary\r\n                // Swap names\r\n                char tempName[100];\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n\r\n                // Swap IDs\r\n                int tempID = i->id;\r\n                i->id = j->id;\r\n                j->id = tempID;\r\n\r\n                // Swap grades\r\n                float tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Students sorted by grade!\\n\");\r\n}\r\n\r\nint main() {\r\n    int choice;    // Variable to store user's menu choice\r\n    char name[100]; // Temporary variable to store name input\r\n    int id;        // Temporary variable to store ID input\r\n    float grade;   // Temporary variable to store grade input\r\n\r\n    // Menu-driven program for managing student records\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1: // Insert a new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin); // Read name input\r\n                strtok(name, \"\\n\"); // Remove the trailing newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id); // Read ID input\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade); // Read grade input\r\n                insertStudent(name, id, grade); // Call insert function\r\n                break;\r\n            case 2: // Display all student records\r\n                displayStudents();\r\n                break;\r\n            case 3: // Sort student records by grade\r\n                sortStudents();\r\n                break;\r\n            case 4: // Search for a student record by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id); // Call search function\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5: // Delete the entire linked list\r\n                deleteList();\r\n                break;\r\n            case 6: // Exit the program\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default: // Handle invalid menu choice\r\n                printf(\"Invalid choice!\\n\");\r\n        }\r\n    } while (choice != 6); // Repeat until the user chooses to exit\r\n\r\n    return 0; // Exit the program\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The implementation uses Bubble Sort to sort student records by grade. While this is simple and works correctly, it has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20604846",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n//Addition handling function\r\nvoid addMatrices(int **A, int **B, int rows, int cols, int **result) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Subtraction handling function\r\nvoid subtractMatrices(int **A, int **B, int rows, int cols, int **result) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Transpose handling function\r\nvoid transposeMatrix(int **A, int rows, int cols, int **result) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = A[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Displaying handling function\r\nvoid displayMatrix(int **matrix, int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d\\t\", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int matrixA_rows, matrixA_cols, matrixB_rows, matrixB_cols;\r\n\r\n    // Input dimensions for matrix A\r\n    printf(\"Enter dimensions for Matrix A:\\n\");\r\n    printf(\"Rows: \");\r\n    scanf(\"%d\", &matrixA_rows);\r\n    printf(\"Cols: \");\r\n    scanf(\"%d\", &matrixA_cols);\r\n\r\n    // Input dimensions for matrix B\r\n    printf(\"Enter dimensions for Matrix B:\\n\");\r\n    printf(\"Rows: \");\r\n    scanf(\"%d\", &matrixB_rows);\r\n    printf(\"Cols: \");\r\n    scanf(\"%d\", &matrixB_cols);\r\n\r\n    // Validate dimensions for matrix operations\r\n    if (matrixA_rows != matrixB_rows || matrixA_cols != matrixB_cols) {\r\n        printf(\"Error: Matrices must have the same dimensions for addition and subtraction.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Allocate memory for matrices\r\n    int **matrixA = (int **)malloc(matrixA_rows * sizeof(int *));\r\n    int **matrixB = (int **)malloc(matrixB_rows * sizeof(int *));\r\n    int **result = (int **)malloc(matrixA_rows * sizeof(int *));\r\n\r\n    for (int i = 0; i < matrixA_rows; i++) {\r\n        matrixA[i] = (int *)malloc(matrixA_cols * sizeof(int));\r\n        matrixB[i] = (int *)malloc(matrixB_cols * sizeof(int));\r\n        result[i] = (int *)malloc(matrixA_cols * sizeof(int));\r\n    }\r\n\r\n    // Input elements for matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < matrixA_rows; i++) {\r\n        for (int j = 0; j < matrixA_cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input elements for matrix B\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    for (int i = 0; i < matrixB_rows; i++) {\r\n        for (int j = 0; j < matrixB_cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n    int choice;\r\n    do {\r\n        //menu options\r\n        printf(\"----------------------------\");\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"----------------------------\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //handling menu options\r\n        switch (choice) {\r\n            case 1:\r\n                addMatrices(matrixA, matrixB, matrixA_rows, matrixA_cols, result);\r\n                printf(\"\\nResult of Matrix A + Matrix B:\\n\");\r\n                displayMatrix(result, matrixA_rows, matrixA_cols);\r\n                break;\r\n            case 2:\r\n                subtractMatrices(matrixA, matrixB, matrixA_rows, matrixA_cols, result);\r\n                printf(\"\\nResult of Matrix A - Matrix B:\\n\");\r\n                displayMatrix(result, matrixA_rows, matrixA_cols);\r\n                break;\r\n            case 3:\r\n                transposeMatrix(matrixA, matrixA_rows, matrixA_cols, result);\r\n                printf(\"\\nTranspose of Matrix A:\\n\");\r\n                displayMatrix(result, matrixA_cols, matrixA_rows);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(matrixB, matrixB_rows, matrixB_cols, result);\r\n                printf(\"\\nTranspose of Matrix B:\\n\");\r\n                displayMatrix(result, matrixB_cols, matrixB_rows);\r\n                break;\r\n            case 5:\r\n                printf(\"\\nExiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"\\nInvalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    // Free allocated memory\r\n    for (int i = 0; i < matrixA_rows; i++) {\r\n        free(matrixA[i]);\r\n        free(matrixB[i]);\r\n        free(result[i]);\r\n    }\r\n    free(matrixA);\r\n    free(matrixB);\r\n    free(result);\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX_LINE_LENGTH 256\r\n#define FILE_NAME \"grocery_inventory.csv\"\r\n\r\n// grocery item structure\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    char availability[20];\r\n} GroceryItem;\r\n\r\n//load grocery items from csv file\r\nvoid loadItems(GroceryItem items[], int *itemCount) {\r\n    FILE *file = fopen(FILE_NAME, \"r\");\r\n    if (!file) {\r\n        printf(\"No inventory file found. Starting fresh.\\n\");\r\n        *itemCount = 0;\r\n        return;\r\n    }\r\n\r\n    char line[MAX_LINE_LENGTH];\r\n    *itemCount = 0;\r\n    while (fgets(line, sizeof(line), file)) {\r\n        sscanf(line, \"%[^,],%[^,],%d,%f,%[^\\n]\", items[*itemCount].name, items[*itemCount].category,\r\n               &items[*itemCount].quantity, &items[*itemCount].price, items[*itemCount].availability);\r\n        (*itemCount)++;\r\n    }\r\n\r\n    fclose(file);\r\n}\r\n\r\n//save items to file\r\nvoid saveItems(GroceryItem items[], int itemCount) {\r\n    FILE *file = fopen(FILE_NAME, \"w\");\r\n    if (!file) {\r\n        printf(\"Error saving inventory to file.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        fprintf(file, \"%s,%s,%d,%.2f,%s\\n\", items[i].name, items[i].category, items[i].quantity,\r\n                items[i].price, items[i].availability);\r\n    }\r\n\r\n    fclose(file);\r\n}\r\n\r\n//display the items function\r\nvoid displayItems(GroceryItem items[], int itemCount) {\r\n    printf(\"\\nName\\tCategory\\tQuantity\\tPrice\\tAvailability\\n\");\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"%s\\t%s\\t%d\\t%.2f\\t%s\\n\", items[i].name, items[i].category, items[i].quantity,\r\n               items[i].price, items[i].availability);\r\n    }\r\n}\r\n\r\n//adding items to list function\r\nvoid addItem(GroceryItem items[], int *itemCount) {\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\"%s\", items[*itemCount].name);\r\n    printf(\"Enter Category: \");\r\n    scanf(\"%s\", items[*itemCount].category);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &items[*itemCount].quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &items[*itemCount].price);\r\n\r\n    strcpy(items[*itemCount].availability, (items[*itemCount].quantity > 0) ? \"In Stock\" : \"Out of Stock\");\r\n    (*itemCount)++;\r\n\r\n    saveItems(items, *itemCount);\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n//update quantity of existing item\r\nvoid updateQuantity(GroceryItem items[], int itemCount) {\r\n    char itemName[100];\r\n    printf(\"Enter item name to update quantity: \");\r\n    scanf(\"%s\", itemName);\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(items[i].name, itemName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &items[i].quantity);\r\n            strcpy(items[i].availability, (items[i].quantity > 0) ? \"In Stock\" : \"Out of Stock\");\r\n            saveItems(items, itemCount);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n//remove an item from list\r\nvoid removeItem(GroceryItem items[], int *itemCount) {\r\n    char itemName[100];\r\n    printf(\"Enter item name to remove: \");\r\n    scanf(\"%s\", itemName);\r\n\r\n    for (int i = 0; i < *itemCount; i++) {\r\n        if (strcmp(items[i].name, itemName) == 0) {\r\n            for (int j = i; j < *itemCount - 1; j++) {\r\n                items[j] = items[j + 1];\r\n            }\r\n            (*itemCount)--;\r\n            saveItems(items, *itemCount);\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nint main() {\r\n    GroceryItem groceryItems[100];\r\n    int itemCount = 0;\r\n\r\n    loadItems(groceryItems, &itemCount);\r\n\r\n    int choice;\r\n    do {\r\n        //options\r\n        printf(\"-----------------------------------------\");\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"-----------------------------------------\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //handling options\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(groceryItems, &itemCount);\r\n                break;\r\n\r\n            case 2:\r\n                displayItems(groceryItems, itemCount);\r\n                break;\r\n\r\n            case 3:\r\n                updateQuantity(groceryItems, itemCount);\r\n                break;\r\n\r\n            case 4:\r\n                removeItem(groceryItems, &itemCount);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting!\\n\");\r\n                break;\r\n\r\n            default:\r\n                //invalid input handling\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct Student {\r\n    char name[50];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n//insert a new student record function\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// display student records function\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    printf(\"Name\\tID\\tGrade\\n\");\r\n    while (current != NULL) {\r\n        printf(\"%s\\t%d\\t%.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// search for student handling\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//delete the list function\r\nvoid deleteList() {\r\n    while (head != NULL) {\r\n        Student* temp = head;\r\n        head = head->next;\r\n        free(temp);\r\n    }\r\n}\r\n\r\n// free all memory (deletes list)\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n//sorting students function\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap the nodes\r\n                char tempName[50];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempId = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempId;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    char name[50];\r\n    int id;\r\n    float grade;\r\n\r\n    while (1) {\r\n        //options are output\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //handling selected option\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                scanf(\"%s\", name);\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade in ascending order.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                Student* student = searchStudentByID(id);\r\n                if (student == NULL) {\r\n                    printf(\"Student not found.\\n\");\r\n                } else {\r\n                    printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", student->name, student->id, student->grade);\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                freeMemory();\r\n                return 0;\r\n\r\n            default:\r\n                //error handling for invalid inputs\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    }\r\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function implements Bubble Sort to arrange student records by grade. While this algorithm is easy to understand and works correctly, it has a time complexity of O(n?), which could be inefficient for larger datasets. Consider using more efficient algorithms like Merge Sort or Quick Sort in future implementations."
  },
  {
    "student_id": "20619015",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10\n\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\n// Function to input matrix elements\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Enter element [%d][%d]: \", i+1, j+1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Function to print a matrix\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to add two matrices\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\n// Function to subtract two matrices\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\n// Function to transpose a matrix\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j <cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\nint main() {\n    int A[MAX_SIZE][MAX_SIZE], B[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions and elements for Matrix A\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    printf(\"Enter elements of Matrix A:\\n\");\n    inputMatrix(A, rowsA, colsA);\n\n    // Input dimensions and elements for Matrix B\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    printf(\"Enter elements of Matrix B:\\n\");\n    inputMatrix(B, rowsB, colsB);\n\n    // Ensure the matrices can be added or subtracted\n    if (rowsA != rowsB || colsA != colsB) {\n        printf(\"Matrices cannot be added or subtracted as their dimensions don't match.\\n\");\n        return 0;\n    }\n\n    do {\n        // Menu for matrix operations\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                addMatrices(A, B, result, rowsA, colsA);\n                printf(\"Matrix A + Matrix B = \\n\");\n                printMatrix(result, rowsA, colsA);\n                break;\n            case 2:\n                subtractMatrices(A, B, result, rowsA, colsA);\n                printf(\"Matrix A - Matrix B = \\n\");\n                printMatrix(result, rowsA, colsA);\n                break;\n            case 3:\n                transposeMatrix(A, result, rowsA, colsA);\n                printf(\"Transpose of Matrix A = \\n\");\n                printMatrix(result, colsA, rowsA); // Rows and columns are swapped\n                break;\n            case 4:\n                transposeMatrix(B, result, rowsB, colsB);\n                printf(\"Transpose of Matrix B = \\n\");\n                printMatrix(result, colsB, rowsB); \n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LENGTH 100\n#define MAX_CATEGORY_LENGTH 50\n\n// Structure for Grocery Item\nstruct GroceryItem {\n    char name[MAX_NAME_LENGTH];\n    char category[MAX_CATEGORY_LENGTH];\n    int quantity;\n    float price;\n};\n\n// Enum for availability status\ntypedef enum {\n    IN_STOCK,\n    OUT_OF_STOCK\n} AvailabilityStatus;\n\n// Structure for Inventory\nstruct GroceryInventory {\n    struct GroceryItem items[MAX_ITEMS];\n    AvailabilityStatus status[MAX_ITEMS];\n    int itemCount;\n};\n\nvoid addGroceryItem(struct GroceryInventory *inventory);\nvoid listGroceryItems(struct GroceryInventory *inventory);\nvoid updateQuantity(struct GroceryInventory *inventory);\nvoid removeGroceryItem(struct GroceryInventory *inventory);\n\n// Function to list all grocery items with their availability\nvoid listGroceryItems(struct GroceryInventory *inventory) {\n    if (inventory->itemCount == 0) {\n        printf(\"No items in the inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\n--- Grocery Inventory ---\\n\");\n    for (int i = 0; i < inventory->itemCount; i++) {\n        printf(\"Item %d: %s\\n\", i + 1, inventory->items[i].name);\n        printf(\"Category: %s\\n\", inventory->items[i].category);\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\n        printf(\"Availability: %s\\n\", inventory->status[i] == IN_STOCK ? \"In Stock\" : \"Out of Stock\");\n        printf(\"\\n\");\n    }\n}\n\n// Function to update the quantity of a grocery item\nvoid updateQuantity(struct GroceryInventory *inventory) {\n    if (inventory->itemCount == 0) {\n        printf(\"No items in the inventory to update.\\n\");\n        return;\n    }\n\n    int itemIndex;\n    printf(\"Enter the item number to update quantity: \");\n    scanf(\"%d\", &itemIndex);\n\n    if (itemIndex < 1 || itemIndex > inventory->itemCount) {\n        printf(\"Invalid item number.\\n\");\n        return;\n    }\n\n    itemIndex--; // Adjust for 0-based index\n    printf(\"Current quantity: %d\\n\", inventory->items[itemIndex].quantity);\n    printf(\"Enter new quantity: \");\n    scanf(\"%d\", &inventory->items[itemIndex].quantity);\n\n    // Update availability status based on new quantity\n    if (inventory->items[itemIndex].quantity > 0) {\n        inventory->status[itemIndex] = IN_STOCK;\n    } else {\n        inventory->status[itemIndex] = OUT_OF_STOCK;\n    }\n\n    printf(\"Quantity updated successfully!\\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid removeGroceryItem(struct GroceryInventory *inventory) {\n    if (inventory->itemCount == 0) {\n        printf(\"No items in the inventory to remove.\\n\");\n        return;\n    }\n\n    int itemIndex;\n    printf(\"Enter the item number to remove: \");\n    scanf(\"%d\", &itemIndex);\n\n    if (itemIndex < 1 || itemIndex > inventory->itemCount) {\n        printf(\"Invalid item number.\\n\");\n        return;\n    }\n\n    itemIndex--; // Adjust for 0-based index\n    for (int i = itemIndex; i < inventory->itemCount - 1; i++) {\n        inventory->items[i] = inventory->items[i + 1];\n        inventory->status[i] = inventory->status[i + 1];\n    }\n\n    inventory->itemCount--;\n    printf(\"Item removed successfully!\\n\");\n}\n\nint main() {\n    struct GroceryInventory inventory = {{0}, {OUT_OF_STOCK}, 0};  // Initialize inventory\n\n    int choice;\n    do {\n         printf(\"\\n-- Grocery Inventory Menu --\\n\");\n        printf(\"1. Add grocery item\\n\");\n        printf(\"2. List all grocery items\\n\");\n        printf(\"3. Update quantity\\n\");\n        printf(\"4. Remove grocery item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch(choice) {\n            case 1:\n                addGroceryItem(&inventory);\n                break;\n            case 2:\n                listGroceryItems(&inventory);\n                break;\n            case 3:\n                updateQuantity(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function to add a grocery item to the inventory\nvoid addGroceryItem(struct GroceryInventory *inventory) {\n    if (inventory->itemCount >= MAX_ITEMS) {\n        printf(\"Inventory is full, cannot add more items.\\n\");\n        return;\n    }\n\n    struct GroceryItem newItem;\n    printf(\"Enter item name: \");\n    getchar();  // To consume the newline character left by scanf\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0;  // Remove trailing newline\n\n    printf(\"Enter category: \");\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0;\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &newItem.price);\n\n    // Set availability status based on quantity\n    if (newItem.quantity > 0) {\n        inventory->status[inventory->itemCount] = IN_STOCK;\n    } else {\n        inventory->status[inventory->itemCount] = OUT_OF_STOCK;\n    }\n\n    inventory->items[inventory->itemCount] = newItem;\n    inventory->itemCount++;\n    printf(\"Grocery item added successfully!\\n\");\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\n// Head pointer to the linked list\nStudent* head = NULL;\n\n// Function prototypes\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid freeMemory();\nvoid sortStudents();\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n\n    return newStudent;\n}\n\n// Function to insert a new student record into the linked list\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record inserted successfully!\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records available.\\n\");\n        return;\n    }\n\n    Student* current = head;\n    printf(\"\\n-- Student Records --\\n\");\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;  // Student not found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* temp;\n\n    while (current != NULL) {\n        temp = current;\n        current = current->next;\n        free(temp);\n    }\n\n    head = NULL;\n}\n\n// Function to free the memory when the program exits\nvoid freeMemory() {\n    deleteList();\n}\n\n// Function to sort the student records by grade \nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        return;  // List is empty or has only one element\n    }\n\n    Student* current;\n    Student* next;\n    float tempGrade;\n    int tempID;\n    char tempName[100];\n\n    // Bubble Sort\n    for (current = head; current != NULL; current = current->next) {\n        for (next = current->next; next != NULL; next = next->next) {\n            if (current->grade > next->grade) {\n                // Swap the student data\n                strcpy(tempName, current->name);\n                strcpy(current->name, next->name);\n                strcpy(next->name, tempName);\n\n                tempID = current->id;\n                current->id = next->id;\n                next->id = tempID;\n\n                tempGrade = current->grade;\n                current->grade = next->grade;\n                next->grade = tempGrade;\n            }\n        }\n    }\n}\n\n// Main function\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n    Student* student;\n\n    do {\n        printf(\"\\n-- Student Records Menu --\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter student name: \");\n                getchar();  // To consume the newline left by scanf\n                fgets(name, sizeof(name), stdin);\n                name[strcspn(name, \"\\n\")] = '\\0';  \n\n                printf(\"Enter student ID: \");\n                scanf(\"%d\", &id);\n\n                printf(\"Enter student grade: \");\n                scanf(\"%f\", &grade);\n\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortStudents();\n                printf(\"Student records sorted by grade using Bubble Sort.\\n\");\n                break;\n\n            case 4:\n                printf(\"Enter student ID to search: \");\n                scanf(\"%d\", &id);\n\n                student = searchStudentByID(id);\n                if (student != NULL) {\n                    printf(\"Student Found: %s (ID: %d, Grade: %.2f)\\n\", student->name, student->id, student->grade);\n                } else {\n                    printf(\"Student with ID %d not found.\\n\", id);\n                }\n                break;\n\n            case 5:\n                deleteList();\n                printf(\"All student records deleted.\\n\");\n                break;\n\n            case 6:\n                freeMemory();\n                printf(\"Exiting program.\\n\");\n                break;\n\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. While effective for small datasets, Bubble Sort has a time complexity of O(n?), making it inefficient for larger datasets. For scalability, consider more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20683106",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n// Function headers for the initializing matrices and 3 operations to be performed on matrices.\r\nvoid validate(int *row, int *col);\r\nvoid populateMatrix(int rows, int cols, int arr[rows][cols]);\r\nvoid Addition(int row1, int row2, int col1, int col2, int matA[row1][col1], int matB[row2][col2]);\r\nvoid Subtraction(int row1, int row2, int col1, int col2, int matA[row1][col1], int matB[row2][col2]);\r\nvoid Transpose(int row, int col, int arr[row][col]);\r\n\r\n// Function to validate range of matrix dimensions, ensuring it is within 1x1 to 10x10.\r\n// Variables row and col are passed as pointers to directly change the values via the function.\r\nvoid validate(int *row, int *col){\r\n    while(*row<1 || *row>10){\r\n        printf(\"Dimension for row is out of range. Please re-enter row:\\n\");\r\n        scanf(\"%d\", row);\r\n    }\r\n    while(*col<1 || *col>10){\r\n        printf(\"Dimension for column is out of range. Please re-enter column:\\n\");\r\n        scanf(\"%d\", col);\r\n    }\r\n}\r\n\r\n// Function to populate matrix with values provided by user.\r\n// Validates if any non integer values are entered. If yes, prompt for re-input.\r\nvoid populateMatrix(int rows, int cols, int arr[rows][cols]){\r\n    int element;\r\n\r\n    for(int x=0;x<rows;x++){\r\n        for(int y=0;y<cols;y++){\r\n            while (1){ // Infinite loop to accomodate validation\r\n                printf(\"Element [%d][%d]: \", x + 1, y + 1);\r\n                if (scanf(\"%d\", &element) == 1) { // Check if input is a valid integer\r\n                    arr[x][y] = element; \r\n                    break; // Exit the loop if it is a valid integer for the current element\r\n                } else {\r\n                    printf(\"Invalid input. Please enter a valid integer.\\n\");\r\n                    while (getchar() != '\\n'); // Need to clear input buffer to prevent infinite loop of error in program behaviour\r\n                }\r\n            }\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n// Function to add matrix A and B. By laws of matrices - In order for addition to be performed both matrix must have same dimensions.\r\nvoid Addition(int row1, int row2, int col1, int col2, int matA[row1][col1], int matB[row2][col2]){\r\n\r\n    if(row1 != row2 || col1 != col2){\r\n        // Unable to perform addition if different dimensions. Output error message and skip addition process.\r\n        printf(\"Both matrices do not have the same dimensions. Unable to perform matrix addition.\\n\");\r\n    } else {\r\n        printf(\"\\nResult of matrix addition:\");\r\n        for(int x=0;x<row1;x++){\r\n            printf(\"\\n\");\r\n            for(int y=0;y<col1;y++){\r\n                printf(\"%d \",matA[x][y] + matB[x][y]); // Prints final output while looping\r\n            }\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n// Function to subtract matrix B from A. By laws of matrices - In order for subtraction to be performed both matrix must have same dimensions.\r\nvoid Subtraction(int row1, int row2, int col1, int col2, int matA[row1][col1], int matB[row2][col2]){\r\n    \r\n    if(row1 != row2 || col1 != col2){\r\n        // Same as addition function\r\n        printf(\"Both matrices do not have the same dimensions. Unable to perform matrix subtraction.\\n\");\r\n    } else {\r\n        printf(\"\\nResult of matrix subtraction:\");\r\n        for(int x=0;x<row1;x++){\r\n            printf(\"\\n\");\r\n            for(int y=0;y<col1;y++){\r\n                printf(\"%d \",matA[x][y] - matB[x][y]);\r\n            }\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n// Function to transpose matrix\r\nvoid Transpose(int row, int col, int arr[row][col]){\r\n    \r\n    // Transposed matrix will be stored in here. Dimensions are flipped to accomodate rules of transposition\r\n    int Transpose[col][row]; \r\n    \r\n    // Flipping matrix according to diagonal\r\n    for (int i = 0; i < row; ++i){\r\n        for (int j = 0; j < col; ++j){\r\n            Transpose[j][i] = arr[i][j];\r\n        }\r\n    }\r\n\r\n    // Print final matrix\r\n    printf(\"\\nTranspose of the matrix:\\n\");\r\n    for (int i = 0; i < col; ++i){\r\n        for (int j = 0; j < row; ++j){\r\n            printf(\"%d  \", Transpose[i][j]);\r\n            if (j == row - 1)\r\n            printf(\"\\n\");\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\n// Main function to start the program\r\nint main(void){\r\n    int row1, row2, col1, col2;\r\n\r\n    // Prompts user for matrix A and B dimensions, calls validate function to validate input\r\n    printf(\"Enter the dimensions of matrix A: (Min - 1x1, Max - 10x10)\\n\");\r\n    scanf(\"%d%d\", &row1,&col1);\r\n    validate(&row1,&col1);\r\n    \r\n    printf(\"Enter the dimensions of matrix B: (Min - 1x1, Max - 10x10)\\n\");\r\n    scanf(\"%d%d\", &row2,&col2);\r\n    validate(&row2,&col2);\r\n\r\n    // Initialize matrices after getting user input\r\n    int matA[row1][col1], matB[row2][col2];\r\n\r\n    // Calls populate function to populate matrices\r\n    printf(\"Enter elements for Matrix A (%dx%d):\\n\", row1,col1);\r\n    populateMatrix(row1,col1,matA);\r\n    printf(\"\\n\");\r\n    printf(\"Enter elements for Matrix B (%dx%d):\\n\", row2, col2);\r\n    populateMatrix(row2,col2,matB);\r\n\r\n    printf(\"Matrix Operations Menu:\\n\");\r\n    printf(\"1. Add Matrices\\n\");\r\n    printf(\"2. Subtract Matrices\\n\");\r\n    printf(\"3. Transpose Matrix A\\n\");\r\n    printf(\"4. Transpose Matrix B\\n\");\r\n    printf(\"5. Exit\\n\");\r\n    \r\n    // Infinite loop to accomodate multiple operations from user. Only ends when user decides to terminate.\r\n    int choice;\r\n    while(1){\r\n        printf(\"\\nEnter your choice (5 to exit): \");\r\n        if (scanf(\"%d\", &choice) == 1) { // Check if input is a valid integer\r\n            // Condition to end infinite loop and terminate program.\r\n            if (choice == 5) { \r\n                printf(\"Program terminated by user.\");\r\n                break;\r\n            }\r\n            // Calls respective functions base on user operations.\r\n            switch (choice) {\r\n                case 1:\r\n                    Addition(row1, row2, col1, col2, matA, matB);\r\n                    break;\r\n                case 2:\r\n                    Subtraction(row1, row2, col1, col2, matA, matB);\r\n                    break;  \r\n                case 3:\r\n                    Transpose(row1, col1, matA);\r\n                    break;\r\n                case 4:\r\n                    Transpose(row2, col2, matB);\r\n                    break;\r\n                // To check if user input integer that is not 1-5. Shows error message and prompts for re-input.\r\n                default:\r\n                    printf(\"Invalid choice. Please enter a valid option (1-5).\\n\");\r\n            }\r\n        } else { // If input is not a valid integer, shows error message and prompts for re-input\r\n            printf(\"Invalid input. Please enter a valid integer.\\n\");\r\n            printf(\"\\n\");\r\n            while (getchar() != '\\n'); // Need to clear input buffer to prevent infinite loop of error in program behaviour\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <string.h>\r\n\r\n#define MAX 100\r\n\r\n// Struct for grocery items with relavant variables\r\nstruct groceryitem{\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Struct for item availability\r\nstruct status{\r\n    bool instock, nostock;\r\n};\r\n\r\n// Struct for grocery inventory and relavant variables\r\nstruct groceryinventory{\r\n    struct groceryitem items[MAX];\r\n    struct status avail[MAX];\r\n    int counter;\r\n};\r\n\r\nvoid AddItem(struct groceryinventory *inv);\r\nvoid ListItems(const struct groceryinventory *inv);\r\nint UpdateQuantity(struct groceryinventory *inv);\r\nint RemoveItem(struct groceryinventory *inv);\r\n\r\n// Function to add an item into inventory\r\nvoid AddItem(struct groceryinventory *inv){\r\n\r\n    // Check first if inventory is full. If full then print error message and don't need to process anymore\r\n    if(inv->counter == MAX){\r\n        printf(\"\\nUnable to add more items. Inventory is full\\n\");\r\n        while (getchar() != '\\n');\r\n    } else {\r\n        // define new variables with respective struct type to hold new input\r\n        struct groceryitem *thisitem = &inv->items[inv->counter];\r\n        struct status *isavail = &inv->avail[inv->counter];\r\n\r\n        printf(\"Enter item name: \");\r\n        while(1){\r\n            // First if else to check if there are any unexpected error in input\r\n            if (fgets(thisitem->name, 101, stdin) != NULL){\r\n                size_t len = strlen(thisitem->name);\r\n                // Second if else to check if name exceeds 100 character and prompts for re-input if so\r\n                if (len > 0 && thisitem->name[len - 1] == '\\n'){\r\n                    thisitem->name[len - 1] = '\\0'; // If length ok put zero terminator at end of string\r\n                    break;\r\n                } else if (len == 100){\r\n                    printf(\"Name is too long. Please keep it under 100 characters.\\n\");\r\n                    while (getchar() != '\\n');\r\n                }\r\n            } else{\r\n                printf(\"Input error. Please re-enter again.\\n\");\r\n                while (getchar() != '\\n');\r\n            }\r\n            printf(\"\\n\");\r\n            printf(\"Enter item name: \");\r\n        }\r\n        \r\n        \r\n        printf(\"Enter category: \");\r\n        // Same as above check if category name is too long, or if unexpected error happened\r\n          while(1){\r\n            if (fgets(thisitem->category, 51, stdin) != NULL){\r\n                size_t len = strlen(thisitem->category);\r\n                if (len > 0 && thisitem->category[len - 1] == '\\n'){\r\n                    thisitem->category[len - 1] = '\\0';\r\n                    break;\r\n                } else if (len == 50){\r\n                    printf(\"Category is too long. Please keep it under 100 characters.\\n\");\r\n                    while (getchar() != '\\n');\r\n                }\r\n            } else{\r\n                printf(\"Input error. Please re-enter again.\\n\");\r\n                while (getchar() != '\\n');\r\n            }\r\n            printf(\"\\n\");\r\n            printf(\"Enter item category: \");\r\n        }\r\n        \r\n        // Prompt for quantity and price, and do suitable validation\r\n        printf(\"Enter quantity: \");\r\n        while (scanf(\"%d\", &thisitem->quantity) != 1) {\r\n            printf(\"Invalid input. Please enter a valid integer for quantity: \");\r\n            while (getchar() != '\\n'); // Clear input buffer to prevent wierd error\r\n        }\r\n\r\n        printf(\"Enter price: \");\r\n        while (scanf(\"%f\", &thisitem->price) != 1) {\r\n            printf(\"Invalid input. Please enter a valid number for price: \");\r\n            while (getchar() != '\\n'); // Clear input buffer to prevent wierd error\r\n        }\r\n        // Notify successfull addition of item and increase counter since there is one more item now\r\n        printf(\"Grocery item added successfully!\\n\");\r\n\r\n        inv->counter ++;\r\n\r\n        // This is to set availability status flags. If quantity is more than 0 it is in stock. Else not in stock.\r\n        if(thisitem->quantity<=0){\r\n            isavail->instock = false;\r\n            isavail->nostock = true;\r\n        }else{\r\n            isavail->instock = true;\r\n            isavail->nostock = false;\r\n        }\r\n        \r\n    }\r\n}\r\n\r\n// Function to list all the items in inventory\r\nvoid ListItems(const struct groceryinventory *inv){\r\n\r\n    // Same check if inventory is empty, if empty print error message and skip processing phase\r\n    if(inv->counter==0){\r\n        printf(\"Inventory is empty.\\n\");\r\n    } else{\r\n        // Just some header formatting to print inventory\r\n        printf(\"Grocery items in inventory:\\n\");\r\n        printf(\"No.\\tName\\tCategory\\tQuantity\\tPrice\\tAvailability\\n\");\r\n        printf(\"\\n\");\r\n\r\n        // Loop based on counter since counter is the number of items in inventory\r\n        for(int x=0;x<inv->counter;x++){\r\n            const struct groceryitem *thisitem = &inv->items[x];\r\n            const struct status *isavail = &inv->avail[x];\r\n            char *flag;\r\n\r\n            if(isavail->instock==true){\r\n                flag = \"yes\";\r\n            }else{\r\n                flag = \"no\";\r\n            }\r\n            printf(\"%d\\t%s\\t%s\\t\\t%d\\t\\t%.2f\\t\\t%s\\n\",x+1,thisitem->name,thisitem->category,thisitem->quantity,thisitem->price,flag);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to update the quantity of an item\r\nint UpdateQuantity(struct groceryinventory *inv){\r\n\r\n    // // Same check if inventory is empty, if empty retun 0 and exit function\r\n    if (inv->counter == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return 0;\r\n    }\r\n\r\n    // Variable for item name to be searched\r\n    char search[100];\r\n    printf(\"\\nEnter item name to update quantity:\\n\");\r\n    scanf(\" %[^\\n]\", search);\r\n   \r\n    // Loop based on counter to compare and check if item exists\r\n    for(int x=0;x<inv->counter;x++){\r\n        struct groceryitem *thisitem = &inv->items[x];\r\n        struct status *isavail = &inv->avail[x];\r\n\r\n        // If match prompt for new quantity and validate input\r\n        if(strcmp(thisitem->name,search)==0){\r\n\r\n            printf(\"Enter new quantity to update:\\n\");\r\n            while (scanf(\"%d\", &thisitem->quantity) != 1) {\r\n                printf(\"Invalid input. Please enter a valid integer for quantity:\\n\");\r\n                while (getchar() != '\\n'); // Clear input buffer\r\n            }\r\n            while (getchar() != '\\n');\r\n\r\n            // Check if flag needs to be re-updated based on new quantity\r\n            if(thisitem->quantity<=0){\r\n                isavail->instock = false;\r\n                isavail->nostock = true;\r\n            }else{\r\n                isavail->instock = true;\r\n                isavail->nostock = false;\r\n            }\r\n            \r\n            printf(\"\\nQuantity and availability updated successfully!\\n\");\r\n            return 1;\r\n        }\r\n    }\r\n    // Error message if item not found\r\n    printf(\"\\nItem does not exist in inventory.\\n\");\r\n    while (getchar() != '\\n');\r\n    return 0;\r\n}\r\n\r\n// Function to remove an item from inventory\r\nint RemoveItem(struct groceryinventory *inv){\r\n\r\n    if (inv->counter == 0) {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return 0;\r\n    }\r\n    \r\n    // Variable to hold item name to be removed\r\n    char search[100];\r\n    printf(\"\\nEnter item name to be removed:\\n\");\r\n    scanf(\" %[^\\n]\", search);\r\n    while (getchar() != '\\n');\r\n    \r\n    // Loop to search if item exists controlled by counter\r\n    for(int x=0;x<inv->counter;x++){\r\n        // If matched, remove item by replacing it with subsequent item's data\r\n        if(strcmp(inv->items[x].name,search) == 0){\r\n            for (int y = x; y < inv->counter - 1; y++) {\r\n                inv->items[y] = inv->items[y + 1];\r\n                inv->avail[y] = inv->avail[y + 1];\r\n            }\r\n            // Decrement item counter\r\n            inv->counter--;\r\n            printf(\"\\nItem '%s' removed successfully!\\n\", search);\r\n            return 1;\r\n        }\r\n    }\r\n    printf(\"\\nItem does not exist in inventory.\\n\");\r\n    while (getchar() != '\\n');\r\n    return 0;\r\n}\r\n\r\n// Main function to start program\r\nint main(void){\r\n    struct groceryinventory inv = {.counter = 0};\r\n    int function;\r\n\r\n    printf(\"Grocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n\r\n    while(1){\r\n        printf(\"\\nEnter desired function (5 to exit): \");\r\n        if (scanf(\"%d\", &function) == 1) { // Check if input is a valid integer\r\n            while (getchar() != '\\n');\r\n            // Condition to end infinite loop and terminate program.\r\n            if (function == 5) { \r\n                printf(\"Program terminated by user.\");\r\n                break;\r\n            }\r\n            // Calls respective functions base on user operations.\r\n            switch (function) {\r\n                case 1:\r\n                    AddItem(&inv);\r\n                    break;\r\n                case 2:\r\n                    ListItems(&inv);\r\n                    break;\r\n                case 3:\r\n                    if (!UpdateQuantity(&inv) ) {\r\n                        continue;\r\n                    }\r\n                    break;\r\n                case 4:\r\n                    if (!RemoveItem(&inv) ) {\r\n                        continue;\r\n                    }\r\n                    break;\r\n                // To check if user input integer that is not 1-5. Shows error message and prompts for re-input.\r\n                default:\r\n                    printf(\"Invalid choice. Please enter a valid function (1-5).\\n\");\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n\r\n    // Using malloc to define a new link list\r\n    Student *studentlist = (Student*)malloc(sizeof(Student));\r\n\r\n    // Set respective variables from function parameters\r\n    studentlist->id = id;\r\n    studentlist->grade = grade;\r\n\r\n    // Here I want to use strncpy to copy student name to its variable, so I defined a len for length and strncpy it\r\n    unsigned int len = sizeof(studentlist->name);\r\n    strncpy(studentlist->name,name,len-1);\r\n    studentlist->name[len-1] = '\\0'; // Add zero terminator after cpying\r\n\r\n    // Move pointer after adding\r\n    studentlist->next = NULL;\r\n\r\n    return studentlist;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    \r\n    // Calls createstudent function to create a student first in order to insert\r\n    Student *addstudent = createStudent(name,id,grade);\r\n\r\n    // If linked list is empty it becomes the first node (head)\r\n    if(head == NULL){\r\n        head = addstudent;\r\n    }else{\r\n        // Set a temp pointer as head, loop until temp->next is NULL which indicate end of list\r\n        Student *temp = head;\r\n        while(temp->next){\r\n            temp = temp->next;\r\n        }\r\n        // When end of linked list add student to last node\r\n        temp->next = addstudent;\r\n    }\r\n\r\n    printf(\"\\nStudent record successfully inserted.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    \r\n    // Set a temp pointer that points to the head of the linked list\r\n    Student *temp = head;\r\n    // While temp is not NULL print every information\r\n    while(temp){\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\",temp->name,temp->id,temp->grade);\r\n        temp = temp->next;\r\n    }\r\n    \r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n\r\n    // Loop until temp is NULL which means end of list (student not found). If found it will return temp which is pointer to the node that matches and exit\r\n    Student *temp = head;\r\n    while(temp != NULL){\r\n        if(temp->id == id){\r\n            return temp;\r\n        }\r\n        temp = temp-> next;\r\n    }\r\n    \r\n    return NULL; // Student not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// From here onwards the functions are for my implementation of merge sort based on how it functions.\r\n// I have three functions, split to split the list in half, merge to merge the lists together after sorting, and mergesort to perform the sorting.\r\n// I used merge sort because it is more efficient in the case of linked list since linked list only support sequential accessed data so algorithms that uses random access perform badly\r\n\r\nStudent *split(Student *head){\r\n\r\n    // Define two pointer, fast will point to the end and while it is at the end slow will be at midpoint. This prepares for splitting\r\n    Student *fast = head;\r\n    Student *slow = head;\r\n\r\n    // Fast increments twice while slow moves once\r\n    while(fast != NULL && fast->next != NULL){\r\n        fast = fast->next->next;\r\n        if(fast != NULL){\r\n            slow = slow->next;\r\n        }\r\n    }\r\n\r\n    // Using slow to split the list into two (start to one after slow pointer and the rest)\r\n    Student *temp = slow->next;\r\n    slow->next = NULL;\r\n    return temp;\r\n\r\n}\r\n\r\n// Recursive function to combine lists again after sorting. \r\nStudent *merge(Student *first, Student *second){\r\n\r\n    // Handle cases where either half of the list is empty\r\n    if(first == NULL) return second;\r\n    if(second == NULL) return first;\r\n\r\n    // If the grade of the first student (first->grade) is less than the grade of the second student (second->grade).\r\n    // The current node in the first list should appear first in the merged list because it has a smaller grade.\r\n    // Same applies to otherwise (when second is larger than first)\r\n    if(first->grade < second->grade){\r\n        first->next = merge(first->next,second);\r\n        return first;\r\n    } else {\r\n        second->next = merge(first,second->next);\r\n        return second;\r\n    }\r\n\r\n}\r\n\r\nStudent *mergesort(Student *head){\r\n\r\n    // Check if list is empty of only have one node which dont need sorting\r\n    if(head == NULL || head->next == NULL){\r\n        return head;\r\n    }\r\n\r\n    // Calls split function to split initial list\r\n    Student *second = split(head);\r\n\r\n    // Call mergesort function recursively for both first half and second half of the list to keep splitting and srting\r\n    head = mergesort(head);\r\n    second = mergesort(second);\r\n\r\n    printf(\"\\nStudent records have been successfully sorted by grade using merge sort.\\n\");\r\n\r\n    // Returns head of the sorted linked list\r\n    return merge(head,second);\r\n\r\n}\r\n\r\n\r\n// Main function to drive the program\r\nint main() {\r\n\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n            printf(\"\\n1. Insert Student Record\\n\");\r\n            printf(\"2. Display Student Records\\n\");\r\n            printf(\"3. Sort Records using Merge Sort\\n\");\r\n            printf(\"4. Search Record by ID\\n\");\r\n            printf(\"5. Delete List\\n\");\r\n            printf(\"6. Exit\\n\");\r\n            printf(\"\\nEnter your choice: \");\r\n            scanf(\"%d\", &choice);\r\n            getchar(); // To consume the newline character\r\n            printf(\"\\n\");\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                head = mergesort(head);\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                    found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0; \r\n\r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The mergesort function is implemented to sort student records by grade. This is an efficient choice for linked lists, as it has a time complexity of O(n log n) and works well with sequential data access."
  },
  {
    "student_id": "20585127",
    "code": "\n/* --- Q1.c --- */\n// Q1 Matrix Operations max size 10\r\n\r\n#include <stdio.h>\r\n#define MAX_SIZE 10\r\n\r\n// Function to input matrix values\r\nvoid inputM(int rows, int cols, int matrix[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element at (%d, %d): \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayM(int rows, int cols, int matrix[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addM(int rows, int cols, int a[rows][cols], int b[rows][cols], int r[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            r[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid SubtM(int rows, int cols, int a[rows][cols], int b[rows][cols], int r[rows][cols]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            r[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid TransM(int rows, int cols, int matrix[rows][cols], int result[cols][rows]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n   int z, y, x, w;\r\n   int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE], r[MAX_SIZE][MAX_SIZE]; // Matrix[row][column]\r\n\r\n   int choice;\r\n   int valid = 0;\r\n\r\n    do {\r\n        printf(\"Enter dimensions of Matrix A (rows columns): \");\r\n        scanf(\"%d %d\", &z, &y);\r\n        if (z > 10 || y > 10 || z <= 0 || y <= 0) {\r\n            printf(\"Invalid input. Dimensions must be between 1 and 10.\\n\");\r\n        }\r\n    } \r\n    while (z > 10 || y > 10 || z <= 0 || y <= 0); //amke sure in range\r\n\r\n    do {\r\n        printf(\"Enter dimensions of Matrix B (rows columns): \");\r\n        scanf(\"%d %d\", &x, &w);\r\n        if (x > 10 || w > 10 || x <= 0 || w <= 0) {\r\n            printf(\"Invalid input. Dimensions must be between 1 and 10.\\n\");\r\n        }\r\n    } \r\n    while (x > 10 || w > 10 || x <= 0 || w <= 0);//amke sure in range\r\n\r\n   // Input matrices\r\n   printf(\"\\nEnter values for matrix A:\\n\");\r\n   inputM(z, y, a);\r\n   printf(\"\\nEnter values for matrix B:\\n\");\r\n   inputM(x, w, b);\r\n\r\n   // Display matrices\r\n   printf(\"\\nMatrix A:\\n\");\r\n   displayM(z, y, a);\r\n   printf(\"\\nMatrix B:\\n\");\r\n   displayM(x, w, b);\r\n\r\n   while (1) {\r\n      printf(\"\\nMatrix Operations Window\\n\");\r\n      printf(\"1. Add\\n\");\r\n      printf(\"2. Subtract\\n\");\r\n      printf(\"3. Transpose Matrix A\\n\");\r\n      printf(\"4. Transpose Matrix B\\n\");\r\n      printf(\"5. Exit\\n\");\r\n      printf(\"\\nEnter Choice: \");\r\n      scanf(\"%d\", &choice);\r\n\r\n      // Validatation on input\r\n      if (choice >= 1 && choice <= 5) {\r\n          valid = 1;\r\n      } \r\n      else {\r\n          printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n          valid = 0;\r\n      }\r\n\r\n       if (valid) {\r\n         // Switch case for options\r\n          switch (choice) {\r\n              case 1: // Add\r\n                  if (z != x || y != w) {\r\n                     printf(\"Matrix dimensions must match for addition!\\n\");\r\n                  } \r\n                  else {\r\n                     addM(z, y, a, b, r);\r\n                     printf(\"Matrix A + Matrix B:\\n\");\r\n                     displayM(z, y, r);\r\n                  }\r\n                  break;\r\n\r\n              case 2: // Subtract\r\n                  if (z != x || y != w) {\r\n                     printf(\"Matrix dimensions must match for subtraction!\\n\");\r\n                  } \r\n                  else {\r\n                     SubtM(z, y, a, b, r);\r\n                     printf(\"Matrix A - Matrix B:\\n\");\r\n                     displayM(z, y, r);\r\n                  }\r\n                  break;\r\n\r\n               case 3: // Transpose A\r\n                  {\r\n                      int transposedA[MAX_SIZE][MAX_SIZE];  // Declare inside the case block\r\n                      TransM(z, y, a, transposedA);\r\n                      printf(\"Transpose of Matrix A:\\n\");\r\n                      displayM(y, z, transposedA); // Transpose has swapped dimensions\r\n                  }\r\n                  break;\r\n\r\n              case 4: // Transpose B\r\n                  {\r\n                      int transposedB[MAX_SIZE][MAX_SIZE];  // Declare inside the case block\r\n                      TransM(x, w, b, transposedB);\r\n                      printf(\"Transpose of Matrix B:\\n\");\r\n                      displayM(w, x, transposedB); // Transpose has swapped dimensions\r\n                  }\r\n                  break;\r\n\r\n              case 5: // Exit\r\n                  printf(\"Exiting the program.\\n\");\r\n                  return 0;\r\n\r\n              default:\r\n                  break;\r\n          }\r\n      }\r\n   }\r\n\r\n   return 0;\r\n}\r\n   \r\n\n/* --- Q2.c --- */\n// Q2 Grocey manage max amount in management 100\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\n// Struct for grocery items\r\nstruct GroceryItem {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Struct to store grocery inventory data\r\nstruct GroceryInventory {\r\n    struct GroceryItem items[MAX_ITEMS];\r\n    int totalItems;  // Keeps track of the number of items in the inventory\r\n};\r\n\r\n// Function to add a grocery item\r\nvoid addGI(struct GroceryInventory *inventory) {\r\n    // If there is already 100 items\r\n    if (inventory->totalItems >= MAX_ITEMS) {\r\n        printf(\"Inventory is full! Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    //else proceed to add items \r\n    struct GroceryItem newItem;\r\n        printf(\"Enter grocery item name: \");\r\n        getchar();  // Consume newline left by previous input the \"enter\" for fgets\r\n        fgets(newItem.name, sizeof(newItem.name), stdin);\r\n        newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0';  // Remove trailing newline\r\n\r\n        printf(\"Enter category: \");\r\n        fgets(newItem.category, sizeof(newItem.category), stdin);\r\n        newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0';  // Remove trailing newline\r\n\r\n        printf(\"Enter quantity: \");\r\n        scanf(\"%d\", &newItem.quantity);\r\n\r\n        printf(\"Enter price: \");\r\n        scanf(\"%f\", &newItem.price);\r\n\r\n        // Add to inventory\r\n        inventory->items[inventory->totalItems] = newItem;\r\n        inventory->totalItems++;\r\n\r\n        printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// List all grocery items\r\nvoid listGI(struct GroceryInventory *inventory) {\r\n    // If no items\r\n    if (inventory->totalItems == 0) {\r\n        printf(\"No items in inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Display\r\n    printf(\"Grocery Inventory:\\n\");\r\n    for (int i = 0; i < inventory->totalItems; i++) {\r\n        printf(\"\\nItem %d:\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: $%.2f\\n\", inventory->items[i].price);\r\n        \r\n        // Automatically determine availability based on quantity\r\n        printf(\"Availability: %s\\n\", (inventory->items[i].quantity > 0) ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update quantity of a grocery item\r\nvoid update(struct GroceryInventory *inventory) {\r\n    int itemIndex, newQuantity;\r\n    listGI(inventory);  // Show current items\r\n\r\n    printf(\"Enter the index of the item to update (1 to %d): \", inventory->totalItems);\r\n    scanf(\"%d\", &itemIndex);\r\n\r\n    if (itemIndex < 1 || itemIndex > inventory->totalItems) {\r\n        printf(\"Invalid item index.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter the new quantity: \");\r\n    scanf(\"%d\", &newQuantity);\r\n\r\n    // Update the quantity\r\n    inventory->items[itemIndex - 1].quantity = newQuantity;\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGI(struct GroceryInventory *inventory) {\r\n    int itemIndex;\r\n    listGI(inventory);  // Show current items\r\n\r\n    printf(\"Enter the index of the item to remove (1 to %d): \", inventory->totalItems);\r\n    scanf(\"%d\", &itemIndex);\r\n\r\n    if (itemIndex < 1 || itemIndex > inventory->totalItems) {\r\n        printf(\"Invalid item index.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift items after the deleted one to fill the gap\r\n    for (int i = itemIndex - 1; i < inventory->totalItems - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1];\r\n    }\r\n\r\n    inventory->totalItems--;  // Decrease the total count of items\r\n    printf(\"Item removed successfully!\\n\");\r\n}\r\n\r\nint main() {\r\n    struct GroceryInventory inventory = { .totalItems = 0 };  // Initialize inventory\r\n\r\n    int choice;\r\n    int valid = 0;\r\n\r\n    while (1) {\r\n        // Display menu\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List all Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter Choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Input validation\r\n        if (choice >= 1 && choice <= 5) {\r\n            valid = 1;\r\n        } else {\r\n            printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n            valid = 0;\r\n        }\r\n\r\n        if (valid) {\r\n            switch (choice) {\r\n                case 1:  // Add\r\n                    addGI(&inventory);\r\n                    break;\r\n                case 2:  // List\r\n                    listGI(&inventory);\r\n                    break;\r\n                case 3:  // Update Quantity\r\n                    update(&inventory);\r\n                    break;\r\n                case 4:  // Remove Item\r\n                    removeGI(&inventory);\r\n                    break;\r\n                case 5:  // Exit\r\n                    printf(\"Exiting the program.\\n\");\r\n                    return 0;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n// Q3 student info list\r\n#include <stdio.h> \r\n#include <stdlib.h> \r\n#include <string.h> \r\n \r\n// Structure for Student \r\ntypedef struct Student { \r\n    char name[100]; \r\n    int id; \r\n    float grade; \r\n    struct Student* next; \r\n} \r\nStudent;  \r\nStudent* head = NULL; \r\n \r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // to add\r\n    //if fail\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed :[\\n\");\r\n        return NULL;\r\n    }\r\n    // add into struct\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n} \r\n \r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) { \r\n    Student* newStudent = createStudent(name, id, grade); //add new into function called \r\n        if (newStudent == NULL) {\r\n            return;\r\n        }\r\n        \r\n        // Insert at the beginning of the list, so it be easier to do\r\n        newStudent->next = head;\r\n        head = newStudent; \r\n} \r\n \r\n// Function to display all student records \r\nvoid displayStudents() { \r\n    if (head == NULL) { //if nothing in memorys\r\n            printf(\"No student records available.\\n\");\r\n            return;\r\n        }\r\n        \r\n        Student* current = head; // print from memory\r\n        while (current != NULL) { \r\n            printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade); \r\n            current = current->next;\r\n        }\r\n} \r\n \r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) { \r\n    Student* current = head;\r\n        while (current != NULL) { \r\n            if (current->id == id) {\r\n                return current;\r\n            }\r\n\r\n            current = current->next;\r\n        }\r\n        return NULL; \r\n}  \r\n \r\n// Function to delete the entire list \r\nvoid deleteList() { \r\n    Student* current = head; \r\n    Student* next; \r\n \r\n    while (current != NULL) { \r\n        next = current->next; \r\n        free(current); \r\n        current = next; \r\n    } \r\n    head = NULL; \r\n} \r\n\r\nvoid freeMemory() { \r\n    deleteList(); \r\n} \r\n \r\n// Sort function to sort the student records by grade based on an \r\n// using bubble sort\r\nvoid sortStudents() { \r\n    // if nothing to sort\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough students to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    // declare\r\n    Student* i;\r\n    Student* j;\r\n    float tempGrade;\r\n    int tempID;\r\n    char tempName[100];\r\n\r\n    // bubble sort, is the easiest and quickest sort i know how to do properly for small amounts of data off the top of my head.\r\n    for (i = head; i != NULL; i = i->next) {\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade < j->grade) {\r\n                // Swap grades\r\n                tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n                \r\n                // Swap IDs\r\n                tempID = i->id;\r\n                i->id = j->id;\r\n                j->id = tempID;\r\n                \r\n                // Swap names\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n            }\r\n        }\r\n    }\r\n\r\n    printf(\"Students sorted by grade in descending order with bubble sort.\\n\");\r\n} \r\n \r\n// Main function to drive the program \r\nint main() { \r\n \r\n    int choice, id; \r\n    char name[100]; \r\n    float grade; \r\n    int valid = 0;\r\n \r\n    do { \r\n        printf(\"\\n1. Insert Student Record\\n\"); \r\n        printf(\"2. Display Student Records\\n\"); \r\n        printf(\"3. Sort Records in bubble sort\\n\"); \r\n        printf(\"4. Search Record by ID\\n\"); \r\n        printf(\"5. Delete List\\n\"); \r\n        printf(\"6. Exit\\n\"); \r\n        printf(\"Enter your choice: \"); \r\n        scanf(\"%d\", &choice); \r\n        // Input validation\r\n        if (choice >= 1 && choice <= 5) {\r\n            valid = 1;\r\n        } else {\r\n            printf(\"Invalid choice. Please enter a number between 1 and 5.\\n\");\r\n            valid = 0;\r\n        }\r\n        getchar(); // To consume the newline character \r\n\r\n        if (valid){\r\n            switch (choice) { \r\n                case 1: \r\n                    printf(\"Enter Name: \"); \r\n                    fgets(name, sizeof(name), stdin); \r\n                    strtok(name, \"\\n\"); \r\n                    printf(\"Enter ID: \"); \r\n                    scanf(\"%d\", &id); \r\n                    printf(\"Enter Grade: \"); \r\n                    scanf(\"%f\", &grade); \r\n                    insertStudent(name, id, grade); \r\n                    break; \r\n\r\n                case 2: \r\n                    displayStudents(); \r\n                    break; \r\n\r\n                case 3: \r\n                    sortStudents();                 \r\n                    break;\r\n\r\n                case 4: \r\n                    printf(\"Enter ID to search: \"); \r\n                    scanf(\"%d\", &id); \r\n                    Student* found = searchStudentByID(id); \r\n                    if (found) { \r\n                        printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade); \r\n                    } \r\n                    else { \r\n                        printf(\"Student not found.\\n\"); \r\n                    } \r\n                    break; \r\n\r\n                case 5: \r\n                    deleteList(); \r\n                    printf(\"List deleted.\\n\"); \r\n                    break; \r\n\r\n                case 6: \r\n                    freeMemory(); \r\n                    printf(\"Exiting...\\n\"); \r\n                    break; \r\n\r\n                default: \r\n                    printf(\"Invalid choice! Please try again.\\n\"); \r\n            } \r\n        }\r\n        \r\n    } while (choice != 6); \r\n \r\n    return 0; \r\n} \r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly to sort student records by grade in descending order. While it is simple and effective for small datasets, it has a time complexity of O(n?), which can be inefficient for larger datasets. For larger lists, consider using more efficient sorting algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20715623",
    "code": "\n/* --- Q1.c --- */\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#define MAX 10\r\n\r\n// \r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols); // Ԫصĺ\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols); // ӡĺ\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols); // ӷĺ\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols); // ĺ\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols); // תõĺ\r\n\r\nint main1() //ʹʱɾmainַ޷\r\n{\r\n    int A[MAX][MAX], B[MAX][MAX]; // AB\r\n    int rowsA, colsA, rowsB, colsB; // ABά\r\n    int result[MAX][MAX]; // 洢ľ\r\n    int choice; // û˵ѡ\r\n\r\n    // Aά\r\n    printf(\"Enter the number of rows and columns for Matrix A (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Bά\r\n    printf(\"Enter the number of rows and columns for Matrix B (max 10x10): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // ֤άǷϷ\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX || rowsA <= 0 || colsA <= 0 || rowsB <= 0 || colsB <= 0)\r\n    {\r\n        printf(\"Invalid matrix dimensions. Please use dimensions between 1 and 10.\\n\");\r\n        return 1; // άЧ˳\r\n    }\r\n\r\n    // AԪ\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // BԪ\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    // Ĳ˵\r\n    do \r\n    {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n        {\r\n        case 1:\r\n            // AB\r\n            if (rowsA == rowsB && colsA == colsB) \r\n            {\r\n                addMatrices(A, B, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            }\r\n            else \r\n            {\r\n                printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 2:\r\n            // AB\r\n            if (rowsA == rowsB && colsA == colsB) \r\n            {\r\n                subtractMatrices(A, B, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                printMatrix(result, rowsA, colsA);\r\n            }\r\n            else \r\n            {\r\n                printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 3:\r\n            // Aת\r\n            transposeMatrix(A, result, rowsA, colsA);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(result, colsA, rowsA);\r\n            break;\r\n\r\n        case 4:\r\n            // Bת\r\n            transposeMatrix(B, result, rowsB, colsB);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(result, colsB, rowsB);\r\n            break;\r\n\r\n        case 5:\r\n            // ˳\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5); // ѭֱûѡ˳\r\n\r\n    return 0;\r\n}\r\n\r\n// Ԫصĺ\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// ӡĺ\r\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            printf(\"%d \", matrix[i][j]); // ӡÿԪ\r\n        }\r\n        printf(\"\\n\"); // \r\n    }\r\n}\r\n\r\n// ӷĺ\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[i][j] = A[i][j] + B[i][j]; // ӦԪ\r\n        }\r\n    }\r\n}\r\n\r\n// ĺ\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[i][j] = A[i][j] - B[i][j]; // ӦԪ\r\n        }\r\n    }\r\n}\r\n\r\n// תõĺ\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) \r\n{\r\n    for (int i = 0; i < rows; i++) \r\n    {\r\n        for (int j = 0; j < cols; j++) \r\n        {\r\n            result[j][i] = matrix[i][j]; // н\r\n        }\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#define MAX_ITEMS 100\r\n\r\n// ӻĿĽṹ\r\ntypedef struct \r\n{\r\n    char name[100]; // \r\n    char category[50]; // \r\n    int quantity; // \r\n    float price; // ۸\r\n    bool inStock; // Ƿп\r\n} GroceryItem;\r\n\r\n// ӻ\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0; // ǰеƷ\r\n\r\n// \r\nvoid addGroceryItem(); // ӻĿ\r\nvoid listGroceryItems(); // гӻĿ\r\nvoid updateQuantity(); // ӻĿ\r\nvoid removeGroceryItem(); // ƳӻĿ\r\n\r\nint main2() //ʹʱɾmainַ޷\r\n{\r\n    int choice;\r\n    do\r\n    {\r\n        // ӡ˵\r\n        printf(\"\\nGrocery Inventory Menu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n        {\r\n        case 1:\r\n            addGroceryItem();\r\n            break;\r\n        case 2:\r\n            listGroceryItems();\r\n            break;\r\n        case 3:\r\n            updateQuantity();\r\n            break;\r\n        case 4:\r\n            removeGroceryItem();\r\n            break;\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// ӻĿ\r\nvoid addGroceryItem()\r\n{\r\n    if (itemCount >= MAX_ITEMS) \r\n    {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem;\r\n\r\n    printf(\"Enter item name: \");\r\n    getchar(); // \r\n    fgets(newItem.name, sizeof(newItem.name), stdin);\r\n    strtok(newItem.name, \"\\n\"); // Ƴз\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(newItem.category, sizeof(newItem.category), stdin);\r\n    strtok(newItem.category, \"\\n\"); // Ƴз\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    newItem.inStock = newItem.quantity > 0; // ÿ״̬\r\n\r\n    inventory[itemCount++] = newItem; // ӵ\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// гӻĿ\r\nvoid listGroceryItems() \r\n{\r\n    if (itemCount == 0) \r\n    {\r\n        printf(\"Inventory is empty.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n%-20s %-15s %-10s %-10s %-10s\\n\", \"Name\", \"Category\", \"Quantity\", \"Price\", \"In Stock\");\r\n    printf(\"-------------------------------------------------------------\\n\");\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        printf(\"%-20s %-15s %-10d $%-9.2f %-10s\\n\",\r\n            inventory[i].name,\r\n            inventory[i].category,\r\n            inventory[i].quantity,\r\n            inventory[i].price,\r\n            inventory[i].inStock ? \"Yes\" : \"No\");\r\n    }\r\n}\r\n\r\n// ӻĿ\r\nvoid updateQuantity() \r\n{\r\n    char name[100];\r\n    printf(\"Enter the name of the item to update: \");\r\n    getchar(); // \r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\"); // Ƴз\r\n\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        if (strcmp(inventory[i].name, name) == 0)\r\n        {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            inventory[i].inStock = inventory[i].quantity > 0; // ¿״̬\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// ƳӻĿ\r\nvoid removeGroceryItem() \r\n{\r\n    char name[100];\r\n    printf(\"Enter the name of the item to remove: \");\r\n    getchar(); // \r\n    fgets(name, sizeof(name), stdin);\r\n    strtok(name, \"\\n\"); // Ƴз\r\n\r\n    for (int i = 0; i < itemCount; i++) \r\n    {\r\n        if (strcmp(inventory[i].name, name) == 0)\r\n        {\r\n            // ԪǰƸҪƳԪ\r\n            for (int j = i; j < itemCount - 1; j++)\r\n            {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\"Item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\n/* --- Q3.c --- */\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// ѧ¼Ľṹ\r\ntypedef struct Student \r\n{\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL; // ͷָ\r\n\r\n// \r\nStudent* createStudent(const char* name, int id, float grade); // ѧڵ\r\nvoid insertStudent(const char* name, int id, float grade); // ѧ¼\r\nvoid displayStudents(); // ʾѧ¼\r\nvoid sortStudents(); // ɼѧ¼\r\nStudent* searchStudentByID(int id); // IDѧ¼\r\nvoid deleteList(); // ɾ\r\n\r\nint main3() //ʹʱɾmainַ޷\r\n{\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do \r\n    {\r\n        printf(\"\\nStudent Record Menu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n        {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            getchar(); // \r\n            fgets(name, sizeof(name), stdin);\r\n            strtok(name, \"\\n\"); // Ƴз\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n\r\n        case 3:\r\n            sortStudents();\r\n            printf(\"Records sorted by grade successfully!\\n\");\r\n            break;\r\n\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student* found = searchStudentByID(id);\r\n            if (found) \r\n            {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n            }\r\n            else \r\n            {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n\r\n        case 5:\r\n            deleteList();\r\n            printf(\"All records deleted successfully!\\n\");\r\n            break;\r\n\r\n        case 6:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\n// ѧڵ\r\nStudent* createStudent(const char* name, int id, float grade)\r\n{\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent)\r\n    {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// ѧ¼\r\nvoid insertStudent(const char* name, int id, float grade) \r\n{\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record inserted successfully!\\n\");\r\n}\r\n\r\n// ʾѧ¼\r\nvoid displayStudents()\r\n{\r\n    if (!head) \r\n    {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\n%-20s %-10s %-10s\\n\", \"Name\", \"ID\", \"Grade\");\r\n    printf(\"----------------------------------------\\n\");\r\n    Student* current = head;\r\n    while (current) \r\n    {\r\n        printf(\"%-20s %-10d %-10.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// ɼѧ¼\r\nvoid sortStudents() \r\n{\r\n    if (!head || !head->next)\r\n    {\r\n        return; // Ϊջֻһڵʱ\r\n    }\r\n\r\n    Student* i;\r\n    Student* j;\r\n    for (i = head; i->next; i = i->next)\r\n    {\r\n        for (j = i->next; j; j = j->next)\r\n        {\r\n            if (i->grade > j->grade) \r\n            {\r\n                // ڵ\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempID = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempID;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// IDѧ¼\r\nStudent* searchStudentByID(int id) \r\n{\r\n    Student* current = head;\r\n    while (current) \r\n    {\r\n        if (current->id == id) \r\n        {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// ɾ\r\nvoid deleteList()\r\n{\r\n    Student* current = head;\r\n    while (current) \r\n    {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The implementation of bubble sort correctly sorts student records by grade. While bubble sort is easy to implement, it has a time complexity of O(n?), which can lead to inefficiency with larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20703088",
    "code": "\n/* --- Task 1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n//function declaration\r\nvoid addmatrix(int rowsA, int colsA, int rowsB, int colsB, int A[rowsA][colsA], int B[rowsB][colsB]);\r\nvoid subtractMatrices(int rowsA, int colsA, int rowsB, int colsB, int A[rowsA][colsA], int B[rowsB][colsB]);\r\nvoid transpose(int rows, int cols, int matrix[rows][cols], char matrixName);\r\n\r\n\r\n\r\nint main(){\r\n    int rowsA;\r\n    int columnsA;\r\n    int rowsB;\r\n    int columnsB;\r\n    int choice;\r\n    //rows and column input for matrix A\r\n    printf(\"Enter the number of rows and columns in matrix A (r c): \");\r\n    scanf(\"%d %d\", &rowsA, &columnsA);\r\n    //store rows and columns inputted by the user \r\n    int matrixA[rowsA][columnsA];\r\n    \r\n    //rows and colums input for matrix B\r\n    printf(\"Enter the number of rows and columns in the matrix B (r c): \");\r\n    scanf(\"%d %d\", &rowsB, &columnsB);\r\n    //store rows and columns inputted by the user\r\n    int matrixB[rowsB][columnsB];\r\n    \r\n    //take elements for matrix A\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    for (int i = 0; i < rowsA; i++) {\r\n        for (int j = 0; j < columnsA; j++) {\r\n            printf(\"A[%d][%d]: \", i, j);\r\n            scanf(\"%d\", &matrixA[i][j]);\r\n        }\r\n    }\r\n\r\n    //take elements for matrix B\r\n    for (int i = 0; i < rowsB; i++) {\r\n        for (int j = 0; j < columnsB; j++) {\r\n            printf(\"B[%d][%d]: \", i, j);\r\n            scanf(\"%d\", &matrixB[i][j]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n        //code for menu options\r\n        do{\r\n\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        //switch case to choose the required operation\r\n    \r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            addmatrix(rowsA, columnsA, rowsB, columnsB, matrixA, matrixB);\r\n            break;\r\n        \r\n        case 2:\r\n            subtractMatrices(rowsA, columnsA, rowsB, columnsB, matrixA, matrixB);\r\n            break;\r\n        \r\n        case 3:\r\n            transpose(rowsA, columnsA, matrixA, 'A');\r\n            break;\r\n        \r\n        case 4:\r\n            transpose(rowsB, columnsB, matrixB, 'B');\r\n            break;\r\n        \r\n        case 5:\r\n            printf(\"Exitting...\\n\");\r\n            break;\r\n        \r\n        default:\r\n            printf(\"Invalid choice, please try again\");\r\n            break;\r\n\r\n        }\r\n        }while(choice!= 5);\r\n    \r\n    return 0;\r\n\r\n}\r\nvoid addmatrix(int rowsA, int colsA, int rowsB, int colsB, int A[rowsA][colsA], int B[rowsB][colsB] ){\r\n    //check if addition of matrices is possible, matrix can be only added if dimensions of matrix are same\r\n    if(rowsA != rowsB || colsA != colsB){\r\n        printf(\"\\n Addition of matrices not possible if they have different rows and columns number, dimensions must be same!\");\r\n        return;\r\n    }\r\n\r\n    //set the matrix to store the result, either row or column of A can be used as they must have same size for addition\r\n    int result[rowsA][colsA];\r\n    printf(\"Result of A + B: \\n\");\r\n    for(int i = 0; i< rowsA; i++){\r\n        for(int j =0; j< colsA; j++ ){\r\n            result[i][j]= A[i][j] + B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        //add new line for readability after ever row \r\n        printf(\"\\n\");\r\n\r\n    }\r\n}\r\n\r\n//function same as addition just with (-) sign for calculating the difference\r\nvoid subtractMatrices(int rowsA, int colsA, int rowsB, int colsB, int A[rowsA][colsA], int B[rowsB][colsB] ){\r\n    //check if addition of matrices is possible, matrix can be only added if dimensions of matrix are same\r\n    if(rowsA != rowsB || colsA != colsB){\r\n        printf(\"\\n Subtraction of matrices not possible if they have different rows and columns number, dimensions must be same!\");\r\n        return;\r\n    }\r\n\r\n    //set the matrix to store the result, either row or column of A can be used as they must have same size for subtraction\r\n    int result[rowsA][colsA];\r\n    printf(\"Result of A - B: \\n\");\r\n    for(int i = 0; i< rowsA; i++){\r\n        for(int j =0; j< colsA; j++ ){\r\n            result[i][j]= A[i][j] - B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        //add new line for readability after ever row \r\n        printf(\"\\n\");\r\n\r\n    }\r\n\r\n}\r\n\r\n//function to transpose matrix\r\nvoid transpose(int rows, int cols, int matrix[rows][cols], char matrixName){\r\n    printf(\"Transpose of Matrix %c:\", matrixName);\r\n    //iterate through rows as inner loop as it is transpose (opposite operation to the normal matrix)\r\n    for(int i = 0; i<cols; i++){\r\n        for(int j = 0; j<rows; j++){\r\n            printf(\"%d \", matrix[j][i]);\r\n\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n\r\n}\r\n\n/* --- Task 2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME 100\r\n#define MAX_CATEGORY 50\r\n\r\n// Structure for grocery items\r\ntypedef struct \r\n{\r\n    char name[MAX_NAME];\r\n    char category[MAX_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Structure for checking availability of the products\r\ntypedef struct\r\n{\r\n    int inStock;\r\n    int outOfStock;\r\n} Availibility;\r\n\r\n// Structure for the inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS]; // Holds grocery item data\r\n    Availibility availibility[MAX_ITEMS]; // Holds availability status\r\n    int count; // Number of items in inventory\r\n} Inventory;\r\n\r\n// Function declarations\r\nvoid addItem(Inventory *inventory);\r\nvoid listItems(const Inventory *inventory);\r\nvoid updateQuantity(Inventory *inventory);\r\nvoid removeItem(Inventory *inventory);\r\nint findItemIndex(const Inventory *inventory, const char *name);\r\nvoid menu();\r\n\r\nint main() {\r\n    int choice;\r\n    Inventory inventory = {.count = 0}; // Initialize inventory\r\n    do {\r\n        menu(); // Display menu\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume the newline left by scanf\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid menu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add grocery item\\n\");\r\n    printf(\"2. List all grocery items\\n\");\r\n    printf(\"3. Update quantity of a grocery item\\n\");\r\n    printf(\"4. Remove grocery item from inventory\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\n// Add grocery items to the inventory\r\nvoid addItem(Inventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full, cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem newItem; // Temporarily stores the new item's details\r\n    Availibility newstatus; // Temporarily stores the availability of the item\r\n\r\n    // Input details for new item\r\n    printf(\"Enter the name of the grocery item: \");\r\n    fgets(newItem.name, MAX_NAME, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter the category of the item: \");\r\n    fgets(newItem.category, MAX_CATEGORY, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter the quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter the price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Set the stock availability\r\n    if (newItem.quantity > 0) {\r\n        newstatus.inStock = 1;\r\n        newstatus.outOfStock = 0;\r\n    } else {\r\n        newstatus.inStock = 0;\r\n        newstatus.outOfStock = 1;\r\n    }\r\n\r\n    // Add the new item to the inventory\r\n    inventory->items[inventory->count] = newItem;\r\n    inventory->availibility[inventory->count] = newstatus;\r\n    inventory->count++; // Increase the count of items in the inventory\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// List all grocery items in the inventory\r\nvoid listItems(const Inventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No items found.\\n\");\r\n        return;\r\n    }\r\n    printf(\"Items in the inventory:\\n\");\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        GroceryItem item = inventory->items[i]; // Get the grocery item\r\n        Availibility status = inventory->availibility[i]; // Get availability status\r\n        printf(\"\\nItem: %s\\n\", item.name);\r\n        printf(\"Category: %s\\n\", item.category);\r\n        printf(\"Quantity: %d\\n\", item.quantity);\r\n        printf(\"Price: %.2f\\n\", item.price);\r\n        printf(\"Availability: %s\\n\", status.inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Update quantity of a grocery item in the inventory\r\nvoid updateQuantity(Inventory *inventory) {\r\n    char itemName[MAX_NAME]; // Store the item name temporarily\r\n    printf(\"Enter the name of the grocery item to update: \");\r\n    fgets(itemName, MAX_NAME, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    int index = findItemIndex(inventory, itemName); // Find the index of the item\r\n    if (index == -1) {\r\n        printf(\"Item not found.\\n\");\r\n        return;\r\n    }\r\n\r\n    int updatedQuantity; // Store updated quantity\r\n    printf(\"Enter the quantity for %s: \", itemName);\r\n    scanf(\"%d\", &updatedQuantity);\r\n\r\n    // Update the item's quantity and availability\r\n    inventory->items[index].quantity = updatedQuantity;\r\n    if (updatedQuantity > 0) {\r\n        inventory->availibility[index].inStock = 1;\r\n        inventory->availibility[index].outOfStock = 0;\r\n    } else {\r\n        inventory->availibility[index].inStock = 0;\r\n        inventory->availibility[index].outOfStock = 1;\r\n    }\r\n    printf(\"Quantity updated successfully!\\n\");\r\n}\r\n\r\n// Remove a grocery item from the inventory\r\nvoid removeItem(Inventory *inventory) {\r\n    char itemName[MAX_NAME];\r\n    printf(\"Enter the grocery item you want to remove: \");\r\n    fgets(itemName, MAX_NAME, stdin);\r\n    itemName[strcspn(itemName, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    int index = findItemIndex(inventory, itemName); // Find the index of the item\r\n    if (index == -1) {\r\n        printf(\"Item not found.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Shift items to the left to remove the selected item\r\n    for (int i = index; i < inventory->count - 1; i++) {\r\n        inventory->items[i] = inventory->items[i + 1]; // Shift the item data to left\r\n        inventory->availibility[i] = inventory->availibility[i + 1]; // Shift the availability status\r\n    }\r\n\r\n    inventory->count--; // Decrease the total count of items in the inventory\r\n    printf(\"Item removed successfully!\\n\");\r\n}\r\n\r\n// Function to find the index of an item in the inventory by name\r\nint findItemIndex(const Inventory *inventory, const char *name) {\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            return i; // Return the index of the item if found\r\n        }\r\n    }\r\n    return -1; // Return -1 if the item is not found\r\n}\r\n\n/* --- Task 3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Allocate memory for the new student\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n\r\n    // Copy the student's information into the node\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent; // Return the new student node\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student node\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) {\r\n        return; // If memory allocation failed, exit the function\r\n    }\r\n\r\n    // If the list is empty, set the new student as the head\r\n    if (head == NULL) {\r\n        head = newStudent;\r\n    } else {\r\n        // Otherwise, traverse to the end of the list and add the student\r\n        Student* temp = head;\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;\r\n    }\r\n\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n\r\n    // Traverse the list to find the student with the given ID\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp; // Return the student if found\r\n        }\r\n        temp = temp->next;\r\n    }\r\n\r\n    return NULL; // Return NULL if the student is not found\r\n}\r\n\r\n// Sort function to sort the student records by grade (simple bubble sort)\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough students to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current;\r\n    Student* next;\r\n    int swapped;\r\n\r\n    // Bubble sort algorithm\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n\r\n        while (current->next != NULL) {\r\n            next = current->next;\r\n\r\n            if (current->grade > next->grade) {\r\n                // Swap data between current and next\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, current->name);\r\n                tempId = current->id;\r\n                tempGrade = current->grade;\r\n\r\n                strcpy(current->name, next->name);\r\n                current->id = next->id;\r\n                current->grade = next->grade;\r\n\r\n                strcpy(next->name, tempName);\r\n                next->id = tempId;\r\n                next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n\r\n            current = current->next;\r\n        }\r\n    } while (swapped);\r\n\r\n    printf(\"Students sorted by grade successfully!\\n\");\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current); // Free the memory of the current node\r\n        current = next;\r\n    }\r\n\r\n    head = NULL; // Set head to NULL since the list is now empty\r\n    printf(\"All student records have been deleted.\\n\");\r\n}\r\n\r\n// Function to free memory when the program exits\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume the newline character left in the input buffer\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove the trailing newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student with ID %d not found.\\n\", id);\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation correctly sorts student records by grade. While bubble sort is simple and effective for small datasets, its time complexity of O(n?) can be inefficient for larger datasets. It may be beneficial to consider more efficient sorting algorithms like Merge Sort or Quick Sort for better performance on larger lists."
  },
  {
    "student_id": "20678343",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n#define MAX 10\n\n// Function declarations\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols);\n\nint main() {\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\n    int rowsA, colsA, rowsB, colsB;\n    int choice;\n\n    // Input dimensions for both matrices\n    printf(\"Enter rows and columns for Matrix A: \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    printf(\"Enter rows and columns for Matrix B: \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n\n    if (rowsA <= 0 || rowsA > MAX || colsA <= 0 || colsA > MAX || rowsB <= 0 || rowsB > MAX || colsB <= 0 || colsB > MAX) {\n        printf(\"Invalid dimensions. Maximum size is 10x10.\\n\");\n        return 1;\n    }\n\n    // Input matrices\n    printf(\"Enter elements of Matrix A:\\n\");\n    inputMatrix(A, rowsA, colsA);\n    printf(\"Enter elements of Matrix B:\\n\");\n    inputMatrix(B, rowsB, colsB);\n\n    // Menu-driven program\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        if (choice == 1) {\n            if (rowsA == rowsB && colsA == colsB) {\n                addMatrices(A, B, result, rowsA, colsA);\n                printf(\"Result of Addition:\\n\");\n                printMatrix(result, rowsA, colsA);\n            } else {\n                printf(\"Addition not possible. Dimensions must match.\\n\");\n            }\n        } else if (choice == 2) {\n            if (rowsA == rowsB && colsA == colsB) {\n                subtractMatrices(A, B, result, rowsA, colsA);\n                printf(\"Result of Subtraction:\\n\");\n                printMatrix(result, rowsA, colsA);\n            } else {\n                printf(\"Subtraction not possible. Dimensions must match.\\n\");\n            }\n        } else if (choice == 3) {\n            transposeMatrix(A, result, rowsA, colsA);\n            printf(\"Transpose of Matrix A:\\n\");\n            printMatrix(result, colsA, rowsA);\n        } else if (choice == 4) {\n            transposeMatrix(B, result, rowsB, colsB);\n            printf(\"Transpose of Matrix B:\\n\");\n            printMatrix(result, colsB, rowsB);\n        } else if (choice == 5) {\n            printf(\"Exiting program.\\n\");\n        } else {\n            printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Input elements for a matrix\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Enter element [%d][%d]: \", i, j);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// Add two matrices\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\n// Subtract two matrices\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\n// Transpose a matrix\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n}\n\n// Print a matrix\nvoid printMatrix(int matrix[MAX][MAX], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#define MAX_ITEMS 100\n\n// Structure to represent a grocery item\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n    int inStock;\n} GroceryItem;\n\nGroceryItem inventory[MAX_ITEMS];\nint itemCount = 0;\n\n// Function prototypes\nvoid addItem();\nvoid listItems();\nvoid updateQuantity();\nvoid removeItem();\n\nint main() {\n    int choice;\n\n    // Menu for managing the grocery inventory\n    while (1) {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Item\\n\");\n        printf(\"2. List Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                addItem();\n                break;\n            case 2:\n                listItems();\n                break;\n            case 3:\n                updateQuantity();\n                break;\n            case 4:\n                removeItem();\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                return 0;\n            default:\n                printf(\"Invalid choice. Try again.\\n\");\n        }\n    }\n    return 0;\n}\n\n// Function to add a new item to the inventory\nvoid addItem() {\n    if (itemCount >= MAX_ITEMS) {\n        printf(\"Inventory full!\\n\");\n        return;\n    }\n    printf(\"Enter item name: \");\n    scanf(\" %[^\n]\", inventory[itemCount].name);\n    printf(\"Enter category: \");\n    scanf(\" %[^\n]\", inventory[itemCount].category);\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &inventory[itemCount].quantity);\n    printf(\"Enter price: \");\n    scanf(\"%f\", &inventory[itemCount].price);\n\n    inventory[itemCount].inStock = (inventory[itemCount].quantity > 0) ? 1 : 0;\n    itemCount++;\n    printf(\"Item added successfully!\\n\");\n}\n\n// Function to list all items in the inventory\nvoid listItems() {\n    if (itemCount == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n    printf(\"Inventory List:\\n\");\n    for (int i = 0; i < itemCount; i++) {\n        printf(\"Name: %s, Category: %s, Quantity: %d, Price: %.2f, Status: %s\\n\",\n               inventory[i].name, inventory[i].category, inventory[i].quantity,\n               inventory[i].price, inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of an item\nvoid updateQuantity() {\n    char name[100];\n    int newQuantity;\n\n    printf(\"Enter the name of the item to update: \");\n    scanf(\" %[^\n]\", name);\n\n    for (int i = 0; i < itemCount; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            printf(\"Enter new quantity: \");\n            scanf(\"%d\", &newQuantity);\n            inventory[i].quantity = newQuantity;\n            inventory[i].inStock = (newQuantity > 0) ? 1 : 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Item not found!\\n\");\n}\n\n// Function to remove an item from the inventory\nvoid removeItem() {\n    char name[100];\n\n    printf(\"Enter the name of the item to remove: \");\n    scanf(\" %[^\n]\", name);\n\n    for (int i = 0; i < itemCount; i++) {\n        if (strcmp(inventory[i].name, name) == 0) {\n            for (int j = i; j < itemCount - 1; j++) {\n                inventory[j] = inventory[j + 1];\n            }\n            itemCount--;\n            printf(\"Item removed successfully!\\n\");\n            return;\n        }\n    }\n    printf(\"Item not found!\\n\");\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for a student record\ntypedef struct Student {\n    char name[100]; \n    int id; \n    float grade; \n    struct Student* next; \n} Student;\n\nStudent* head = NULL; // Head of the linked list\n\n// Function prototypes\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid sortStudents();\n\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    // Menu for student record management\n    while (1) {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete All Records\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                scanf(\" %[^\n]\", name);\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                printf(\"Records sorted by grade.\\n\");\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found!\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"All records deleted successfully!\\n\");\n                break;\n            case 6:\n                deleteList(); // Free memory before exiting\n                printf(\"Exiting program.\\n\");\n                return 0;\n            default:\n                printf(\"Invalid choice. Try again.\\n\");\n        }\n    }\n    return 0;\n}\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to add a student to the list\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head; // Insert at the beginning\n    head = newStudent;\n    printf(\"Student added successfully!\\n\");\n}\n\n// Function to display all students\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records found.\\n\");\n        return;\n    }\n    Student* temp = head;\n    printf(\"Student Records:\\n\");\n    while (temp != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp != NULL) {\n        if (temp->id == id) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* temp = head;\n    while (temp != NULL) {\n        Student* toDelete = temp;\n        temp = temp->next;\n        free(toDelete);\n    }\n    head = NULL;\n}\n\n// Function to sort students by grade\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) return;\n\n    int swapped;\n    Student* ptr;\n    Student* lptr = NULL;\n\n    do {\n        swapped = 0;\n        ptr = head;\n\n        while (ptr->next != lptr) {\n            if (ptr->grade > ptr->next->grade) {\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, ptr->name);\n                strcpy(ptr->name, ptr->next->name);\n                strcpy(ptr->next->name, tempName);\n\n                tempID = ptr->id;\n                ptr->id = ptr->next->id;\n                ptr->next->id = tempID;\n\n                tempGrade = ptr->grade;\n                ptr->grade = ptr->next->grade;\n                ptr->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            ptr = ptr->next;\n        }\n        lptr = ptr;\n    } while (swapped);\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-     The program uses bubble sort to sort student records by grade. While bubble sort is straightforward, it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient sorting algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20509169",
    "code": "\n/* --- Question1.c --- */\n#include <stdio.h>\r\n#define MAX 10 // Define the maximum size for matrices as 10x10\r\n\r\n// Function prototypes: declarations of functions used in the program\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols);\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB; // Variables for matrix dimensions\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX]; // Matrices A, B, and result\r\n    int choice; // Variable to store user's menu choice\r\n\r\n    // Ask the user to enter dimensions of Matrix A\r\n    printf(\"Enter dimensions of Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Ask the user to enter dimensions of Matrix B\r\n    printf(\"Enter dimensions of Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Check if the matrix dimensions are within the allowed size\r\n    if (rowsA > MAX || colsA > MAX || rowsB > MAX || colsB > MAX) {\r\n        printf(\"Matrix dimensions exceed maximum allowed size (%dx%d).\\n\", MAX, MAX);\r\n        return 1; // Exit the program if dimensions are invalid\r\n    }\r\n\r\n    // Input elements of Matrix A\r\n    printf(\"Enter elements of Matrix A:\\n\");\r\n    inputMatrix(A, rowsA, colsA);\r\n\r\n    // Input elements of Matrix B\r\n    printf(\"Enter elements of Matrix B:\\n\");\r\n    inputMatrix(B, rowsB, colsB);\r\n\r\n    // Start a loop for the menu\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice); // Read user's choice\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                // Check if matrices have the same dimensions for addition\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Addition:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible: Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // Check if matrices have the same dimensions for subtraction\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(A, B, result, rowsA, colsA);\r\n                    printf(\"Result of Subtraction:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible: Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // Transpose Matrix A and display the result\r\n                transposeMatrix(A, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n            case 4:\r\n                // Transpose Matrix B and display the result\r\n                transposeMatrix(B, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n            case 5:\r\n                // Exit the program\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                // Handle invalid input\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5); // Continue the menu loop until the user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to input elements of a matrix\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Enter element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]); // Read each element of the matrix\r\n        }\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j]; // Add corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j]; // Subtract corresponding elements\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j]; // Swap rows and columns\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]); // Print each element\r\n        }\r\n        printf(\"\\n\"); // Move to the next row\r\n    }\r\n}\r\n\n/* --- Question2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n// Define a struct to represent a Grocery Item\r\ntypedef struct {\r\n    char name[100];        // Name of the grocery item (max length: 100)\r\n    char category[50];     // Category of the item (max length: 50)\r\n    int quantity;          // Quantity of the item\r\n    float price;           // Price of the item\r\n    int inStock;           // Availability status (1: in stock, 0: out of stock)\r\n} GroceryItem;\r\n\r\n// Global array to store grocery items\r\nGroceryItem inventory[100];\r\nint itemCount = 0; // Tracks the total number of items in the inventory\r\n\r\n// Function prototypes\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice; // Variable to store user's menu choice\r\n\r\n    do {\r\n        // Display the menu\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity of an Item\\n\");\r\n        printf(\"4. Remove a Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume the newline character\r\n\r\n        // Handle menu choices\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5); // Exit loop when user selects 5\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem() {\r\n    if (itemCount >= 100) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Get details of the new item from the user\r\n    printf(\"Enter item name: \");\r\n    fgets(inventory[itemCount].name, 100, stdin);\r\n    strtok(inventory[itemCount].name, \"\\n\"); // Remove newline character\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(inventory[itemCount].category, 50, stdin);\r\n    strtok(inventory[itemCount].category, \"\\n\"); // Remove newline character\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &inventory[itemCount].quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &inventory[itemCount].price);\r\n\r\n    inventory[itemCount].inStock = inventory[itemCount].quantity > 0 ? 1 : 0; // Determine availability\r\n\r\n    itemCount++; // Increment item count\r\n    printf(\"Item added successfully.\\n\");\r\n}\r\n\r\n// Function to list all grocery items\r\nvoid listGroceryItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nInventory:\\n\");\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"Item %d:\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity() {\r\n    char name[100];\r\n    int found = 0;\r\n\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Ask for the name of the item to update\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(name, 100, stdin);\r\n    strtok(name, \"\\n\"); // Remove newline character\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            inventory[i].inStock = inventory[i].quantity > 0 ? 1 : 0; // Update availability\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found.\\n\");\r\n    }\r\n}\r\n\r\n// Function to remove a grocery item\r\nvoid removeGroceryItem() {\r\n    char name[100];\r\n    int found = 0;\r\n\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Ask for the name of the item to remove\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(name, 100, stdin);\r\n    strtok(name, \"\\n\"); // Remove newline character\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            // Shift items to overwrite the removed item\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--; // Decrease item count\r\n            printf(\"Item removed successfully.\\n\");\r\n            found = 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found.\\n\");\r\n    }\r\n}\n/* --- Question3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];              // Student's name\r\n    int id;                      // Student's ID\r\n    float grade;                 // Student's grade\r\n    struct Student* next;        // Pointer to the next student in the linked list\r\n} Student;\r\n\r\nStudent* head = NULL;            // Pointer to the head of the linked list\r\n\r\n// Function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nvoid sortStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\r\n    strcpy(newStudent->name, name);                         // Copy name\r\n    newStudent->id = id;                                    // Set ID\r\n    newStudent->grade = grade;                              // Set grade\r\n    newStudent->next = NULL;                                // Initialize next pointer to NULL\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record into the linked list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);   // Create a new student node\r\n    if (head == NULL) {                                     // If the list is empty\r\n        head = newStudent;                                  // Set head to the new student\r\n    } else {\r\n        Student* temp = head;                               // Traverse to the end of the list\r\n        while (temp->next != NULL) {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = newStudent;                            // Append the new student at the end\r\n    }\r\n    printf(\"Student inserted successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* temp = head;                                   // Start from the head of the list\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (temp != NULL) {                                  // Traverse the list\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;                                  // Move to the next student\r\n    }\r\n}\r\n\r\n// Function to sort students by grade in ascending order\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) return;         // If 0 or 1 student, no need to sort\r\n\r\n    Student* i;\r\n    Student* j;\r\n    float tempGrade;\r\n    int tempID;\r\n    char tempName[100];\r\n\r\n    for (i = head; i != NULL; i = i->next) {                // Bubble sort algorithm\r\n        for (j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {                      // Swap if grades are out of order\r\n                // Swap grades\r\n                tempGrade = i->grade;\r\n                i->grade = j->grade;\r\n                j->grade = tempGrade;\r\n\r\n                // Swap IDs\r\n                tempID = i->id;\r\n                i->id = j->id;\r\n                j->id = tempID;\r\n\r\n                // Swap names\r\n                strcpy(tempName, i->name);\r\n                strcpy(i->name, j->name);\r\n                strcpy(j->name, tempName);\r\n            }\r\n        }\r\n    }\r\n    printf(\"Students sorted by grade successfully.\\n\");\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;                                   // Start from the head of the list\r\n    while (temp != NULL) {\r\n        if (temp->id == id) return temp;                    // Return the student if ID matches\r\n        temp = temp->next;\r\n    }\r\n    return NULL;                                            // Return NULL if not found\r\n}\r\n\r\n// Function to delete the entire list and free memory\r\nvoid deleteList() {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        Student* next = temp->next;                         // Store the next node\r\n        free(temp);                                         // Free the current node\r\n        temp = next;                                        // Move to the next node\r\n    }\r\n    head = NULL;                                            // Set head to NULL after deletion\r\n    printf(\"All student records deleted successfully.\\n\");\r\n}\r\n\r\n// Main function to provide a menu for the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records by Grade\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete All Records\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                printf(\"Exiting program.\\n\");\r\n                deleteList(); // Clean up memory before exit\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6); // Continue until user chooses to exit\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly, but it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20480891",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n//Function prototypes\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    //Input dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    if (rowsA > MAX_SIZE || colsA > MAX_SIZE || rowsA <= 0 || colsA <= 0) {\r\n        printf(\"Invalid dimensions for Matrix A. Exiting.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //Input elements for Matrix A\r\n    inputMatrix(matrixA, rowsA, colsA, 'A');\r\n\r\n    //Input dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    if (rowsB > MAX_SIZE || colsB > MAX_SIZE || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid dimensions for Matrix B. Exiting.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    //Input elements for Matrix B\r\n    inputMatrix(matrixB, rowsB, colsB, 'B');\r\n\r\n    //Menu-driven operations\r\n    do {\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Addition not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Matrices must have the same dimensions.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 3:\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA);\r\n                break;\r\n\r\n            case 4:\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB);\r\n                break;\r\n\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n//Function to input a matrix\r\nint inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//Function to add two matrices\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Function to subtract two matrices\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Function to display a matrix\r\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define NAME_LEN 100\r\n#define CATEGORY_LEN 50\r\n\r\n//Struct to store grocery item information\r\ntypedef struct {\r\n    char name[NAME_LEN];\r\n    char category[CATEGORY_LEN];\r\n    int quantity;\r\n    float price;\r\n    bool in_stock;\r\n} GroceryItem;\r\n\r\n//Global inventory\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n//Function prototypes\r\nvoid addGroceryItem();\r\nvoid listGroceryItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    while (1) {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); //Consume newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listGroceryItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem() {\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item.name, NAME_LEN, stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = '\\0'; //Remove newline\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, CATEGORY_LEN, stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = '\\0'; //Remove newline\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n    getchar(); //Consume newline character\r\n\r\n    item.in_stock = (item.quantity > 0);\r\n\r\n    inventory[itemCount++] = item;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listGroceryItems() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"Name: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].in_stock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"--------------------\\n\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[NAME_LEN];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(name, NAME_LEN, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; //Remove newline\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            getchar(); //Consume newline character\r\n\r\n            inventory[i].in_stock = (inventory[i].quantity > 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found.\\n\", name);\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    if (itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[NAME_LEN];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(name, NAME_LEN, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; //Remove newline\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item '%s' not found.\\n\", name);\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n//Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL; //Head pointer for the linked list\r\n\r\n//Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n//Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully!\\n\");\r\n}\r\n\r\n//Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n//Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"List deleted successfully!\\n\");\r\n}\r\n\r\n//Sort function to sort the student records by grade using Bubble Sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempID = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempID;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n//Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); //To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n\r\n            case 6:\r\n                deleteList();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The bubble sort implementation effectively sorts student records by grade. However, bubble sort has a time complexity of O(n?), which can be inefficient for larger datasets. For improved performance, consider using more efficient sorting algorithms, such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20717554",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_SIZE 10 //The maximum dimension of the matrix is ​​limited to 10×10.\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\r\n    int result[MAX_SIZE][MAX_SIZE];\r\n    int choice;\r\n\r\n    //Get the dimensions of matrices a and b.\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    printf(\"Enter elements for Matrix A:\\n\");\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    printf(\"\\nEnter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    printf(\"Enter elements for Matrix B:\\n\");\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    do {\r\n        //Show Menu Options.\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: //Addition.\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions to add.\\n\");\r\n                }\r\n                break;\r\n            case 2: //Subtraction.\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    printMatrix(result, rowsA, colsA);\r\n                } else {\r\n                    printf(\"Error: Matrices must have the same dimensions to subtract.\\n\");\r\n                }\r\n                break;\r\n            case 3: //Transpose the matrix A.\r\n                {\r\n                    int transposedA[MAX_SIZE][MAX_SIZE];\r\n                    transposeMatrix(matrixA, transposedA, rowsA, colsA);\r\n                    printf(\"Transpose of Matrix A:\\n\");\r\n                    printMatrix(transposedA, colsA, rowsA);\r\n                }\r\n                break;\r\n            case 4: //Transpose the matrix B.\r\n                {\r\n                    int transposedB[MAX_SIZE][MAX_SIZE];\r\n                    transposeMatrix(matrixB, transposedB, rowsB, colsB);\r\n                    printf(\"Transpose of Matrix B:\\n\");\r\n                    printMatrix(transposedB, colsB, rowsB);\r\n                }\r\n                break;\r\n            case 5: //Quit.\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n//Input matrix function.\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n//Output matrix function.\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//Matrix addition function.\r\nvoid addMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Matrix subtraction function.\r\nvoid subtractMatrices(int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//Transpose matrix function.\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            transposed[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100  // Maximum number of grocery items.\r\n\r\n// Structure for grocery item information.\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Inventory structure with grocery items and availability status.\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    bool availability[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function declarations.\r\nvoid addGroceryItem(GroceryInventory *inventory);\r\nvoid listGroceryItems(GroceryInventory *inventory);\r\nvoid updateQuantity(GroceryInventory *inventory);\r\nvoid removeGroceryItem(GroceryInventory *inventory);\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.count = 0; // Initialize inventory count to 0.\r\n\r\n    int choice;\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:  // Add grocery item.\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:  // List all grocery items.\r\n                listGroceryItems(&inventory);\r\n                break;\r\n            case 3:  // Update grocery quantity.\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:  // Remove grocery item.\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:  // Exit.\r\n                printf(\"Exiting the system...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice, please try again.\\n\");\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to add a grocery item to the inventory.\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    if (inventory->count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full, cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item;\r\n    printf(\"Enter the name of the grocery item: \");\r\n    scanf(\"%s\", item.name);\r\n    printf(\"Enter the category of the grocery item: \");\r\n    scanf(\"%s\", item.category);\r\n    printf(\"Enter the quantity of the grocery item: \");\r\n    scanf(\"%d\", &item.quantity);\r\n    printf(\"Enter the price of the grocery item: \");\r\n    scanf(\"%f\", &item.price);\r\n\r\n    inventory->items[inventory->count] = item;\r\n    inventory->availability[inventory->count] = (item.quantity > 0) ? true : false;\r\n    inventory->count++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items.\r\nvoid listGroceryItems(GroceryInventory *inventory) {\r\n    if (inventory->count == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nCurrent grocery items in the inventory:\\n\");\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        printf(\"Name: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\", inventory->availability[i] ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"-------------------------\\n\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item.\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter the name of the grocery item to update the quantity: \");\r\n    scanf(\"%s\", name);\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &inventory->items[i].quantity);\r\n            inventory->availability[i] = (inventory->items[i].quantity > 0) ? true : false;\r\n\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item not found.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory.\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char name[100];\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    scanf(\"%s\", name);\r\n\r\n    for (int i = 0; i < inventory->count; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Shift items to remove the selected item.\r\n            for (int j = i; j < inventory->count - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->count--;\r\n\r\n            printf(\"Grocery item removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Grocery item not found.\\n\");\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\n// Head pointer for the linked list.\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node.\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent) {\r\n        strcpy(newStudent->name, name);\r\n        newStudent->id = id;\r\n        newStudent->grade = grade;\r\n        newStudent->next = NULL;\r\n    }\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record.\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return;\r\n    }\r\n\r\n    newStudent->next = head;\r\n    head = newStudent; // Insert at the beginning of the list.\r\n    printf(\"Student record inserted successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records.\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records currently available.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nCurrent student records are as follows:\\n\");\r\n    Student* current = head;\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID.\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the entire list.\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n\r\n    head = NULL; // Set head to NULL after deletion.\r\n}\r\n\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"No need to sort. List is empty or contains only one record.\\n\");\r\n        return;\r\n    }\r\n\r\n    bool swapped;\r\n    do {\r\n        swapped = false;\r\n        Student* current = head;\r\n        while (current->next) {\r\n            if (current->grade > current->next->grade) {\r\n                // Swap the data.\r\n                char tempName[100];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, current->name);\r\n                tempID = current->id;\r\n                tempGrade = current->grade;\r\n\r\n                strcpy(current->name, current->next->name);\r\n                current->id = current->next->id;\r\n                current->grade = current->next->grade;\r\n\r\n                strcpy(current->next->name, tempName);\r\n                current->next->id = tempID;\r\n                current->next->grade = tempGrade;\r\n\r\n                swapped = true;\r\n            }\r\n            current = current->next;\r\n        }\r\n    } while (swapped);\r\n\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n// Function to free memory when exit.\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Clear newline from input buffer.\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", \r\n                           found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-Bubble Sort is simple and works well for small datasets but has a time complexity of O(n?). For larger datasets, consider implementing more efficient sorting algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20598184",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10 // assigning 10 to MAX_SIZE to allow easier reading and understanding of code\n\n// Calling function\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrix(int a[MAX_SIZE][MAX_SIZE],int b[MAX_SIZE][MAX_SIZE],int c[MAX_SIZE][MAX_SIZE] ,int rows, int cols);\nvoid subMatrix(int a[MAX_SIZE][MAX_SIZE],int b[MAX_SIZE][MAX_SIZE],int c[MAX_SIZE][MAX_SIZE] ,int rows, int cols);\nvoid tranposeMatrix(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int rows, int cols );\n\n\nint main(void) {\n    int rowsA, colsA, rowsB, colsB;\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\n    int result[MAX_SIZE][MAX_SIZE];\n    int choice;\n\n    // Input dimensions for matrixA\n    do {\n        printf(\"Enter dimension for Matrix A (rows and columns): \" );\n        scanf(\"%d %d\", &rowsA, &colsA);\n    } while (rowsA <= 0 || rowsA > MAX_SIZE || colsA <= 0 || colsA > MAX_SIZE);\n\n    // Input dimensions for matrixB \n    do {\n        printf(\"Enter dimension for Matrix B (rows and columns): \" );\n        scanf(\"%d %d\", &rowsB, &colsB);\n    } while (rowsB <= 0 || rowsB > MAX_SIZE || colsB <= 0 || colsB > MAX_SIZE);\n\n    // Input elements for matrixA\n    printf(\"\\nEnter elements of Matrix A: \\n\");\n    inputMatrix(matrixA, rowsA, colsA);\n\n    // Input elemnts for matrixB\n    printf(\"\\nEnter elements of Matrix B: \\n\");\n    inputMatrix(matrixB, rowsB, colsB);\n\n    // Menu with do-while loop for validation\n    do {\n        printf(\"\\nMatrix Operations Menu: \\n\");\n        printf(\"1. Add matrices\\n\");\n        printf(\"2. Substract matrices\\n\");\n        printf(\"3. Tranpose matrixA\\n\");\n        printf(\"4. Tranpose matrixB\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) { // Checks if matrices have same dimension\n                    addMatrix(matrixA, matrixB, result, rowsA, colsA);\n                    printf(\"Results of Matrix A + Matrix B: \\n\");\n                    displayMatrix(result, rowsA, colsA);\n                } else { // Prints error message if they do not have the same dimensions\n                    printf(\"Matrix dimensions need to have the same dimension for addition. \\n\");\n                }\n                break;\n\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) { // Checks if matrices have same dimension\n                    subMatrix(matrixA, matrixB, result, rowsA, colsA);\n                    printf(\"Result of Matrix A - Matrix B: \\n\");\n                    displayMatrix(result, rowsA, colsA);\n                } else { // Prints error message if they do not have the same dimensions\n                    printf(\"Matrix dimensions need to have the same dimension for substraction. \\n\");\n                }\n                break;\n            \n            case 3:\n                tranposeMatrix(matrixA, result, rowsA, colsA); \n                printf(\"Tranpose of Matrix A: \\n\");\n                displayMatrix(result, colsA, rowsA); // Swap position of rows and cols to flip the matrix\n                break;\n\n            case 4:\n                tranposeMatrix(matrixB, result, rowsB, colsB);\n                printf(\"Tranpose of Matrix A: \\n\");\n                displayMatrix(result, colsB, rowsB);\n                break;\n\n            case 5:\n                printf(\"Exiting... \\n\");\n                break;\n/*\n            case 6:\n                displayMatrix(matrixA, rowsA, colsA);\n                displayMatrix(matrixB, rowsB, colsB);\n*/\n            default:\n                printf(\"Invalid choice. Please try again. \\n\");\n            \n        }    \n    } while (choice != 5);\n\n    return 0;\n}\n\n// Function implement section\n// function for assigment elements to the matrix\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\n// function for printing matrix\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\" %d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// addition function for matrix\nvoid addMatrix(int a[MAX_SIZE][MAX_SIZE],int b[MAX_SIZE][MAX_SIZE], int c[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            c[i][j] = a[i][j] + b[i][j];\n        }\n    }\n}\n\n// substraction function for matrix\nvoid subMatrix(int a[MAX_SIZE][MAX_SIZE],int b[MAX_SIZE][MAX_SIZE], int c[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            c[i][j] = a[i][j] - b[i][j];\n        }\n    }\n}\n\n// tranposing matrix function\nvoid tranposeMatrix(int a[MAX_SIZE][MAX_SIZE], int c[MAX_SIZE][MAX_SIZE], int rows, int cols ) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            c[i][j] = a[j][i];\n        }\n    }\n}\n\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ITEM 100\n#define MAX_NAME_LENGTH 100\n#define MAX_CATEGORY_LENGTH 100\n\n// struct to hold grocery information\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n} GroceryItem;\n\n// struct to hold availability status\ntypedef struct {\n    bool inStock;\n    bool outOfStock;\n} StockAvailability;\n\n// struct to hold inventory\ntypedef struct {\n    GroceryItem item[MAX_ITEM];\n    StockAvailability availability[MAX_ITEM];\n    int itemCounter;\n} Inventory;\n\n//Calling functions\nvoid AddGrocery(Inventory *inventory);\nvoid listGrocery(Inventory *inventory);\nvoid updateGrocery(Inventory *inventory);\nvoid removeGrocery(Inventory *inventory);\n\nint main() {\n    Inventory inventory = {{0}, {{false, false}}, 0};\n    int choice;\n\n    do {\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar();\n\n        switch (choice)\n        {\n        case 1:\n            AddGrocery(&inventory);\n            break;\n\n        case 2:\n            listGrocery(&inventory);\n            break;\n\n        case 3:\n            updateGrocery(&inventory);\n            break;\n\n        case 4:\n            removeGrocery(&inventory);\n            break;\n        \n        case 5:\n            printf(\"Exiting...\\n\");\n            break;\n        \n        default:\n            printf(\"Invalid choice. Please try again. \\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\n// Implementing functons \n// Adding grocery function\nvoid AddGrocery(Inventory *inventory) {\n    if (inventory->itemCounter >= MAX_ITEM) {\n        printf(\"Inventory is full! Adding items unavailable. \\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n    printf(\"Enter Item Name: \");\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\n    newItem.name[strcspn(newItem.name, \"\\n\")] = '\\0'; // removes newline created by fgets\n\n    printf(\"Enter Category: \");\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\n    newItem.category[strcspn(newItem.category, \"\\n\")] = '\\0'; // rmeoves newline created by fgets\n\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &newItem.quantity);\n\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &newItem.price);\n    getchar(); // removes newline created by scanf\n\n    // assigning item to invenetory\n    inventory->item[inventory->itemCounter] = newItem;\n    inventory->availability[inventory->itemCounter].inStock = (newItem.quantity > 0);\n    inventory->availability[inventory->itemCounter].outOfStock = (newItem.quantity == 0);\n    inventory->itemCounter++;\n\n    printf(\"Grocery item added successfully! \\n\");\n}\n\n// Listing feature\nvoid listGrocery(Inventory *inventory) {\n    if (inventory->itemCounter == 0) {\n        printf(\"\\nNo items found.\\n\");\n        return;\n    }\n\n    printf(\"\\nGrocery Stock Inventory: \\n\");\n    for (int i = 0; i < inventory->itemCounter; i++) {\n        printf(\"Name: %s\\n\", inventory->item[i].name);\n        printf(\"Category: %s\\n\", inventory->item[i].category);\n        printf(\"Quantity: %d\\n\", inventory->item[i].quantity);\n        printf(\"Price: %.2f\\n\", inventory->item[i].price);\n        if (inventory->availability[i].inStock) {\n            printf(\"Status: In Stock\\n\");\n        } else if (inventory->availability[i].outOfStock) {\n            printf(\"Status: Out of Stock\\n\");\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Updating grocery function\nvoid updateGrocery(Inventory *inventory) {\n    char name[MAX_NAME_LENGTH];\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets(name, MAX_NAME_LENGTH, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // removes newline created\n\n    for (int i = 0; i < inventory->itemCounter; i++) {\n        if (strcmp(inventory->item[i].name, name) == 0) {\n            printf(\"Enter the new quantity: \");\n            int newQuantity;\n            scanf(\"%d\", &newQuantity);\n            getchar(); // removes newline\n\n            inventory->item[i].quantity = newQuantity;\n            inventory->availability[i].inStock = (newQuantity > 0);\n            inventory->availability[i].outOfStock = (newQuantity == 0);\n            \n            printf(\"Quantity updated successfully! \\n\");\n        }\n    }\n}\n\n// Remove Grocery Function\nvoid removeGrocery(Inventory *inventory) {\n    char name[MAX_NAME_LENGTH];\n    printf(\"Enter the name of the grocery item to remove: \");\n    fgets(name, MAX_NAME_LENGTH, stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // removes newline\n\n    for (int i = 0; i < inventory->itemCounter; i++) {\n        if (strcmp(inventory->item[i].name, name) == 0) {\n            // Moves every items up one slot after deletion\n            for (int j = 0; j < inventory->itemCounter - 1; j++) {\n                inventory->item[j] = inventory->item[j + 1];\n                inventory->availability[j] = inventory->availability[j + 1];\n            }\n            inventory->itemCounter--;\n            printf(\"Grocery item '%s' removed successfully\\n\", name);\n            return;\n        }\n    }\n\n    printf(\"Item not found in inventory. \\n\");\n}\n \n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* addStudent = (Student*)malloc(sizeof(Student));\n    if (!addStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(EXIT_FAILURE);\n    }\n    strcpy(addStudent->name, name);\n    addStudent->id = id;\n    addStudent->grade = grade;\n    addStudent->next = NULL;\n    return addStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* addStudent = createStudent(name, id, grade);\n    if (head == NULL) {\n        head = addStudent;\n    } else {\n        Student* temp = head;\n        while (temp->next != NULL ) {\n            temp = temp->next;\n        }\n        temp->next = addStudent;\n    }\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (head == NULL) {\n        printf(\"No student records available. \\n\");\n        return;\n    }\n    Student* temp = head;\n    while (temp != NULL) {\n        printf(\"Name: %s ID: %d Grade: %.2f \\n\", temp->name, temp->id, temp->grade);\n        temp = temp->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* temp = head;\n    while (temp != NULL) {\n        if (temp->id == id) {\n            return temp;\n        }\n        temp = temp->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n} \n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade based on an\n// algorithm of your choice\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        printf(\"Not enough record to sort.\\n\");\n        return;\n    }\n\n    int swapped;\n    Student *current, *prev = NULL;\n\n    do {\n        swapped = 0;\n        current = head;\n\n        // Bubble sorting\n        while (current->next != prev) {\n            if (current->grade > current->next->grade) {\n                // Arranging student \n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, current->name);\n                tempID =  current->id;\n                tempGrade = current->grade;\n\n                strcpy(current->name, current->next->name);\n                current->id = current->next->id;\n                current->grade = current->next->grade;\n\n                strcpy(current->next->name, tempName);\n                current->next->id =  tempID;\n                current->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            current = current->next;\n        }\n        prev = current;\n    } while (swapped);\n\n    printf(\"Student records sorted by grade.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (choose sorting method)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\");\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n\n            case 2:\n                displayStudents();\n                break;\n\n            case 3:\n                sortStudents();\n                break;\n\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id); \n\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",found->name, found->id, found->grade);\n                } else {\n                printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6:\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n} ",
    "feedback": "q1-The function tranposeMatrix incorrectly assigns values when transposing. The assignment should be c[j][i] = a[i][j] to properly transpose the matrix.\nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While bubble sort is simple and straightforward, it has a time complexity of O(n?), making it inefficient for large datasets. Consider implementing a more efficient sorting algorithm, such as Quick Sort or Merge Sort, for better performance."
  },
  {
    "student_id": "20698295",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX 10\r\n\r\n\r\n//Function to prinr the matrices \r\nvoid printmatrice(int matrix[MAX][MAX],int matrows,int matcols){\r\n    for(int i=0;i<matrows;++i){\r\n        for(int j=0; j<matcols; ++j){\r\n            printf(\"%d  \",matrix[i][j]);\r\n        }\r\n    printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//function for making the matrices\r\nvoid creatematrix(int matrx[MAX][MAX],int matrows, int matcols){\r\n    for(int i=0;i<matrows;++i){\r\n        for(int j=0; j<matcols; ++j){\r\n            printf(\"Element [%d][%d]: \", i+1,j+1);\r\n            scanf(\"%d\", &matrx[i][j] );\r\n        }\r\n    }\r\n\r\n}\r\n\r\n//function to add the 2 matrices\r\nvoid addmatrice(int matrix1[MAX][MAX],int matrix2[MAX][MAX], int rows,int cols){\r\n    int addedmatrx[MAX][MAX];\r\n    for(int i=0;i<rows;++i){\r\n        for(int j=0; j<cols; ++j){\r\n            addedmatrx[i][j]=matrix1[i][j] + matrix2[i][j];\r\n        }\r\n    }\r\n    printmatrice(addedmatrx,rows,cols);\r\n}\r\n\r\n//function for subtracting matrices\r\nvoid submatrice(int matrix1[MAX][MAX],int matrix2[MAX][MAX], int rows,int cols){\r\n    int submatrix[MAX][MAX];\r\n    for(int i=0;i<rows;++i){\r\n        for(int j=0; j<cols; ++j){\r\n            submatrix[i][j]=matrix1[i][j] - matrix2[i][j];\r\n        }\r\n    }\r\n    printmatrice(submatrix,rows,cols);\r\n}\r\n\r\n//function for transposing entered matrice\r\nvoid transposematrix(int matrix[MAX][MAX],int rows,int cols){\r\n    int transposedmat[MAX][MAX];\r\n    for(int i=0;i<rows;i++){\r\n        for(int j=0; j<cols; j++){\r\n            transposedmat[j][i]=matrix[i][j];\r\n        }\r\n    }\r\n    printmatrice(transposedmat,cols,rows);\r\n\r\n}\r\n\r\nint main(){\r\n\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX];\r\n    int rowsA,columnsA,rowsB,columnsB;\r\n    int choice;\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\",&rowsA, &columnsA);\r\n    while ((rowsA>10||rowsA<=0)|| (columnsA>10||columnsA<=0)){ //validation of row and column size\r\n        printf(\"Rows and columns from 1 to 10 only.\\n\");\r\n        printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n        scanf(\"%d %d\",&rowsA, &columnsA); //keep asking user for input until size is valid\r\n    }\r\n\r\n    printf(\"Enter Elements for Matrix A:\\n\");\r\n    creatematrix(matrixA,rowsA, columnsA);  //calling creatematrix for matrix A\r\n\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\",&rowsB, &columnsB);\r\n    while ((rowsB>10||rowsB<=0)|| (columnsB>10||columnsB<=0)){\r\n        printf(\"Rows and columns from 1 to 10 only.\\n\");\r\n        printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n        scanf(\"%d %d\",&rowsB, &columnsB);\r\n    }\r\n\r\n    printf(\"Enter Elements for Matrix B:\\n\");\r\n    creatematrix(matrixB,rowsB, columnsB);   //calling creatematrix for matrix B\r\n\r\n    do{\r\n        //menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"==========================\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice:\");\r\n        scanf(\"%d\",&choice);\r\n\r\n        switch(choice){\r\n            case 1:\r\n            //addition only when size of matrices are equal\r\n                if (rowsA==rowsB && columnsA==columnsB){\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\" );\r\n                    addmatrice(matrixA,matrixB,rowsA,columnsA);\r\n                }else{\r\n                    printf(\"Matrices must be of equal size for addition.\\n\");\r\n                }\r\n                break;   \r\n            \r\n            case 2:\r\n                //subtraction only when size of matrices are equal\r\n                if (rowsA==rowsB && columnsA==columnsB){\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\" );\r\n                    submatrice(matrixA,matrixB,rowsA,columnsA);\r\n                }else{\r\n                    printf(\"Matrices must be of equal size for subtraction.\\n\");\r\n                }\r\n                break;  \r\n\r\n            case 3:\r\n                printf(\"Transpose of Matrix A: \\n\");\r\n                transposematrix(matrixA,rowsA,columnsA);\r\n                break;\r\n\r\n            case 4:\r\n                printf(\"Transpose of Matrix B: \\n\");\r\n                transposematrix(matrixB,rowsB,columnsB);\r\n                break;\r\n            \r\n            case 5:\r\n                printf(\"Exiting...\");\r\n                break;\r\n\r\n            default:\r\n                //if choice is invalid character\r\n                printf(\"Invalid Choice: Must be within 1 to 5 only. \\n\");\r\n        }   \r\n            \r\n\r\n            \r\n    //looping menu until user exits\r\n    }while(choice!=5);\r\n\r\n    return 0;\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n\r\n#define MAX_NAME 100\r\n#define MAX_CATEGORY 50\r\n#define MAX_ITEMS 100\r\n\r\n//defining the groceryitem struct\r\ntypedef struct {\r\n    char name[MAX_NAME];\r\n    char category[MAX_CATEGORY];\r\n    int quantity;\r\n    float price;\r\n}Groceryitem;\r\n\r\ntypedef struct{\r\n    bool Instock;  //boolean to store if item is in or out of stock\r\n\r\n}Availabilitystatus;\r\n\r\ntypedef struct{\r\n    Groceryitem groceryarray[MAX_ITEMS]; //array to store groceryitems\r\n    Availabilitystatus availabilityarr[MAX_ITEMS]; //array to store availability status\r\n    int itemcount;  \r\n}GroceryInventory;\r\n\r\n\r\n//adding new item to inventory function\r\nvoid additem(GroceryInventory *inventory){\r\n\r\n    //check if inventory is full\r\n    if(inventory->itemcount>=MAX_ITEMS){\r\n        printf(\"Inventory is full. Unable to add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    //pointers for new item and its availability status\r\n    Groceryitem *item=&inventory->groceryarray[inventory->itemcount];\r\n    Availabilitystatus *status=&inventory->availabilityarr[inventory->itemcount];\r\n\r\n\r\n    printf(\"Enter Item Name: \");\r\n    getchar();  //clear newline left from previour input\r\n\r\n    fgets(item->name,MAX_NAME,stdin);\r\n    item->name[strcspn(item->name,\"\\n\")]='\\0';  //remove trailing newline\r\n\r\n\r\n    printf(\"Enter Category: \");\r\n\r\n    fgets(item->category,MAX_CATEGORY,stdin);\r\n    item->category[strcspn(item->category,\"\\n\")]='\\0';  //remove trailing newline\r\n\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\",&item->quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\",&item->price);\r\n\r\n    getchar();  //clear newline character left from scanf\r\n\r\n    inventory->itemcount++;\r\n    if(item->quantity >0){\r\n        status->Instock=1;\r\n    }\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n\r\n//function to list all items in inventory\r\nvoid listitems(GroceryInventory *inventory){\r\n\r\n\r\n    if(inventory->itemcount<=0){\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for(int i=0;i<inventory->itemcount;i++){\r\n\r\n        Groceryitem *item=&inventory->groceryarray[i];\r\n        Availabilitystatus *status=&inventory->availabilityarr[i];\r\n\r\n        printf(\"Name: %s\\n\",item->name);\r\n        printf(\"Category: %s\\n\",item->category);\r\n        printf(\"Quantity: %d\\n\",item->quantity);\r\n        printf(\"Price: %.2f\\n\",item->price);\r\n\r\n        if(status->Instock==1){\r\n            printf(\"Status: In Stock\\n\");\r\n        }else{printf(\"Status: Out of Stock\\n\");}\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n//function for updating quantity of an item\r\nvoid updatequantity(GroceryInventory *inventory){\r\n\r\n    //check if any items in inventory\r\n    if(inventory->itemcount<=0){\r\n        printf(\"No grocery items in inventory\\n\");\r\n        return;\r\n    }\r\n\r\n    char itemtoupdate[MAX_NAME];\r\n    int updated=0;\r\n\r\n    printf(\"Enter name of grocery item to update quantity: \");\r\n    getchar();\r\n    fgets(itemtoupdate,MAX_NAME,stdin);  \r\n    itemtoupdate[strcspn(itemtoupdate,\"\\n\")]='\\0';\r\n\r\n    //search for item name in inventory\r\n    for(int i=0;i<inventory->itemcount;i++){\r\n        Groceryitem *item=&inventory->groceryarray[i];\r\n        if (strcmp(inventory->groceryarray[i].name,itemtoupdate)==0){\r\n            printf(\"Enter new quantity of %s: \",itemtoupdate);\r\n            scanf(\"%d\",&item->quantity);    //update quantity to new input value\r\n            getchar();\r\n            updated=1;\r\n\r\n            if (item->quantity==0){\r\n                inventory->availabilityarr[i].Instock=0;  //if new quantity is 0, update availability status\r\n            }\r\n        }\r\n    }\r\n    if (updated==0){\r\n        printf(\"Item not found.\\n\");\r\n    }else{\r\n        printf(\"Quantity updated successfully!\\n\");\r\n    }\r\n}\r\n\r\n//removing item function\r\nvoid removeitem(GroceryInventory *inventory){\r\n    if(inventory->itemcount<=0){\r\n        printf(\"No grocery items in inventory\\n\");\r\n        return;\r\n    }\r\n    char itemtoremove[MAX_NAME];\r\n    int removed=0;\r\n\r\n    printf(\"Enter name of grocery item to remove: \");\r\n    getchar();\r\n    fgets(itemtoremove,MAX_NAME,stdin);  \r\n    itemtoremove[strcspn(itemtoremove,\"\\n\")]='\\0';\r\n\r\n    //search for item name\r\n    for(int i=0 ; i<inventory->itemcount ; i++){\r\n        Groceryitem *item=&inventory->groceryarray[i];\r\n        if (strcmp(inventory->groceryarray[i].name,itemtoremove)==0){\r\n            for(int j=i;j<inventory->itemcount-1;j++){\r\n\r\n                //shift items and availability status to fill the space of removed item\r\n                inventory->groceryarray[j] = inventory->groceryarray[j + 1];\r\n                inventory->availabilityarr[j] = inventory->availabilityarr[j + 1];\r\n            }\r\n            removed=1;\r\n            inventory->itemcount--;  //update itemcount\r\n        }\r\n    }\r\n\r\n    if (removed==0){\r\n        printf(\"Item not found.\\n\");\r\n    }else{\r\n        printf(\"Grocery Item '%s' removed successfully!\\n\",itemtoremove);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nint main(){\r\n    int choice;\r\n    GroceryInventory Inventory;\r\n    do{\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"=====================================\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            while (getchar() != '\\n');\r\n            printf(\"Invalid input. Please enter a number between 1 and 5.\\n\");\r\n            choice = 0; // Ensure choice isn't treated as valid\r\n        } else {\r\n            switch(choice){\r\n                case 1:\r\n                    additem(&Inventory);\r\n                    break;\r\n                case 2:\r\n                    listitems(&Inventory);\r\n                    break;\r\n                case 3:\r\n                    updatequantity(&Inventory);\r\n                    break;\r\n\r\n                case 4:\r\n                    removeitem(&Inventory);\r\n                    break;\r\n                \r\n                case 5:\r\n                    printf(\"Exiting...\");\r\n                    break;\r\n\r\n                default:\r\n                    printf(\"Invalid Choice: Must be within 1 to 5 only. \\n\");\r\n            }   \r\n    \r\n        }\r\n    }while(choice!=5);\r\n\r\n    return 0;\r\n}\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student *next;\r\n} Student;\r\n\r\n//global head pointer\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char *name, int id, float grade) {\r\n\r\n    //allocate memory for new student\r\n    Student *newstudent= (Student *)malloc(sizeof(Student));\r\n    if (!newstudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        return NULL;\r\n    }\r\n    strncpy(newstudent->name,name,sizeof(newstudent->name)-1);\r\n    newstudent->id=id;\r\n    newstudent->grade=grade;\r\n    newstudent->next=NULL;  //set next pointer to NULL\r\n\r\n    return newstudent;\r\n}\r\n\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student *newstudent= createStudent(name,id,grade);\r\n    if(!newstudent){      //exit function if creation failed\r\n        return;\r\n    }\r\n    newstudent->next=head;\r\n    head=newstudent;\r\n    printf(\"Student record inserted successfully.\\n\");\r\n\r\n}\r\n\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records to display.\\n\");\r\n        return;\r\n    }\r\n    Student *current = head;  //start at head of list\r\n\r\n    printf(\"\\nStudent Records:\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    if (head == NULL) {\r\n        printf(\"No student records present.\\n\");\r\n        return NULL;\r\n    }    \r\n\r\n    Student *current =head;\r\n    while(current!=NULL){\r\n        if(current->id==id){\r\n            return current;\r\n        }\r\n        current=current->next;\r\n    }\r\n\r\n    return NULL;\r\n}\r\n\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using bubblesort algorithm\r\nvoid sortStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records present.\\n\");\r\n        return;\r\n    } \r\n\r\n    Student *current=head;\r\n    float gradetemp;\r\n    int idtemp;\r\n    char nametemp[100];\r\n    int swapped,i;\r\n    Student *ptr1;\r\n    Student *lptr=NULL;\r\n\r\n    do{\r\n        swapped=0;\r\n        ptr1=head;\r\n\r\n        while (ptr1->next!=lptr){\r\n            if(ptr1->grade > ptr1->next->grade){  //if current grade is larger than grade pointed to by next pointer\r\n\r\n                //put current grade,id,name in respective temp arrays\r\n                gradetemp=ptr1->grade;\r\n                idtemp=ptr1->id;\r\n                strncpy(nametemp,ptr1->name,sizeof(nametemp));\r\n\r\n                //swap grade, ID,name\r\n                ptr1->grade= ptr1->next->grade;\r\n                ptr1->id=ptr1->next->id;\r\n                strncpy(ptr1->name,ptr1->next->name,sizeof(ptr1->name));\r\n                \r\n                ptr1->next->grade=gradetemp;\r\n                ptr1->next->id=idtemp;\r\n                strncpy(ptr1->next->name,nametemp,sizeof(ptr1->next->name));\r\n\r\n                swapped=1;\r\n\r\n            }\r\n            ptr1=ptr1->next;\r\n        }\r\n\r\n        lptr=ptr1;  //reduce unsorted pointer\r\n\r\n    }while(swapped);\r\n    printf(\"Records sorted by using Bubble Sort.\\n\");\r\n\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n\r\n        if (scanf(\"%d\", &choice) != 1) {\r\n            while (getchar() != '\\n');\r\n            printf(\"Invalid input. Please enter a number between 1 and 5.\\n\");\r\n            choice = 0; // Ensure choice isn't treated as valid\r\n        } else {\r\n            switch (choice) {\r\n            \r\n                case 1:\r\n                    printf(\"Enter Name: \");\r\n                    getchar();\r\n                    fgets(name, sizeof(name), stdin);\r\n                    name[strcspn(name, \"\\n\")] = '\\0';\r\n                    \r\n                    printf(\"Enter ID: \");\r\n                    scanf(\"%d\", &id);\r\n\r\n                    printf(\"Enter Grade: \");\r\n                    scanf(\"%f\", &grade);\r\n\r\n                    insertStudent(name, id, grade);\r\n                    break;\r\n                \r\n                case 2:\r\n                    displayStudents();\r\n                    break;\r\n            \r\n                case 3:\r\n                    sortStudents();\r\n                    break;\r\n                \r\n                case 4:\r\n                //take user input for ID to search\r\n                    printf(\"Enter ID to search: \");\r\n                    scanf(\"%d\", &id);\r\n\r\n                    Student* found = searchStudentByID(id);\r\n                    if (found!=NULL) {\r\n                        printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",found->name, found->id, found->grade);\r\n                    } else {\r\n                        printf(\"Student not found.\\n\");\r\n                    }\r\n                    break;\r\n\r\n                case 5:\r\n                    deleteList();\r\n                    printf(\"List deleted.\\n\");\r\n                    break;\r\n\r\n                case 6:\r\n                    freeMemory();\r\n                    printf(\"Exiting...\\n\");\r\n                    break;\r\n\r\n                default:\r\n                //if choice if invalid\r\n                    printf(\"Invalid choice! Please try again.\\n\");\r\n                }\r\n            }\r\n    } while (choice != 6); //loop menu until user exits\r\n\r\n    return 0;\r\n}",
    "feedback": "q1- The transposematrix function does not initialize the transposedmat array. This could lead to undefined behavior if the matrix is not fully populated.\nq2-    In the additem function, the check for inventory fullness uses >= instead of >, which could allow adding one more item than intended if the maximum is reached.    In the main function, the inventory (Inventory) is not initialized before use, which may lead to undefined behavior when accessing itemcount.\nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While Bubble Sort works for small datasets, its time complexity of O(n?) can be inefficient for larger lists. For better performance, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20611325",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#define MAX_ROWS 10\r\n#define MAX_COLS 10\r\n\r\n//Declaration of matrix for global use\r\nint rowsA, colsA, rowsB, colsB = 0;\r\nint matrixA[MAX_ROWS][MAX_COLS];\r\nint matrixB[MAX_ROWS][MAX_COLS];\r\nint final_matrix[MAX_ROWS][MAX_COLS];\r\n\r\n//Function prototypes\r\nvoid insert_matrix(int matrix[MAX_ROWS][MAX_COLS], int row, int col, char matrix_identifier);\r\nvoid matrix_calculation(int matrixA[MAX_ROWS][MAX_COLS], int matrixB[MAX_ROWS][MAX_COLS], int row, int col, char operation_symbol);\r\nvoid matrix_transpose(int matrix[MAX_ROWS][MAX_COLS], int row, int col);\r\nvoid output_matrix(int matrix[MAX_ROWS][MAX_COLS], int row, int col);\r\n\r\nint main(){\r\n    char choice;\r\n\r\n    while (1){\r\n        //Matrix A rows and columns\r\n        printf(\"Enter dimensions for matrix A (rows and columns): \");\r\n        scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n        if (rowsA <= 0 || colsA <= 0 || rowsA > 10 || colsA > 10){ //Check availability of matrix\r\n            printf(\"Matrix cannot be formed due to invalid dimensions\\n\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    insert_matrix(matrixA , rowsA, colsA, 'A');\r\n\r\n    while (1){\r\n        //Matrix B rows and columns\r\n        printf(\"Enter dimensions for matrix B (rows and columns): \");\r\n        scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n        if (rowsB <= 0 || colsB <= 0 || rowsB > 10 || colsB > 10){ //Check availability of matrix\r\n            printf(\"Matrix cannot be formed due to invalid dimensions\\n\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    insert_matrix(matrixB , rowsB, colsB, 'B');\r\n\r\n    //Operation Menu\r\n    while (choice != '5'){\r\n        printf(\"Matrix Operation Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix A\\n4. Transpose Matrix B\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\" %c\", &choice);  // Note the space before %c to consume any leftover newline\r\n\r\n        //Validation of choice given by user\r\n        if (choice == '1' || choice == '2' || choice == '3' || choice == '4' || choice == '5'){\r\n            switch (choice){\r\n                case '1':   //Perform addition of matrices\r\n                    if (rowsA != rowsB || colsA != colsB){    //Check whether matrix can be added\r\n                        printf(\"Matrices cannot be added, because the dimensions do not match\\n\");\r\n                        break;\r\n                    }\r\n                    matrix_calculation(matrixA, matrixB, rowsA, colsA, '+');\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    output_matrix(final_matrix, rowsA, colsA);\r\n                    break;\r\n\r\n                case '2':   //Perform subtraction of matrices\r\n                    if (rowsA != rowsB || colsA != colsB){    //Check whether matrix can be subtracted\r\n                        printf(\"Matrices cannot be subtracted, because the dimensions do not match\\n\");\r\n                        break;\r\n                    }\r\n                    matrix_calculation(matrixA, matrixB, rowsA, colsA, '-');\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    output_matrix(final_matrix, rowsA, colsA);\r\n                    break;\r\n\r\n                case '3':   //Transpose of matrix A\r\n                    matrix_transpose(matrixA, rowsA, colsA);\r\n                    printf(\"Transpose of Matrix A:\\n\");\r\n                    output_matrix(final_matrix, colsA, rowsA);\r\n                    break;\r\n\r\n                case '4':   //Transpose of matrix B\r\n                    matrix_transpose(matrixB, rowsB, colsB);\r\n                    printf(\"Transpose of Matrix B:\\n\");\r\n                    output_matrix(final_matrix, colsB, rowsB);\r\n                    break;              \r\n\r\n                case '5':   //Exit\r\n                    printf(\"Exiting...\");\r\n                    break;  \r\n            }\r\n        } else {   //Not a valid choice\r\n            printf(\"Invalid choice. Please enter a valid choice: \");\r\n        }\r\n    }\r\n\r\n}\r\n\r\n//Insertion of elements in matrix\r\nvoid insert_matrix(int matrix[MAX_ROWS][MAX_COLS], int row, int col, char matrix_identifier){\r\n    printf(\"Enter elements for matrix %c:\\n\", matrix_identifier);\r\n    for (int r = 0; r < row; r++){  //Row\r\n        for (int c = 0; c < col; c++){  //Column\r\n            printf(\"Element [%d][%d]: \", r + 1, c + 1);\r\n            scanf(\"%d\", &matrix[r][c]);\r\n        }\r\n    }\r\n}\r\n\r\n//Perform addition or subtraction of matrices\r\nvoid matrix_calculation(int matrixA[MAX_ROWS][MAX_COLS], int matrixB[MAX_ROWS][MAX_COLS], int row, int col, char operation_symbol){\r\n    for (int r = 0; r < row; r++){\r\n        for (int c = 0; c < col; c++){\r\n            if (operation_symbol == '+'){\r\n                final_matrix[r][c] = matrixA[r][c] + matrixB[r][c];\r\n            } else if (operation_symbol == '-'){\r\n                final_matrix[r][c] = matrixA[r][c] - matrixB[r][c];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//Performing transpose of matrix\r\nvoid matrix_transpose(int matrix[MAX_ROWS][MAX_COLS], int row, int col){\r\n    for (int r = 0; r < row; r++){\r\n        for (int c = 0; c < col; c++){\r\n            final_matrix[c][r] = matrix[r][c];    //Passing values from rows into columns\r\n        }\r\n    }\r\n}\r\n\r\n//Printing out finalised matrix\r\nvoid output_matrix(int matrix[MAX_ROWS][MAX_COLS], int row, int col){\r\n    for (int r = 0; r < row; r++){\r\n        for (int c = 0; c < col; c++){\r\n            printf(\"%d \", matrix[r][c]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n\r\nstruct Groceries {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n};\r\n\r\n// Function prototypes\r\nvoid add_grocery_item(struct Groceries groceries[], int *count);\r\nvoid list_all_grocery_items(struct Groceries groceries[], int count);\r\nvoid update_quantity(struct Groceries groceries[], int count);\r\nvoid remove_grocery_item(struct Groceries groceries[], int *count);\r\n\r\nint main(){\r\n    struct Groceries groceries[MAX_ITEMS];\r\n    int count = 0; // Number of items in the inventory\r\n    int choice = 0;\r\n\r\n    while (choice != 5){\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n2. List All Grocery Items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Consume newline character\r\n\r\n        switch(choice){\r\n            case 1:\r\n                add_grocery_item(groceries, &count);\r\n                printf(\"\\n\");\r\n                break;\r\n            case 2:\r\n                list_all_grocery_items(groceries, count);\r\n                printf(\"\\n\");\r\n                break;\r\n            case 3:\r\n                update_quantity(groceries, count);\r\n                printf(\"\\n\");\r\n                break;\r\n            case 4:\r\n                remove_grocery_item(groceries, &count);\r\n                printf(\"\\n\");\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n// Add grocery items\r\nvoid add_grocery_item(struct Groceries groceries[], int *count){\r\n    if (*count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n    printf(\"Enter item name: \");\r\n    fgets(groceries[*count].name, 100, stdin);\r\n    groceries[*count].name[strcspn(groceries[*count].name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(groceries[*count].category, 50, stdin);\r\n    groceries[*count].category[strcspn(groceries[*count].category, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &groceries[*count].quantity);\r\n    getchar(); // Consume newline character\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &groceries[*count].price);\r\n    getchar(); // Consume newline character\r\n\r\n    (*count)++;\r\n    printf(\"Item added successfully\\n\");    \r\n}\r\n\r\n// List all grocery items\r\nvoid list_all_grocery_items(struct Groceries groceries[], int count){\r\n    if(count == 0){   // Check if inventory is empty\r\n        printf(\"No grocery items in the inventory\\n\");\r\n    } else {\r\n        for (int i = 0; i < count; i++) {   // List out all the items in the inventory\r\n            printf(\"Name: %s\\n\\033[0;32mCategory: %s\\033[0m\\nQuantity: %d\\nPrice: %.2f\\n\", groceries[i].name, groceries[i].category, groceries[i].quantity, groceries[i].price);\r\n            if (groceries[i].quantity <= 0){\r\n                printf(\"Status: Out of stock\\n\");\r\n            } else {\r\n                printf(\"Status: In stock\\n\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Update quantity of grocery items\r\nvoid update_quantity(struct Groceries groceries[], int count){\r\n    char item_name[100];\r\n    int new_quantity;\r\n\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    fgets(item_name, 100, stdin);\r\n    item_name[strcspn(item_name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    if (count == 0) {   // Check if inventory is empty\r\n        printf(\"No grocery items in the inventory\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < count; i++) {   // Loop through the inventory to find the item\r\n        if (strcmp(groceries[i].name, item_name) == 0) {    // Found item then update quantity\r\n            printf(\"Enter new quantity for %s: \", item_name);\r\n            scanf(\"%d\", &new_quantity);\r\n            getchar(); // Consume newline character\r\n\r\n            groceries[i].quantity = new_quantity;   //Update quantity\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"No grocery item in the inventory!\\n\"); // No grocery items found\r\n}\r\n\r\n// Remove grocery items\r\nvoid remove_grocery_item(struct Groceries groceries[], int *count){\r\n    char item_name[100];\r\n\r\n    printf(\"Enter the name of the grocery item to remove: \");\r\n    fgets(item_name, 100, stdin);\r\n    item_name[strcspn(item_name, \"\\n\")] = '\\0'; // Remove newline character\r\n\r\n    for(int i = 0; i < *count; i++){   // Loop through the inventory to find the item\r\n        if (strcmp(groceries[i].name, item_name) == 0){   // Found item then remove the specified item\r\n            for (int j = i; j < *count - 1; j++){   // Shift the items to the left\r\n                groceries[j] = groceries[j + 1];    \r\n            }\r\n            (*count)--; // Decrement the count\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", item_name); \r\n            return;\r\n        }\r\n    }\r\n    printf(\"No grocery item in the inventory!\\n\"); // No grocery items found\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));    //Allocate memory for a new student record\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n\r\n    //Store data of a student as linked list\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;    \r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* insertNewStudent = createStudent(name, id, grade);\r\n    if (head == NULL) { //Check if the list is empty\r\n        head = insertNewStudent;    \r\n    } else {    //Insert at the end of the list\r\n        Student* current = head;\r\n        while (current->next != NULL) { //Traverse to the end of the list\r\n            current = current->next;\r\n        }\r\n        current->next = insertNewStudent; //Link the new student to the end of the list\r\n\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    Student* current = head;\r\n    if (current == NULL) {  //Check if the list is empty, by checking the head (start) of the list\r\n        printf(\"No student records found.\\n\");\r\n    } else {\r\n        while (current != NULL) {   //List out all the student records until the end of the list\r\n            printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n            current = current->next;    //Move to the next student record after current student record is accessed\r\n        }\r\n    }\r\n}\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL){\r\n        if (current->id == id){ //Check if ID matches, if ID found, return the student record\r\n            return current; \r\n        }else{\r\n        current = current->next;    //Move to the next student record if ID does not match\r\n        }\r\n    }\r\n}\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    //Delete all the student records until the end of the list\r\n    while (current != NULL) {   \r\n    next = current->next;\r\n    free(current);  //Free memory of the current student record after deletion\r\n    current = next;\r\n    }\r\n\r\n    head = NULL;\r\n    }\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n    }\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice\r\nvoid sortStudents() {\r\n    Student* current = head;\r\n    Student* next;\r\n    Student* temp;\r\n\r\n    if(current == NULL || current->next == NULL) { //Check if the list is empty or has only one student record\r\n        printf(\"Unable to sort due to lack of student record\");\r\n        return;\r\n    }\r\n\r\n    //Bubble sort algorithm to sort the student records by ID in ascending order\r\n    for(current = head; current->next != NULL; current = current->next) {   //Moving from first to second of the student records\r\n        for(next = current->next; next != NULL; next = next->next) {        //Move from second to the last student record\r\n            if(current->grade > next->grade) {  //Check if the current student record grade is greater than the next student record grade\r\n                temp = createStudent(current->name, current->id, current->grade); \r\n                \r\n                //Swap position of student records\r\n\r\n                //Previous student record replaced by next student record\r\n                strcpy(current->name, next->name);\r\n                current->id = next->id;\r\n                current->grade = next->grade;\r\n\r\n                //Next student record replaced by previous student record\r\n                strcpy(next->name, temp->name);\r\n                next->id = temp->id;\r\n                next->grade = temp->grade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort algorithm\\n\");\r\n}\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {    //Display the student record if found\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n                }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n    } ",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. While this method is simple and works correctly, it has a time complexity of O(n?), which may not be efficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20621249",
    "code": "\n/* --- q1.c --- */\n#include <stdio.h>\n#define MAX_SIZE 10 // Define the maximum size for matrices\n\n// Function to add two matrices\nvoid add_matrix(int row, int col, int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE]) {\n    int result[MAX_SIZE][MAX_SIZE];\n\n    // Calculate the addition of matrices\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\n        }\n    }\n\n    // Print the result\n    printf(\"\\nResult of Matrix Addition:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d \", result[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to subtract two matrices\nvoid sub_matrix(int row, int col, int matrixA[MAX_SIZE][MAX_SIZE], int matrixB[MAX_SIZE][MAX_SIZE]) {\n    int result[MAX_SIZE][MAX_SIZE];\n\n    // Calculate the subtraction of matrices\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\n        }\n    }\n\n    // Print the result\n    printf(\"\\nResult of Matrix Subtraction:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d \", result[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to calculate the transpose of a matrix\nvoid transpose_matrix(int row, int col, int matrix[MAX_SIZE][MAX_SIZE]){\n    int result[MAX_SIZE][MAX_SIZE];\n\n    // Calculate the transpose\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            result[j][i] = matrix[i][j];\n        }\n    }\n\n    // Print the transpose\n    printf(\"Transpose of the Matrix:\\n\");\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < col; j++) {\n            printf(\"%d \", result[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(){\n    int rowA = 0, colA = 0; // Dimensions for Matrix A\n    int valuesA[MAX_SIZE][MAX_SIZE]; // Values of Matrix A\n    int rowB = 0, colB = 0; // Dimensions for Matrix B\n    int valuesB[MAX_SIZE][MAX_SIZE]; // Values of Matrix B\n    int choice = 0; // User's menu choice\n\n    // Input for Matrix A and Matrix B with validation\n    while(1){\n        printf(\"Enter dimensions for Matrix A: (rows and columns): \");\n        scanf(\"%d\", &rowA);\n        scanf(\"%d\", &colA);\n\n        if ((rowA <= MAX_SIZE) && (colA <= MAX_SIZE)) {\n            printf(\"Enter elements for Matrix A:\");\n            for (int i = 0; i < rowA; i++) {\n                for (int j = 0; j < colA; j++) {\n                    printf(\"\\nElement [%d][%d]: \", i + 1, j + 1);\n                    scanf(\"%d\", &valuesA[i][j]);\n                }\n            }\n        } else {\n            printf(\"Matrix dimensions exceed the maximum allowed size of %d.\\n\", MAX_SIZE);\n        }\n    \n        printf(\"\\nEnter dimensions for Matrix B: (rows and columns): \");\n        scanf(\"%d\", &rowB);\n        scanf(\"%d\", &colB);\n\n        if ((rowB <= MAX_SIZE) && (colB <= MAX_SIZE)) {\n            printf(\"Enter elements for Matrix B:\");\n            for (int i = 0; i < rowB; i++) {\n                for (int j = 0; j < colB; j++) {\n                    printf(\"\\nElement [%d][%d]: \", i + 1, j + 1);\n                    scanf(\"%d\", &valuesB[i][j]);\n                }\n            }\n        } else {\n            printf(\"Matrix dimensions exceed the maximum allowed size of %d.\\n\", MAX_SIZE);\n        }\n\n        // Ensure both matrices have the same dimensions\n        if (rowA != rowB || colA != colB) {\n            printf(\"Error! The number of rows and columns for both Matrices must be the same!\\n\");\n            continue; // Restart the loop for re-entry\n        } else {\n            break; // Exit the loop\n        }\n    }\n    \n    // Menu to perform matrix operations\n    while (1) {\n        printf(\"\\nMatrix Operation Menu:\\n\");\n        printf(\"1. Add Matrix\\n\");\n        printf(\"2. Subtract Matrix\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1: // Add matrices\n                add_matrix(rowA, colA, valuesA, valuesB);\n                break;\n            case 2: // Subtract matrices\n                sub_matrix(rowA, colA, valuesA, valuesB);\n                break;\n            case 3: // Transpose Matrix A\n                transpose_matrix(rowA, colA, valuesA);\n                break;\n            case 4: // Transpose Matrix B\n                transpose_matrix(rowB, colB, valuesB);\n                break;\n            case 5: // Exit the program\n                printf(\"Exiting...\\n\");\n                return 0;\n            default: // Invalid input\n                printf(\"Invalid choice. Please enter 1, 2, 3, 4, or 5.\\n\");\n        }\n    }\n\n    return 0;\n}\n\n/* --- q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#define MAX_SIZE 100 // Maximum number of grocery items\n\n// Structure to represent a grocery item\ntypedef struct {\n    char name[100];     // Name of the item\n    char category[100]; // Category of the item\n    int quantity;       // Quantity available\n    float price;        // Price of the item\n} GroceryItem;\n\n// Structure to represent the availability status of an item\ntypedef struct {\n    int InStock;     // Flag for items in stock\n    int OutofStock;  // Flag for items out of stock\n} AvailablityStatus;\n\n// Structure to represent the grocery inventory\ntypedef struct {\n    GroceryItem items[MAX_SIZE];         // Array to hold grocery items\n    AvailablityStatus availabity[MAX_SIZE]; // Array to hold availability statuses\n    int totalitems;                      // Total number of items in the inventory\n} GroceryInventory;\n\n// Function to add a new grocery item to the inventory\nvoid AddGroceryItems(GroceryInventory *inventory) {\n    // Check if the inventory has reached its maximum size\n    if ((*inventory).totalitems >= MAX_SIZE) {\n        printf(\"\\nThe max number of items has been reached!\\n\");\n        return;  \n    }\n\n    // Get pointers to the current product and its status\n    GroceryItem *product = &(*inventory).items[(*inventory).totalitems];\n    AvailablityStatus *status = &(*inventory).availabity[(*inventory).totalitems];\n\n    // Input details for the new item\n    printf(\"Enter item name: \");\n    fgets((*product).name, sizeof((*product).name), stdin);\n    (*product).name[strcspn((*product).name, \"\\n\")] = '\\0'; // Remove newline character\n\n    printf(\"Enter your category: \");\n    fgets((*product).category, sizeof((*product).category), stdin);\n    (*product).category[strcspn((*product).category, \"\\n\")] = '\\0'; // Remove newline character\n\n    printf(\"Enter quantity: \");\n    scanf(\"%d\", &(*product).quantity);\n\n    printf(\"Enter price: \");\n    scanf(\"%f\", &(*product).price);\n\n    // Set availability status based on quantity\n    if ((*product).quantity > 0) {\n        (*status).InStock = 1;\n    } else if ((*product).quantity == 0) {\n        (*status).OutofStock = 1;\n    }\n\n    // Increment the total number of items in the inventory\n    (*inventory).totalitems++;\n\n    printf(\"\\nGrocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items in the inventory\nvoid ListGroceryItems(GroceryInventory *inventory) {\n    // Check if the inventory is empty\n    if ((*inventory).totalitems == 0) {\n        printf(\"\\nNo grocery items in the inventory.\\n\");\n        return;\n    }\n\n    // Print details of each item\n    for (int i = 0; i < (*inventory).totalitems; i++) {\n        GroceryItem *product = &(*inventory).items[i];\n        AvailablityStatus *status = &(*inventory).availabity[i];\n\n        printf(\"Name: %s\\n\", (*product).name);\n        printf(\"Category: %s\\n\", (*product).category);\n        printf(\"Quantity: %d\\n\", (*product).quantity);\n        printf(\"Price: %.2f\\n\", (*product).price);\n        if ((*status).InStock == 1) {\n            printf(\"Status: In Stock\\n\");\n        }\n        if ((*status).OutofStock == 1) {\n            printf(\"Status: Out of Stock\\n\");\n        }\n        printf(\"\\n\");\n    }\n}\n\n// Function to update the quantity of a specific grocery item\nvoid UpdateQuantity(GroceryInventory *inventory) {\n    char name[100];\n\n    // Input the name of the item to update\n    printf(\"Enter the name of the grocery item to update quantity: \");\n    fgets(name, sizeof(name), stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\n\n    int itemfound = 0;\n\n    // Search for the item in the inventory\n    for (int i = 0; i < (*inventory).totalitems; i++) {\n        GroceryItem *product = &(*inventory).items[i];\n        AvailablityStatus *status = &(*inventory).availabity[i];\n\n        if (strcmp((*product).name, name) == 0) {\n            itemfound = 1;\n            printf(\"Enter new quantity for %s: \", name);\n            scanf(\"%d\", &(*product).quantity);\n            \n            // Clear input buffer\n            while (getchar() != '\\n');\n\n            // Update availability status\n            if ((*product).quantity <= 0) {\n                (*status).InStock = 0;\n                (*status).OutofStock = 1;\n            }\n            printf(\"\\nQuantity updated successfully!\\n\");\n            break;\n        }\n    }\n\n    // If the item is not found\n    if (!itemfound) {\n        printf(\"Name not found in the inventory!\\n\");\n    }\n}\n\n// Function to remove a grocery item from the inventory\nvoid RemoveGroceryItems(GroceryInventory *inventory) {\n    char name[100];\n\n    // Input the name of the item to remove\n    printf(\"Enter the name of the grocery item to be removed: \");\n    fgets(name, sizeof(name), stdin);\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline character\n\n    int itemfound = 0;\n\n    // Search for the item in the inventory\n    for (int i = 0; i < (*inventory).totalitems; i++) {\n        GroceryItem *product = &(*inventory).items[i];\n        AvailablityStatus *status = &(*inventory).availabity[i];\n\n        if (strcmp((*product).name, name) == 0) {\n            itemfound = 1;\n            // Remove the item by shifting the remaining items\n            for (int j = i; j < (*inventory).totalitems - 1; j++) {\n                (*inventory).items[j] = (*inventory).items[j + 1];\n                (*inventory).availabity[j] = (*inventory).availabity[j + 1];\n            }\n            (*inventory).totalitems--; // Decrement total items\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\n            break;\n        }\n    }\n\n    // If the item is not found\n    if (!itemfound) {\n        printf(\"\\nItem name was not found in the inventory!\\n\");\n    }\n}\n\n// Main function to display the menu and handle user choices\nint main() {\n    int choice = 0;\n    GroceryInventory inventory = {.totalitems = 0}; // Initialize inventory\n\n    while (1) {\n        // Display menu\n        printf(\"\\nGrocery Inventory Management System\\n\");\n        printf(\"1. Add Grocery Items\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        // Clear input buffer\n        while (getchar() != '\\n');\n\n        // Perform the selected operation\n        switch (choice) {\n            case 1:\n                AddGroceryItems(&inventory);\n                break;\n            case 2:\n                ListGroceryItems(&inventory);\n                break;\n            case 3:\n                UpdateQuantity(&inventory);\n                break;\n            case 4:\n                RemoveGroceryItems(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                return 0;\n            default:\n                printf(\"Invalid choice! Please try again!\\n\");\n                break;\n        }\n    }\n\n    return 0;\n}\n\n/* --- q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];            // Name of the student\n    int id;                    // ID of the student\n    float grade;               // Grade of the student\n    struct Student* next;      // Pointer to the next student in the list\n} Student;\n\n// Pointer to the head of the linked list\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student)); // Allocate memory for a new student\n    if (!newStudent) { // Check for memory allocation failure\n        printf(\"Memory allocation has failed!\\n\");\n        exit(1);\n    }\n\n    // Assign values to the new student node\n    strcpy((*newStudent).name, name);\n    (*newStudent).id = id;\n    (*newStudent).grade = grade;\n    (*newStudent).next = NULL;\n    return newStudent; // Return the new student node\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade); // Create a new student\n    if (!head) { // If the list is empty, make the new student the head\n        head = newStudent;\n    } else {\n        Student* current = head; // Traverse to the end of the list\n        while ((*current).next) {\n            current = (*current).next;\n        }\n        ((*current).next) = newStudent; // Add the new student at the end\n    }\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (!head) { // Check if the list is empty\n        printf(\"No student records found!\\n\");\n        return;\n    }\n    Student* current = head; // Start from the head\n    while (current) { // Traverse and display each student\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", (*current).name, (*current).id, (*current).grade);\n        current = (*current).next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head; // Start from the head\n    while (current) { // Traverse the list\n        if ((*current).id == id) { // Check if the current student's ID matches\n            return current;\n        }\n        current = (*current).next; // Move to the next student\n    }\n    return NULL; // Return NULL if the student is not found\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head; // Start from the head\n    Student* next;\n    while (current != NULL) { // Traverse and free each node\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL; // Reset the head pointer\n}\n\n// Wrapper function to delete the list (free all memory)\nvoid freeMemory() {\n    deleteList();\n}\n\n// Function to sort the student records by grade using Bubble Sort\nvoid sortStudents() {\n    if (!head || !(*head).next) { // Check if sorting is necessary\n        printf(\"No need to sort.\\n\");\n        return;\n    }\n\n    int swapped;\n    Student* current;\n    Student* lastnode = NULL;\n\n    do {\n        swapped = 0;\n        current = head;\n        while ((*current).next != lastnode) { // Traverse the list\n            if ((*current).grade > (*(*current).next).grade) { // Compare grades\n                // Swap data between current and next node\n                char tempname[100];\n                int tempid;\n                float tempgrade;\n\n                strcpy(tempname, (*current).name);\n                tempid = (*current).id;\n                tempgrade = (*current).grade;\n\n                strcpy((*current).name, (*(*current).next).name);\n                (*current).id = (*(*current).next).id;\n                (*current).grade = (*(*current).next).grade;\n\n                strcpy((*(*current).next).name, tempname);\n                (*(*current).next).id = tempid;\n                (*(*current).next).grade = tempgrade;\n\n                swapped = 1; // Mark as swapped\n            }\n            current = (*current).next; // Move to the next node\n        }\n        lastnode = current; // Update the last sorted node\n    } while (swapped);\n\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        // Display menu options\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records (choose sorting method)\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Consume the newline character\n\n        switch (choice) {\n            case 1: // Insert a new student\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                strtok(name, \"\\n\"); // Remove newline character\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n                insertStudent(name, id, grade);\n                break;\n            case 2: // Display all students\n                displayStudents();\n                break;\n            case 3: // Sort students by grade\n                sortStudents();\n                break;\n            case 4: // Search for a student by ID\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5: // Delete the list\n                deleteList();\n                printf(\"List deleted.\\n\");\n                break;\n            case 6: // Exit the program\n                freeMemory();\n                printf(\"Exiting...\\n\");\n                break;\n            default: // Invalid input\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6); // Repeat until the user chooses to exit\n\n    return 0;\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-    The program uses bubble sort to sort student records by grade. While bubble sort is straightforward and easy to implement, it has a time complexity of O(n?), which can be inefficient for larger datasets. For enhanced performance, consider using more efficient algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20615279",
    "code": "\n/* --- 20615279_ChongChengJun Lab assesment 3/20615279_ChongChengJun Lab assesment 3/Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAXIMUM 10\r\n\r\nvoid inputMatrix(int matrix[MAXIMUM][MAXIMUM], int rows, int columns, char name) {\r\n    // Obtain user input for each Matrix\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid addMatrices(int A[MAXIMUM][MAXIMUM], int B[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    // Addition of matrices\r\n    int result[MAXIMUM][MAXIMUM];\r\n    printf(\"Sum of Matrix A + Matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int A[MAXIMUM][MAXIMUM], int B[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    // Subtraction of matrices\r\n    int result[MAXIMUM][MAXIMUM];\r\n    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < columns; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAXIMUM][MAXIMUM], int rows, int columns) {\r\n    // Transpose of a matrix\r\n    int result[MAXIMUM][MAXIMUM];\r\n    printf(\"Transpose of the Matrix:\\n\");\r\n    for (int i = 0; i < columns; i++) {\r\n        for (int j = 0; j < rows; j++) {\r\n            result[i][j] = matrix[j][i];\r\n            printf(\"%d \", result[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    int A[MAXIMUM][MAXIMUM], B[MAXIMUM][MAXIMUM];\r\n    int Arows, Acolumns, Brows, Bcolumns;\r\n    int choice;\r\n\r\n    // Input dimensions for Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d%d\", &Arows, &Acolumns);\r\n    if (Arows > MAXIMUM || Acolumns > MAXIMUM || Arows <= 0 || Acolumns <= 0) {\r\n        printf(\"Invalid dimensions. Please enter values between 1 and %d.\\n\", MAXIMUM);\r\n        return 1;\r\n    }\r\n    \r\n    // Input elements for Matrix A\r\n    inputMatrix(A, Arows, Acolumns, 'A');\r\n\r\n    // Input dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d%d\", &Brows, &Bcolumns);\r\n    if (Brows > MAXIMUM || Bcolumns > MAXIMUM || Brows <= 0 || Bcolumns <= 0) {\r\n        printf(\"Invalid dimensions. Please enter values between 1 and %d.\\n\", MAXIMUM);\r\n        return 1;\r\n    }\r\n\r\n    // Input elements for Matrix B\r\n    inputMatrix(B, Brows, Bcolumns, 'B');\r\n\r\n    while (1) {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Use switch case to determine what function to use\r\n        switch (choice) {\r\n            case 1:\r\n                if (Arows == Brows && Acolumns == Bcolumns) {\r\n                    addMatrices(A, B, Arows, Acolumns);\r\n                } else {\r\n                    printf(\"Matrices must have the same dimensions to be added.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (Arows == Brows && Acolumns == Bcolumns) {\r\n                    subtractMatrices(A, B, Arows, Acolumns);\r\n                } else {\r\n                    printf(\"Matrices must have the same dimensions to be subtracted.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transposeMatrix(A, Arows, Acolumns);\r\n                break;\r\n            case 4:\r\n                transposeMatrix(B, Brows, Bcolumns);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n}\r\n\r\n\n/* --- 20615279_ChongChengJun Lab assesment 3/20615279_ChongChengJun Lab assesment 3/Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Maximum sizes\r\n#define MAX_ITEMS 100\r\n#define NAME_LENGTH 100\r\n#define CATEGORY_LENGTH 50\r\n\r\n// Define struct for Grocery Item\r\ntypedef struct {\r\n    char name[NAME_LENGTH];\r\n    char category[CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n    int inStock; // 1 if in stock, 0 for no stock\r\n} GroceryItem;\r\n\r\n// Define struct for grocery Inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    int count;\r\n} GroceryInventory;\r\n\r\n// Function to add a grocery item to the inventory\r\nvoid addItem(GroceryInventory *inventory) {\r\n    if ((*inventory).count >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem *item = &((*inventory).items[(*inventory).count]);\r\n    printf(\"Enter item name: \");\r\n    fgets((*item).name, NAME_LENGTH, stdin);\r\n    (*item).name[strcspn((*item).name, \"\\n\")] = '\\0'; // Remove '\\n' character\r\n\r\n    printf(\"Enter item category: \");\r\n    fgets((*item).category, CATEGORY_LENGTH, stdin);\r\n    (*item).category[strcspn((*item).category, \"\\n\")] = '\\0'; // Remove '\\n' character\r\n\r\n    printf(\"Enter item quantity: \");\r\n    scanf(\"%d\", &(*item).quantity);\r\n    getchar(); // Remove '\\n' left by scanf\r\n\r\n    printf(\"Enter item price: \");\r\n    scanf(\"%f\", &(*item).price);\r\n    getchar(); // Remove '\\n' left by scanf\r\n\r\n    (*item).inStock = (*item).quantity > 0 ? 1 : 0; // Set availability status\r\n    (*inventory).count++;\r\n\r\n    printf(\"Item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their availability\r\nvoid listItems(GroceryInventory *inventory) {\r\n    if ((*inventory).count == 0) { // Checks if inventory is empty or not\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < (*inventory).count; i++) {\r\n        GroceryItem *item = &((*inventory).items[i]);\r\n        printf(\"Name: %s\\n\", (*item).name);\r\n        printf(\"Category: %s\\n\", (*item).category);\r\n        printf(\"Quantity: %d\\n\", (*item).quantity);\r\n        printf(\"Price: %.2f\\n\", (*item).price);\r\n        printf(\"Status: %s\\n\", (*item).inStock ? \"In Stock\" : \"Out of Stock\");\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    if ((*inventory).count == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[NAME_LENGTH];\r\n    printf(\"Enter item name: \");\r\n    fgets(name, NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove '\\n' character\r\n\r\n    for (int i = 0; i < (*inventory).count; i++) {\r\n        GroceryItem *item = &((*inventory).items[i]);\r\n        if (strcmp((*item).name, name) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &(*item).quantity);\r\n            getchar(); // Remove '\\n' left by scanf\r\n            (*item).inStock = (*item).quantity > 0 ? 1 : 0; // Update availability status\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeItem(GroceryInventory *inventory) {\r\n    if ((*inventory).count == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    char name[NAME_LENGTH];\r\n    printf(\"Enter item name: \");\r\n    fgets(name, NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0'; // Remove '\\n' character\r\n\r\n    // Use linear search to look for the item name\r\n    for (int i = 0; i < (*inventory).count; i++) {\r\n        // Check if the item name matches the input\r\n        if (strcmp((*inventory).items[i].name, name) == 0) {\r\n            for (int j = i; j < (*inventory).count - 1; j++) {\r\n                (*inventory).items[j] = (*inventory).items[j + 1];\r\n            }\r\n            (*inventory).count--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nint main() {\r\n    GroceryInventory inventory;\r\n    inventory.count = 0; // Initialize inventory count\r\n\r\n    int choice;\r\n    while (1) {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List Grocery Items\\n\");\r\n        printf(\"3. Update Grocery Item\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // Remove '\\n' character left by scanf\r\n\r\n        // Use switch case to determine what function to use\r\n        switch (choice) {\r\n            case 1:\r\n                addItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting...\\n\");\r\n                return 0;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    }\r\n}\r\n\n/* --- 20615279_ChongChengJun Lab assesment 3/20615279_ChongChengJun Lab assesment 3/Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Initialize struct Student for data\r\ntypedef struct Student {\r\n    char name[100];       \r\n    int id;               \r\n    float grade;          \r\n    struct Student* next; \r\n} Student;\r\n\r\nStudent* head = NULL; // Head pointer for the linked list\r\n\r\nvoid insertStudent(const char* name, int id, float grade); \r\nvoid displayStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList(); \r\nvoid freeMemory();\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid sortStudents(); \r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        // Display menu options\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Insert Student Record\\n\");\r\n        printf(\"2. Display Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        while (getchar() != '\\n');\r\n\r\n        // Use switch case to determine what function to use\r\n        switch (choice) {\r\n            case 1:\r\n                // Input new student record\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin); // Read a line of input\r\n                name[strcspn(name, \"\\n\")] = '\\0'; // Clear input buffer\r\n\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n\r\n                printf(\"Enter Grade: \");            \r\n                scanf(\"%f\", &grade);\r\n\r\n                insertStudent(name, id, grade);\r\n                break;\r\n\r\n            case 2:\r\n                // Display all student records\r\n                displayStudents();\r\n                break;\r\n\r\n            case 3:\r\n                // Sort student records by grade\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using bubble sort.\\n\");\r\n                break;\r\n\r\n            case 4:\r\n                // Search for a student record by ID\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", (*found).name, (*found).id, (*found).grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n\r\n            case 5:\r\n                // Delete the entire linked list\r\n                deleteList();\r\n                printf(\"List of student records have been deleted.\\n\");\r\n                break;\r\n\r\n            case 6:\r\n                // Exit the program \r\n                printf(\"Exiting program...\\n\");\r\n                deleteList(); // Delete the list before exiting\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 6); // Loops if doesnt chooses 6 to exit\r\n\r\n    return 0;\r\n}\r\n\r\n// Function to create a new student record\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    // Dynamically allocate memory for a new student \r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    \r\n    // Set the student's attributes\r\n    strcpy((*newStudent).name, name);\r\n    (*newStudent).id = id;\r\n    (*newStudent).grade = grade;\r\n    (*newStudent).next = NULL; // Initialize the next pointer to NULL\r\n    \r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record at the beginning of the linked list\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    // Create a new student record\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    \r\n    // Link new student to the current head\r\n    (*newStudent).next = head;\r\n    \r\n    // New student becomes the head pointer\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records in the linked list\r\nvoid displayStudents() {\r\n    // Temporary pointer to traverse the linked list\r\n    Student* current = head;\r\n    \r\n    // Checks if the list is empty\r\n    if (!current) {\r\n        printf(\"No student records found.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Go through the list and print all student details\r\n    while (current) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", (*current).name, (*current).id, (*current).grade);\r\n        current = (*current).next;\r\n    }\r\n}\r\n\r\n// Function to search for a student record by their ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head; // Start at the first record\r\n\r\n    // Go through the list to find the matching ID\r\n    while (current) {\r\n        if ((*current).id == id) {\r\n            return current; // Return the pointer to the matching student \r\n        }\r\n        current = (*current).next; \r\n    }\r\n    return NULL; // Return NULL if not found\r\n}\r\n\r\n// Function to sort the student records by grade in ascending order \r\nvoid sortStudents() { \r\n    // Skip sorting if the list is empty or has only one element \r\n    if (!head || !(*head).next) { \r\n        return; \r\n    } \r\n    \r\n    int swapped; \r\n    Student *i; \r\n    Student *prev = NULL; // Pointer to mark the end of the sorted part of the list \r\n\r\n    // Use bubble sort to sort the records\r\n    do { \r\n        swapped = 0; \r\n        i = head;  // Start from the head of the list \r\n\r\n        // Traverse the list up to the sorted part \r\n        while ((*i).next != prev) { \r\n            // Compare the current student's grade with the next student's grade \r\n            if ((*i).grade > (*(*i).next).grade) { \r\n                // Swap data between the current student and the next student \r\n                char tempName[100]; \r\n                int tempID; \r\n                float tempGrade; \r\n\r\n                strcpy(tempName, (*i).name); \r\n                tempID = (*i).id; \r\n                tempGrade = (*i).grade; \r\n\r\n                strcpy((*i).name, (*(*i).next).name); \r\n                (*i).id = (*(*i).next).id; \r\n                (*i).grade = (*(*i).next).grade; \r\n\r\n                strcpy((*(*i).next).name, tempName); \r\n                (*(*i).next).id = tempID; \r\n                (*(*i).next).grade = tempGrade; \r\n\r\n                swapped = 1; // Set swapped flag to 1 \r\n            } \r\n\r\n            i = (*i).next; // Move to the next student in the list \r\n        } \r\n\r\n        prev = i; // Move the sorted boundary one step backward \r\n\r\n    } while (swapped); // Repeat until no swaps are made in a complete pass \r\n}\r\n\r\n\r\n// Function to delete the entire linked list and free allocated memory\r\nvoid deleteList() {\r\n    Student* current = head; // Start at the head of the list\r\n\r\n    // Traverse and free each record\r\n    while (current) {\r\n        Student* temp = current; \r\n        current = (*current).next; // Move to the next record\r\n        free(temp); \r\n    }\r\n    \r\n    head = NULL; // Set head to NULL after deleting all records\r\n}\n/* --- 20615279_ChongChengJun Lab assesment 3/20615279_ChongChengJun Lab assesment 3/tempCodeRunnerFile.c --- */\ngetchar();",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The sortStudents function uses Bubble Sort to arrange student records by grade. Although this algorithm is simple and easy to implement, it has a time complexity of O(n?), which may not be efficient for large datasets. Consider using a more efficient sorting algorithm, such as Quick Sort or Merge Sort, for better performance."
  },
  {
    "student_id": "20718629",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\nint main() {\r\n\r\n    // Declare variables for matrix dimensions, arrays, and result storage\r\n    int rowsA, columnsA, rowsB, columnsB;\r\n    int arrA[50][50], arrB[50][50];  // Matrices A and B\r\n    int choice;\r\n    int sum[50][50], subtract[50][50], transposeA[50][50], transposeB[50][50];  // Result matrices for sum, subtraction, and transpose\r\n    int i, j;\r\n\r\n    // Input for Matrix A\r\n    printf(\"Enter dimensions for Matrix A(rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &columnsA);\r\n\r\n    printf(\"Enter the element for Matrix A:\\n\");\r\n    for (i = 1; i <= rowsA; i++) {  // Loop through each element of Matrix A\r\n        for (j = 1; j <= columnsA; j++) {\r\n            printf(\"Element [%d][%d]: \", i, j);\r\n            scanf(\"%d\", &arrA[i][j]);\r\n        }\r\n    }\r\n\r\n    // Input for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &columnsB);\r\n\r\n    printf(\"Enter the element for Matrix B:\\n\");\r\n    for (i = 1; i <= rowsB; i++) {  // Loop through each element of Matrix B\r\n        for (j = 1; j <= columnsB; j++) {\r\n            printf(\"Element [%d][%d]: \", i, j);\r\n            scanf(\"%d\", &arrB[i][j]);\r\n        }\r\n    }\r\n\r\n    // Main menu for matrix operations\r\n    do {\r\n        printf(\"Matrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Switch case to handle the chosen matrix operation\r\n        switch (choice) {\r\n            // Add Matrices\r\n            case 1: {\r\n                // Check if matrices can be added (must have the same dimensions)\r\n                if (rowsA == rowsB && columnsA == columnsB) {\r\n                    for (i = 1; i <= rowsA; ++i) {  // Loop to add corresponding elements\r\n                        for (j = 1; j <= columnsA; j++) {\r\n                            sum[i][j] = arrA[i][j] + arrB[i][j];  // Sum of corresponding elements\r\n                        }\r\n                    }\r\n\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    for (i = 1; i <= rowsA; i++) {\r\n                        for (j = 1; j <= columnsA; j++) {\r\n                            printf(\"%d \", sum[i][j]);  // Print result matrix\r\n                        }\r\n                        printf(\"\\n\");\r\n                    }\r\n                    printf(\"\\n\");\r\n                } else {\r\n                    printf(\"Matrices dimensions must be the same for addition.\\n\");\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Subtract Matrices\r\n            case 2: {\r\n                // Check if matrices can be subtracted (must have the same dimensions)\r\n                if (rowsA == rowsB && columnsA == columnsB) {\r\n                    for (i = 1; i <= rowsA; ++i) {  // Loop to subtract corresponding elements\r\n                        for (j = 1; j <= columnsA; j++) {\r\n                            subtract[i][j] = arrA[i][j] - arrB[i][j];  // Difference of corresponding elements\r\n                        }\r\n                    }\r\n\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    for (i = 1; i <= rowsA; i++) {\r\n                        for (j = 1; j <= columnsA; j++) {\r\n                            printf(\"%d \", subtract[i][j]);  // Print result matrix\r\n                        }\r\n                        printf(\"\\n\");\r\n                    }\r\n                    printf(\"\\n\");\r\n                } else {\r\n                    printf(\"Matrices dimensions must be the same for subtraction.\\n\");\r\n                }\r\n                break;\r\n            }\r\n\r\n            // Transpose of Matrix A\r\n            case 3: {\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                for (i = 1; i <= rowsA; i++) {  // Loop to calculate transpose of Matrix A\r\n                    for (j = 1; j <= columnsA; j++) {\r\n                        transposeA[j][i] = arrA[i][j];  // Swap rows and columns for transpose\r\n                    }\r\n                }\r\n\r\n                for (i = 1; i <= columnsA; i++) {  // Print the transposed matrix\r\n                    for (j = 1; j <= rowsA; j++) {\r\n                        printf(\"%d \", transposeA[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                printf(\"\\n\");\r\n                break;\r\n            }\r\n\r\n            // Transpose of Matrix B\r\n            case 4: {\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                for (i = 1; i <= rowsB; i++) {  // Loop to calculate transpose of Matrix B\r\n                    for (j = 1; j <= columnsB; j++) {\r\n                        transposeB[j][i] = arrB[i][j];  // Swap rows and columns for transpose\r\n                    }\r\n                }\r\n\r\n                for (i = 1; i <= columnsB; i++) {  // Print the transposed matrix\r\n                    for (j = 1; j <= rowsB; j++) {\r\n                        printf(\"%d \", transposeB[i][j]);\r\n                    }\r\n                    printf(\"\\n\");\r\n                }\r\n                printf(\"\\n\");\r\n                break;\r\n            }\r\n\r\n            // Exit the program\r\n            case 5: {\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            }\r\n\r\n            // Invalid choice handling\r\n            default: {\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n                printf(\"\\n\");\r\n            }\r\n        }\r\n    } while (choice != 5);  // Continue until the user chooses to exit\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n// Structure for Grocery Item\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Structure for Availability Status\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Structure for Grocery Inventory\r\ntypedef struct {\r\n    GroceryItem items[100];\r\n    AvailabilityStatus availability[100];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\nint main() {\r\n    int choice;\r\n    GroceryInventory inventory;\r\n    inventory.itemCount = 0;\r\n\r\n    do {\r\n        printf(\"Grocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n    \r\n        switch (choice) {\r\n            case 1: // Add Grocery Item\r\n                GroceryItem *item = &inventory.items[inventory.itemCount];\r\n                AvailabilityStatus *status = &inventory.availability[inventory.itemCount];\r\n\r\n                printf(\"Name: \");\r\n                fgets(item->name, sizeof(item->name), stdin);\r\n                item->name[strcspn(item->name, \"\\n\")] = '\\0';  // Remove newline\r\n\r\n                printf(\"Category: \");\r\n                fgets(item->category, sizeof(item->category), stdin);\r\n                item->category[strcspn(item->category, \"\\n\")] = '\\0';  // Remove newline\r\n\r\n                printf(\"Quantity: \");\r\n                scanf(\"%d\", &item->quantity);\r\n\r\n                printf(\"Price: \");\r\n                scanf(\"%f\", &item->price);\r\n\r\n                status->inStock = item->quantity > 0;\r\n                status->outOfStock = !status->inStock;\r\n\r\n                inventory.itemCount++;\r\n                printf(\"Grocery item added successfully.\\n\\n\");\r\n                break;\r\n\r\n            case 2: // List All Grocery Items\r\n                if (inventory.itemCount == 0) {\r\n                    printf(\"No grocery items in the inventory.\\n\\n\");\r\n                    break;\r\n                }\r\n\r\n                printf(\"\\n%-20s %-15s %-10s %-10s %-s\\n\", \"Name\", \"Category\", \"Quantity\", \"Price\", \"Availability\");\r\n\r\n                for (int i = 0; i < inventory.itemCount; i++) {\r\n                    const GroceryItem *item = &inventory.items[i];\r\n                    const AvailabilityStatus *status = &inventory.availability[i];\r\n                    printf(\"%-20s %-15s %-10d %-10.2f %-s\\n\\n\", item->name, item->category, item->quantity, item->price,\r\n                        status->inStock ? \"In Stock\" : \"Out of Stock\");\r\n                }\r\n                break;\r\n\r\n            case 3: // Update Quantity\r\n                {\r\n                    char name[100];  // Declare the name variable here, scoped to case 3\r\n\r\n                    printf(\"Enter the name of the item to update: \");\r\n                    fgets(name, sizeof(name), stdin);\r\n                    name[strcspn(name, \"\\n\")] = '\\0';  // Remove newline\r\n\r\n                    bool found = false;\r\n                    for (int i = 0; i < inventory.itemCount; i++) {\r\n                        GroceryItem *item = &inventory.items[i];\r\n                        if (strcmp(item->name, name) == 0) {\r\n                            printf(\"Enter the new quantity for %s: \", name);\r\n                            scanf(\"%d\", &item->quantity);\r\n                            getchar();  // Consume newline\r\n\r\n                            AvailabilityStatus *status = &inventory.availability[i];\r\n                            status->inStock = item->quantity > 0;\r\n                            status->outOfStock = !status->inStock;\r\n\r\n                            printf(\"Quantity updated successfully.\\n\\n\");\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (!found) {\r\n                        printf(\"Item is not found.\\n\");\r\n                    }\r\n                    break;\r\n                }\r\n\r\n            case 4: // Remove Grocery Item\r\n                {\r\n                    char name[100];  // Declare the name variable here, scoped to case 4\r\n\r\n                    printf(\"Enter the name of the item to remove: \");\r\n                    fgets(name, sizeof(name), stdin);\r\n                    name[strcspn(name, \"\\n\")] = '\\0';  // Remove newline\r\n\r\n                    bool found = false;\r\n                    for (int i = 0; i < inventory.itemCount; i++) {\r\n                        if (strcmp(inventory.items[i].name, name) == 0) {\r\n                            for (int j = i; j < inventory.itemCount - 1; j++) {\r\n                                inventory.items[j] = inventory.items[j + 1];\r\n                                inventory.availability[j] = inventory.availability[j + 1];\r\n                            }\r\n                            inventory.itemCount--;\r\n                            printf(\"Grocery item %s removed successfully!\\n\\n\", name);\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        printf(\"Item does not found in the inventory.\\n\\n\");\r\n                    }\r\n                    break;\r\n                }\r\n\r\n            case 5: // Exit\r\n                printf(\"Exiting program.\\n\\n\");\r\n                break;\r\n\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed\\n\");\r\n        exit(1); // Exit if memory allocation fails\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (head == NULL) {\r\n        head = newStudent;  // If the list is empty, the new student becomes the head\r\n    } else {\r\n        newStudent->next = head; // Point the new student's next to the current head\r\n        head = newStudent; // Make the new student the new head\r\n    }\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No students in the list.\\n\");\r\n        return;\r\n    }\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp; // Return the student node if the ID matches\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL; // Return NULL if student not found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current); // Free memory for each student\r\n        current = next;\r\n    }\r\n    head = NULL; // Set head to NULL after deleting all nodes\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Sort function to sort the student records by grade using bubble sort\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return; // No need to sort if the list has 0 or 1 student\r\n    }\r\n\r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* ptr2 = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != ptr2) {\r\n            if (ptr1->grade > ptr1->next->grade) { // Change condition to sort in ascending order\r\n                // Swap grades\r\n                float tempGrade = ptr1->grade;\r\n                int tempID = ptr1->id;\r\n                char tempName[100];\r\n                strcpy(tempName, ptr1->name);\r\n\r\n                ptr1->grade = ptr1->next->grade;\r\n                ptr1->id = ptr1->next->id;\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n\r\n                ptr1->next->grade = tempGrade;\r\n                ptr1->next->id = tempID;\r\n                strcpy(ptr1->next->name, tempName);\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        ptr2 = ptr1; // Decrease the range of the list to be sorted\r\n    } while (swapped);\r\n}\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\");\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using bubble sort.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id); \r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\",\r\n                        found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-The program uses 1-based indexing for the arrays (starting from 1), which can lead to undefined behavior when accessing arrA[0][0] or arrB[0][0] if those indices are accessed. Arrays in C are indexed from 0. The transposed matrices transposeA and transposeB are printed with swapped dimensions, but the loop for printing does not accurately reflect the transposed dimensions, which can lead to incorrect output.\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While Bubble Sort is easy to understand and implement, its time complexity of O(n?) can be inefficient for larger datasets. For better performance, consider using more efficient algorithms such as Merge Sort or Quick Sort."
  },
  {
    "student_id": "20702950",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define LIMIT 10\r\n//Function to prompt user input for Matrix\r\nvoid getMatrixInput(int mat[LIMIT][LIMIT], int rows, int cols, char matName) {\r\n    printf(\"Enter elements for Matrix %c:\\n\", matName);\r\n    for (int r = 0; r < rows; r++) {\r\n        for (int c = 0; c < cols; c++) {\r\n            printf(\"Element [%d][%d]: \", r + 1, c + 1);\r\n            scanf(\"%d\", &mat[r][c]);\r\n        }\r\n    }\r\n}\r\n//Function to display the matrix\r\nvoid displayMatrix(int mat[LIMIT][LIMIT], int rows, int cols) {\r\n    for (int r = 0; r < rows; r++) {\r\n        for (int c = 0; c < cols; c++) {\r\n            printf(\"%d \", mat[r][c]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n//Function to add the 2 matrices together\r\nvoid matrixAddition(int mat1[LIMIT][LIMIT], int mat2[LIMIT][LIMIT], int sum[LIMIT][LIMIT], int rows, int cols) {\r\n    for (int r = 0; r < rows; r++) {\r\n        for (int c = 0; c < cols; c++) {\r\n            sum[r][c] = mat1[r][c] + mat2[r][c];\r\n        }\r\n    }\r\n}\r\n//Function to subtract the matrices\r\nvoid matrixSubtraction(int mat1[LIMIT][LIMIT], int mat2[LIMIT][LIMIT], int diff[LIMIT][LIMIT], int rows, int cols) {\r\n    for (int r = 0; r < rows; r++) {\r\n        for (int c = 0; c < cols; c++) {\r\n            diff[r][c] = mat1[r][c] - mat2[r][c];\r\n        }\r\n    }\r\n}\r\n//Function to compute the transpose of a matrix\r\nvoid matrixTranspose(int mat[LIMIT][LIMIT], int trans[LIMIT][LIMIT], int rows, int cols) {\r\n    for (int r = 0; r < rows; r++) {\r\n        for (int c = 0; c < cols; c++) {\r\n            trans[c][r] = mat[r][c];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    //Variables for the matrices and the dimensions\r\n    int mat1[LIMIT][LIMIT], mat2[LIMIT][LIMIT], result[LIMIT][LIMIT];\r\n    int mat1Rows, mat1Cols, mat2Rows, mat2Cols;\r\n    int option;\r\n\r\n    //Inputting the dimensions of Matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d%d\", &mat1Rows, &mat1Cols);\r\n\r\n    //Validating dimensions for Matrix A\r\n    if (mat1Rows > LIMIT || mat1Cols > LIMIT || mat1Rows < 1 || mat1Cols < 1) {\r\n        printf(\"Error: Invalid dimensions for Matrix A.\\n\");\r\n        return 1;\r\n    }\r\n    getMatrixInput(mat1, mat1Rows, mat1Cols, '1');\r\n\r\n    //Inputting dimensions for Matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d%d\", &mat2Rows, &mat2Cols);\r\n\r\n    //Validating dimensions of Matrix B\r\n    if (mat2Rows > LIMIT || mat2Cols > LIMIT || mat2Rows < 1 || mat2Cols < 1) {\r\n        printf(\"Error: Invalid dimensions for Matrix B.\\n\");\r\n        return 1;   \r\n    }\r\n    getMatrixInput(mat2, mat2Rows, mat2Cols, '2');\r\n\r\n    //Menu\r\n    do {\r\n        printf(\"\\nMenu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix 1\\n\");\r\n        printf(\"4. Transpose Matrix 2\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &option);\r\n\r\n        switch (option) {\r\n            case 1: //To add the matrices\r\n                if (mat1Rows == mat2Rows && mat1Cols == mat2Cols) {\r\n                    matrixAddition(mat1, mat2, result, mat1Rows, mat1Cols);\r\n                    printf(\"Result of Matrix 1 + Matrix 2:\\n\");\r\n                    displayMatrix(result, mat1Rows, mat1Cols);\r\n                } else {\r\n                    printf(\"Error: Addition not possible. Dimensions must match.\\n\");\r\n                }\r\n                break;\r\n            case 2: //To subtract the matrices\r\n                if (mat1Rows == mat2Rows && mat1Cols == mat2Cols) {\r\n                    matrixSubtraction(mat1, mat2, result, mat1Rows, mat1Cols);\r\n                    printf(\"Result of Matrix 1 - Matrix 2:\\n\");\r\n                    displayMatrix(result, mat1Rows, mat1Cols);\r\n                } else {\r\n                    printf(\"Error: Subtraction not possible. Dimensions must match.\\n\");\r\n                }\r\n                break;\r\n            case 3: //To transpose Matrix A\r\n                matrixTranspose(mat1, result, mat1Rows, mat1Cols);\r\n                printf(\"Transpose of Matrix 1:\\n\");\r\n                displayMatrix(result, mat1Cols, mat1Rows);\r\n                break;\r\n            case 4: //To transpose Matrix B\r\n                matrixTranspose(mat2, result, mat2Rows, mat2Cols);\r\n                printf(\"Transpose of Matrix 2:\\n\");\r\n                displayMatrix(result, mat2Cols, mat2Rows);\r\n                break;\r\n            case 5: //Exit program\r\n                printf(\"Exiting the program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a valid option.\\n\");\r\n        }\r\n    } while (option != 5);\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_CAPACITY 100\r\n\r\n//Structure which represents a product\r\ntypedef struct {\r\n    char itemName[100];\r\n    char itemCategory[50];\r\n    int itemQuantity;\r\n    float itemPrice;\r\n    int isInStock;\r\n} Product;\r\n\r\n//Structure which represents the inventory\r\ntypedef struct {\r\n    Product products[MAX_CAPACITY];\r\n    int totalProducts;\r\n} ProductInventory;\r\n\r\n//Function t add a new product\r\nvoid addProduct(ProductInventory *inventory) {\r\n    if (inventory->totalProducts >= MAX_CAPACITY) {\r\n        printf(\"Inventory is full! Cannot add more products.\\n\");\r\n        return;\r\n    }\r\n    Product *product = &inventory->products[inventory->totalProducts];\r\n    printf(\"Enter Item Name: \");\r\n    scanf(\" %[^\\n]\", product->itemName);\r\n    printf(\"Enter Category: \");\r\n    scanf(\" %[^\\n]\", product->itemCategory);\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &product->itemQuantity);\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &product->itemPrice);\r\n    product->isInStock = product->itemQuantity > 0;\r\n    inventory->totalProducts++;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n//Function to list all the products available in the inventory\r\nvoid listProducts(const ProductInventory *inventory) {\r\n    if (inventory->totalProducts == 0) {\r\n        printf(\"No products in inventory.\\n\");\r\n        return;\r\n    }\r\n    for (int i = 0; i < inventory->totalProducts; i++) {\r\n        const Product *product = &inventory->products[i];\r\n        printf(\"\\nProduct %d:\\n\", i + 1);\r\n        printf(\"Name: %s\\n\", product->itemName);\r\n        printf(\"Category: %s\\n\", product->itemCategory);\r\n        printf(\"Quantity: %d\\n\", product->itemQuantity);\r\n        printf(\"Price: %.2f\\n\", product->itemPrice);\r\n        printf(\"Status: %s\\n\", product->isInStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n//Function to update the quantity of a product\r\nvoid updateProductQuantity(ProductInventory *inventory) {\r\n    char productName[100];\r\n    printf(\"Enter the name of the grocery item to update quantity: \");\r\n    scanf(\" %[^\\n]\", productName);\r\n\r\n    for (int i = 0; i < inventory->totalProducts; i++) {\r\n        Product *product = &inventory->products[i];\r\n        if (strcmp(product->itemName, productName) == 0) {\r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &product->itemQuantity);\r\n            product->isInStock = product->itemQuantity > 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Error: Product not found.\\n\");\r\n}\r\n\r\n//Function to remove a product \r\nvoid removeProduct(ProductInventory *inventory) {\r\n    char productName[100];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    scanf(\" %[^\\n]\", productName);\r\n\r\n    for (int i = 0; i < inventory->totalProducts; i++) {\r\n        if (strcmp(inventory->products[i].itemName, productName) == 0) {\r\n            for (int j = i; j < inventory->totalProducts - 1; j++) {\r\n                inventory->products[j] = inventory->products[j + 1];\r\n            }\r\n            inventory->totalProducts--;\r\n            printf(\"Product removed successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Error: Product not found.\\n\");\r\n}\r\n\r\nint main() {\r\n    ProductInventory inventory = {.totalProducts = 0};\r\n    int userChoice;\r\n\r\n    printf(\"Grocery Inventory Management System\\n\");\r\n\r\n    //Displaying the menu\r\n    do {\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &userChoice);\r\n\r\n        switch (userChoice) {\r\n            case 1: //Adding a new product\r\n                addProduct(&inventory);\r\n                break;\r\n            case 2: //Listing all the products\r\n                listProducts(&inventory);\r\n                break;\r\n            case 3: //Updating the quantity of a product \r\n                updateProductQuantity(&inventory);\r\n                break;\r\n            case 4: //Removing a product\r\n                removeProduct(&inventory);\r\n                break;\r\n            case 5: //Exiting the program\r\n                printf(\"Exiting the program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (userChoice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n//Structure for a student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n//Function to create a student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n//Function to insert a student node\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n//Function to diplay all the student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No records to display.\\n\");\r\n        return;\r\n    }\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n//Function to search student by their ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n//Function to delete the whole list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n    printf(\"List deleted successfully.\\n\");\r\n}\r\n\r\n//Function to sort the student records based on their grade\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;\r\n    }\r\n\r\n    for (Student* i = head; i != NULL; i = i->next) {\r\n        for (Student* j = i->next; j != NULL; j = j->next) {\r\n            if (i->grade > j->grade) {\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, i->name);\r\n                tempId = i->id;\r\n                tempGrade = i->grade;\r\n\r\n                strcpy(i->name, j->name);\r\n                i->id = j->id;\r\n                i->grade = j->grade;\r\n\r\n                strcpy(j->name, tempName);\r\n                j->id = tempId;\r\n                j->grade = tempGrade;\r\n            }\r\n        }\r\n    }\r\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n}\r\n\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    //Menu\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The program uses a bubble sort approach to sort student records by grade. While this is a simple and clear method, it has a time complexity of O(n?), which can lead to inefficiencies with larger datasets. For improved performance, consider using a more efficient sorting algorithm like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20690629",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX 10\r\n\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols)\r\n{\r\n    // for every row\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        // for every column\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            // prompt user to input each element\r\n            printf(\"Enter element %dx%d: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid AddMatrices(int p[MAX][MAX], int q[MAX][MAX], int ans[MAX][MAX], int rows, int cols)\r\n{\r\n    // for every row\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        // for every column\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            // calculate the sum of elements in the same position of matrices A and B and store in answer matrix\r\n            ans[i][j] = p[i][j] + q[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid SubtractMatrices(int p[MAX][MAX], int q[MAX][MAX], int ans[MAX][MAX], int rows, int cols)\r\n{\r\n    // for every row\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        // for every column\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            // calculate the difference of elements in the same position of matrices A and B and store in answer matrix\r\n            ans[i][j] = p[i][j] - q[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid TransposeMatrix(int matrix[MAX][MAX], int ans[MAX][MAX], int rows, int cols)\r\n{\r\n    // for every row\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        // for every column\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            // change the position of elements in matrix\r\n            ans[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid Display(int matrix[MAX][MAX], int rows, int cols)\r\n{\r\n    // for every row\r\n    for (int i = 0; i < rows; i++)\r\n    {\r\n        // for every column\r\n        for (int j = 0; j < cols; j++)\r\n        {\r\n            // display each item on console\r\n            printf(\"%d\\t\", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n    // my double array for matrix A is p and for matrix B is q\r\n    int p[MAX][MAX], q[MAX][MAX], ans[MAX][MAX];\r\n    int rowp, colp, rowq, colq;\r\n    int choice = -1;\r\n    int option = 0;\r\n\r\n    // input number of rows, columns, and elements of each matrix\r\n    printf(\"Enter the dimensions of matrices separated with a space\\n\");\r\n\r\n    printf(\"\\nEnter rows of matrix A: \");\r\n    scanf(\"%d\", &rowp);\r\n\r\n    printf(\"\\nEnter columns of matrix A: \");\r\n    scanf(\"%d\", &colp);\r\n\r\n    printf(\"\\nEnter elements for matrix A\\n\");\r\n    inputMatrix(p, rowp, colp);\r\n\r\n    printf(\"\\nEnter rows of matrix B: \");\r\n    scanf(\"%d\", &rowq);\r\n\r\n    printf(\"\\nEnter columns of matrix B: \");\r\n    scanf(\"%d\", &colq);\r\n\r\n    printf(\"\\nEnter elements for matrix B\\n\");\r\n    inputMatrix(q, rowq, colq);\r\n\r\n    while (choice)\r\n    {\r\n        // prompt user to choose an operation on matrices p and q\r\n        printf(\"Matrix Operations\\n\");\r\n        printf(\"1. Add Matrices\\n2. Subtract Matrices\\n3. Transpose Matrix\\n4. Display Matrix\\n0. Exit\\n\");\r\n        printf(\"Enter your choice of operation: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // choice is a sentinal value, loop terminates when 0 is input\r\n        switch(choice)\r\n        {\r\n            case 0:\r\n                break;\r\n            case 1:\r\n                // if matrices have same dimensions, addition can happen\r\n                if (rowp == rowq && colp == colq)\r\n                {\r\n                    AddMatrices(p, q, ans, rowp, colp);\r\n                    Display(ans, rowp, colp);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"\\nDimensions of matrices are not the same\\n\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                // if matrices have same dimensions, subtraction can happen\r\n                if (rowp == rowq && colp == colq)\r\n                {\r\n                    SubtractMatrices(p, q, ans, rowp, colp);\r\n                    Display(ans, rowp, colp);\r\n                }\r\n                else\r\n                {\r\n                    printf(\"\\nDimensions of matrices are not the same\\n\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                // prompt input from user on which matrix to transpose\r\n                option = 0;\r\n                printf(\"Enter 1 for matrix A, 2 for matrix B: \");\r\n                scanf(\"%d\", &option);\r\n                if (option == 1) \r\n                {\r\n                    TransposeMatrix(p, ans, rowp, colp);\r\n                    Display(ans, colp, rowp);\r\n                }\r\n                else if (option == 2)\r\n                {\r\n                    TransposeMatrix(q, ans, rowq, colq);\r\n                    Display(ans, colq, rowq);\r\n                }\r\n                else \r\n                {\r\n                    printf(\"option is not valid\\n\");\r\n                }\r\n                break;\r\n            case 4:\r\n                // display only matrix A and matrix B\r\n                printf(\"Matrix A\\n\");\r\n                Display(p, rowp, colp);\r\n                printf(\"\\n\");\r\n                printf(\"Matrix B\\n\");\r\n                Display(q, rowq, colq);\r\n                break;\r\n            default:\r\n                // user must input a valid operation\r\n                printf(\"You did not enter a valid option\\n\");\r\n                break;\r\n        }\r\n    }\r\n}\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n\r\ntypedef struct \r\n{\r\n    char name[101];\r\n    char category[101];\r\n    int quantity;\r\n    float price;\r\n} Item;\r\n\r\nvoid AddItem(Item groceries[], int status[], int* count)\r\n{\r\n    // if inventory is full\r\n    if (*count >= 100)\r\n    {\r\n        printf(\"Inventory of groceries is full\\n\");\r\n    }\r\n\r\n    // prompt user to input details for new item\r\n    char name[101];\r\n    char category[101];\r\n    int quantity;\r\n    float price;\r\n\r\n    printf(\"Enter item name: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter category: \");\r\n    fgets(category, 100, stdin);\r\n    category[strcspn(category, \"\\n\")] = '\\0';\r\n\r\n    printf(\"Enter quantity: \");\r\n    scanf(\"%d\", &quantity);\r\n\r\n    printf(\"Enter price: \");\r\n    scanf(\"%f\", &price);\r\n\r\n    // if quantity or price is negative\r\n    if (quantity < 0 || price < 0)\r\n    {\r\n        printf(\"Input is not valid\\n\");\r\n        printf(\"Grocery item not added\\n\");\r\n    }\r\n    else\r\n    {\r\n        // create new item and initialise item details\r\n        Item new_item;\r\n        groceries[*count] = new_item;\r\n\r\n        strcpy(groceries[*count].name, name);\r\n        strcpy(groceries[*count].category, category);\r\n        groceries[*count].quantity = quantity;\r\n        groceries[*count].price = price;\r\n\r\n        if (quantity == 0)\r\n        {\r\n            status[*count] = 0;\r\n        }\r\n        else if (quantity > 0)\r\n        {\r\n            status[*count] = 1;\r\n        }\r\n\r\n        *count += 1;\r\n        printf(\"\\nGrocery item added\\n\");\r\n    }\r\n}\r\n\r\nvoid UpdateQuantity(Item groceries[], int status[], int* count)\r\n{\r\n    char name[100];\r\n    int num;\r\n    // prompt user for item to update quantity\r\n    printf(\"Enter name of grocery item to update quantity: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    // find item in inventory\r\n    int index = -1;\r\n    for (int i = 0; i < *count; i++)\r\n    {\r\n        if (strcmp(groceries[i].name, name) == 0)\r\n        {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // if item is not found in inventory\r\n    if (index < 0)\r\n    {\r\n        printf(\"Item is not found in the item\\n\");\r\n    }\r\n    // if item is found in inventory\r\n    else \r\n    {\r\n        // prompt user for new quantity\r\n        printf(\"Enter new quantity for grocery item: \");\r\n        scanf(\"%d\", &num);\r\n\r\n        // if quantity is 0, item is out of stock\r\n        if (num == 0)\r\n        {\r\n            groceries[index].quantity = num;\r\n            status[index] = 0;\r\n        }\r\n        // if quantity is greater than 0, item is in stock\r\n        else if (num > 0)\r\n        {\r\n            groceries[index].quantity = num;\r\n            status[index] = 1;\r\n        }\r\n        // if quantity is less than 0, value is not valid\r\n        else\r\n        {\r\n            printf(\"Quantity is not updated as input is not a valid quantity\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid RemoveItem(Item groceries[], int status[], int* count)\r\n{\r\n    char name[100];\r\n    // prompt user for item to remove\r\n    printf(\"Enter name of grocery item to remove: \");\r\n    fgets(name, 100, stdin);\r\n    name[strcspn(name, \"\\n\")] = '\\0';\r\n\r\n    // search for item in inventory\r\n    int index = -1;\r\n    for (int i = 0; i < *count; i++)\r\n    {\r\n        if (strcmp(groceries[i].name, name) == 0)\r\n        {\r\n            index = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (index >= 0 && index < *count)\r\n    {\r\n        // move all items after removed item one backward position and decrease number of items\r\n        for (int i = index; i < *count - 1; i++) \r\n        {\r\n            groceries[i] = groceries[i + 1];\r\n            status[i] = status[i + 1];\r\n        }\r\n        (*count)--;\r\n    }\r\n\r\n    // if item not found\r\n    if (index < 0)\r\n    {\r\n        printf(\"\\nItem is not found in list\\n\");\r\n    }\r\n    // item is found and removed\r\n    else\r\n    {\r\n        printf(\"\\nItem removed successfully\\n\");\r\n    }\r\n}\r\n\r\nvoid ListItems(Item groceries[], int status[], int* count)\r\n{\r\n\r\n    for (int i = 0; i < *count; i++)\r\n    {\r\n        // to determine if item is in stock or out of stock based on boolean value\r\n        char* bools = (status[i]) ? \"In stock\" : \"Out of stock\";\r\n        // display details of item\r\n        printf(\"\\n\");\r\n        printf(\"name: %s\\n\", groceries[i].name);\r\n        printf(\"category: %s\\n\", groceries[i].category);\r\n        printf(\"quantity: %d\\n\", groceries[i].quantity);\r\n        printf(\"price: %.2f\\n\", groceries[i].price);\r\n        printf(\"status: %s\\n\", bools);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main(void)\r\n{\r\n    Item groceries[100];\r\n    int status[100] = {0};\r\n    int count = 0;\r\n\r\n    // open inventory file and read file lines into array of structs\r\n    FILE *read_inventory = fopen(\"inventory.csv\", \"r+\");\r\n    while (fscanf(read_inventory, \"%100[^,], %100[^,], %d, %f, %d\\n\", groceries[count].name, groceries[count].category, &groceries[count].quantity, &groceries[count].price, &status[count]) != EOF)\r\n    {\r\n        count++;\r\n    }\r\n    fclose(read_inventory);\r\n\r\n    int choice = 0;\r\n    while (choice != 5)\r\n    {\r\n        printf(\"\\nGrocery Management Inventory System\\n\");\r\n        printf(\"1. Add Grocery Item\\n2. List All Grocery items\\n3. Update Quantity\\n4. Remove Grocery Item\\n5. Exit\\n\");\r\n        // prompt user for options on grocery items\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar();\r\n\r\n        switch (choice)\r\n        {\r\n            case 1:\r\n                AddItem(groceries, status, &count);\r\n                break;\r\n            case 2:\r\n                ListItems(groceries, status, &count);\r\n                break;\r\n            case 3:\r\n                UpdateQuantity(groceries, status, &count);\r\n                break;\r\n            case 4:\r\n                RemoveItem(groceries, status, &count);\r\n                break;\r\n            case 5:\r\n                break;\r\n            default:\r\n                // user option is not valid\r\n                printf(\"Not a valid option\\n\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    // write new information, array of structs, to the file inventory\r\n    FILE *write_inventory = fopen(\"inventory.csv\", \"w\");\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        fprintf(write_inventory, \"%s, %s, %d, %.2f, %d\\n\", groceries[i].name, groceries[i].category, groceries[i].quantity, groceries[i].price, status[i]);\r\n    }\r\n    fclose(write_inventory);\r\n}\r\n\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n// Structure for Student \r\ntypedef struct Student {     \r\n    char name[100];     \r\n    int id;     \r\n    float grade;     \r\n    struct Student* next; \r\n} Student;  \r\n\r\nStudent* head = NULL;  \r\n\r\n// Function to create a new student node \r\nStudent* createStudent(const char* name, int id, float grade) \r\n{ \r\n    // create new student node and assign a pointer to it\r\n    // assign name, id and grade to it\r\n    Student* node = (Student*)malloc(sizeof(Student));\r\n    strcpy(node->name, name);\r\n    node->id = id;\r\n    node->grade = grade;\r\n    node->next = NULL;\r\n    return node;\r\n}  \r\n\r\n// Function to insert a new student record \r\nvoid insertStudent(const char* name, int id, float grade) \r\n{ \r\n    // creat student\r\n    Student *new = createStudent(name, id, grade);\r\n    Student *temp = head;\r\n    if (head == NULL) \r\n        head = new;\r\n    else\r\n    {\r\n        // traverse the list and insert the node at the end\r\n        while (temp->next != NULL)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = new;\r\n    }\r\n} \r\n\r\n// Function to display all student records \r\nvoid displayStudents() \r\n{    \r\n    if (head == NULL) return;\r\n    Student *node = head;\r\n    printf(\"\\n\");\r\n    // traverse the list and print out attributes of each node\r\n    while (node != NULL)\r\n    {\r\n        printf(\"%s,  %d,  %.2f\\n\", node->name, node->id, node->grade);\r\n        node = node->next;\r\n    }\r\n}  \r\n\r\n// Function to search for a student by ID \r\nStudent* searchStudentByID(int id) \r\n{ \r\n    // traverse the list and check the id of each node agains the input id\r\n    Student* node = head;\r\n    while(node != NULL)\r\n    {\r\n        if (node->id == id) return node;\r\n        node = node->next;\r\n    }\r\n    return NULL;\r\n}  \r\n\r\n// Function to delete the entire list \r\nvoid deleteList() \r\n{     \r\n    Student* current = head;     \r\n    Student* next;      \r\n    while (current != NULL) \r\n    {         \r\n        next = current->next;         \r\n        free(current);         \r\n        current = next;     \r\n    }     \r\n    head = NULL; \r\n} \r\nvoid freeMemory() \r\n{     \r\n    deleteList(); \r\n}  \r\n\r\n// splitting lists into halves\r\nvoid splitList(Student* source, Student** front, Student** back)\r\n{\r\n    // a fast pointer that points to the next node after the next node to determine end of list\r\n    // a slow pointer that points to the next node to determine middle of list\r\n    Student* slow = source;\r\n    Student* fast = source->next;\r\n\r\n    while (fast != NULL && fast->next != NULL)\r\n    {\r\n        fast=fast->next->next;\r\n        slow=slow->next;\r\n    }\r\n    // splitting list to first half and second half\r\n    *front = source;\r\n    *back = slow->next;\r\n\r\n    slow->next = NULL;\r\n}\r\n\r\n// merge sorted lists after splitting happens\r\nStudent* mergeLists(Student *p, Student *q)\r\n{\r\n    Student *ans = NULL;\r\n    // if first half is empty, return remaining of second half\r\n    if (p == NULL) return q;\r\n    // if second half is empty, return remaining of first half\r\n    if (q == NULL) return p;\r\n\r\n    // compare value of node in first half and value of node in second half\r\n    if (p->grade <= q->grade)\r\n    {\r\n        // move to next node in first half\r\n        ans = p;\r\n        ans->next = mergeLists(p->next, q);\r\n    }\r\n    else\r\n    {\r\n        // move to next node in second half\r\n        ans = q;\r\n        ans->next = mergeLists(p, q->next);\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\n// Sort function to sort the student records by grade based on an algorithm of your choice \r\nvoid sortStudents(Student** source) \r\n{ \r\n    // merge sort\r\n    if (*source == NULL || (*source)->next == NULL) return;\r\n\r\n    Student* front;\r\n    Student* back;\r\n    // split lists\r\n    splitList(*source, &front, &back);\r\n    // merge sorted lists\r\n    sortStudents(&front);\r\n    sortStudents(&back);\r\n\r\n    *source = mergeLists(front, back);\r\n}  \r\n\r\n// Main function to drive the program \r\nint main() \r\n{      \r\n    int choice, id;     \r\n    char name[100];     \r\n    float grade;      \r\n    do {         \r\n        printf(\"\\n1. Insert Student Record\\n\");         \r\n        printf(\"2. Display Student Records\\n\");         \r\n        printf(\"3. Sort Records\\n\");         \r\n        printf(\"4. Search Record by ID\\n\");         \r\n        printf(\"5. Delete List\\n\");         \r\n        printf(\"6. Exit\\n\");         \r\n        printf(\"Enter your choice: \");         \r\n        scanf(\"%d\", &choice);         \r\n        getchar(); // To consume the newline character          \r\n        switch (choice) \r\n        {             \r\n            case 1:                 \r\n                printf(\"Enter Name: \");                 \r\n                fgets(name, sizeof(name), stdin);                 \r\n                strtok(name, \"\\n\");                 \r\n                printf(\"Enter ID: \");                 \r\n                scanf(\"%d\", &id);                 \r\n                printf(\"Enter Grade: \");                 \r\n                scanf(\"%f\", &grade);                 \r\n                insertStudent(name, id, grade);                 \r\n                break;             \r\n            case 2:                 \r\n                displayStudents();                 \r\n                break;             \r\n            case 3:      \r\n                sortStudents(&head);                                 \r\n                break;             \r\n            case 4:                 \r\n                printf(\"Enter ID to search: \");                 \r\n                scanf(\"%d\", &id);                 \r\n                Student* found = searchStudentByID(id);                 \r\n                if (found) \r\n                {                     \r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);                 \r\n                } \r\n                else \r\n                {                     \r\n                    printf(\"Student not found.\\n\");                 \r\n                }                 \r\n                break;             \r\n            case 5:                 \r\n                deleteList();                 \r\n                printf(\"List deleted.\\n\");                 \r\n                break;             \r\n            case 6:                 \r\n                freeMemory();                 \r\n                printf(\"Exiting...\\n\");                 \r\n                break;             \r\n            default:                 \r\n                printf(\"Invalid choice! Please try again.\\n\");         \r\n        }     \r\n    } while (choice != 6); \r\n\r\n    return 0; \r\n} ",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-    The implementation of bubble sort correctly sorts student records by grade. While bubble sort is straightforward and easy to implement, its O(n?) time complexity can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20409676",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h> \r\n#include <stdlib.h>\r\n\r\n#define MAX 10\r\n\r\n// Function to input matrix\r\nvoid inputMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    printf(\"Enter the elements of the matrix:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n\r\n// Function to display a matrix\r\nvoid displayMatrix(int matrix[MAX][MAX], int rows, int cols) {\r\n    printf(\"Matrix is:\\n\");\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// Function to add two matrices\r\nvoid addMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] + matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to subtract two matrices\r\nvoid subtractMatrices(int matrixA[MAX][MAX], int matrixB[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = matrixA[i][j] - matrixB[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n// Function to transpose a matrix\r\nvoid transposeMatrix(int matrix[MAX][MAX], int result[MAX][MAX], int rows, int cols) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int matrixA[MAX][MAX], matrixB[MAX][MAX], result[MAX][MAX];\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int choice;\r\n\r\n    // Input the elements of matrix A\r\n    printf(\"Enter the number of rows and columns for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n\r\n    // Validate dimensions for matrix A\r\n    if (rowsA <= 0 || rowsA > 10 || colsA <= 0 || colsA > 10) {\r\n        printf(\"Invalid dimensions for Matrix A.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input the elements of matrix A\r\n    inputMatrix(matrixA, rowsA, colsA);\r\n\r\n    // Input the dimensions of matrix B\r\n    printf(\"Enter the number of rows and columns for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n\r\n    // Validate dimensions for matrix B\r\n    if (rowsB <= 0 || rowsB > 10 || colsB <= 0 || colsB > 10) {\r\n        printf(\"Invalid dimensions for Matrix B.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Check if addition or subtraction can be performed\r\n    if (rowsA != rowsB || colsA != colsB) {\r\n        printf(\"Matrices must have the same dimensions for addition or subtraction.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input the elements of matrix B\r\n    inputMatrix(matrixB, rowsB, colsB);\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"\\nMatrix Operation Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1: // Add matrices\r\n                addMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                displayMatrix(result, rowsA, colsA);\r\n                break;\r\n            case 2: // Subtract matrices\r\n                subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\r\n                printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                displayMatrix(result, rowsA, colsA);\r\n                break;\r\n            case 3: // Transpose matrix A\r\n                transposeMatrix(matrixA, result, rowsA, colsA);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(result, colsA, rowsA); // Swapping rows and columns for display\r\n                break;\r\n            case 4: // Transpose matrix B\r\n                transposeMatrix(matrixB, result, rowsB, colsB);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(result, colsB, rowsB); // Swapping rows and columns for display\r\n                break;\r\n            case 5: // Exit\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please choose again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Structure for Grocery Item\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH];\r\n    char category[MAX_CATEGORY_LENGTH];\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Structure for Availability Status\r\ntypedef struct {\r\n    bool inStock;\r\n    bool outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Structure for Grocery Inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus availability[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function to add a grocery item\r\nvoid addGroceryItem(GroceryInventory *inventory) {\r\n    GroceryItem newItem;\r\n    printf(\"Enter Item Name: \");\r\n    getchar();  // To clear the newline character from previous input\r\n    fgets(newItem.name, MAX_NAME_LENGTH, stdin);\r\n    newItem.name[strcspn(newItem.name, \"\\n\")] = 0;  // Remove newline character from input\r\n\r\n    printf(\"Enter Category: \");\r\n    fgets(newItem.category, MAX_CATEGORY_LENGTH, stdin);\r\n    newItem.category[strcspn(newItem.category, \"\\n\")] = 0;\r\n\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &newItem.quantity);\r\n\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &newItem.price);\r\n\r\n    // Update the inventory\r\n    inventory->items[inventory->itemCount] = newItem;\r\n    inventory->availability[inventory->itemCount].inStock = (newItem.quantity > 0);\r\n    inventory->availability[inventory->itemCount].outOfStock = (newItem.quantity == 0);\r\n    inventory->itemCount++;\r\n\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\n// Function to list all grocery items with their availability\r\nvoid listAllItems(GroceryInventory *inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        printf(\"\\nName: %s\\n\", inventory->items[i].name);\r\n        printf(\"Category: %s\\n\", inventory->items[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory->items[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory->items[i].price);\r\n        printf(\"Status: %s\\n\", inventory->availability[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\n// Function to update the quantity of a grocery item\r\nvoid updateQuantity(GroceryInventory *inventory) {\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to update quantity: \");\r\n    getchar();  // To clear the newline character from previous input\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;  // Remove newline character from input\r\n\r\n    // Search for the item by name\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            int newQuantity;\r\n            printf(\"Enter new quantity for %s: \", name);\r\n            scanf(\"%d\", &newQuantity);\r\n\r\n            inventory->items[i].quantity = newQuantity;\r\n            inventory->availability[i].inStock = (newQuantity > 0);\r\n            inventory->availability[i].outOfStock = (newQuantity == 0);\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Function to remove a grocery item from the inventory\r\nvoid removeGroceryItem(GroceryInventory *inventory) {\r\n    char name[MAX_NAME_LENGTH];\r\n    printf(\"Enter name of the grocery item to remove: \");\r\n    getchar();  // To clear the newline character from previous input\r\n    fgets(name, MAX_NAME_LENGTH, stdin);\r\n    name[strcspn(name, \"\\n\")] = 0;  // Remove newline character from input\r\n\r\n    // Search for the item by name and remove it\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            // Shift items to remove the item\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Grocery item '%s' removed successfully!\\n\", name);\r\n            return;\r\n        }\r\n    }\r\n\r\n    printf(\"Item not found in the inventory.\\n\");\r\n}\r\n\r\n// Main menu for interacting with the inventory\r\nvoid displayMenu() {\r\n    printf(\"\\nGrocery Inventory Management System\\n\");\r\n    printf(\"1. Add Grocery Item\\n\");\r\n    printf(\"2. List All Grocery Items\\n\");\r\n    printf(\"3. Update Quantity\\n\");\r\n    printf(\"4. Remove Grocery Item\\n\");\r\n    printf(\"5. Exit\\n\");\r\n}\r\n\r\nint main() {\r\n    GroceryInventory inventory = { .itemCount = 0 };  // Initialize the inventory with no items\r\n\r\n    int choice;\r\n    do {\r\n        displayMenu();\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem(&inventory);\r\n                break;\r\n            case 2:\r\n                listAllItems(&inventory);\r\n                break;\r\n            case 3:\r\n                updateQuantity(&inventory);\r\n                break;\r\n            case 4:\r\n                removeGroceryItem(&inventory);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;  // Head of the linked list\r\n\r\n// Function to create a new student node\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent == NULL) {\r\n        printf(\"Memory allocation failed!\\n\");\r\n        return NULL;\r\n    }\r\n    strcpy(newStudent->name, name);  // Copy the name into the student record\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to insert a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent == NULL) return;\r\n\r\n    // Insert at the beginning of the list\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    Student* current = head;\r\n    printf(\"\\n\");\r\n    while (current != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search for a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;  // Return student with the matching ID\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;  // Return NULL if no student with the given ID is found\r\n}\r\n\r\n// Function to delete the entire list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);  // Free memory of the current student node\r\n        current = next;\r\n    }\r\n    head = NULL;  // Set head to NULL after the list is deleted\r\n}\r\n\r\n// Utility function to free memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Bubble Sort to sort the student records by grade in ascending order\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        return;  // List is empty or contains only one element\r\n    }\r\n\r\n    Student* current;\r\n    Student* next;\r\n    int swapped;\r\n\r\n    do {\r\n        swapped = 0;\r\n        current = head;\r\n        while (current != NULL && current->next != NULL) {\r\n            next = current->next;\r\n            if (current->grade > next->grade) {\r\n                // Swap grades\r\n                float tempGrade = current->grade;\r\n                current->grade = next->grade;\r\n                next->grade = tempGrade;\r\n\r\n                // Swap names\r\n                char tempName[100];\r\n                strcpy(tempName, current->name);  // Potential risk: No validation for string size\r\n                strcpy(current->name, next->name);\r\n                strcpy(next->name, tempName);\r\n\r\n                // Swap IDs\r\n                int tempID = current->id;\r\n                current->id = next->id;\r\n                next->id = tempID;\r\n\r\n                swapped = 1;\r\n            }\r\n            current = current->next;\r\n        }\r\n    } while (swapped);\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);  // Read name input with fgets\r\n                strtok(name, \"\\n\");  // Remove newline character\r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                printf(\"Records sorted by grade using Bubble Sort.\\n\");\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n    return 0;\r\n}\r\n\r\n\r\n",
    "feedback": "q1-Meet requirement\nq2-The AvailabilityStatus struct is defined with two boolean members (inStock and outOfStock), but only one of them is needed. This could lead to confusion about the availability status. A single boolean (e.g., isAvailable) or using a Union would suffice.\nq3-Bubble Sort is a simple but inefficient sorting algorithm with a time complexity of O(n?) in the worst and average cases. It is not ideal for larger datasets. While it is correctly implemented here, a more efficient algorithm like Quick Sort or Merge Sort would be preferable for better performance."
  },
  {
    "student_id": "20616849",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_DIM 10\n\n// Function prototypes\nvoid inputMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]);\nvoid displayMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]);\nvoid addMatrices(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]);\nvoid subtractMatrices(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]);\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM], int transposed[MAX_DIM][MAX_DIM]);\n\nvoid inputMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid displayMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = mat1[i][j] + mat2[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int rows, int cols, int mat1[MAX_DIM][MAX_DIM], int mat2[MAX_DIM][MAX_DIM], int result[MAX_DIM][MAX_DIM]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = mat1[i][j] - mat2[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int rows, int cols, int matrix[MAX_DIM][MAX_DIM], int transposed[MAX_DIM][MAX_DIM]) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\nint main() {\n    int rowsMat1, colsMat1, rowsMat2, colsMat2;\n    int mat1[MAX_DIM][MAX_DIM], mat2[MAX_DIM][MAX_DIM];\n    int resultMatrix[MAX_DIM][MAX_DIM];\n    int menuChoice;\n\n    // Input dimensions and elements for Matrix 1\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\n    scanf(\"%d %d\", &rowsMat1, &colsMat1);\n    if (rowsMat1 <= 0 || rowsMat1 > MAX_DIM || colsMat1 <= 0 || colsMat1 > MAX_DIM) {\n        printf(\"Invalid dimensions for Matrix A.\\n\");\n        return 1;\n    }\n    printf(\"Enter elements for Matrix A:\\n\");\n    inputMatrix(rowsMat1, colsMat1, mat1);\n\n    // Input dimensions and elements for Matrix 2\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\n    scanf(\"%d %d\", &rowsMat2, &colsMat2);\n    if (rowsMat2 <= 0 || rowsMat2 > MAX_DIM || colsMat2 <= 0 || colsMat2 > MAX_DIM) {\n        printf(\"Invalid dimensions for Matrix B.\\n\");\n        return 1;\n    }\n    printf(\"Enter elements for Matrix B:\\n\");\n    inputMatrix(rowsMat2, colsMat2, mat2);\n\n    do {\n        // Display menu\n        printf(\"\\nMatrix Operations Menu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &menuChoice);\n\n        switch (menuChoice) {\n            case 1:\n                if (rowsMat1 == rowsMat2 && colsMat1 == colsMat2) {\n                    addMatrices(rowsMat1, colsMat1, mat1, mat2, resultMatrix);\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\n                    displayMatrix(rowsMat1, colsMat1, resultMatrix);\n                } else {\n                    printf(\"Matrices cannot be added due to incompatible dimensions.\\n\");\n                }\n                break;\n            case 2:\n                if (rowsMat1 == rowsMat2 && colsMat1 == colsMat2) {\n                    subtractMatrices(rowsMat1, colsMat1, mat1, mat2, resultMatrix);\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\n                    displayMatrix(rowsMat1, colsMat1, resultMatrix);\n                } else {\n                    printf(\"Matrices cannot be subtracted due to incompatible dimensions.\\n\");\n                }\n                break;\n            case 3:\n                transposeMatrix(rowsMat1, colsMat1, mat1, resultMatrix);\n                printf(\"Transpose of Matrix A:\\n\");\n                displayMatrix(colsMat1, rowsMat1, resultMatrix);\n                break;\n            case 4:\n                transposeMatrix(rowsMat2, colsMat2, mat2, resultMatrix);\n                printf(\"Transpose of Matrix B:\\n\");\n                displayMatrix(colsMat2, rowsMat2, resultMatrix);\n                break;\n            case 5:\n                printf(\"Exiting...\\n\");\n                break;\n            default:\n                printf(\"Invalid choice. Please try again.\\n\");\n        }\n    } while (menuChoice != 5);\n\n    return 0;\n}\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n#define MAX_NAME_LEN 100\n#define MAX_CATEGORY_LEN 50\n\n// Function prototypes\nvoid addItem();\nvoid displayItems();\nvoid updateItemQuantity();\nvoid deleteItem();\nvoid displayMenu();\n\n// Structure to represent a grocery item\ntypedef struct {\n    char itemName[MAX_NAME_LEN];    \n    char itemCategory[MAX_CATEGORY_LEN]; \n    int itemQuantity;              \n    float itemPrice;               \n    bool isAvailable;              \n} GroceryItem;\n\n// Global variables to store inventory details\nGroceryItem inventoryList[MAX_ITEMS];\nint totalItems = 0; \n\n// Function to display the main menu\nvoid displayMenu() {\n    printf(\"\\nGrocery Inventory Management System\\n\");\n    printf(\"1. Add Grocery Item\\n\");\n    printf(\"2. List All Grocery Items\\n\");\n    printf(\"3. Update Quantity\\n\");\n    printf(\"4. Remove Grocery Item\\n\");\n    printf(\"5. Exit\\n\");\n}\n\n// Function to add a new grocery item\nvoid addItem() {\n    if (totalItems >= MAX_ITEMS) {\n        printf(\"Inventory is full! Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem newItem;\n    printf(\"Enter Item name: \");\n    fgets(newItem.itemName, MAX_NAME_LEN, stdin);\n    newItem.itemName[strcspn(newItem.itemName, \"\\n\")] = 0; \n\n    printf(\"Enter Category: \");\n    fgets(newItem.itemCategory, MAX_CATEGORY_LEN, stdin);\n    newItem.itemCategory[strcspn(newItem.itemCategory, \"\\n\")] = 0; \n\n    printf(\"Enter Quantity: \");\n    scanf(\"%d\", &newItem.itemQuantity);\n\n    printf(\"Enter Price: \");\n    scanf(\"%f\", &newItem.itemPrice);\n    getchar(); \n\n    // Update availability status based on quantity\n    newItem.isAvailable = newItem.itemQuantity > 0;\n\n    // Add the new item to the inventory\n    inventoryList[totalItems++] = newItem;\n    printf(\"Grocery item added successfully!\\n\");\n}\n\n// Function to list all grocery items in the inventory\nvoid displayItems() {\n    if (totalItems == 0) {\n        printf(\"No grocery items in the inventory.\\n\");\n        return;\n    }\n\n    for (int i = 0; i < totalItems; i++) {\n        printf(\"Name: %s\\n\", inventoryList[i].itemName);\n        printf(\"Category: %s\\n\", inventoryList[i].itemCategory);\n        printf(\"Quantity: %d\\n\", inventoryList[i].itemQuantity);\n        printf(\"Price: %.2f\\n\", inventoryList[i].itemPrice);\n        printf(\"Status: %s\\n\", inventoryList[i].isAvailable ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\n// Function to update the quantity of a specific item\nvoid updateItemQuantity() {\n    char targetItem[MAX_NAME_LEN];\n    int updatedQuantity;\n\n    if (totalItems == 0) {\n        printf(\"No items in the inventory to update.\\n\");\n        return;\n    }\n\n    printf(\"Enter name of the grocery item to update quantity: \");\n    fgets(targetItem, MAX_NAME_LEN, stdin);\n    targetItem[strcspn(targetItem, \"\\n\")] = 0; \n\n    for (int i = 0; i < totalItems; i++) {\n        if (strcmp(inventoryList[i].itemName, targetItem) == 0) {\n            printf(\"Enter new quantity for %s: \", inventoryList[i].itemName);\n            scanf(\"%d\", &updatedQuantity);\n            getchar(); \n\n            // Update quantity and availability status\n            inventoryList[i].itemQuantity = updatedQuantity;\n            inventoryList[i].isAvailable = updatedQuantity > 0;\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\");\n}\n\n// Function to remove a grocery item from the inventory\nvoid deleteItem() {\n    char targetItem[MAX_NAME_LEN];\n\n    if (totalItems == 0) {\n        printf(\"No items in the inventory to delete.\\n\");\n        return;\n    }\n\n    printf(\"Enter name of the grocery item to remove: \");\n    fgets(targetItem, MAX_NAME_LEN, stdin);\n    targetItem[strcspn(targetItem, \"\\n\")] = 0; \n    for (int i = 0; i < totalItems; i++) {\n        if (strcmp(inventoryList[i].itemName, targetItem) == 0) {\n            // Save the name for confirmation message\n            char removedItemName[MAX_NAME_LEN];\n            strcpy(removedItemName, inventoryList[i].itemName);\n\n            // Shift items to fill the gap\n            for (int j = i; j < totalItems - 1; j++) {\n                inventoryList[j] = inventoryList[j + 1];\n            }\n            totalItems--;\n\n            // Print confirmation message\n            printf(\"Grocery item '%s' removed successfully!\\n\", inventoryList[i].itemName);\n            return;\n        }\n    }\n\n    printf(\"Item not found in the inventory.\\n\");\n}\n\nint main() {\n    int menuChoice;\n\n    do {\n        displayMenu();\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &menuChoice);\n        getchar(); \n\n        switch (menuChoice) {\n            case 1:\n                addItem();\n                break;\n            case 2:\n                displayItems();\n                break;\n            case 3:\n                updateItemQuantity();\n                break;\n            case 4:\n                deleteItem();\n                break;\n            case 5:\n                printf(\"Exiting the program.\\n\");\n                break;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (menuChoice != 5);\n\n    return 0;\n}\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for Student\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL;\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (newStudent == NULL) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    Student* current = head;\n    if (current == NULL) {\n        printf(\"No student records to display.\\n\");\n        return;\n    }\n    while (current != NULL) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current != NULL) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    Student* next;\n    while (current != NULL) {\n        next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n    printf(\"All records have been deleted.\\n\");\n}\n\nvoid freeMemory() {\n    deleteList();\n}\n\n// Sort function to sort the student records by grade\nvoid sortStudents() {\n    if (head == NULL || head->next == NULL) {\n        printf(\"Not enough records to sort.\\n\");\n        return;\n    }\n    int swapped;\n    Student* ptr1;\n    Student* lptr = NULL;\n    do {\n        swapped = 0;\n        ptr1 = head;\n        while (ptr1->next != lptr) {\n            if (ptr1->grade > ptr1->next->grade) {\n                // Swap the data of the nodes\n                char tempName[100];\n                int tempID;\n                float tempGrade;\n\n                strcpy(tempName, ptr1->name);\n                tempID = ptr1->id;\n                tempGrade = ptr1->grade;\n\n                strcpy(ptr1->name, ptr1->next->name);\n                ptr1->id = ptr1->next->id;\n                ptr1->grade = ptr1->next->grade;\n\n                strcpy(ptr1->next->name, tempName);\n                ptr1->next->id = tempID;\n                ptr1->next->grade = tempGrade;\n\n                swapped = 1;\n            }\n            ptr1 = ptr1->next;\n        }\n        lptr = ptr1;\n    } while (swapped);\n\n    printf(\"Records sorted by grade using Bubble Sort.\\n\");\n}\n\n// Main function to drive the program\nint main() {\n    int choice, id;\n    char name[100];\n    float grade;\n\n    do {\n        printf(\"\\n1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete List\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n        getchar(); // To consume the newline character\n\n        switch (choice) {\n        case 1:\n            printf(\"Enter Name: \");\n            fgets(name, sizeof(name), stdin);\n            strtok(name, \"\\n\"); // Remove trailing newline\n            printf(\"Enter ID: \");\n            scanf(\"%d\", &id);\n            printf(\"Enter Grade: \");\n            scanf(\"%f\", &grade);\n            insertStudent(name, id, grade);\n            break;\n        case 2:\n            displayStudents();\n            break;\n        case 3:\n            sortStudents();\n            break;\n        case 4:\n            printf(\"Enter ID to search: \");\n            scanf(\"%d\", &id);\n            Student* found = searchStudentByID(id);\n            if (found) {\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n            } else {\n                printf(\"Student not found.\\n\");\n            }\n            break;\n        case 5:\n            deleteList();\n            break;\n        case 6:\n            freeMemory();\n            printf(\"Exiting...\\n\");\n            break;\n        default:\n            printf(\"Invalid choice! Please try again.\\n\");\n        }\n    } while (choice != 6);\n\n    return 0;\n}",
    "feedback": "q1-Meet requirement\nq2-In the deleteItem function, the confirmation message incorrectly references inventoryList[i].itemName after the item has been removed. It should instead use removedItemName, which holds the name of the item that was deleted.\nq3-The Bubble Sort algorithm is implemented correctly and sorts the student records by grade in ascending order. While Bubble Sort is straightforward, it has a time complexity of O(n?), which can be inefficient for larger datasets. For improved performance, consider using more efficient sorting algorithms like Quick Sort or Merge Sort."
  },
  {
    "student_id": "20705228",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\r\n\r\n#define MAX 10\r\n// define input function\r\nvoid inputMatrix(int rows, int cols, int matrix[MAX][MAX], char name) {\r\n    printf(\"Enter elements for Matrix %c:\\n\", name);\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\r\n// define display function\r\nvoid displayMatrix(int rows, int cols, int matrix[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\n// define addition function\r\nvoid addMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] + B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//define Subtraction function\r\nvoid subMatrices(int rows, int cols, int A[MAX][MAX], int B[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[i][j] = A[i][j] - B[i][j];\r\n        }\r\n    }\r\n}\r\n\r\n//define transposition function\r\nvoid transMatrix(int rows, int cols, int matrix[MAX][MAX], int result[MAX][MAX]) {\r\n    for (int i = 0; i < rows; i++) {\r\n        for (int j = 0; j < cols; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    int rowsA, colsA, rowsB, colsB;\r\n    int A[MAX][MAX], B[MAX][MAX], result[MAX][MAX];\r\n    int choice;\r\n\r\n    // Dimensions and contents of input matrix A\r\n    printf(\"Enter dimensions for Matrix A (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsA, &colsA);\r\n    if (rowsA > MAX || colsA > MAX || rowsA <= 0 || colsA <= 0) {\r\n        printf(\"Invalid dimensions! Exiting program.\\n\");\r\n        return 1;\r\n    }\r\n    inputMatrix(rowsA, colsA, A, 'A');\r\n\r\n    // Dimensions and contents of input matrix B\r\n    printf(\"Enter dimensions for Matrix B (rows and columns): \");\r\n    scanf(\"%d %d\", &rowsB, &colsB);\r\n    if (rowsB > MAX || colsB > MAX || rowsB <= 0 || colsB <= 0) {\r\n        printf(\"Invalid dimensions! Exiting program.\\n\");\r\n        return 1;\r\n    }\r\n    inputMatrix(rowsB, colsB, B, 'B');\r\n\r\n    do {\r\n        // display the menu\r\n        printf(\"\\nMatrix Operations Menu:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    addMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Matrix A + Matrix B:\\n\");\r\n                    displayMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Addition not possible. Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 2:\r\n                if (rowsA == rowsB && colsA == colsB) {\r\n                    subMatrices(rowsA, colsA, A, B, result);\r\n                    printf(\"Result of Matrix A - Matrix B:\\n\");\r\n                    displayMatrix(rowsA, colsA, result);\r\n                } else {\r\n                    printf(\"Subtraction not possible. Dimensions do not match.\\n\");\r\n                }\r\n                break;\r\n            case 3:\r\n                transMatrix(rowsA, colsA, A, result);\r\n                printf(\"Transpose of Matrix A:\\n\");\r\n                displayMatrix(colsA, rowsA, result);\r\n                break;\r\n            case 4:\r\n                transMatrix(rowsB, colsB, B, result);\r\n                printf(\"Transpose of Matrix B:\\n\");\r\n                displayMatrix(colsB, rowsB, result);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\n/* --- Q2.c --- */\n#include <stdio.h>\r\n#include <string.h>\r\n#define MAX_ITEMS 100\r\n\r\n// define struct\r\ntypedef struct {\r\n    char name[100];\r\n    char category[50];\r\n    int quantity;\r\n    float price;\r\n    int inStock; \r\n} GroceryItem;\r\n\r\n// set global variables\r\nGroceryItem inventory[MAX_ITEMS];\r\nint itemCount = 0;\r\n\r\n// set functions\r\nvoid addGroceryItem();\r\nvoid listAllItems();\r\nvoid updateQuantity();\r\nvoid removeGroceryItem();\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity\\n\");\r\n        printf(\"4. Remove Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addGroceryItem();\r\n                break;\r\n            case 2:\r\n                listAllItems();\r\n                break;\r\n            case 3:\r\n                updateQuantity();\r\n                break;\r\n            case 4:\r\n                removeGroceryItem();\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem() {\r\n    // check if the stock is full\r\n    if (itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem item; \r\n\r\n    // get the item name\r\n    printf(\"Enter Item Name: \");\r\n    fgets(item.name, sizeof(item.name), stdin);\r\n    item.name[strcspn(item.name, \"\\n\")] = 0; \r\n\r\n    // get the item category\r\n    printf(\"Enter Category: \");\r\n    fgets(item.category, sizeof(item.category), stdin);\r\n    item.category[strcspn(item.category, \"\\n\")] = 0; \r\n\r\n    // get the item quantity\r\n    printf(\"Enter Quantity: \");\r\n    scanf(\"%d\", &item.quantity);\r\n\r\n    // get the item price\r\n    printf(\"Enter Price: \");\r\n    scanf(\"%f\", &item.price);\r\n    getchar(); // 清理输入缓冲区\r\n\r\n    // set the stock status\r\n    item.inStock = item.quantity > 0 ? 1 : 0;\r\n\r\n    // increase the item counter\r\n    inventory[itemCount++] = item;\r\n    printf(\"Grocery item added successfully!\\n\");\r\n}\r\n\r\nvoid listAllItems() {\r\n    // check if the stock is empty\r\n    if (itemCount == 0) {\r\n        printf(\"No items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        printf(\"\\nName: %s\\n\", inventory[i].name);\r\n        printf(\"Category: %s\\n\", inventory[i].category);\r\n        printf(\"Quantity: %d\\n\", inventory[i].quantity);\r\n        printf(\"Price: %.2f\\n\", inventory[i].price);\r\n        printf(\"Status: %s\\n\", inventory[i].inStock ? \"In Stock\" : \"Out of Stock\");\r\n    }\r\n}\r\n\r\nvoid updateQuantity() {\r\n    char name[100]; \r\n    int found = 0; \r\n\r\n    printf(\"Enter the name of the item to update: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; \r\n\r\n    // search for the related item\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            \r\n            printf(\"Enter new quantity: \");\r\n            scanf(\"%d\", &inventory[i].quantity);\r\n            getchar(); \r\n\r\n            // update the stock status\r\n            inventory[i].inStock = inventory[i].quantity > 0 ? 1 : 0;\r\n            printf(\"Quantity updated successfully!\\n\");\r\n            found = 1; \r\n            break;\r\n        }\r\n    }\r\n\r\n    // if can't find the item\r\n    if (!found) {\r\n        printf(\"Item not found in the inventory.\\n\");\r\n    }\r\n}\r\n\r\nvoid removeGroceryItem() {\r\n    char name[100]; \r\n    int found = 0; \r\n\r\n    printf(\"Enter the name of the item to remove: \");\r\n    fgets(name, sizeof(name), stdin);\r\n    name[strcspn(name, \"\\n\")] = 0; \r\n\r\n    for (int i = 0; i < itemCount; i++) {\r\n        if (strcmp(inventory[i].name, name) == 0) {\r\n            // cover the deleted item\r\n            for (int j = i; j < itemCount - 1; j++) {\r\n                inventory[j] = inventory[j + 1];\r\n            }\r\n            itemCount--; // decrease the stock counter\r\n            printf(\"Item removed successfully!\\n\");\r\n            found = 1; \r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!found) {\r\n        printf(\"Item not found in the inventory.\\n\");\r\n    }\r\n}\r\n\n/* --- Q3.c --- */\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[100];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function to create a node of new student\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (!newStudent) {\r\n        printf(\"Memory allocation failed.\\n\");\r\n        exit(1);\r\n    }\r\n    strcpy(newStudent->name, name);\r\n    newStudent->id = id;\r\n    newStudent->grade = grade;\r\n    newStudent->next = NULL;\r\n    return newStudent;\r\n}\r\n\r\n// Function to add a new student record\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    newStudent->next = head;\r\n    head = newStudent;\r\n    printf(\"Student record added successfully.\\n\");\r\n}\r\n\r\n// Function to display all student records\r\nvoid displayStudents() {\r\n    if (head == NULL) {\r\n        printf(\"No student records available.\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"\\nName\\t\\tID\\t\\tGrade\\n\");\r\n    printf(\"---------------------------------\\n\");\r\n\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        printf(\"%s\\t\\t%d\\t\\t%.2f\\n\", current->name, current->id, current->grade);\r\n        current = current->next;\r\n    }\r\n}\r\n\r\n// Function to search a student by ID\r\nStudent* searchStudentByID(int id) {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        if (current->id == id) {\r\n            return current;\r\n        }\r\n        current = current->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// Function to delete the whole list\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    while (current != NULL) {\r\n        Student* temp = current;\r\n        current = current->next;\r\n        free(temp);\r\n    }\r\n    head = NULL;\r\n}\r\n\r\n// Sort function to sort the student records by grade\r\nvoid sortStudents() {\r\n    if (head == NULL || head->next == NULL) {\r\n        printf(\"Not enough records to sort.\\n\");\r\n        return;\r\n    }\r\n\r\n    // Bubble Sort \r\n    int swapped;\r\n    Student* ptr1;\r\n    Student* lptr = NULL;\r\n\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                // Swap data\r\n                char tempName[100];\r\n                int tempId;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->name);\r\n                tempId = ptr1->id;\r\n                tempGrade = ptr1->grade;\r\n\r\n                strcpy(ptr1->name, ptr1->next->name);\r\n                ptr1->id = ptr1->next->id;\r\n                ptr1->grade = ptr1->next->grade;\r\n\r\n                strcpy(ptr1->next->name, tempName);\r\n                ptr1->next->id = tempId;\r\n                ptr1->next->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n\r\n    printf(\"sorted successfully.\\n\");\r\n}\r\n\r\n// Function to free all allocated memory\r\nvoid freeMemory() {\r\n    deleteList();\r\n}\r\n\r\n// Main function to drive the program\r\nint main() {\r\n    int choice, id;\r\n    char name[100];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records (choose sorting method)\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); \r\n\r\n        switch (choice) {\r\n            case 1:\r\n                printf(\"Enter Name: \");\r\n                fgets(name, sizeof(name), stdin);\r\n                strtok(name, \"\\n\"); \r\n                printf(\"Enter ID: \");\r\n                scanf(\"%d\", &id);\r\n                printf(\"Enter Grade: \");\r\n                scanf(\"%f\", &grade);\r\n                insertStudent(name, id, grade);\r\n                break;\r\n            case 2:\r\n                displayStudents();\r\n                break;\r\n            case 3:\r\n                sortStudents();\r\n                break;\r\n            case 4:\r\n                printf(\"Enter ID to search: \");\r\n                scanf(\"%d\", &id);\r\n                Student* found = searchStudentByID(id);\r\n                if (found) {\r\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n                } else {\r\n                    printf(\"Student not found.\\n\");\r\n                }\r\n                break;\r\n            case 5:\r\n                deleteList();\r\n                printf(\"List deleted.\\n\");\r\n                break;\r\n            case 6:\r\n                freeMemory();\r\n                printf(\"Exiting...\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "feedback": "q1-Meet requirement\nq2-Meet requirement. \nq3-The Bubble Sort algorithm is implemented correctly. However, it has a time complexity of O(n?), which can be inefficient for larger datasets. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20717101",
    "code": "\n/* --- Q1.c --- */\n#include <stdio.h>\n\n#define MAX_SIZE 10\n\n// Function prototypes\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name);\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols);\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols);\n\nint main() {\n    int rowsA, colsA, rowsB, colsB;\n    int matrixA[MAX_SIZE][MAX_SIZE], matrixB[MAX_SIZE][MAX_SIZE];\n    int result[MAX_SIZE][MAX_SIZE];\n    int choice;\n\n    // Input dimensions of matrices\n    do {\n        printf(\"Enter the dimensions of Matrix A (rows cols): \");\n        scanf(\"%d %d\", &rowsA, &colsA);\n        if (rowsA < 1 || rowsA > MAX_SIZE || colsA < 1 || colsA > MAX_SIZE) {\n            printf(\"Invalid dimensions! Please enter values between 1 and %d.\\n\", MAX_SIZE);\n        }\n    } while (rowsA < 1 || rowsA > MAX_SIZE || colsA < 1 || colsA > MAX_SIZE);\n\n    do {\n        printf(\"Enter the dimensions of Matrix B (rows cols): \");\n        scanf(\"%d %d\", &rowsB, &colsB);\n        if (rowsB < 1 || rowsB > MAX_SIZE || colsB < 1 || colsB > MAX_SIZE) {\n            printf(\"Invalid dimensions! Please enter values between 1 and %d.\\n\", MAX_SIZE);\n        }\n    } while (rowsB < 1 || rowsB > MAX_SIZE || colsB < 1 || colsB > MAX_SIZE);\n\n    // Input matrices\n    inputMatrix(matrixA, rowsA, colsA, 'A');\n    inputMatrix(matrixB, rowsB, colsB, 'B');\n\n    // Menu loop\n    do {\n        printf(\"\\nMenu:\\n\");\n        printf(\"1. Add Matrices\\n\");\n        printf(\"2. Subtract Matrices\\n\");\n        printf(\"3. Transpose Matrix A\\n\");\n        printf(\"4. Transpose Matrix B\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &choice);\n\n        switch (choice) {\n            case 1:\n                if (rowsA == rowsB && colsA == colsB) {\n                    addMatrices(matrixA, matrixB, result, rowsA, colsA);\n                    printf(\"\\nResult of Addition:\\n\");\n                    displayMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"\\nAddition not possible. Matrices must have the same dimensions.\\n\");\n                }\n                break;\n\n            case 2:\n                if (rowsA == rowsB && colsA == colsB) {\n                    subtractMatrices(matrixA, matrixB, result, rowsA, colsA);\n                    printf(\"\\nResult of Subtraction:\\n\");\n                    displayMatrix(result, rowsA, colsA);\n                } else {\n                    printf(\"\\nSubtraction not possible. Matrices must have the same dimensions.\\n\");\n                }\n                break;\n\n            case 3:\n                transposeMatrix(matrixA, result, rowsA, colsA);\n                printf(\"\\nTranspose of Matrix A:\\n\");\n                displayMatrix(result, colsA, rowsA);\n                break;\n\n            case 4:\n                transposeMatrix(matrixB, result, rowsB, colsB);\n                printf(\"\\nTranspose of Matrix B:\\n\");\n                displayMatrix(result, colsB, rowsB);\n                break;\n\n            case 5:\n                printf(\"Exiting program.\\n\");\n                break;\n\n            default:\n                printf(\"\\nInvalid choice! Please try again.\\n\");\n        }\n    } while (choice != 5);\n\n    return 0;\n}\n\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols, char name) {\n    printf(\"\\nEnter elements of Matrix %c:\\n\", name);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"Element [%d][%d]: \", i + 1, j + 1);\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid displayMatrix(int matrix[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid addMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n}\n\nvoid subtractMatrices(int A[MAX_SIZE][MAX_SIZE], int B[MAX_SIZE][MAX_SIZE], int C[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n}\n\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int transposed[MAX_SIZE][MAX_SIZE], int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n}\n\n/* --- Q2.c --- */\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_ITEMS 100\n\n// Define the structures\ntypedef struct {\n    char name[100];\n    char category[50];\n    int quantity;\n    float price;\n} GroceryItem;\n\ntypedef struct {\n    bool inStock;\n    bool outOfStock;\n} AvailabilityStatus;\n\ntypedef struct {\n    GroceryItem items[MAX_ITEMS];\n    AvailabilityStatus status[MAX_ITEMS];\n    int totalItems;\n} GroceryInventory;\n\n// Function prototypes\nvoid addGroceryItem(GroceryInventory *inventory);\nvoid listGroceryItems(const GroceryInventory *inventory);\nvoid updateQuantity(GroceryInventory *inventory);\nvoid removeGroceryItem(GroceryInventory *inventory);\n\nint main() {\n    GroceryInventory inventory = { .totalItems = 0 };\n    int choice;\n\n    while (1) {\n        // Display menu\n        printf(\"\\nGrocery Inventory Management:\\n\");\n        printf(\"1. Add Grocery Item\\n\");\n        printf(\"2. List All Grocery Items\\n\");\n        printf(\"3. Update Item Quantity\\n\");\n        printf(\"4. Remove Grocery Item\\n\");\n        printf(\"5. Exit\\n\");\n        printf(\"Select an option: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Clear newline from buffer\n\n        switch (choice) {\n            case 1:\n                addGroceryItem(&inventory);\n                break;\n            case 2:\n                listGroceryItems(&inventory);\n                break;\n            case 3:\n                updateQuantity(&inventory);\n                break;\n            case 4:\n                removeGroceryItem(&inventory);\n                break;\n            case 5:\n                printf(\"Exiting program.\\n\");\n                return 0;\n            default:\n                printf(\"Invalid option. Please try again.\\n\");\n        }\n    }\n}\n\nvoid addGroceryItem(GroceryInventory *inventory) {\n    if (inventory->totalItems >= MAX_ITEMS) {\n        printf(\"Inventory is full. Cannot add more items.\\n\");\n        return;\n    }\n\n    GroceryItem *newItem = &inventory->items[inventory->totalItems];\n    AvailabilityStatus *newStatus = &inventory->status[inventory->totalItems];\n\n    printf(\"Enter item name: \");\n    fgets(newItem->name, sizeof(newItem->name), stdin);\n    newItem->name[strcspn(newItem->name, \"\\n\")] = '\\0';\n\n    printf(\"Enter item category: \");\n    fgets(newItem->category, sizeof(newItem->category), stdin);\n    newItem->category[strcspn(newItem->category, \"\\n\")] = '\\0';\n\n    printf(\"Enter item quantity: \");\n    scanf(\"%d\", &newItem->quantity);\n\n    printf(\"Enter item price: \");\n    scanf(\"%f\", &newItem->price);\n\n    // Update availability status\n    newStatus->inStock = newItem->quantity > 0;\n    newStatus->outOfStock = newItem->quantity == 0;\n\n    inventory->totalItems++;\n    printf(\"Item added successfully!\\n\");\n}\n\nvoid listGroceryItems(const GroceryInventory *inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    printf(\"\\nGrocery Inventory:\\n\");\n    for (int i = 0; i < inventory->totalItems; i++) {\n        const GroceryItem *item = &inventory->items[i];\n        const AvailabilityStatus *status = &inventory->status[i];\n        printf(\"%d.\\n\", i + 1);\n        printf(\"Name: %s\\n\", item->name);\n        printf(\"Category: %s\\n\", item->category);\n        printf(\"Quantity: %d\\n\", item->quantity);\n        printf(\"Price: %.2f\\n\", item->price);\n        printf(\"Status: %s\\n\\n\", status->inStock ? \"In Stock\" : \"Out of Stock\");\n    }\n}\n\nvoid updateQuantity(GroceryInventory *inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    char itemName[100];\n    printf(\"Enter the name of the item to update quantity: \");\n    fgets(itemName, sizeof(itemName), stdin);\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\n\n    for (int i = 0; i < inventory->totalItems; i++) {\n        GroceryItem *item = &inventory->items[i];\n        AvailabilityStatus *status = &inventory->status[i];\n\n        if (strcmp(item->name, itemName) == 0) {\n            printf(\"Enter new quantity for %s: \", item->name);\n            scanf(\"%d\", &item->quantity);\n            getchar(); // Clear newline from buffer\n\n            // Update availability status\n            status->inStock = item->quantity > 0;\n            status->outOfStock = item->quantity == 0;\n\n            printf(\"Quantity updated successfully!\\n\");\n            return;\n        }\n    }\n\n    printf(\"Item with name '%s' not found in inventory.\\n\", itemName);\n}\n\nvoid removeGroceryItem(GroceryInventory *inventory) {\n    if (inventory->totalItems == 0) {\n        printf(\"No items in inventory.\\n\");\n        return;\n    }\n\n    char itemName[100];\n    printf(\"Enter the name of the item to remove: \");\n    fgets(itemName, sizeof(itemName), stdin);\n    itemName[strcspn(itemName, \"\\n\")] = '\\0';\n\n    for (int i = 0; i < inventory->totalItems; i++) {\n        if (strcmp(inventory->items[i].name, itemName) == 0) {\n            for (int j = i; j < inventory->totalItems - 1; j++) {\n                inventory->items[j] = inventory->items[j + 1];\n                inventory->status[j] = inventory->status[j + 1];\n            }\n\n            inventory->totalItems--;\n            printf(\"Item '%s' removed successfully!\\n\", itemName);\n            return;\n        }\n    }\n\n    printf(\"Item with name '%s' not found in inventory.\\n\", itemName);\n}\n\n/* --- Q3.c --- */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Define the structure for a student record\ntypedef struct Student {\n    char name[100];\n    int id;\n    float grade;\n    struct Student* next;\n} Student;\n\nStudent* head = NULL; // Head of the linked list\n\n// Function prototypes\nStudent* createStudent(const char* name, int id, float grade);\nvoid insertStudent(const char* name, int id, float grade);\nvoid displayStudents();\nStudent* searchStudentByID(int id);\nvoid deleteList();\nvoid sortStudents();\n\nint main() {\n    int choice;\n    char name[100];\n    int id;\n    float grade;\n\n    while (1) {\n        printf(\"\\nStudent Records Management:\\n\");\n        printf(\"1. Insert Student Record\\n\");\n        printf(\"2. Display Student Records\\n\");\n        printf(\"3. Sort Records by Grade\\n\");\n        printf(\"4. Search Record by ID\\n\");\n        printf(\"5. Delete All Records\\n\");\n        printf(\"6. Exit\\n\");\n        printf(\"Select an option: \");\n        scanf(\"%d\", &choice);\n        getchar(); // Clear newline from input buffer\n\n        switch (choice) {\n            case 1:\n                printf(\"Enter Name: \");\n                fgets(name, sizeof(name), stdin);\n                name[strcspn(name, \"\\n\")] = '\\0'; // Remove newline\n\n                printf(\"Enter ID: \");\n                scanf(\"%d\", &id);\n\n                printf(\"Enter Grade: \");\n                scanf(\"%f\", &grade);\n\n                insertStudent(name, id, grade);\n                break;\n            case 2:\n                displayStudents();\n                break;\n            case 3:\n                sortStudents();\n                break;\n            case 4:\n                printf(\"Enter ID to search: \");\n                scanf(\"%d\", &id);\n                Student* found = searchStudentByID(id);\n                if (found) {\n                    printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\n                } else {\n                    printf(\"Student not found.\\n\");\n                }\n                break;\n            case 5:\n                deleteList();\n                printf(\"All records deleted.\\n\");\n                break;\n            case 6:\n                deleteList();\n                printf(\"Exiting program.\\n\");\n                return 0;\n            default:\n                printf(\"Invalid choice! Please try again.\\n\");\n        }\n    }\n}\n\n// Function to create a new student node\nStudent* createStudent(const char* name, int id, float grade) {\n    Student* newStudent = (Student*)malloc(sizeof(Student));\n    if (!newStudent) {\n        printf(\"Memory allocation failed.\\n\");\n        exit(1);\n    }\n    strcpy(newStudent->name, name);\n    newStudent->id = id;\n    newStudent->grade = grade;\n    newStudent->next = NULL;\n    return newStudent;\n}\n\n// Function to insert a new student record\nvoid insertStudent(const char* name, int id, float grade) {\n    Student* newStudent = createStudent(name, id, grade);\n    newStudent->next = head;\n    head = newStudent;\n    printf(\"Student record added successfully.\\n\");\n}\n\n// Function to display all student records\nvoid displayStudents() {\n    if (!head) {\n        printf(\"No student records found.\\n\");\n        return;\n    }\n\n    printf(\"\\nStudent Records:\\n\");\n    Student* current = head;\n    while (current) {\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", current->name, current->id, current->grade);\n        current = current->next;\n    }\n}\n\n// Function to search for a student by ID\nStudent* searchStudentByID(int id) {\n    Student* current = head;\n    while (current) {\n        if (current->id == id) {\n            return current;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\n// Function to delete the entire list\nvoid deleteList() {\n    Student* current = head;\n    while (current) {\n        Student* next = current->next;\n        free(current);\n        current = next;\n    }\n    head = NULL;\n}\n\n// Function to sort student records by grade\nvoid sortStudents() {\n    if (!head || !head->next) {\n        printf(\"Not enough records to sort.\\n\");\n        return;\n    }\n\n    for (Student* i = head; i && i->next; i = i->next) {\n        for (Student* j = head; j->next; j = j->next) {\n            if (j->grade > j->next->grade) {\n                // Swap records\n                char tempName[100];\n                int tempID = j->id;\n                float tempGrade = j->grade;\n\n                strcpy(tempName, j->name);\n                j->id = j->next->id;\n                j->grade = j->next->grade;\n                strcpy(j->name, j->next->name);\n\n                strcpy(j->next->name, tempName);\n                j->next->id = tempID;\n                j->next->grade = tempGrade;\n            }\n        }\n    }\n    printf(\"Records sorted by grade successfully.\\n\");\n}\n",
    "feedback": "q1-Meet requirement. \nq2-Meet requirement. \nq3-The Bubble Sort algorithm is correctly implemented, but it is not efficient for larger datasets due to its O(n?) time complexity. For better performance, consider using more efficient algorithms like Merge Sort or Quick Sort."
  },
  {
    "student_id": "20717489",
    "code": "\n/* --- q1.c --- */\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n\r\n#define MAX_SIZE 10\r\n\r\n// Function prototypes\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int m, int n);\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int m, int n);\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int m, int n);\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int m, int n);\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int m, int n);\r\n\r\nint main() {\r\n    int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE], result[MAX_SIZE][MAX_SIZE];\r\n    int m, n, p, q, choice;\r\n\r\n    // Input dimensions of matrix A\r\n    printf(\"Enter dimensions of matrix A (rows x columns, max 10x10): \");\r\n    scanf(\"%d %d\", &m, &n);\r\n    if (m > 10 || n > 10 || m <= 0 || n <= 0) {\r\n        printf(\"Invalid dimensions.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements of matrix A\r\n    printf(\"Enter elements of matrix A:\\n\");\r\n    inputMatrix(a, m, n);\r\n\r\n    // Input dimensions of matrix B\r\n    printf(\"Enter dimensions of matrix B (rows x columns, max 10x10): \");\r\n    scanf(\"%d %d\", &p, &q);\r\n    if (p > 10 || q > 10 || p <= 0 || q <= 0) {\r\n        printf(\"Invalid dimensions.\\n\");\r\n        return 1;\r\n    }\r\n    if (m != p || n != q) {\r\n        printf(\"Matrices A and B must have the same dimensions.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    // Input elements of matrix B\r\n    printf(\"Enter elements of matrix B:\\n\");\r\n    inputMatrix(b, p, q);\r\n\r\n    do {\r\n        // Menu for operations\r\n        printf(\"\\nChoose an operation:\\n\");\r\n        printf(\"1. Add Matrices\\n\");\r\n        printf(\"2. Subtract Matrices\\n\");\r\n        printf(\"3. Transpose Matrix A\\n\");\r\n        printf(\"4. Transpose Matrix B\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            addMatrices(a, b, result, m, n);\r\n            printf(\"Result of addition:\\n\");\r\n            printMatrix(result, m, n);\r\n            break;\r\n        case 2:\r\n            subtractMatrices(a, b, result, m, n);\r\n            printf(\"Result of subtraction:\\n\");\r\n            printMatrix(result, m, n);\r\n            break;\r\n        case 3:\r\n            transposeMatrix(a, result, m, n);\r\n            printf(\"Transpose of Matrix A:\\n\");\r\n            printMatrix(result, n, m);\r\n            break;\r\n        case 4:\r\n            transposeMatrix(b, result, m, n);\r\n            printf(\"Transpose of Matrix B:\\n\");\r\n            printMatrix(result, n, m);\r\n            break;\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int m, int n) {\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            result[i][j] = a[i][j] + b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid subtractMatrices(int a[MAX_SIZE][MAX_SIZE], int b[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int m, int n) {\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            result[i][j] = a[i][j] - b[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid transposeMatrix(int matrix[MAX_SIZE][MAX_SIZE], int result[MAX_SIZE][MAX_SIZE], int m, int n) {\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            result[j][i] = matrix[i][j];\r\n        }\r\n    }\r\n}\r\n\r\nvoid printMatrix(int matrix[MAX_SIZE][MAX_SIZE], int m, int n) {\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            printf(\"%d \", matrix[i][j]);\r\n        }\r\n        printf(\"\\n\");\r\n    }\r\n}\r\n\r\nvoid inputMatrix(int matrix[MAX_SIZE][MAX_SIZE], int m, int n) {\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            scanf(\"%d\", &matrix[i][j]);\r\n        }\r\n    }\r\n}\n/* --- q2.c --- */\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\n#define MAX_ITEMS 100\r\n#define MAX_NAME_LENGTH 100\r\n#define MAX_CATEGORY_LENGTH 50\r\n\r\n// Define the structure for Grocery Item\r\ntypedef struct {\r\n    char name[MAX_NAME_LENGTH + 1]; // max length 100 + 1 for null terminator\r\n    char category[MAX_CATEGORY_LENGTH + 1]; // max length 50 + 1 for null terminator\r\n    int quantity;\r\n    float price;\r\n} GroceryItem;\r\n\r\n// Define the structure for Availability Status\r\ntypedef struct {\r\n    int inStock;\r\n    int outOfStock;\r\n} AvailabilityStatus;\r\n\r\n// Define the structure for Grocery Inventory\r\ntypedef struct {\r\n    GroceryItem items[MAX_ITEMS];\r\n    AvailabilityStatus availability[MAX_ITEMS];\r\n    int itemCount;\r\n} GroceryInventory;\r\n\r\n// Function prototypes\r\nvoid addGroceryItem(GroceryInventory* inventory);\r\nvoid listAllGroceryItems(GroceryInventory* inventory);\r\nvoid updateQuantity(GroceryInventory* inventory, int quantity, char* name);\r\nvoid removeGroceryItem(GroceryInventory* inventory, char* name);\r\nvoid printGroceryItem(const GroceryItem* item, const AvailabilityStatus* status);\r\n\r\nint main() {\r\n    GroceryInventory inventory = { 0 }; // Initialize inventory with zero items\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nGrocery Inventory Management System\\n\");\r\n        printf(\"1. Add Grocery Item\\n\");\r\n        printf(\"2. List All Grocery Items\\n\");\r\n        printf(\"3. Update Quantity of a Grocery Item\\n\");\r\n        printf(\"4. Remove a Grocery Item\\n\");\r\n        printf(\"5. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        while (getchar() != '\\n'); // Clear the input buffer\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            addGroceryItem(&inventory);\r\n            break;\r\n        case 2:\r\n            listAllGroceryItems(&inventory);\r\n            break;\r\n        case 3: {\r\n            char name[MAX_NAME_LENGTH + 1];\r\n            int quantity;\r\n            printf(\"Enter the name of the item to update: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            name[strcspn(name, \"\\n\")] = 0; // Remove newline\r\n            printf(\"Enter the new quantity: \");\r\n            scanf(\"%d\", &quantity);\r\n            while (getchar() != '\\n'); // Clear the input buffer\r\n            updateQuantity(&inventory, quantity, name);\r\n            break;\r\n        }\r\n        case 4: {\r\n            char name[MAX_NAME_LENGTH + 1];\r\n            printf(\"Enter the name of the item to remove: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            name[strcspn(name, \"\\n\")] = 0; // Remove newline\r\n            removeGroceryItem(&inventory, name);\r\n            break;\r\n        }\r\n        case 5:\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid addGroceryItem(GroceryInventory* inventory) {\r\n    if (inventory->itemCount >= MAX_ITEMS) {\r\n        printf(\"Inventory is full. Cannot add more items.\\n\");\r\n        return;\r\n    }\r\n\r\n    GroceryItem* item = &inventory->items[inventory->itemCount];\r\n    AvailabilityStatus* status = &inventory->availability[inventory->itemCount];\r\n\r\n    printf(\"Enter the name of the item: \");\r\n    fgets(item->name, sizeof(item->name), stdin);\r\n    item->name[strcspn(item->name, \"\\n\")] = 0; // Remove newline\r\n    printf(\"Enter the category of the item: \");\r\n    fgets(item->category, sizeof(item->category), stdin);\r\n    item->category[strcspn(item->category, \"\\n\")] = 0; // Remove newline\r\n    printf(\"Enter the quantity of the item: \");\r\n    scanf(\"%d\", &item->quantity);\r\n    while (getchar() != '\\n'); // Clear the input buffer\r\n    printf(\"Enter the price of the item: \");\r\n    scanf(\"%f\", &item->price);\r\n    while (getchar() != '\\n'); // Clear the input buffer\r\n\r\n    status->inStock = item->quantity > 0;\r\n    status->outOfStock = item->quantity <= 0;\r\n\r\n    inventory->itemCount++;\r\n    printf(\"Grocery item added successfully.\\n\");\r\n}\r\n\r\nvoid listAllGroceryItems(GroceryInventory* inventory) {\r\n    if (inventory->itemCount == 0) {\r\n        printf(\"No grocery items in the inventory.\\n\");\r\n        return;\r\n    }\r\n\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        printGroceryItem(&inventory->items[i], &inventory->availability[i]);\r\n    }\r\n}\r\n\r\nvoid updateQuantity(GroceryInventory* inventory, int quantity, char* name) {\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            inventory->items[i].quantity = quantity;\r\n            inventory->availability[i].inStock = quantity > 0;\r\n            inventory->availability[i].outOfStock = quantity <= 0;\r\n            printf(\"Quantity updated successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nvoid removeGroceryItem(GroceryInventory* inventory, char* name) {\r\n    for (int i = 0; i < inventory->itemCount; i++) {\r\n        if (strcmp(inventory->items[i].name, name) == 0) {\r\n            for (int j = i; j < inventory->itemCount - 1; j++) {\r\n                inventory->items[j] = inventory->items[j + 1];\r\n                inventory->availability[j] = inventory->availability[j + 1];\r\n            }\r\n            inventory->itemCount--;\r\n            printf(\"Item removed successfully.\\n\");\r\n            return;\r\n        }\r\n    }\r\n    printf(\"Item not found.\\n\");\r\n}\r\n\r\nvoid printGroceryItem(const GroceryItem* item, const AvailabilityStatus* status) {\r\n    printf(\"Name: %s\\n\", item->name);\r\n    printf(\"Category: %s\\n\", item->category);\r\n    printf(\"Quantity: %d\\n\", item->quantity);\r\n    printf(\"Price: %.2f\\n\", item->price);\r\n    if (status->inStock) {\r\n        printf(\"Availability: In Stock\\n\");\r\n    }\r\n    else {\r\n        printf(\"Availability: Out of Stock\\n\");\r\n    }\r\n    printf(\"\\n\");\r\n}\n/* --- q3.c --- */\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#define MAX_NAME_LENGTH 100\r\n\r\n// Structure for Student\r\ntypedef struct Student {\r\n    char name[MAX_NAME_LENGTH];\r\n    int id;\r\n    float grade;\r\n    struct Student* next;\r\n} Student;\r\n\r\nStudent* head = NULL;\r\n\r\n// Function prototypes\r\nStudent* createStudent(const char* name, int id, float grade);\r\nvoid insertStudent(const char* name, int id, float grade);\r\nvoid displayStudents();\r\nvoid sortStudents();\r\nStudent* searchStudentByID(int id);\r\nvoid deleteList();\r\nvoid freeMemory();\r\n\r\nint main() {\r\n    int choice, id;\r\n    char name[MAX_NAME_LENGTH];\r\n    float grade;\r\n\r\n    do {\r\n        printf(\"\\n1. Insert Student Record\\n\");\r\n        printf(\"2. Display Student Records\\n\");\r\n        printf(\"3. Sort Records\\n\");\r\n        printf(\"4. Search Record by ID\\n\");\r\n        printf(\"5. Delete List\\n\");\r\n        printf(\"6. Exit\\n\");\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n        getchar(); // To consume the newline character\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            printf(\"Enter Name: \");\r\n            fgets(name, sizeof(name), stdin);\r\n            name[strcspn(name, \"\\n\")] = 0; // Remove newline\r\n            printf(\"Enter ID: \");\r\n            scanf(\"%d\", &id);\r\n            printf(\"Enter Grade: \");\r\n            scanf(\"%f\", &grade);\r\n            insertStudent(name, id, grade);\r\n            break;\r\n        case 2:\r\n            displayStudents();\r\n            break;\r\n        case 3:\r\n            sortStudents();\r\n            printf(\"Records sorted by grade using bubble sort\\n\");\r\n            break;\r\n        case 4:\r\n            printf(\"Enter ID to search: \");\r\n            scanf(\"%d\", &id);\r\n            Student* found = searchStudentByID(id);\r\n            if (found) {\r\n                printf(\"Found: Name: %s, ID: %d, Grade: %.2f\\n\", found->name, found->id, found->grade);\r\n            }\r\n            else {\r\n                printf(\"Student not found.\\n\");\r\n            }\r\n            break;\r\n        case 5:\r\n            deleteList();\r\n            printf(\"List deleted.\\n\");\r\n            break;\r\n        case 6:\r\n            freeMemory();\r\n            printf(\"Exiting...\\n\");\r\n            break;\r\n        default:\r\n            printf(\"Invalid choice! Please try again.\\n\");\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n\r\nStudent* createStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = (Student*)malloc(sizeof(Student));\r\n    if (newStudent) {\r\n        strcpy(newStudent->name, name);\r\n        newStudent->id = id;\r\n        newStudent->grade = grade;\r\n        newStudent->next = NULL;\r\n    }\r\n    return newStudent;\r\n}\r\n\r\nvoid insertStudent(const char* name, int id, float grade) {\r\n    Student* newStudent = createStudent(name, id, grade);\r\n    if (newStudent) {\r\n        newStudent->next = head;\r\n        head = newStudent;\r\n    }\r\n}\r\n\r\nvoid displayStudents() {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        printf(\"Name: %s, ID: %d, Grade: %.2f\\n\", temp->name, temp->id, temp->grade);\r\n        temp = temp->next;\r\n    }\r\n}\r\n\r\nvoid sortStudents() {\r\n    int swapped;\r\n    Student* ptr1, * lptr = NULL;\r\n    do {\r\n        swapped = 0;\r\n        ptr1 = head;\r\n        while (ptr1->next != lptr) {\r\n            if (ptr1->grade > ptr1->next->grade) {\r\n                char tempName[MAX_NAME_LENGTH];\r\n                int tempID;\r\n                float tempGrade;\r\n\r\n                strcpy(tempName, ptr1->next->name);\r\n                strcpy(ptr1->next->name, ptr1->name);\r\n                strcpy(ptr1->name, tempName);\r\n\r\n                tempID = ptr1->next->id;\r\n                ptr1->next->id = ptr1->id;\r\n                ptr1->id = tempID;\r\n\r\n                tempGrade = ptr1->next->grade;\r\n                ptr1->next->grade = ptr1->grade;\r\n                ptr1->grade = tempGrade;\r\n\r\n                swapped = 1;\r\n            }\r\n            ptr1 = ptr1->next;\r\n        }\r\n        lptr = ptr1;\r\n    } while (swapped);\r\n}\r\n\r\nStudent* searchStudentByID(int id) {\r\n    Student* temp = head;\r\n    while (temp != NULL) {\r\n        if (temp->id == id) {\r\n            return temp;\r\n        }\r\n        temp = temp->next;\r\n    }\r\n    return NULL;\r\n}\r\n\r\nvoid deleteList() {\r\n    Student* current = head;\r\n    Student* next;\r\n    while (current != NULL) {\r\n        next = current->next;\r\n        free(current);\r\n        current = next;\r\n    }\r\n    head = NULL;\r\n}\r\n\r\nvoid freeMemory() {\r\n    deleteList();\r\n}",
    "feedback": "q1-Meet requirement\nq2-The AvailabilityStatus struct contains both inStock and outOfStock fields, which are redundant. Only one status is necessary. This could lead to confusion about the actual availability state since both values can be true or false independently. In the updateQuantity function, if an item with the specified name is not found, the code does not check if the item count is zero before searching. This could lead to unnecessary iterations through the inventory.\nq3-   Bubble Sort is correctly implemented, but it is inefficient for larger datasets, with a time complexity of O(n?). While functional for small lists, consider using a more efficient sorting algorithm, like Quick Sort or Merge Sort, for better performance with larger datasets."
  }
]